       
       
typedef long int ptrdiff_t;
typedef long unsigned int size_t;
namespace std __attribute__ ((__visibility__ ("default"))) {
  using ::ptrdiff_t;
  using ::size_t;
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  void
  __throw_bad_exception(void) __attribute__((__noreturn__));
  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));
  void
  __throw_bad_cast(void) __attribute__((__noreturn__));
  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));
  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));
  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));
  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));
  void
  __throw_length_error(const char*) __attribute__((__noreturn__));
  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));
  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));
  void
  __throw_range_error(const char*) __attribute__((__noreturn__));
  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));
  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));
  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));
  void
  __throw_system_error(int) __attribute__((__noreturn__));
  void
  __throw_future_error(int) __attribute__((__noreturn__));
  void
  __throw_bad_function_call() __attribute__((__noreturn__));
}
       
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
  template<typename _Iterator, typename _Container>
    class __normal_iterator;
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  struct __true_type { };
  struct __false_type { };
  template<bool>
    struct __truth_type
    { typedef __false_type __type; };
  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };
  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };
  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };
  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };
  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };
  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
  template<typename _Iterator>
    class move_iterator;
  template<typename _Iterator>
    struct __is_move_iterator< move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<typename _Tp>
    class __is_iterator_helper
    {
      typedef char __one;
      typedef struct { char __arr[2]; } __two;
      template<typename _Up>
        struct _Wrap_type
 { };
      template<typename _Up>
        static __one __test(_Wrap_type<typename _Up::iterator_category>*);
      template<typename _Up>
        static __two __test(...);
    public:
      static const bool __value = (sizeof(__test<_Tp>(0)) == 1
       || __is_pointer<_Tp>::__value);
    };
  template<typename _Tp>
    struct __is_iterator
    {
      enum { __value = __is_iterator_helper<_Tp>::__value };
      typedef typename __truth_type<__value>::__type __type;
    };
}
       
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
  template<bool, typename>
    struct __enable_if
    { };
  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };
  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };
  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };
  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
    public:
      typedef typename __if_type::__type __type;
    };
  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };
  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };
  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };
  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };
  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };
  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };
  template<>
    struct __add_unsigned<bool>;
  template<>
    struct __add_unsigned<wchar_t>;
  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;
    public:
      typedef typename __if_type::__type __type;
    };
  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };
  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };
  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };
  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };
  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };
  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };
  template<>
    struct __remove_unsigned<bool>;
  template<>
    struct __remove_unsigned<wchar_t>;
  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }
  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }
  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };
  template<typename _Tp>
    struct __promote<_Tp, false>
    { typedef _Tp __type; };
  template<typename _Tp, typename _Up>
    struct __promote_2
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
    public:
      typedef __typeof__(__type1() + __type2()) __type;
    };
  template<typename _Tp, typename _Up, typename _Vp>
    struct __promote_3
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;
    public:
      typedef __typeof__(__type1() + __type2() + __type3()) __type;
    };
  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
    struct __promote_4
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;
      typedef typename __promote<_Wp>::__type __type4;
    public:
      typedef __typeof__(__type1() + __type2() + __type3() + __type4()) __type;
    };
}
       
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
  template<typename _Value>
    struct __numeric_traits_integer
    {
      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);
      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };
  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;
  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;
  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;
  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
  template<typename _Value>
    struct __numeric_traits_floating
    {
      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 3010 / 10000);
      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };
  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;
  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;
  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;
  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;
  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };
}
       
       
       
       
namespace std
{

  struct __sfinae_types
  {
    typedef char __one;
    typedef struct { char __arr[2]; } __two;
  };
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static const _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
    };
  typedef integral_constant<bool, true> true_type;
  typedef integral_constant<bool, false> false_type;
  template<typename _Tp, _Tp __v>
    const _Tp integral_constant<_Tp, __v>::value;
  template<typename>
    struct remove_cv;
  template<typename>
    struct __is_void_helper
    : public false_type { };
  template<> struct __is_void_helper<void> : public integral_constant<bool, true> { };
  template<typename _Tp>
    struct is_void
    : public integral_constant<bool, (__is_void_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };
  template<typename>
    struct __is_integral_helper
    : public false_type { };
  template<> struct __is_integral_helper<bool> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<char> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<signed char> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned char> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<wchar_t> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<char16_t> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<char32_t> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<short> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned short> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<int> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned int> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<long> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned long> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<long long> : public integral_constant<bool, true> { };
  template<> struct __is_integral_helper<unsigned long long> : public integral_constant<bool, true> { };
  template<typename _Tp>
    struct is_integral
    : public integral_constant<bool, (__is_integral_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };
  template<typename>
    struct __is_floating_point_helper
    : public false_type { };
  template<> struct __is_floating_point_helper<float> : public integral_constant<bool, true> { };
  template<> struct __is_floating_point_helper<double> : public integral_constant<bool, true> { };
  template<> struct __is_floating_point_helper<long double> : public integral_constant<bool, true> { };
  template<typename _Tp>
    struct is_floating_point
    : public integral_constant<bool, (__is_floating_point_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };
  template<typename>
    struct is_array
    : public false_type { };
  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };
  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };
  template<typename>
    struct __is_pointer_helper
    : public false_type { };
  template<typename _Tp> struct __is_pointer_helper<_Tp*> : public integral_constant<bool, true> { };
  template<typename _Tp>
    struct is_pointer
    : public integral_constant<bool, (__is_pointer_helper<typename
          remove_cv<_Tp>::type>::value)>
    { };
  template<typename _Tp>
    struct is_reference;
  template<typename _Tp>
    struct is_function;
  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };
  template<typename _Tp, typename _Cp> struct __is_member_object_pointer_helper<_Tp _Cp::*> : public integral_constant<bool, !is_function<_Tp>::value> { };
  template<typename _Tp>
    struct is_member_object_pointer
    : public integral_constant<bool, (__is_member_object_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };
  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };
  template<typename _Tp, typename _Cp> struct __is_member_function_pointer_helper<_Tp _Cp::*> : public integral_constant<bool, is_function<_Tp>::value> { };
  template<typename _Tp>
    struct is_member_function_pointer
    : public integral_constant<bool, (__is_member_function_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };
  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };
  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };
  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };
  template<typename>
    struct is_function
    : public false_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...)>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......)>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile>
    : public true_type { };
  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile>
    : public true_type { };
  template<typename _Tp>
    struct is_arithmetic
    : public integral_constant<bool, (is_integral<_Tp>::value
          || is_floating_point<_Tp>::value)>
    { };
  template<typename _Tp>
    struct is_fundamental
    : public integral_constant<bool, (is_arithmetic<_Tp>::value
          || is_void<_Tp>::value)>
    { };
  template<typename _Tp>
    struct is_object
    : public integral_constant<bool, !(is_function<_Tp>::value
           || is_reference<_Tp>::value
           || is_void<_Tp>::value)>
    { };
  template<typename _Tp>
    struct is_member_pointer;
  template<typename _Tp>
    struct is_scalar
    : public integral_constant<bool, (is_arithmetic<_Tp>::value
          || is_enum<_Tp>::value
          || is_pointer<_Tp>::value
          || is_member_pointer<_Tp>::value)>
    { };
  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };
  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };
  template<typename _Tp, typename _Cp> struct __is_member_pointer_helper<_Tp _Cp::*> : public integral_constant<bool, true> { };
  template<typename _Tp>
  struct is_member_pointer
    : public integral_constant<bool, (__is_member_pointer_helper<
          typename remove_cv<_Tp>::type>::value)>
    { };
  template<typename>
    struct is_const
    : public false_type { };
  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };
  template<typename>
    struct is_volatile
    : public false_type { };
  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };
  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };
  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };
  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };
  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };
  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };
  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };
  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };
  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };
  template<typename, unsigned _Uint = 0>
    struct extent
    : public integral_constant<std::size_t, 0> { };
  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };
  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };
  template<typename, typename>
    struct is_same
    : public false_type { };
  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };
  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };
  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };
  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };
  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };
  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };
  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };
  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };
  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };
  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };
  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };
  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };
  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };
  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };
  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };
  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };
  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };
  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };
  template<typename>
    struct remove_reference;
  template<typename _Tp>
    struct add_pointer
    { typedef typename remove_reference<_Tp>::type* type; };

}
namespace std
{
  template<typename>
    struct is_lvalue_reference
    : public false_type { };
  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };
  template<typename>
    struct is_rvalue_reference
    : public false_type { };
  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };
  template<typename _Tp>
    struct is_reference
    : public integral_constant<bool, (is_lvalue_reference<_Tp>::value
          || is_rvalue_reference<_Tp>::value)>
    { };
  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };
  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };
  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };
  template<typename _Tp,
    bool = !is_reference<_Tp>::value && !is_void<_Tp>::value,
    bool = is_rvalue_reference<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };
  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true, false>
    { typedef _Tp& type; };
  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, false, true>
    { typedef typename remove_reference<_Tp>::type& type; };
  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };
  template<typename _Tp,
    bool = !is_reference<_Tp>::value && !is_void<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };
  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };
  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };
  template<typename _Tp,
    bool = is_integral<_Tp>::value,
    bool = is_floating_point<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };
  template<typename _Tp>
    struct __is_signed_helper<_Tp, false, true>
    : public true_type { };
  template<typename _Tp>
    struct __is_signed_helper<_Tp, true, false>
    : public integral_constant<bool, static_cast<bool>(_Tp(-1) < _Tp(0))>
    { };
  template<typename _Tp>
    struct is_signed
    : public integral_constant<bool, __is_signed_helper<_Tp>::value>
    { };
  template<typename _Tp>
    struct is_unsigned
    : public integral_constant<bool, (is_arithmetic<_Tp>::value
          && !is_signed<_Tp>::value)>
    { };
  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };
  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };
  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };
  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval();
  template<typename _Tp, typename... _Args>
    class __is_constructible_helper
    : public __sfinae_types
    {
      template<typename _Tp1, typename... _Args1>
        static decltype(_Tp1(declval<_Args1>()...), __one()) __test(int);
      template<typename, typename...>
        static __two __test(...);
    public:
      static const bool __value = sizeof(__test<_Tp, _Args...>(0)) == 1;
    };
  template<typename _Tp, typename _Arg>
    class __is_constructible_helper<_Tp, _Arg>
    : public __sfinae_types
    {
      template<typename _Tp1, typename _Arg1>
        static decltype(static_cast<_Tp1>(declval<_Arg1>()), __one())
 __test(int);
      template<typename, typename>
        static __two __test(...);
    public:
      static const bool __value = sizeof(__test<_Tp, _Arg>(0)) == 1;
    };
  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public integral_constant<bool,
          __is_constructible_helper<_Tp,
        _Args...>::__value>
    { };
  template<typename _Tp>
    struct has_trivial_default_constructor
    : public integral_constant<bool, __has_trivial_constructor(_Tp)>
    { };
  template<typename _Tp>
    struct has_trivial_copy_constructor
    : public integral_constant<bool, __has_trivial_copy(_Tp)>
    { };
  template<typename _Tp>
    struct has_trivial_assign
    : public integral_constant<bool, __has_trivial_assign(_Tp)>
    { };
  template<typename _Tp>
    struct has_trivial_destructor
    : public integral_constant<bool, __has_trivial_destructor(_Tp)>
    { };
  template<typename _Tp>
    struct has_nothrow_default_constructor
    : public integral_constant<bool, __has_nothrow_constructor(_Tp)>
    { };
  template<typename _Tp>
    struct has_nothrow_copy_constructor
    : public integral_constant<bool, __has_nothrow_copy(_Tp)>
    { };
  template<typename _Tp>
    struct has_nothrow_assign
    : public integral_constant<bool, __has_nothrow_assign(_Tp)>
    { };
  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };
  template<typename _From, typename _To,
    bool = (is_void<_From>::value || is_void<_To>::value
     || is_function<_To>::value || is_array<_To>::value)>
    struct __is_convertible_helper
    { static const bool __value = (is_void<_From>::value
       && is_void<_To>::value); };
  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    : public __sfinae_types
    {
      static __one __test(_To);
      static __two __test(...);
    public:
      static const bool __value = sizeof(__test(declval<_From>())) == 1;
    };
  template<typename _From, typename _To>
    struct is_convertible
    : public integral_constant<bool,
          __is_convertible_helper<_From, _To>::__value>
    { };
  template<typename _From, typename _To>
    struct is_explicitly_convertible
    : public is_constructible<_To, _From>
    { };
  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };
  template<bool, typename _Tp = void>
    struct enable_if
    { };
  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };
  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };
  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };
  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;
  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };
  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };
  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };
  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;
    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };
  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;
  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };
  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };
  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };
  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };
  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;
    public:
      typedef typename __match::__type __type;
    };
  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };
  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };
  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };
  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };
  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };
  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };
  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;
  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;
    public:
      typedef typename __cv_unsigned::__type __type;
    };
  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {
      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      typedef conditional<__b2, unsigned int, unsigned long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;
    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };
  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };
  template<>
    struct make_unsigned<bool>;
  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };
  template<>
    struct __make_signed<char>
    { typedef signed char __type; };
  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };
  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };
  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };
  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };
  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;
  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;
    public:
      typedef typename __cv_signed::__type __type;
    };
  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef signed char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(signed short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(signed int);
      typedef conditional<__b2, signed int, signed long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, signed short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;
    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };
  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };
  template<>
    struct make_signed<bool>;
  template<typename... _Tp>
    struct common_type;
  template<typename _Tp>
    struct common_type<_Tp>
    { typedef _Tp type; };
  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    { typedef decltype(true ? declval<_Tp>() : declval<_Up>()) type; };
  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    {
      typedef typename
        common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;
    };
  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };
  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval()
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Tp>
    struct identity
    {
      typedef _Tp type;
    };
  template<typename _Tp>
    inline typename enable_if<!is_lvalue_reference<_Tp>::value, _Tp&&>::type
    forward(typename std::identity<_Tp>::type& __t)
    { return static_cast<_Tp&&>(__t); }
  template<typename _Tp>
    inline typename enable_if<!is_lvalue_reference<_Tp>::value, _Tp&&>::type
    forward(typename std::identity<_Tp>::type&& __t)
    { return static_cast<_Tp&&>(__t); }
  template<typename _Tp>
    inline typename enable_if<is_lvalue_reference<_Tp>::value, _Tp>::type
    forward(typename std::identity<_Tp>::type __t)
    { return __t; }
  template<typename _Tp>
    inline typename enable_if<is_lvalue_reference<_Tp>::value, _Tp>::type
    forward(typename std::remove_reference<_Tp>::type&& __t) = delete;
  template<typename _Tp>
    inline typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t)
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {
     
      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }
  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;
      _T1 first;
      _T2 second;
      pair()
      : first(), second() { }
      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
      template<class _U1, class = typename
        std::enable_if<std::is_convertible<_U1, _T1>::value>::type>
        pair(_U1&& __x, const _T2& __y)
 : first(std::forward<_U1>(__x)),
   second(__y) { }
      template<class _U2, class = typename
        std::enable_if<std::is_convertible<_U2, _T2>::value>::type>
        pair(const _T1& __x, _U2&& __y)
 : first(__x),
   second(std::forward<_U2>(__y)) { }
      template<class _U1, class _U2, class = typename
        std::enable_if<std::is_convertible<_U1, _T1>::value
         && std::is_convertible<_U2, _T2>::value>::type>
        pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)),
   second(std::forward<_U2>(__y)) { }
      template<class _U1, class _U2>
        pair(const pair<_U1, _U2>& __p)
 : first(__p.first),
   second(__p.second) { }
      template<class _U1, class _U2>
        pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }
      pair&
      operator=(pair&& __p)
      {
 first = std::move(__p.first);
 second = std::move(__p.second);
 return *this;
      }
      template<class _U1, class _U2>
        pair&
        operator=(pair<_U1, _U2>&& __p)
 {
   first = std::move(__p.first);
   second = std::move(__p.second);
   return *this;
 }
      void
      swap(pair& __p)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }
    };
  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }
  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }
  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }
  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }
  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }
  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
  template<class _T1, class _T2>
    inline void
    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    { __x.swap(__y); }
  template<typename _Tp>
    class reference_wrapper;
  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };
  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };
  template<typename _Tp>
    struct __strip_reference_wrapper<const reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };
  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };
  template<class _T1, class _T2>
    inline pair<typename __decay_and_strip<_T1>::__type,
  typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      return pair<typename __decay_and_strip<_T1>::__type,
           typename __decay_and_strip<_T2>::__type>
 (std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
}
       
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  struct input_iterator_tag { };
  struct output_iterator_tag { };
  struct forward_iterator_tag : public input_iterator_tag { };
  struct bidirectional_iterator_tag : public forward_iterator_tag { };
  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {
      typedef _Category iterator_category;
      typedef _Tp value_type;
      typedef _Distance difference_type;
      typedef _Pointer pointer;
      typedef _Reference reference;
    };
  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };
  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };
  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {
     
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }
  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {
     
      return __last - __first;
    }
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {
      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }
  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {
     
      while (__n--)
 ++__i;
    }
  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {
     
      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }
  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {
     
      __i += __n;
    }
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {
      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _ForwardIterator>
    inline typename
    __gnu_cxx::__enable_if<__is_iterator<_ForwardIterator>::__value,
      _ForwardIterator>::__type
    next(_ForwardIterator __x, typename
  iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {
      std::advance(__x, __n);
      return __x;
    }
  template<typename _BidirectionalIterator>
    inline typename
    __gnu_cxx::__enable_if<__is_iterator<_BidirectionalIterator>::__value,
      _BidirectionalIterator>::__type
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {
      std::advance(__x, -__n);
      return __x;
    }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;
      typedef iterator_traits<_Iterator> __traits_type;
    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;
      reverse_iterator() : current() { }
      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }
      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }
      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }
      iterator_type
      base() const
      { return current; }
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }
      pointer
      operator->() const
      { return &(operator*()); }
      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }
      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }
      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }
      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }
      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }
      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }
      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }
      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }
      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }
  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }
  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }
  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }
  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }
  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }
  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }
  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }
  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
    public:
      typedef _Container container_type;
      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }
      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }
      back_insert_iterator&
      operator*()
      { return *this; }
      back_insert_iterator&
      operator++()
      { return *this; }
      back_insert_iterator
      operator++(int)
      { return *this; }
    };
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
    public:
      typedef _Container container_type;
      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }
      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }
      front_insert_iterator&
      operator*()
      { return *this; }
      front_insert_iterator&
      operator++()
      { return *this; }
      front_insert_iterator
      operator++(int)
      { return *this; }
    };
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;
    public:
      typedef _Container container_type;
      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }
      insert_iterator&
      operator*()
      { return *this; }
      insert_iterator&
      operator++()
      { return *this; }
      insert_iterator&
      operator++(int)
      { return *this; }
    };
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }
}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;
      typedef iterator_traits<_Iterator> __traits_type;
    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;
      __normal_iterator() : _M_current(_Iterator()) { }
      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }
      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }
      reference
      operator*() const
      { return *_M_current; }
      pointer
      operator->() const
      { return _M_current; }
      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }
      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }
      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }
      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }
      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }
      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }
      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }
      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }
      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }
      const _Iterator&
      base() const
      { return _M_current; }
    };
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }
  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }
  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }
  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }
  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }
  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }
  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    -> decltype(__lhs.base() - __rhs.base())
    { return __lhs.base() - __rhs.base(); }
  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }
  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;
      typedef iterator_traits<_Iterator> __traits_type;
    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef _Iterator pointer;
      typedef value_type&& reference;
      move_iterator()
      : _M_current() { }
      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }
      template<typename _Iter>
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }
      iterator_type
      base() const
      { return _M_current; }
      reference
      operator*() const
      { return std::move(*_M_current); }
      pointer
      operator->() const
      { return _M_current; }
      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }
      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }
      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }
      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }
      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }
      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }
      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }
      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }
      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }
  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }
  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }
  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(const _Iterator& __i)
    { return move_iterator<_Iterator>(__i); }
}
namespace std
{
  namespace __debug { }
}
namespace __gnu_debug
{
  using namespace std::__debug;
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = std::move(*__a);
          *__a = std::move(*__b);
          *__b = std::move(__tmp);
 }
    };
  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;
     
     
     
     
      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {
     
     
      ;
      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {
     
      if (__b < __a)
 return __b;
      return __a;
    }
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {
     
      if (__a < __b)
 return __b;
      return __a;
    }
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      if (__comp(__b, __a))
 return __b;
      return __a;
    }
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      if (__comp(__a, __b))
 return __b;
      return __a;
    }
  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type
      _S_base(_Iterator __it)
      { return __it; }
    };
  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type
      _S_base(_Iterator __it)
      { return __it.base(); }
    };
  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };
  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }
  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };
  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }
  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };
  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };
  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_pod(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);
      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }
  template<typename _CharT>
    struct char_traits;
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;
  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;
  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);
  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);
  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);
  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {
     
     
      ;
      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {
     
     
      ;
      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }
  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };
  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };
  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_pod(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);
      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }
  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {
     
     
     
      ;
      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {
     
     
     
      ;
      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }
  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {
     
      ;
      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }
  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, ++__first)
 *__first = __value;
      return __first;
    }
  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, ++__first)
 *__first = __tmp;
      return __first;
    }
  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {
     
      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }
  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };
  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };
  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = (__is_integer<_ValueType1>::__value
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);
      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }
  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }
      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };
  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }
      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };
  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };
  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;
 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }
  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };
  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);
      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
     
     
      ;
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 0; __n >>= 1)
 ++__k;
      return __k - 1;
    }
  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }
  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }
  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {
     
     
     
      ;
      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {
     
     
      ;
      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
     
     
     
     
      ;
      ;
      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;
     
     
      ;
      ;
      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {
     
     
     
      ;
      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
     
     
      ;
      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
}
       
       
       
#pragma GCC visibility push(default)
extern "C++" {
namespace std
{
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();
    virtual const char* what() const throw();
  };
  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }
    virtual ~bad_exception() throw();
    virtual const char* what() const throw();
  };
  typedef void (*terminate_handler) ();
  typedef void (*unexpected_handler) ();
  terminate_handler set_terminate(terminate_handler) throw();
  void terminate() throw() __attribute__ ((__noreturn__));
  unexpected_handler set_unexpected(unexpected_handler) throw();
  void unexpected() __attribute__ ((__noreturn__));
  bool uncaught_exception() throw() __attribute__ ((__pure__));
}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
  void __verbose_terminate_handler();
}
}
#pragma GCC visibility pop
#pragma GCC visibility push(default)
extern "C++" {
namespace std
{
  namespace __exception_ptr
  {
    class exception_ptr;
  }
  using __exception_ptr::exception_ptr;
  exception_ptr current_exception() throw();
  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));
  namespace __exception_ptr
  {
    class exception_ptr
    {
      void* _M_exception_object;
      explicit exception_ptr(void* __e) throw();
      void _M_addref() throw();
      void _M_release() throw();
      void *_M_get() const throw() __attribute__ ((__pure__));
      void _M_safe_bool_dummy() throw() __attribute__ ((__const__));
      friend exception_ptr std::current_exception() throw();
      friend void std::rethrow_exception(exception_ptr);
    public:
      exception_ptr() throw();
      typedef void (exception_ptr::*__safe_bool)();
      exception_ptr(__safe_bool) throw();
      exception_ptr(const exception_ptr&) throw();
      exception_ptr(exception_ptr&& __o) throw()
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
      exception_ptr&
      operator=(const exception_ptr&) throw();
      exception_ptr&
      operator=(exception_ptr&& __o) throw()
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }
      ~exception_ptr() throw();
      void
      swap(exception_ptr&) throw();
      friend bool
      operator==(const exception_ptr&, const exception_ptr&) throw()
      __attribute__ ((__pure__));
      const type_info*
      __cxa_exception_type() const throw() __attribute__ ((__pure__));
    };
    bool
    operator==(const exception_ptr&, const exception_ptr&) throw()
    __attribute__ ((__pure__));
    bool
    operator!=(const exception_ptr&, const exception_ptr&) throw()
    __attribute__ ((__pure__));
  }
  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) throw()
    {
      try
 {
   throw __ex;
 }
      catch(...)
 {
   return current_exception();
 }
    }
}
}
#pragma GCC visibility pop
#pragma GCC visibility push(default)
extern "C++" {
namespace std
{
  class nested_exception
  {
    exception_ptr _M_ptr;
  public:
    nested_exception() throw() : _M_ptr(current_exception()) { }
    nested_exception(const nested_exception&) = default;
    nested_exception& operator=(const nested_exception&) = default;
    inline virtual ~nested_exception();
    void
    rethrow_nested() const __attribute__ ((__noreturn__))
    { rethrow_exception(_M_ptr); }
    exception_ptr
    nested_ptr() const
    { return _M_ptr; }
  };
  inline nested_exception::~nested_exception() = default;
  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };
  template<typename _Ex>
    struct __get_nested_helper
    {
      static const nested_exception*
      _S_get(const _Ex& __ex)
      { return dynamic_cast<const nested_exception*>(&__ex); }
    };
  template<typename _Ex>
    struct __get_nested_helper<_Ex*>
    {
      static const nested_exception*
      _S_get(const _Ex* __ex)
      { return dynamic_cast<const nested_exception*>(__ex); }
    };
  template<typename _Ex>
    inline const nested_exception*
    __get_nested_exception(const _Ex& __ex)
    { return __get_nested_helper<_Ex>::_S_get(__ex); }
  template<typename _Ex>
    void
    __throw_with_nested(_Ex&&, const nested_exception* = 0)
    __attribute__ ((__noreturn__));
  template<typename _Ex>
    void
    __throw_with_nested(_Ex&&, ...) __attribute__ ((__noreturn__));
  template<typename _Ex>
    inline void
    __throw_with_nested(_Ex&& __ex, const nested_exception* = 0)
    { throw __ex; }
  template<typename _Ex>
    inline void
    __throw_with_nested(_Ex&& __ex, ...)
    { throw _Nested_exception<_Ex>(static_cast<_Ex&&>(__ex)); }
  template<typename _Ex>
    void
    throw_with_nested(_Ex __ex) __attribute__ ((__noreturn__));
  template<typename _Ex>
    inline void
    throw_with_nested(_Ex __ex)
    {
      if (__get_nested_exception(__ex))
        throw __ex;
      __throw_with_nested(static_cast<_Ex&&>(__ex), &__ex);
    }
  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    {
      if (const nested_exception* __nested = __get_nested_exception(__ex))
        __nested->rethrow_nested();
    }
  inline void
  rethrow_if_nested(const nested_exception& __ex)
  { __ex.rethrow_nested(); }
}
}
#pragma GCC visibility pop
#pragma GCC visibility push(default)
extern "C++" {
namespace std
{
  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }
    virtual ~bad_alloc() throw();
    virtual const char* what() const throw();
  };
  struct nothrow_t { };
  extern const nothrow_t nothrow;
  typedef void (*new_handler)();
  new_handler set_new_handler(new_handler) throw();
}
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();
inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }
inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }
}
#pragma GCC visibility pop
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
  using std::size_t;
  using std::ptrdiff_t;
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;
      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };
      new_allocator() throw() { }
      new_allocator(const new_allocator&) throw() { }
      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }
      ~new_allocator() throw() { }
      pointer
      address(reference __x) const { return &__x; }
      const_pointer
      address(const_reference __x) const { return &__x; }
      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();
 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }
      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }
      template<typename... _Args>
        void
        construct(pointer __p, _Args&&... __args)
 { ::new((void *)__p) _Tp(std::forward<_Args>(__args)...); }
      void
      destroy(pointer __p) { __p->~_Tp(); }
    };
  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }
  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Tp>
    class allocator;
  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;
      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;
      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
      allocator() throw() { }
      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }
      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }
      ~allocator() throw() { }
    };
  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }
  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }
  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }
  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }
  extern template class allocator<char>;
  extern template class allocator<wchar_t>;
  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };
  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {
 if (__one != __two)
   swap(__one, __two);
      }
    };
  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };
  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };
   template<typename _Tp,
     bool = __has_trivial_copy(typename _Tp::value_type)>
     struct __shrink_to_fit
     { static void _S_do_it(_Tp&) { } };
   template<typename _Tp>
     struct __shrink_to_fit<_Tp, true>
     {
       static void
       _S_do_it(_Tp& __v)
       {
  try
    { _Tp(__v).swap(__v); }
  catch(...) { }
       }
     };
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, _T2&& __value)
    {
      ::new(static_cast<void*>(__p)) _T1(std::forward<_T2>(__value));
    }
  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }
  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(&*__first);
 }
    };
  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };
  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }
  template <typename _Tp> class allocator;
  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)
 __alloc.destroy(&*__first);
    }
  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<bool>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        uninitialized_copy(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, ++__cur)
  std::_Construct(&*__cur, *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };
  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        uninitialized_copy(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;
      return std::__uninitialized_copy<(__is_pod(_ValueType1)
     && __is_pod(_ValueType2))>::
 uninitialized_copy(__first, __last, __result);
    }
  template<bool>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        uninitialized_fill(_ForwardIterator __first,
      _ForwardIterator __last, const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(&*__cur, __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };
  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        uninitialized_fill(_ForwardIterator __first,
      _ForwardIterator __last, const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      std::__uninitialized_fill<__is_pod(_ValueType)>::
 uninitialized_fill(__first, __last, __x);
    }
  template<bool>
    struct __uninitialized_construct_range_dispatch
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __ucr(_ForwardIterator __first, _ForwardIterator __last,
       _Tp& __value)
        {
   if(__first == __last)
     return;
   _ForwardIterator __cur = __first;
   try
     {
       std::_Construct(&*__first, std::move(__value));
       _ForwardIterator __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(&*__cur, std::move(*__prev));
       __value = std::move(*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };
  template<>
    struct __uninitialized_construct_range_dispatch<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __ucr(_ForwardIterator, _ForwardIterator, _Tp&) { }
    };
  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_construct_range(_ForwardIterator __first,
        _ForwardIterator __last,
        _Tp& __value)
    {
      typedef typename std::iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      std::__uninitialized_construct_range_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __value);
    }
  template<bool>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        uninitialized_fill_n(_ForwardIterator __first, _Size __n,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(&*__cur, __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };
  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        uninitialized_fill_n(_ForwardIterator __first, _Size __n,
        const _Tp& __x)
        { std::fill_n(__first, __n, __x); }
    };
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      std::__uninitialized_fill_n<__is_pod(_ValueType)>::
 uninitialized_fill_n(__first, __n, __x);
    }
  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, ++__cur)
     __alloc.construct(&*__cur, *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }
  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }
  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }
  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }
  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }
  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, ++__cur)
     __alloc.construct(&*__cur, __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }
  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill_n(__first, __n, __x); }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }
  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }
  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }
  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, ++__first, ++__cur)
     ::new(static_cast<void*>(&*__cur)) typename
  iterator_traits<_ForwardIterator>::value_type(*__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }
  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }
}
       
#pragma GCC visibility push(default)
       
namespace std
{
  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;
    private:
      iterator _M_array;
      size_type _M_len;
      initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }
    public:
      initializer_list() : _M_array(__null), _M_len(0) { }
      size_type
      size() const { return _M_len; }
      const_iterator
      begin() const { return _M_array; }
      const_iterator
      end() const { return begin() + size(); }
  };
}
#pragma GCC visibility pop
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;
      struct _Vector_impl
      : public _Tp_alloc_type
      {
 typename _Tp_alloc_type::pointer _M_start;
 typename _Tp_alloc_type::pointer _M_finish;
 typename _Tp_alloc_type::pointer _M_end_of_storage;
 _Vector_impl()
 : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
      };
    public:
      typedef _Alloc allocator_type;
      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }
      _Vector_base()
      : _M_impl() { }
      _Vector_base(const allocator_type& __a)
      : _M_impl(__a) { }
      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
      _Vector_base(_Vector_base&& __x)
      : _M_impl(__x._M_get_Tp_allocator())
      {
 this->_M_impl._M_start = __x._M_impl._M_start;
 this->_M_impl._M_finish = __x._M_impl._M_finish;
 this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
 __x._M_impl._M_start = 0;
 __x._M_impl._M_finish = 0;
 __x._M_impl._M_end_of_storage = 0;
      }
      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }
    public:
      _Vector_impl _M_impl;
      typename _Tp_alloc_type::pointer
      _M_allocate(size_t __n)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }
      void
      _M_deallocate(typename _Tp_alloc_type::pointer __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }
    };
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
      typedef typename _Alloc::value_type _Alloc_value_type;
     
     
      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;
    public:
      vector()
      : _Base() { }
      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
      vector(const vector& __x)
      : _Base(__x.size(), __x._M_get_Tp_allocator())
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
      vector(vector&& __x)
      : _Base(std::forward<_Base>(__x)) { }
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }
      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
      vector&
      operator=(const vector& __x);
      vector&
      operator=(vector&& __x)
      {
 this->clear();
 this->swap(__x);
 return *this;
      }
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }
      using _Base::get_allocator;
      iterator
      begin()
      { return iterator(this->_M_impl._M_start); }
      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_start); }
      iterator
      end()
      { return iterator(this->_M_impl._M_finish); }
      const_iterator
      end() const
      { return const_iterator(this->_M_impl._M_finish); }
      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }
      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }
      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }
      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
      const_iterator
      cbegin() const
      { return const_iterator(this->_M_impl._M_start); }
      const_iterator
      cend() const
      { return const_iterator(this->_M_impl._M_finish); }
      const_reverse_iterator
      crbegin() const
      { return const_reverse_iterator(end()); }
      const_reverse_iterator
      crend() const
      { return const_reverse_iterator(begin()); }
      size_type
      size() const
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
 else
   insert(end(), __new_size - size(), __x);
      }
      void
      shrink_to_fit()
      { std::__shrink_to_fit<vector>::_S_do_it(*this); }
      size_type
      capacity() const
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }
      bool
      empty() const
      { return begin() == end(); }
      void
      reserve(size_type __n);
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }
    protected:
      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }
    public:
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
      reference
      front()
      { return *begin(); }
      const_reference
      front() const
      { return *begin(); }
      reference
      back()
      { return *(end() - 1); }
      const_reference
      back() const
      { return *(end() - 1); }
      pointer
      data()
      { return pointer(this->_M_impl._M_start); }
      const_pointer
      data() const
      { return const_pointer(this->_M_impl._M_start); }
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     this->_M_impl.construct(this->_M_impl._M_finish, __x);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), __x);
      }
      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }
      template<typename... _Args>
        void
        emplace_back(_Args&&... __args);
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 this->_M_impl.destroy(this->_M_impl._M_finish);
      }
      template<typename... _Args>
        iterator
        emplace(iterator __position, _Args&&... __args);
      iterator
      insert(iterator __position, const value_type& __x);
      iterator
      insert(iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
      void
      insert(iterator __position, initializer_list<value_type> __l)
      { this->insert(__position, __l.begin(), __l.end()); }
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
      iterator
      erase(iterator __position);
      iterator
      erase(iterator __first, iterator __last);
      void
      swap(vector& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);
 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }
      void
      clear()
      { _M_erase_at_end(this->_M_impl._M_start); }
    protected:
      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }
      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }
      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }
      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }
      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }
      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);
      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);
      void
      _M_fill_assign(size_type __n, const value_type& __val);
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }
      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }
      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);
      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);
      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
      template<typename... _Args>
        void
        _M_insert_aux(iterator __position, _Args&&... __args);
      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));
 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }
      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }
    };
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }
  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };
  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;
    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }
    _Bit_reference() : _M_p(0), _M_mask(0) { }
    operator bool() const
    { return !!(*_M_p & _M_mask); }
    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }
    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }
    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }
    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }
    void
    flip()
    { *_M_p ^= _M_mask; }
  };
  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;
    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }
    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }
    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }
    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }
    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }
    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }
    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }
    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }
    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }
    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };
  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }
  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;
    _Bit_iterator() : _Bit_iterator_base(0, 0) { }
    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }
    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }
    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }
    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }
    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }
    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }
    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }
    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }
    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }
    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }
    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };
  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }
  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;
    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }
    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }
    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }
    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }
    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }
    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }
    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }
    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }
    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }
    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }
    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }
    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }
    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };
  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }
  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }
  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }
  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;
      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;
 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }
      };
    public:
      typedef _Alloc allocator_type;
      _Bit_alloc_type&
      _M_get_Bit_allocator()
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }
      const _Bit_alloc_type&
      _M_get_Bit_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }
      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Bit_allocator()); }
      _Bvector_base()
      : _M_impl() { }
      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }
      _Bvector_base(_Bvector_base&& __x)
      : _M_impl(__x._M_get_Bit_allocator())
      {
 this->_M_impl._M_start = __x._M_impl._M_start;
 this->_M_impl._M_finish = __x._M_impl._M_finish;
 this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
 __x._M_impl._M_start = _Bit_iterator();
 __x._M_impl._M_finish = _Bit_iterator();
 __x._M_impl._M_end_of_storage = 0;
      }
      ~_Bvector_base()
      { this->_M_deallocate(); }
    protected:
      _Bvector_impl _M_impl;
      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate((__n + int(_S_word_bit) - 1)
    / int(_S_word_bit)); }
      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }
    };
}
namespace std __attribute__ ((__visibility__ ("default"))) {
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;
    template<typename> friend class hash;
  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;
    allocator_type get_allocator() const
    { return _Base::get_allocator(); }
  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_M_get_Bit_allocator;
  public:
    vector()
    : _Base() { }
    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }
    explicit
    vector(size_type __n, const bool& __value = bool(),
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }
    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }
    vector(vector&& __x)
    : _Base(std::forward<_Base>(__x)) { }
    vector(initializer_list<bool> __l,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize_range(__l.begin(), __l.end(),
     random_access_iterator_tag());
    }
    template<typename _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }
    ~vector() { }
    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }
    vector&
    operator=(vector&& __x)
    {
      this->clear();
      this->swap(__x);
      return *this;
    }
    vector&
    operator=(initializer_list<bool> __l)
    {
      this->assign (__l.begin(), __l.end());
      return *this;
    }
    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }
    template<typename _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }
    void
    assign(initializer_list<bool> __l)
    { this->assign(__l.begin(), __l.end()); }
    iterator
    begin()
    { return this->_M_impl._M_start; }
    const_iterator
    begin() const
    { return this->_M_impl._M_start; }
    iterator
    end()
    { return this->_M_impl._M_finish; }
    const_iterator
    end() const
    { return this->_M_impl._M_finish; }
    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }
    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }
    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }
    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }
    const_iterator
    cbegin() const
    { return this->_M_impl._M_start; }
    const_iterator
    cend() const
    { return this->_M_impl._M_finish; }
    const_reverse_iterator
    crbegin() const
    { return const_reverse_iterator(end()); }
    const_reverse_iterator
    crend() const
    { return const_reverse_iterator(begin()); }
    size_type
    size() const
    { return size_type(end() - begin()); }
    size_type
    max_size() const
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }
    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }
    bool
    empty() const
    { return begin() == end(); }
    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }
    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }
  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }
  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }
    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }
    void
    reserve(size_type __n);
    reference
    front()
    { return *begin(); }
    const_reference
    front() const
    { return *begin(); }
    reference
    back()
    { return *(end() - 1); }
    const_reference
    back() const
    { return *(end() - 1); }
    void
    data() { }
    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }
    void
    swap(vector& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);
      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }
    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }
    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }
    template<typename _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }
    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }
    void insert(iterator __p, initializer_list<bool> __l)
    { this->insert(__p, __l.begin(), __l.end()); }
    void
    pop_back()
    { --this->_M_impl._M_finish; }
    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }
    iterator
    erase(iterator __first, iterator __last)
    {
      _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }
    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }
    void
    shrink_to_fit()
    { std::__shrink_to_fit<vector>::_S_do_it(*this); }
    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }
    void
    clear()
    { _M_erase_at_end(begin()); }
  protected:
    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }
    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = (__q
      + ((__n + int(_S_word_bit) - 1)
         / int(_S_word_bit)));
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }
    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }
    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }
    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }
    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }
    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }
    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }
    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }
    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }
    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }
    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }
    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);
    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }
    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);
    void
    _M_insert_aux(iterator __position, bool __x);
    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));
      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }
    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };
}
       
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Arg, typename _Result>
    struct unary_function
    {
      typedef _Arg argument_type;
      typedef _Result result_type;
    };
  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {
      typedef _Arg1 first_argument_type;
      typedef _Arg2 second_argument_type;
      typedef _Result result_type;
    };
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };
  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };
  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };
  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };
  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };
  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };
  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };
  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };
  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };
  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };
  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };
  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };
  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };
  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };
  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;
    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };
  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }
  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;
    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };
  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);
    public:
      pointer_to_unary_function() { }
      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }
      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };
  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }
  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);
    public:
      pointer_to_binary_function() { }
      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }
      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };
  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }
  template<typename _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }
      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };
  template<typename _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }
      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
    };
  template<typename _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }
      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }
      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)();
    };
  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }
      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)() const;
    };
  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }
      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)();
  };
  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }
      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }
    private:
      _Ret (_Tp::*_M_f)() const;
    };
  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }
      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };
  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }
      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };
  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }
      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };
  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }
      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }
    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };
  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }
  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }
  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }
  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }
  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }
  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }
  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;
    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }
      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));
  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }
  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;
    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }
      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));
  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }
}
namespace std
{
  template<typename _Tp>
    struct hash : public std::unary_function<_Tp, size_t>
    {
      size_t
      operator()(_Tp __val) const;
    };
  template<typename _Tp>
    struct hash<_Tp*> : public std::unary_function<_Tp*, size_t>
    {
      size_t
      operator()(_Tp* __p) const
      { return reinterpret_cast<size_t>(__p); }
    };
  template<> inline size_t hash<bool>::operator()(bool __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<char>::operator()(char __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<signed char>::operator()(signed char __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<unsigned char>::operator()(unsigned char __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<wchar_t>::operator()(wchar_t __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<char16_t>::operator()(char16_t __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<char32_t>::operator()(char32_t __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<short>::operator()(short __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<int>::operator()(int __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<long>::operator()(long __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<long long>::operator()(long long __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<unsigned short>::operator()(unsigned short __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<unsigned int>::operator()(unsigned int __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<unsigned long>::operator()(unsigned long __val) const { return static_cast<size_t>(__val); };
  template<> inline size_t hash<unsigned long long>::operator()(unsigned long long __val) const { return static_cast<size_t>(__val); };
  template<size_t>
    struct _Fnv_hash_base
    {
      template<typename _Tp>
        static size_t
        hash(const _Tp* __ptr, size_t __clength, size_t __hash = 0)
        {
   const char* __cptr = reinterpret_cast<const char*>(__ptr);
   for (; __clength; --__clength)
     __hash = (__hash * 131) + *__cptr++;
   return __hash;
 }
    };
  template<>
    struct _Fnv_hash_base<4>
    {
      template<typename _Tp>
        static size_t
        hash(const _Tp* __ptr, size_t __clength,
      size_t __hash = static_cast<size_t>(2166136261UL))
        {
   const char* __cptr = reinterpret_cast<const char*>(__ptr);
   for (; __clength; --__clength)
     {
       __hash ^= static_cast<size_t>(*__cptr++);
       __hash *= static_cast<size_t>(16777619UL);
     }
   return __hash;
 }
    };
  template<>
    struct _Fnv_hash_base<8>
    {
      template<typename _Tp>
        static size_t
        hash(const _Tp* __ptr, size_t __clength,
      size_t __hash = static_cast<size_t>(14695981039346656037ULL))
        {
   const char* __cptr = reinterpret_cast<const char*>(__ptr);
   for (; __clength; --__clength)
     {
       __hash ^= static_cast<size_t>(*__cptr++);
       __hash *= static_cast<size_t>(1099511628211ULL);
     }
   return __hash;
 }
    };
    struct _Fnv_hash
    : public _Fnv_hash_base<sizeof(size_t)>
    {
      using _Fnv_hash_base<sizeof(size_t)>::hash;
      template<typename _Tp>
        static size_t
        hash(const _Tp& __val)
        { return hash(&__val, sizeof(__val)); }
      template<typename _Tp>
        static size_t
        __hash_combine(const _Tp& __val, size_t __hash)
        { return hash(&__val, sizeof(__val), __hash); }
    };
  template<>
    inline size_t
    hash<float>::operator()(float __val) const
    {
      return __val != 0.0f ? std::_Fnv_hash::hash(__val) : 0;
    }
  template<>
    inline size_t
    hash<double>::operator()(double __val) const
    {
      return __val != 0.0 ? std::_Fnv_hash::hash(__val) : 0;
    }
  template<>
    __attribute__ ((__pure__)) size_t
    hash<long double>::operator()(long double __val) const;
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public std::unary_function<std::vector<bool, _Alloc>, size_t>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>& __b) const;
    };
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
   std::make_move_iterator(this->_M_impl._M_start),
   std::make_move_iterator(this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     this->_M_impl.construct(this->_M_impl._M_finish,
        std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(end(), std::forward<_Args>(__args)...);
      }
  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   this->_M_impl.construct(this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {
   if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
     {
       _Tp __x_copy = __x;
       _M_insert_aux(__position, std::move(__x_copy));
     }
   else
     _M_insert_aux(__position, __x);
 }
      return iterator(this->_M_impl._M_start + __n);
    }
  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      this->_M_impl.destroy(this->_M_impl._M_finish);
      return __position;
    }
  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__last != end())
 std::move(__last, end(), __first);
      _M_erase_at_end(__first.base() + (end() - __last));
      return __first;
    }
  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }
  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }
  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename vector<_Tp, _Alloc>::iterator
      vector<_Tp, _Alloc>::
      emplace(iterator __position, _Args&&... __args)
      {
 const size_type __n = __position - begin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
     && __position == end())
   {
     this->_M_impl.construct(this->_M_impl._M_finish,
        std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(__position, std::forward<_Args>(__args)...);
 return iterator(this->_M_impl._M_start + __n);
      }
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Args&&... __args)
    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   this->_M_impl.construct(this->_M_impl._M_finish,
      std::move(*(this->_M_impl._M_finish - 1)));
   ++this->_M_impl._M_finish;
   std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1);
   *__position = _Tp(std::forward<_Args>(__args)...);
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {
       this->_M_impl.construct(__new_start + __elems_before,
          std::forward<_Args>(__args)...);
       __new_finish = 0;
       __new_finish =
  std::__uninitialized_move_a(this->_M_impl._M_start,
         __position.base(), __new_start,
         _M_get_Tp_allocator());
       ++__new_finish;
       __new_finish =
  std::__uninitialized_move_a(__position.base(),
         this->_M_impl._M_finish,
         __new_finish,
         _M_get_Tp_allocator());
     }
          catch(...)
     {
       if (!__new_finish)
  this->_M_impl.destroy(__new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish);
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {
    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = 0;
    __new_finish =
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __position.base(),
      __new_start,
      _M_get_Tp_allocator());
    __new_finish += __n;
    __new_finish =
      std::__uninitialized_move_a(__position.base(),
      this->_M_impl._M_finish,
      __new_finish,
      _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }
  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }
  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish);
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish =
        std::__uninitialized_move_a(this->_M_impl._M_start,
        __position.base(),
        __new_start,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_copy_a(__first, __last,
        __new_finish,
        _M_get_Tp_allocator());
      __new_finish =
        std::__uninitialized_move_a(__position.base(),
        this->_M_impl._M_finish,
        __new_finish,
        _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }
  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   _Bit_type* __q = this->_M_allocate(__n);
   this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
          iterator(__q, 0));
   this->_M_deallocate();
   this->_M_impl._M_start = iterator(__q, 0);
   this->_M_impl._M_end_of_storage = (__q + (__n + int(_S_word_bit) - 1)
          / int(_S_word_bit));
 }
    }
  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }
  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = (__q
         + ((__len
             + int(_S_word_bit) - 1)
            / int(_S_word_bit)));
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }
  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = (__q + ((__len
           + int(_S_word_bit) - 1)
          / int(_S_word_bit)));
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;
      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Fnv_hash::hash(__b._M_impl._M_start._M_p, __clength);
 }
      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);
   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Fnv_hash::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Fnv_hash::hash(&__hiword, __clength);
 }
      return __hash;
    }
}
       
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Alloc>
    class allocator;
  template<class _CharT>
    struct char_traits;
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;
  template<> struct char_traits<char>;
  typedef basic_string<char> string;
  template<> struct char_traits<wchar_t>;
  typedef basic_string<wchar_t> wstring;
  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;
  typedef basic_string<char16_t> u16string;
  typedef basic_string<char32_t> u32string;
}
       
       
       
       
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;
typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
typedef int __darwin_ct_rune_t;
typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;
typedef __mbstate_t __darwin_mbstate_t;
typedef long int __darwin_ptrdiff_t;
typedef long unsigned int __darwin_size_t;
typedef __builtin_va_list __darwin_va_list;
typedef int __darwin_wchar_t;
typedef __darwin_wchar_t __darwin_rune_t;
typedef int __darwin_wint_t;
typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
struct __darwin_pthread_handler_rec
{
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};
struct _opaque_pthread_attr_t { long __sig; char __opaque[56]; };
struct _opaque_pthread_cond_t { long __sig; char __opaque[40]; };
struct _opaque_pthread_condattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_mutex_t { long __sig; char __opaque[56]; };
struct _opaque_pthread_mutexattr_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_once_t { long __sig; char __opaque[8]; };
struct _opaque_pthread_rwlock_t { long __sig; char __opaque[192]; };
struct _opaque_pthread_rwlockattr_t { long __sig; char __opaque[16]; };
struct _opaque_pthread_t { long __sig; struct __darwin_pthread_handler_rec *__cleanup_stack; char __opaque[1168]; };
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;
typedef __darwin_ino64_t __darwin_ino_t;
typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef struct _opaque_pthread_attr_t
   __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t
   __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t
   __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t
   __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t
   __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t
   __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t
   __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t
   __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t
   *__darwin_pthread_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;
typedef __uint32_t __darwin_wctype_t;
typedef __darwin_mbstate_t mbstate_t;
typedef __darwin_ct_rune_t ct_rune_t;
typedef __darwin_rune_t rune_t;
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
typedef __darwin_off_t fpos_t;
struct __sbuf {
 unsigned char *_base;
 int _size;
};
struct __sFILEX;
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;
 void *_cookie;
 int (*_close)(void *);
 int (*_read) (void *, char *, int);
 fpos_t (*_seek) (void *, fpos_t, int);
 int (*_write)(void *, const char *, int);
 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;
 unsigned char _ubuf[3];
 unsigned char _nbuf[1];
 struct __sbuf _lb;
 int _blksize;
 fpos_t _offset;
} FILE;
extern "C" {
extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
}
extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * , fpos_t *);
char *fgets(char * , int, FILE *);
FILE *fopen(const char * , const char * ) __asm("_" "fopen" );
int fprintf(FILE * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char * , FILE * ) __asm("_" "fputs" );
size_t fread(void * , size_t, size_t, FILE * );
FILE *freopen(const char * , const char * ,
                 FILE * ) __asm("_" "freopen" );
int fscanf(FILE * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * , size_t, size_t, FILE * ) __asm("_" "fwrite" );
int getc(FILE *);
int getchar(void);
char *gets(char *);
void perror(const char *);
int printf(const char * , ...) __attribute__((__format__ (__printf__, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *, const char *);
void rewind(FILE *);
int scanf(const char * , ...) __attribute__((__format__ (__scanf__, 1, 2)));
void setbuf(FILE * , char * );
int setvbuf(FILE * , char * , int, size_t);
int sprintf(char * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int sscanf(const char * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
FILE *tmpfile(void);
char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
int vprintf(const char * , va_list) __attribute__((__format__ (__printf__, 1, 0)));
int vsprintf(char * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
}
extern "C" {
char *ctermid(char *);
FILE *fdopen(int, const char *) __asm("_" "fdopen" );
int fileno(FILE *);
}
extern "C" {
int pclose(FILE *);
FILE *popen(const char *, const char *) __asm("_" "popen" );
}
extern "C" {
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int __swbuf(int, FILE *);
}
static inline int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
extern "C" {
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);
int getw(FILE *);
int putw(int, FILE *);
char *tempnam(const char *, const char *) __asm("_" "tempnam" );
}
typedef __darwin_off_t off_t;
extern "C" {
int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);
}
extern "C" {
int snprintf(char * , size_t, const char * , ...) __attribute__((__format__ (__printf__, 3, 4)));
int vfscanf(FILE * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int vscanf(const char * , va_list) __attribute__((__format__ (__scanf__, 1, 0)));
int vsnprintf(char * , size_t, const char * , va_list) __attribute__((__format__ (__printf__, 3, 0)));
int vsscanf(const char * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));
}
typedef __darwin_ssize_t ssize_t;
extern "C" {
int dprintf(int, const char * , ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((visibility("default")));
int vdprintf(int, const char * , va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((visibility("default")));
ssize_t getdelim(char ** , size_t * , int, FILE * ) __attribute__((visibility("default")));
ssize_t getline(char ** , size_t * , FILE * ) __attribute__((visibility("default")));
}
extern "C" {
extern const int sys_nerr;
extern const char *const sys_errlist[];
int asprintf(char **, const char *, ...) __attribute__((__format__ (__printf__, 2, 3)));
char *ctermid_r(char *);
char *fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *);
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char **, const char *, va_list) __attribute__((__format__ (__printf__, 2, 0)));
FILE *zopen(const char *, const char *, int);
FILE *funopen(const void *,
                 int (*)(void *, char *, int),
                 int (*)(void *, const char *, int),
                 fpos_t (*)(void *, fpos_t, int),
                 int (*)(void *));
}
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};
typedef __darwin_clock_t clock_t;
typedef __darwin_time_t time_t;
struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
extern char *tzname[];
extern int getdate_err;
extern long timezone __asm("_" "timezone" );
extern int daylight;
extern "C" {
char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock" );
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime" );
size_t strftime(char * , size_t, const char * , const struct tm * ) __asm("_" "strftime" );
char *strptime(const char * , const char * , struct tm * ) __asm("_" "strptime" );
time_t time(time_t *);
void tzset(void);
char *asctime_r(const struct tm * , char * );
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * , struct tm * );
struct tm *localtime_r(const time_t * , struct tm * );
time_t posix2time(time_t);
void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);
int nanosleep(const struct timespec *, struct timespec *) __asm("_" "nanosleep" );
}
typedef __darwin_wint_t wint_t;
typedef __darwin_wctype_t wctype_t;
typedef struct {
 __darwin_rune_t __min;
 __darwin_rune_t __max;
 __darwin_rune_t __map;
 __uint32_t *__types;
} _RuneEntry;
typedef struct {
 int __nranges;
 _RuneEntry *__ranges;
} _RuneRange;
typedef struct {
 char __name[14];
 __uint32_t __mask;
} _RuneCharClass;
typedef struct {
 char __magic[8];
 char __encoding[32];
 __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
 int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
 __darwin_rune_t __invalid_rune;
 __uint32_t __runetype[(1 <<8 )];
 __darwin_rune_t __maplower[(1 <<8 )];
 __darwin_rune_t __mapupper[(1 <<8 )];
 _RuneRange __runetype_ext;
 _RuneRange __maplower_ext;
 _RuneRange __mapupper_ext;
 void *__variable;
 int __variable_len;
 int __ncharclasses;
 _RuneCharClass *__charclasses;
} _RuneLocale;
extern "C" {
extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;
}
extern "C" {
unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);
}
static inline int
isascii(int _c)
{
 return ((_c & ~0x7F) == 0);
}
extern "C" {
int __maskrune(__darwin_ct_rune_t, unsigned long);
}
static inline int
__istype(__darwin_ct_rune_t _c, unsigned long _f)
{
 return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)
  : !!__maskrune(_c, _f));
}
static inline __darwin_ct_rune_t
__isctype(__darwin_ct_rune_t _c, unsigned long _f)
{
 return (_c < 0 || _c >= (1 <<8 )) ? 0 :
  !!(_DefaultRuneLocale.__runetype[_c] & _f);
}
extern "C" {
__darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
__darwin_ct_rune_t __tolower(__darwin_ct_rune_t);
}
static inline int
__wcwidth(__darwin_ct_rune_t _c)
{
 unsigned int _x;
 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune(_c, 0xe0000000L|0x00040000L);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}
static inline int
isalnum(int _c)
{
 return (__istype(_c, 0x00000100L|0x00000400L));
}
static inline int
isalpha(int _c)
{
 return (__istype(_c, 0x00000100L));
}
static inline int
isblank(int _c)
{
 return (__istype(_c, 0x00020000L));
}
static inline int
iscntrl(int _c)
{
 return (__istype(_c, 0x00000200L));
}
static inline int
isdigit(int _c)
{
 return (__isctype(_c, 0x00000400L));
}
static inline int
isgraph(int _c)
{
 return (__istype(_c, 0x00000800L));
}
static inline int
islower(int _c)
{
 return (__istype(_c, 0x00001000L));
}
static inline int
isprint(int _c)
{
 return (__istype(_c, 0x00040000L));
}
static inline int
ispunct(int _c)
{
 return (__istype(_c, 0x00002000L));
}
static inline int
isspace(int _c)
{
 return (__istype(_c, 0x00004000L));
}
static inline int
isupper(int _c)
{
 return (__istype(_c, 0x00008000L));
}
static inline int
isxdigit(int _c)
{
 return (__isctype(_c, 0x00010000L));
}
static inline int
toascii(int _c)
{
 return (_c & 0x7F);
}
static inline int
tolower(int _c)
{
        return (__tolower(_c));
}
static inline int
toupper(int _c)
{
        return (__toupper(_c));
}
static inline int
digittoint(int _c)
{
 return (__maskrune(_c, 0x0F));
}
static inline int
ishexnumber(int _c)
{
 return (__istype(_c, 0x00010000L));
}
static inline int
isideogram(int _c)
{
 return (__istype(_c, 0x00080000L));
}
static inline int
isnumber(int _c)
{
 return (__istype(_c, 0x00000400L));
}
static inline int
isphonogram(int _c)
{
 return (__istype(_c, 0x00200000L));
}
static inline int
isrune(int _c)
{
 return (__istype(_c, 0xFFFFFFF0L));
}
static inline int
isspecial(int _c)
{
 return (__istype(_c, 0x00100000L));
}
static inline int
iswalnum(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L|0x00000400L));
}
static inline int
iswalpha(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L));
}
static inline int
iswcntrl(wint_t _wc)
{
 return (__istype(_wc, 0x00000200L));
}
static inline int
iswctype(wint_t _wc, wctype_t _charclass)
{
 return (__istype(_wc, _charclass));
}
static inline int
iswdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00000400L));
}
static inline int
iswgraph(wint_t _wc)
{
 return (__istype(_wc, 0x00000800L));
}
static inline int
iswlower(wint_t _wc)
{
 return (__istype(_wc, 0x00001000L));
}
static inline int
iswprint(wint_t _wc)
{
 return (__istype(_wc, 0x00040000L));
}
static inline int
iswpunct(wint_t _wc)
{
 return (__istype(_wc, 0x00002000L));
}
static inline int
iswspace(wint_t _wc)
{
 return (__istype(_wc, 0x00004000L));
}
static inline int
iswupper(wint_t _wc)
{
 return (__istype(_wc, 0x00008000L));
}
static inline int
iswxdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00010000L));
}
static inline wint_t
towlower(wint_t _wc)
{
        return (__tolower(_wc));
}
static inline wint_t
towupper(wint_t _wc)
{
        return (__toupper(_wc));
}
extern "C" {
wctype_t
 wctype(const char *);
}
extern "C" {
wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t *fgetws(wchar_t * , int, FILE * );
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t * , FILE * );
int fwide(FILE *, int);
int fwprintf(FILE * , const wchar_t * , ...) ;
int fwscanf(FILE * , const wchar_t * , ...) ;
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char * , size_t, mbstate_t * );
size_t mbrtowc(wchar_t * , const char * , size_t,
     mbstate_t * );
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t * , const char ** , size_t,
     mbstate_t * );
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t * , size_t, const wchar_t * ,
     ...) ;
int swscanf(const wchar_t * , const wchar_t * , ...) ;
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE * , const wchar_t * ,
     __darwin_va_list) ;
int vswprintf(wchar_t * , size_t, const wchar_t * ,
     __darwin_va_list) ;
int vwprintf(const wchar_t * , __darwin_va_list) ;
size_t wcrtomb(char * , wchar_t, mbstate_t * );
wchar_t *wcscat(wchar_t * , const wchar_t * );
wchar_t *wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t * , const wchar_t * );
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcsftime(wchar_t * , size_t, const wchar_t * ,
     const struct tm * ) __asm("_" "wcsftime" );
size_t wcslen(const wchar_t *);
wchar_t *wcsncat(wchar_t * , const wchar_t * , size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t *wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char * , const wchar_t ** , size_t,
     mbstate_t * );
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcsstr(const wchar_t * , const wchar_t * );
size_t wcsxfrm(wchar_t * , const wchar_t * , size_t);
int wctob(wint_t);
double wcstod(const wchar_t * , wchar_t ** );
wchar_t *wcstok(wchar_t * , const wchar_t * ,
     wchar_t ** );
long wcstol(const wchar_t * , wchar_t ** , int);
unsigned long
  wcstoul(const wchar_t * , wchar_t ** , int);
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t * , const wchar_t * , size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
int wprintf(const wchar_t * , ...) ;
int wscanf(const wchar_t * , ...) ;
int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);
}
extern "C" {
int vfwscanf(FILE * , const wchar_t * ,
     __darwin_va_list) ;
int vswscanf(const wchar_t * , const wchar_t * ,
     __darwin_va_list) ;
int vwscanf(const wchar_t * , __darwin_va_list) ;
float wcstof(const wchar_t * , wchar_t ** );
long double
 wcstold(const wchar_t * , wchar_t ** ) ;
long long
 wcstoll(const wchar_t * , wchar_t ** , int);
unsigned long long
 wcstoull(const wchar_t * , wchar_t ** , int);
}
extern "C" {
size_t mbsnrtowcs(wchar_t * , const char ** , size_t,
            size_t, mbstate_t * );
wchar_t *wcpcpy(wchar_t * , const wchar_t * ) __attribute__((visibility("default")));
wchar_t *wcpncpy(wchar_t * , const wchar_t * , size_t) __attribute__((visibility("default")));
wchar_t *wcsdup(const wchar_t *) __attribute__((visibility("default")));
int wcscasecmp(const wchar_t *, const wchar_t *) __attribute__((visibility("default")));
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n) __attribute__((visibility("default")));
size_t wcsnlen(const wchar_t *, size_t) __attribute__((visibility("default")));
size_t wcsnrtombs(char * , const wchar_t ** , size_t,
            size_t, mbstate_t * );
}
extern "C" {
wchar_t *fgetwln(FILE * , size_t *) __attribute__((visibility("default")));
size_t wcslcat(wchar_t *, const wchar_t *, size_t);
size_t wcslcpy(wchar_t *, const wchar_t *, size_t);
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  using ::mbstate_t;
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  using ::wint_t;
  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;
  using ::swprintf;
  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;
  using ::vfwscanf;
  using ::vswprintf;
  using ::vswscanf;
  using ::vwprintf;
  using ::vwscanf;
  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;
  using ::wcstof;
  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }
  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }
  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }
  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }
  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }
}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
  using ::wcstold;
  using ::wcstoll;
  using ::wcstoull;
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
namespace std
{

  using std::wcstof;
  using std::vfwscanf;
  using std::vswscanf;
  using std::vwscanf;
  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
namespace std __attribute__ ((__visibility__ ("default"))) {
  typedef long long streamoff;
  typedef ptrdiff_t streamsize;
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;
    public:
      fpos()
      : _M_off(0), _M_state() { }
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }
      operator streamoff() const { return _M_off; }
      void
      state(_StateT __st)
      { _M_state = __st; }
      _StateT
      state() const
      { return _M_state; }
      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }
      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }
      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }
      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }
      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };
  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }
  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }
  typedef fpos<mbstate_t> streampos;
  typedef fpos<mbstate_t> wstreampos;
  typedef fpos<mbstate_t> u16streampos;
  typedef fpos<mbstate_t> u32streampos;
}
       
       
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;
      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }
      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }
      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }
      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);
      static std::size_t
      length(const char_type* __s);
      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);
      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);
      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);
      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);
      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }
      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }
      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }
      static int_type
      eof()
      { return static_cast<int_type>((-1)); }
      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };
  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }
  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }
  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }
  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }
  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }
  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {
      std::fill_n(__s, __n, __a);
      return __s;
    }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };
  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;
      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }
      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }
      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }
      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }
      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }
      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }
      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }
      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }
      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }
      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }
      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }
      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }
      static int_type
      eof()
      { return static_cast<int_type>((-1)); }
      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };
  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;
      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }
      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }
      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }
      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }
      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }
      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }
      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }
      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }
      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }
      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }
      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }
      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }
      static int_type
      eof()
      { return static_cast<int_type>(((__darwin_wint_t)-1)); }
      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };
}
       
typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;
typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;
typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;
typedef long intptr_t;
typedef unsigned long uintptr_t;
typedef long int intmax_t;
typedef long unsigned int uintmax_t;
namespace std
{

  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;
  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;
  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;
  using ::intmax_t;
  using ::intptr_t;
  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;
  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;
  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;
  using ::uintmax_t;
  using ::uintptr_t;

}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;
      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }
      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }
      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }
      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }
      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }
      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }
      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }
      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }
      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }
      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }
      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }
      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }
      static int_type
      eof()
      { return static_cast<int_type>(-1); }
      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };
  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;
      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }
      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }
      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }
      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }
      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }
      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }
      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }
      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }
      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }
      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }
      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }
      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }
      static int_type
      eof()
      { return static_cast<int_type>(-1); }
      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };
}
       
       
       
struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;
 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_n_cs_precedes;
 char int_p_sep_by_space;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};
extern "C" {
struct lconv *localeconv(void);
}
extern "C" {
char *setlocale(int, const char *);
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  typedef int* __c_locale;
  inline int
  __convert_from_v(const __c_locale&, char* __out,
     const int __size __attribute__((__unused__)),
     const char* __fmt, ...)
  {
    char* __old = std::setlocale(4, __null);
    char* __sav = __null;
    if (__builtin_strcmp(__old, "C"))
      {
 const size_t __len = __builtin_strlen(__old) + 1;
 __sav = new char[__len];
 __builtin_memcpy(__sav, __old, __len);
 std::setlocale(4, "C");
      }
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);
    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);
    __builtin_va_end(__args);
    if (__sav)
      {
 std::setlocale(4, __sav);
 delete [] __sav;
      }
    return __ret;
  }
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  class ios_base;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;
  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;
  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;
  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_stringstream<char> stringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;
  typedef basic_ios<wchar_t> wios;
  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t> wistream;
  typedef basic_ostream<wchar_t> wostream;
  typedef basic_iostream<wchar_t> wiostream;
  typedef basic_stringbuf<wchar_t> wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_stringstream<wchar_t> wstringstream;
  typedef basic_filebuf<wchar_t> wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t> wfstream;
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}
namespace std
{

  using ::isblank;

}
namespace std __attribute__ ((__visibility__ ("default"))) {
  class locale;
  template<typename _Facet>
    bool
    has_facet(const locale&) throw();
  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);
  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);
  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);
  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);
  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);
  template<typename _CharT>
    bool
    islower(_CharT, const locale&);
  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);
  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);
  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);
  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);
  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);
  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);
  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);
  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);
  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;
  template<> class ctype<wchar_t>;
  template<typename _CharT>
    class ctype_byname;
  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;
  template<> class codecvt<wchar_t, char, mbstate_t>;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;
  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;
  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}
       
       
#pragma GCC visibility push(default)
namespace __cxxabiv1
{
  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();
    virtual void __pure_dummy() = 0;
  };
}
#pragma GCC visibility pop
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }
  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }
  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);
  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);
}
       
#pragma GCC visibility push(default)
extern "C" {
struct sched_param { int sched_priority; char __opaque[4]; };
extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);
}
typedef __darwin_pthread_attr_t pthread_attr_t;
typedef __darwin_pthread_cond_t pthread_cond_t;
typedef __darwin_pthread_condattr_t pthread_condattr_t;
typedef __darwin_pthread_key_t pthread_key_t;
typedef __darwin_pthread_mutex_t pthread_mutex_t;
typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
typedef __darwin_pthread_once_t pthread_once_t;
typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
typedef __darwin_pthread_t pthread_t;
typedef __darwin_mach_port_t mach_port_t;
typedef __darwin_sigset_t sigset_t;
extern "C" {
int pthread_atfork(void (*)(void), void (*)(void),
                      void (*)(void));
int pthread_attr_destroy(pthread_attr_t *);
int pthread_attr_getdetachstate(const pthread_attr_t *,
          int *);
int pthread_attr_getguardsize(const pthread_attr_t * ,
                                      size_t * );
int pthread_attr_getinheritsched(const pthread_attr_t * ,
           int * );
int pthread_attr_getschedparam(const pthread_attr_t * ,
                                     struct sched_param * );
int pthread_attr_getschedpolicy(const pthread_attr_t * ,
          int * );
int pthread_attr_getscope(const pthread_attr_t * , int * );
int pthread_attr_getstack(const pthread_attr_t * ,
                                      void ** , size_t * );
int pthread_attr_getstackaddr(const pthread_attr_t * ,
                                      void ** );
int pthread_attr_getstacksize(const pthread_attr_t * ,
                                      size_t * );
int pthread_attr_init(pthread_attr_t *);
int pthread_attr_setdetachstate(pthread_attr_t *,
          int );
int pthread_attr_setguardsize(pthread_attr_t *, size_t );
int pthread_attr_setinheritsched(pthread_attr_t *,
           int );
int pthread_attr_setschedparam(pthread_attr_t * ,
                                     const struct sched_param * );
int pthread_attr_setschedpolicy(pthread_attr_t *,
          int );
int pthread_attr_setscope(pthread_attr_t *, int);
int pthread_attr_setstack(pthread_attr_t *,
                                      void *, size_t );
int pthread_attr_setstackaddr(pthread_attr_t *,
                                      void *);
int pthread_attr_setstacksize(pthread_attr_t *, size_t );
int pthread_cancel(pthread_t ) __asm("_" "pthread_cancel" );
int pthread_cond_broadcast(pthread_cond_t *);
int pthread_cond_destroy(pthread_cond_t *);
int pthread_cond_init(pthread_cond_t * ,
                            const pthread_condattr_t * ) __asm("_" "pthread_cond_init" );
int pthread_cond_signal(pthread_cond_t *);
int pthread_cond_timedwait(pthread_cond_t * ,
     pthread_mutex_t * ,
     const struct timespec * ) __asm("_" "pthread_cond_timedwait" );
int pthread_cond_wait(pthread_cond_t * ,
       pthread_mutex_t * ) __asm("_" "pthread_cond_wait" );
int pthread_condattr_destroy(pthread_condattr_t *);
int pthread_condattr_init(pthread_condattr_t *);
int pthread_condattr_getpshared(const pthread_condattr_t * ,
   int * );
int pthread_condattr_setpshared(pthread_condattr_t *,
   int );
int pthread_create(pthread_t * ,
                         const pthread_attr_t * ,
                         void *(*)(void *),
                         void * );
int pthread_detach(pthread_t );
int pthread_equal(pthread_t ,
   pthread_t );
void pthread_exit(void *) __attribute__((__noreturn__));
int pthread_getconcurrency(void);
int pthread_getschedparam(pthread_t , int * , struct sched_param * );
void *pthread_getspecific(pthread_key_t );
int pthread_join(pthread_t , void **) __asm("_" "pthread_join" );
int pthread_key_create(pthread_key_t *, void (*)(void *));
int pthread_key_delete(pthread_key_t );
int pthread_mutex_destroy(pthread_mutex_t *);
int pthread_mutex_getprioceiling(const pthread_mutex_t * , int * );
int pthread_mutex_init(pthread_mutex_t * , const pthread_mutexattr_t * );
int pthread_mutex_lock(pthread_mutex_t *);
int pthread_mutex_setprioceiling(pthread_mutex_t * , int, int * );
int pthread_mutex_trylock(pthread_mutex_t *);
int pthread_mutex_unlock(pthread_mutex_t *);
int pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm("_" "pthread_mutexattr_destroy" );
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_getpshared(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_gettype(const pthread_mutexattr_t * , int * );
int pthread_mutexattr_init(pthread_mutexattr_t *);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int );
int pthread_mutexattr_settype(pthread_mutexattr_t *, int);
int pthread_once(pthread_once_t *, void (*)(void));
int pthread_rwlock_destroy(pthread_rwlock_t * ) __asm("_" "pthread_rwlock_destroy" );
int pthread_rwlock_init(pthread_rwlock_t * , const pthread_rwlockattr_t * ) __asm("_" "pthread_rwlock_init" );
int pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_rdlock" );
int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_tryrdlock" );
int pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_trywrlock" );
int pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_wrlock" );
int pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_unlock" );
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * ,
   int * );
int pthread_rwlockattr_init(pthread_rwlockattr_t *);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *,
   int );
pthread_t pthread_self(void);
int pthread_setcancelstate(int , int *) __asm("_" "pthread_setcancelstate" );
int pthread_setcanceltype(int , int *) __asm("_" "pthread_setcanceltype" );
int pthread_setconcurrency(int);
int pthread_setschedparam(pthread_t ,
    int ,
                                const struct sched_param *);
int pthread_setspecific(pthread_key_t ,
         const void *);
void pthread_testcancel(void) __asm("_" "pthread_testcancel" );
int pthread_is_threaded_np(void);
int pthread_threadid_np(pthread_t,__uint64_t*) __attribute__((visibility("default")));
int pthread_rwlock_longrdlock_np(pthread_rwlock_t *) __attribute__((visibility("default")));
int pthread_rwlock_yieldwrlock_np(pthread_rwlock_t *) __attribute__((visibility("default")));
int pthread_rwlock_downgrade_np(pthread_rwlock_t *);
int pthread_rwlock_upgrade_np(pthread_rwlock_t *);
int pthread_rwlock_tryupgrade_np(pthread_rwlock_t *);
int pthread_rwlock_held_np(pthread_rwlock_t *);
int pthread_rwlock_rdheld_np(pthread_rwlock_t *);
int pthread_rwlock_wrheld_np(pthread_rwlock_t *);
int pthread_getname_np(pthread_t,char*,size_t) __attribute__((visibility("default")));
int pthread_setname_np(const char*) __attribute__((visibility("default")));
int pthread_main_np(void);
mach_port_t pthread_mach_thread_np(pthread_t);
size_t pthread_get_stacksize_np(pthread_t);
void * pthread_get_stackaddr_np(pthread_t);
int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t);
int pthread_cond_timedwait_relative_np(pthread_cond_t *,
     pthread_mutex_t *,
     const struct timespec *);
int pthread_create_suspended_np(pthread_t *,
                         const pthread_attr_t *,
                         void *(*)(void *),
                         void *);
int pthread_kill(pthread_t, int);
pthread_t pthread_from_mach_thread_np(mach_port_t) __attribute__((visibility("default")));
int pthread_sigmask(int, const sigset_t *, sigset_t *) __asm("_" "pthread_sigmask" );
void pthread_yield_np(void);
}
struct accessx_descriptor {
 unsigned int ad_name_offset;
 int ad_flags;
 int ad_pad[2];
};
typedef __darwin_gid_t gid_t;
typedef __darwin_pid_t pid_t;
typedef __darwin_uid_t uid_t;
typedef __darwin_useconds_t useconds_t;
extern "C" {
void _exit(int) __attribute__((__noreturn__));
int access(const char *, int);
unsigned int
  alarm(unsigned int);
int chdir(const char *);
int chown(const char *, uid_t, gid_t);
int close(int) __asm("_" "close" );
int dup(int);
int dup2(int, int);
int execl(const char *, const char *, ...);
int execle(const char *, const char *, ...);
int execlp(const char *, const char *, ...);
int execv(const char *, char * const *);
int execve(const char *, char * const *, char * const *);
int execvp(const char *, char * const *);
pid_t fork(void);
long fpathconf(int, int);
char *getcwd(char *, size_t);
gid_t getegid(void);
uid_t geteuid(void);
gid_t getgid(void);
int getgroups(int, gid_t []);
char *getlogin(void);
pid_t getpgrp(void);
pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
int isatty(int);
int link(const char *, const char *);
off_t lseek(int, off_t, int);
long pathconf(const char *, int);
int pause(void) __asm("_" "pause" );
int pipe(int [2]);
ssize_t read(int, void *, size_t) __asm("_" "read" );
int rmdir(const char *);
int setgid(gid_t);
int setpgid(pid_t, pid_t);
pid_t setsid(void);
int setuid(uid_t);
unsigned int
  sleep(unsigned int) __asm("_" "sleep" );
long sysconf(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);
char *ttyname(int);
int ttyname_r(int, char *, size_t) __asm("_" "ttyname_r" );
int unlink(const char *);
ssize_t write(int, const void *, size_t) __asm("_" "write" );
}
extern "C" {
size_t confstr(int, char *, size_t) __asm("_" "confstr" );
int getopt(int, char * const [], const char *) __asm("_" "getopt" );
extern char *optarg;
extern int optind, opterr, optopt;
}
 extern "C" {
void *brk(const void *);
int chroot(const char *) ;
char *crypt(const char *, const char *);
void encrypt(char *, int) __asm("_" "encrypt" );
int fchdir(int);
long gethostid(void);
pid_t getpgid(pid_t);
pid_t getsid(pid_t);
int getdtablesize(void) ;
int getpagesize(void) __attribute__((__const__)) ;
char *getpass(const char *) ;
char *getwd(char *) ;
int lchown(const char *, uid_t, gid_t) __asm("_" "lchown" );
int lockf(int, int, off_t) __asm("_" "lockf" );
int nice(int) __asm("_" "nice" );
ssize_t pread(int, void *, size_t, off_t) __asm("_" "pread" );
ssize_t pwrite(int, const void *, size_t, off_t) __asm("_" "pwrite" );
void *sbrk(int);
pid_t setpgrp(void) __asm("_" "setpgrp" );
int setregid(gid_t, gid_t) __asm("_" "setregid" );
int setreuid(uid_t, uid_t) __asm("_" "setreuid" );
void swab(const void * , void * , ssize_t);
void sync(void);
int truncate(const char *, off_t);
useconds_t ualarm(useconds_t, useconds_t);
int usleep(useconds_t) __asm("_" "usleep" );
pid_t vfork(void);
int fsync(int) __asm("_" "fsync" );
int ftruncate(int, off_t);
int getlogin_r(char *, size_t);
}
extern "C" {
int fchown(int, uid_t, gid_t);
int gethostname(char *, size_t);
ssize_t readlink(const char * , char * , size_t);
int setegid(gid_t);
int seteuid(uid_t);
int symlink(const char *, const char *);
}
struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
extern "C" {
typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;
}
static inline int
__darwin_fd_isset(int _n, const struct fd_set *_p)
{
 return (_p->fds_bits[_n/(sizeof(__int32_t) * 8)] & (1<<(_n % (sizeof(__int32_t) * 8))));
}
typedef __darwin_suseconds_t suseconds_t;
extern "C" {
int pselect(int, fd_set * , fd_set * ,
  fd_set * , const struct timespec * ,
  const sigset_t * )
  __asm("_" "pselect" "$1050")
  ;
int select(int, fd_set * , fd_set * ,
  fd_set * , struct timeval * )
  __asm("_" "select" "$1050")
  ;
}
typedef __darwin_dev_t dev_t;
typedef __darwin_mode_t mode_t;
typedef __darwin_uuid_t uuid_t;
extern "C" {
void _Exit(int) __attribute__((__noreturn__));
int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t);
int acct(const char *);
int add_profil(char *, size_t, unsigned long, unsigned int);
void endusershell(void);
int execvP(const char *, const char *, char * const *);
char *fflagstostr(unsigned long);
int getdomainname(char *, int);
int getgrouplist(const char *, int, int *, int *);
int gethostuuid(uuid_t, const struct timespec *) __attribute__((visibility("default")));
mode_t getmode(const void *, mode_t);
int getpeereid(int, uid_t *, gid_t *);
int getsgroups_np(int *, uuid_t);
char *getusershell(void);
int getwgroups_np(int *, uuid_t);
int initgroups(const char *, int);
int iruserok(unsigned long, int, const char *, const char *);
int iruserok_sa(const void *, int, int, const char *, const char *);
int issetugid(void);
char *mkdtemp(char *);
int mknod(const char *, mode_t, dev_t);
int mkstemp(char *);
int mkstemps(char *, int);
char *mktemp(char *);
int nfssvc(int, void *);
int profil(char *, size_t, unsigned long, unsigned int);
int pthread_setugid_np(uid_t, gid_t);
int pthread_getugid_np( uid_t *, gid_t *);
int rcmd(char **, int, const char *, const char *, const char *, int *);
int rcmd_af(char **, int, const char *, const char *, const char *, int *,
  int);
int reboot(int);
int revoke(const char *);
int rresvport(int *);
int rresvport_af(int *, int);
int ruserok(const char *, int, const char *, const char *);
int setdomainname(const char *, int);
int setgroups(int, const gid_t *);
void sethostid(long);
int sethostname(const char *, int);
void setkey(const char *) __asm("_" "setkey" );
int setlogin(const char *);
void *setmode(const char *) __asm("_" "setmode" );
int setrgid(gid_t);
int setruid(uid_t);
int setsgroups_np(int, const uuid_t);
void setusershell(void);
int setwgroups_np(int, const uuid_t);
int strtofflags(char **, unsigned long *, unsigned long *);
int swapon(const char *);
int syscall(int, ...);
int ttyslot(void);
int undelete(const char *);
int unwhiteout(const char *);
void *valloc(size_t);
extern char *suboptarg;
int getsubopt(char **, char * const *, char **);
int fgetattrlist(int,void*,void*,size_t,unsigned int) __attribute__((visibility("default")));
int fsetattrlist(int,void*,void*,size_t,unsigned int) __attribute__((visibility("default")));
int getattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "getattrlist" );
int setattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "setattrlist" );
int exchangedata(const char*,const char*,unsigned int);
int getdirentriesattr(int,void*,void*,size_t,unsigned int*,unsigned int*,unsigned int*,unsigned int);
struct fssearchblock;
struct searchstate;
int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *);
int fsctl(const char *,unsigned long,void*,unsigned int);
int ffsctl(int,unsigned long,void*,unsigned int) __attribute__((visibility("default")));
extern int optreset;
}
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;

























static inline int
__gthread_active_p (void)
{
  return 1;
}
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return pthread_create (__threadid, __null, __func, __args);
}
static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return pthread_join (__threadid, __value_ptr);
}
static inline int
__gthread_detach (__gthread_t __threadid)
{
  return pthread_detach (__threadid);
}
static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return pthread_equal (__t1, __t2);
}
static inline __gthread_t
__gthread_self (void)
{
  return pthread_self ();
}
static inline int
__gthread_yield (void)
{
  return sched_yield ();
}
static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return pthread_once (__once, __func);
  else
    return -1;
}
static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return pthread_key_create (__key, __dtor);
}
static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return pthread_key_delete (__key);
}
static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return pthread_getspecific (__key);
}
static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return pthread_setspecific (__key, __ptr);
}
static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_destroy (__mutex);
  else
    return 0;
}
static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_lock (__mutex);
  else
    return 0;
}
static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_trylock (__mutex);
  else
    return 0;
}
static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_unlock (__mutex);
  else
    return 0;
}
static inline int
__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    {
      pthread_mutexattr_t __attr;
      int __r;
      __r = pthread_mutexattr_init (&__attr);
      if (!__r)
 __r = pthread_mutexattr_settype (&__attr,
         2);
      if (!__r)
 __r = pthread_mutex_init (__mutex, &__attr);
      if (!__r)
 __r = pthread_mutexattr_destroy (&__attr);
      return __r;
    }
  return 0;
}
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}
static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}
static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return pthread_cond_broadcast (__cond);
}
static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return pthread_cond_signal (__cond);
}
static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return pthread_cond_wait (__cond, __mutex);
}
static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}
static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}
static inline int
__gthread_cond_timedwait_recursive (__gthread_cond_t *__cond,
        __gthread_recursive_mutex_t *__mutex,
        const __gthread_time_t *__abs_timeout)
{
  return __gthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}
static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return pthread_cond_destroy (__cond);
}
#pragma GCC visibility pop
typedef int _Atomic_word;
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __sync_fetch_and_add(__mem, __val); }
  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __sync_fetch_and_add(__mem, __val); }
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }
  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }
  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {
    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);
  }
  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {
    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);
  }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;
    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
    private:
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };
      struct _Rep : _Rep_base
      {
 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
 static const size_type _S_max_size;
 static const _CharT _S_terminal;
        static size_type _S_empty_rep_storage[];
        static _Rep&
        _S_empty_rep()
        {
   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }
        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }
        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }
        void
 _M_set_leaked()
        { this->_M_refcount = -1; }
        void
 _M_set_sharable()
        { this->_M_refcount = 0; }
 void
 _M_set_length_and_sharable(size_type __n)
 {
     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);
     }
 }
 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }
 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }
 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);
 void
 _M_dispose(const _Alloc& __a)
 {
     if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
             -1) <= 0)
       _M_destroy(__a);
 }
 void
 _M_destroy(const _Alloc&) throw();
 _CharT*
 _M_refcopy() throw()
 {
            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }
 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };
      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }
 _CharT* _M_p;
      };
    public:
      static const size_type npos = static_cast<size_type>(-1);
    private:
      mutable _Alloc_hider _M_dataplus;
      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }
      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }
      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }
      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }
      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }
      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }
      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }
      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }
      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }
      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }
      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }
      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }
      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }
      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }
      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }
      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }
      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);
 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }
      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);
      void
      _M_leak_hard();
      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }
    public:
      basic_string()
      : _M_dataplus(_S_construct(size_type(), _CharT(), _Alloc()), _Alloc()){ }
      explicit
      basic_string(const _Alloc& __a);
      basic_string(const basic_string& __str);
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());
      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
      basic_string(basic_string&& __str)
      : _M_dataplus(__str._M_dataplus)
      {
 __str._M_data(_S_construct(size_type(), _CharT(), get_allocator()));
      }
      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc());
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());
      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }
      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }
      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
      basic_string&
      operator=(basic_string&& __str)
      {
 this->swap(__str);
 return *this;
      }
      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }
      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }
      const_iterator
      begin() const
      { return const_iterator(_M_data()); }
      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }
      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }
      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }
      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }
      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }
      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }
      const_iterator
      cbegin() const
      { return const_iterator(this->_M_data()); }
      const_iterator
      cend() const
      { return const_iterator(this->_M_data() + this->size()); }
      const_reverse_iterator
      crbegin() const
      { return const_reverse_iterator(this->end()); }
      const_reverse_iterator
      crend() const
      { return const_reverse_iterator(this->begin()); }
    public:
      size_type
      size() const
      { return _M_rep()->_M_length; }
      size_type
      length() const
      { return _M_rep()->_M_length; }
      size_type
      max_size() const
      { return _Rep::_S_max_size; }
      void
      resize(size_type __n, _CharT __c);
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }
      void
      shrink_to_fit()
      {
 try
   { reserve(0); }
 catch(...)
   { }
      }
      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
      void
      reserve(size_type __res_arg = 0);
      void
      clear()
      { _M_mutate(0, this->size(), 0); }
      bool
      empty() const
      { return this->size() == 0; }
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
      reference
      operator[](size_type __pos)
      {
 ;
 ;
 _M_leak();
 return _M_data()[__pos];
      }
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }
      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }
      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }
      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
      basic_string&
      append(const basic_string& __str);
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);
      basic_string&
      append(const _CharT* __s, size_type __n);
      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
      basic_string&
      append(size_type __n, _CharT __c);
      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }
      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }
      basic_string&
      assign(const basic_string& __str);
      basic_string&
      assign(basic_string&& __str)
      {
 this->swap(__str);
 return *this;
      }
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
      basic_string&
      assign(const _CharT* __s, size_type __n);
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
 ;
 this->insert(__p - _M_ibegin(), __l.begin(), __l.size());
      }
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
      iterator
      erase(iterator __position)
      {
 ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
      iterator
      erase(iterator __first, iterator __last);
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {
 ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
   ;
   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }
      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {
 ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }
      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {
 ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }
      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {
 ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {
 ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
      basic_string& replace(iterator __i1, iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }
      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);
      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);
      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);
      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }
      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }
      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }
      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }
      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);
      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);
      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);
    public:
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
      void
      swap(basic_string& __s);
      const _CharT*
      c_str() const
      { return _M_data(); }
      const _CharT*
      data() const
      { return _M_data(); }
      allocator_type
      get_allocator() const
      { return _M_dataplus; }
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
      size_type
      find(_CharT __c, size_type __pos = 0) const;
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);
 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
      int
      compare(const _CharT* __s) const;
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }
  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);
  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      return __ostream_insert(__os, __str.data(), __str.size());
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }
  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);
  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);
}
       
       
       
       
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;
typedef __darwin_id_t id_t;
typedef int sig_atomic_t;
struct __darwin_i386_thread_state
{
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
struct __darwin_fp_control
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
      :2,
    __pc :2,
    __rc :2,
             :1,
      :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
struct __darwin_fp_status
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
    __stkflt :1,
    __errsumm :1,
    __c0 :1,
    __c1 :1,
    __c2 :1,
    __tos :3,
    __c3 :1,
    __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
struct __darwin_mmst_reg
{
 char __mmst_reg[10];
 char __mmst_rsrv[6];
};
struct __darwin_xmm_reg
{
 char __xmm_reg[16];
};
struct __darwin_i386_float_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
};
struct __darwin_i386_avx_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
};
struct __darwin_i386_exception_state
{
 __uint16_t __trapno;
 __uint16_t __cpu;
 __uint32_t __err;
 __uint32_t __faultvaddr;
};
struct __darwin_x86_debug_state32
{
 unsigned int __dr0;
 unsigned int __dr1;
 unsigned int __dr2;
 unsigned int __dr3;
 unsigned int __dr4;
 unsigned int __dr5;
 unsigned int __dr6;
 unsigned int __dr7;
};
struct __darwin_x86_thread_state64
{
 __uint64_t __rax;
 __uint64_t __rbx;
 __uint64_t __rcx;
 __uint64_t __rdx;
 __uint64_t __rdi;
 __uint64_t __rsi;
 __uint64_t __rbp;
 __uint64_t __rsp;
 __uint64_t __r8;
 __uint64_t __r9;
 __uint64_t __r10;
 __uint64_t __r11;
 __uint64_t __r12;
 __uint64_t __r13;
 __uint64_t __r14;
 __uint64_t __r15;
 __uint64_t __rip;
 __uint64_t __rflags;
 __uint64_t __cs;
 __uint64_t __fs;
 __uint64_t __gs;
};
struct __darwin_x86_float_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
};
struct __darwin_x86_avx_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
};
struct __darwin_x86_exception_state64
{
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint64_t __faultvaddr;
};
struct __darwin_x86_debug_state64
{
 __uint64_t __dr0;
 __uint64_t __dr1;
 __uint64_t __dr2;
 __uint64_t __dr3;
 __uint64_t __dr4;
 __uint64_t __dr5;
 __uint64_t __dr6;
 __uint64_t __dr7;
};
struct __darwin_mcontext32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_float_state __fs;
};
struct __darwin_mcontext_avx32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx_state __fs;
};
struct __darwin_mcontext64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};
struct __darwin_mcontext_avx64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};
typedef struct __darwin_mcontext64 *mcontext_t;
struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;
};
typedef struct __darwin_sigaltstack stack_t;
typedef struct __darwin_ucontext ucontext_t;
union sigval {
 int sival_int;
 void *sival_ptr;
};
struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};
typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
         void *);
};
struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};
struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
typedef void (*sig_t)(int);
struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
extern "C" {
void (*signal(int, void (*)(int)))(int);
}
typedef __uint64_t rlim_t;
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
 long ru_maxrss;
 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;
};
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
extern "C" {
int getpriority(int, id_t);
int getiopolicy_np(int, int) __attribute__((visibility("default")));
int getrlimit(int, struct rlimit *) __asm("_" "getrlimit" );
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);
int setiopolicy_np(int, int, int) __attribute__((visibility("default")));
int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit" );
}
static inline
__uint16_t
_OSSwapInt16(
    __uint16_t _data
)
{
    return ((_data << 8) | (_data >> 8));
}
static inline
__uint32_t
_OSSwapInt32(
    __uint32_t _data
)
{
    __asm__ ("bswap   %0" : "+r" (_data));
    return _data;
}
static inline
__uint64_t
_OSSwapInt64(
    __uint64_t _data
)
{
    __asm__ ("bswap   %0" : "+r" (_data));
    return _data;
}
union wait {
 int w_status;
 struct {
  unsigned int w_Termsig:7,
    w_Coredump:1,
    w_Retcode:8,
    w_Filler:16;
 } w_T;
 struct {
  unsigned int w_Stopval:8,
    w_Stopsig:8,
    w_Filler:16;
 } w_S;
};
extern "C" {
pid_t wait(int *) __asm("_" "wait" );
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid" );
int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid" );
pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);
}
extern "C" {
void *alloca(size_t);
}
typedef struct {
 int quot;
 int rem;
} div_t;
typedef struct {
 long quot;
 long rem;
} ldiv_t;
typedef struct {
 long long quot;
 long long rem;
} lldiv_t;
extern int __mb_cur_max;
extern "C" {
void abort(void) __attribute__((__noreturn__));
int abs(int) __attribute__((__const__));
int atexit(void (*)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);
long long
  atoll(const char *);
void *bsearch(const void *, const void *, size_t,
     size_t, int (*)(const void *, const void *));
void *calloc(size_t, size_t);
div_t div(int, int) __attribute__((__const__));
void exit(int) __attribute__((__noreturn__));
void free(void *);
char *getenv(const char *);
long labs(long) __attribute__((__const__));
ldiv_t ldiv(long, long) __attribute__((__const__));
long long
  llabs(long long);
lldiv_t lldiv(long long, long long);
void *malloc(size_t);
int mblen(const char *, size_t);
size_t mbstowcs(wchar_t * , const char * , size_t);
int mbtowc(wchar_t * , const char * , size_t);
int posix_memalign(void **, size_t, size_t) __attribute__((visibility("default")));
void qsort(void *, size_t, size_t,
     int (*)(const void *, const void *));
int rand(void);
void *realloc(void *, size_t);
void srand(unsigned);
double strtod(const char *, char **) __asm("_" "strtod" );
float strtof(const char *, char **) __asm("_" "strtof" );
long strtol(const char *, char **, int);
long double
  strtold(const char *, char **) ;
long long
  strtoll(const char *, char **, int);
unsigned long
  strtoul(const char *, char **, int);
unsigned long long
  strtoull(const char *, char **, int);
int system(const char *) __asm("_" "system" );
size_t wcstombs(char * , const wchar_t * , size_t);
int wctomb(char *, wchar_t);
void _Exit(int) __attribute__((__noreturn__));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *, int *);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
int getsubopt(char **, char * const *, char **);
int grantpt(int);
char *initstate(unsigned, char *, size_t);
long jrand48(unsigned short[3]);
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void);
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void);
long nrand48(unsigned short[3]);
int posix_openpt(int);
char *ptsname(int);
int putenv(char *) __asm("_" "putenv" );
long random(void);
int rand_r(unsigned *);
char *realpath(const char * , char * ) __asm("_" "realpath" "$DARWIN_EXTSN");
unsigned short
 *seed48(unsigned short[3]);
int setenv(const char *, const char *, int) __asm("_" "setenv" );
void setkey(const char *) __asm("_" "setkey" );
char *setstate(const char *);
void srand48(long);
void srandom(unsigned);
int unlockpt(int);
int unsetenv(const char *) __asm("_" "unsetenv" );
typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long long u_int64_t;
typedef int64_t register_t;
typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;
typedef u_int64_t syscall_arg_t;
u_int32_t
  arc4random(void);
void arc4random_addrandom(unsigned char * , int );
void arc4random_buf(void * , size_t ) __attribute__((visibility("default")));
void arc4random_stir(void);
u_int32_t
  arc4random_uniform(u_int32_t ) __attribute__((visibility("default")));
char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);
int daemon(int, int) __asm("_" "daemon" "$1050") __attribute__((deprecated,visibility("default")));
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);
int heapsort(void *, size_t, size_t,
     int (*)(const void *, const void *));
int mergesort(void *, size_t, size_t,
     int (*)(const void *, const void *));
void psort(void *, size_t, size_t,
     int (*)(const void *, const void *)) __attribute__((visibility("default")));
void psort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *)) __attribute__((visibility("default")));
void qsort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *));
int radixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void setprogname(const char *);
int sradixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *, size_t);
long long
  strtoq(const char *, char **, int);
unsigned long long
  strtouq(const char *, char **, int);
extern char *suboptarg;
void *valloc(size_t);
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  using ::div_t;
  using ::ldiv_t;
  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;
  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;
  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;
  using ::wcstombs;
  using ::wctomb;
  inline long
  abs(long __i) { return labs(__i); }
  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }
}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
  using ::lldiv_t;
  using ::_Exit;
  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }
  using ::llabs;
  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }
  using ::lldiv;
  using ::atoll;
  using ::strtoll;
  using ::strtoull;
  using ::strtof;
  using ::strtold;
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  using ::__gnu_cxx::lldiv_t;
  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;
  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;
  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
namespace std
{

  using std::lldiv_t;
  using std::llabs;
  using std::lldiv;
  using std::atoll;
  using std::strtoll;
  using std::strtoull;
  using std::strtof;
  using std::strtold;
  using std::abs;
  using std::div;

}
       
       
       
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  using ::FILE;
  using ::fpos_t;
  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
namespace std
{

  using std::snprintf;
  using std::vsnprintf;
  using std::vfscanf;
  using std::vscanf;
  using std::vsscanf;

}
       
extern "C" {
extern int * __error(void);
}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;
      _CharT* __endptr;
      (*__error()) = 0;
      const _TRet __tmp = __convf(__str, &__endptr, __base...);
      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__error()) == 34
        || (std::__are_same<_Ret, int>::__value
     && (__tmp < __numeric_traits<int>::__min
         || __tmp > __numeric_traits<int>::__max)))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;
      if (__idx)
 *__idx = __endptr - __str;
      return __ret;
    }
  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {
      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));
      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);
      const int __len = __convf(__s, __n, __fmt, __args);
      __builtin_va_end(__args);
      return _String(__s, __s + __len);
    }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }
  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }
  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }
  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }
  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }
  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }
  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }
  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }
  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }
  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }
  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }
  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }
  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }
  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }
  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }
  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }
  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }
  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }
  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }
  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }
  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }
  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }
  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }
  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }
  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }
  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }
  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }
  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }
  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }
  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }
  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }
  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }
  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }
  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<>
    struct hash<string>
    : public std::unary_function<string, size_t>
    {
      size_t
      operator()(const string& __s) const
      { return std::_Fnv_hash::hash(__s.data(), __s.length()); }
    };
  template<>
    struct hash<wstring>
    : public std::unary_function<wstring, size_t>
    {
      size_t
      operator()(const wstring& __s) const
      { return std::_Fnv_hash::hash(__s.data(),
        __s.length() * sizeof(wchar_t)); }
    };
  template<>
    struct hash<u16string>
    : public std::unary_function<u16string, size_t>
    {
      size_t
      operator()(const u16string& __s) const
      { return std::_Fnv_hash::hash(__s.data(),
        __s.length() * sizeof(char16_t)); }
    };
  template<>
    struct hash<u32string>
    : public std::unary_function<u32string, size_t>
    {
      size_t
      operator()(const u32string& __s) const
      { return std::_Fnv_hash::hash(__s.data(),
        __s.length() * sizeof(char32_t)); }
    };
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;
  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();
  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {
 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {
      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }
  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {
 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct NULL not valid"));
 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));
 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }
  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {
      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);
      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(initializer_list<_CharT> __l, const _Alloc& __a)
    : _M_dataplus(_S_construct(__l.begin(), __l.end(), __a), __a)
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {
   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {
   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }
   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {
           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }
   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {
       ;
       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }
   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {
    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {
    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {
      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;
      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {
   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);
   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);
   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {
   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {
   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }
      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {
      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);
      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;
      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);
   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }
      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;
      __p->_M_set_sharable();
      return __p;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {
      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);
      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);
      return __n;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();
      if (__n == 0)
 return __pos <= __size ? __pos : npos;
      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;
      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {
       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();
       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);
       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {
       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();
       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {
       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);
  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);
}
       
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  namespace rel_ops
  {
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }
  }
}
namespace std
{

  template<class _Tp>
    class tuple_size;
  template<std::size_t _Int, class _Tp>
    class tuple_element;
  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2> >
    { static const std::size_t value = 2; };
  template<class _Tp1, class _Tp2>
    const std::size_t
    tuple_size<std::pair<_Tp1, _Tp2> >::value;
  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2> >
    { typedef _Tp1 type; };
  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2> >
    { typedef _Tp2 type; };
  template<std::size_t _Int>
    struct __pair_get;
  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
      static _Tp1& __get(std::pair<_Tp1, _Tp2>& __pair)
      { return __pair.first; }
      template<typename _Tp1, typename _Tp2>
      static const _Tp1& __const_get(const std::pair<_Tp1, _Tp2>& __pair)
      { return __pair.first; }
    };
  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
      static _Tp2& __get(std::pair<_Tp1, _Tp2>& __pair)
      { return __pair.second; }
      template<typename _Tp1, typename _Tp2>
      static const _Tp2& __const_get(const std::pair<_Tp1, _Tp2>& __pair)
      { return __pair.second; }
    };
  template<std::size_t _Int, class _Tp1, class _Tp2>
    inline typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&
    get(std::pair<_Tp1, _Tp2>& __in)
    { return __pair_get<_Int>::__get(__in); }
  template<std::size_t _Int, class _Tp1, class _Tp2>
    inline const typename tuple_element<_Int, std::pair<_Tp1, _Tp2> >::type&
    get(const std::pair<_Tp1, _Tp2>& __in)
    { return __pair_get<_Int>::__const_get(__in); }

}
       
namespace boost{
   __extension__ typedef long long long_long_type;
   __extension__ typedef unsigned long long ulong_long_type;
}
       
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  class locale
  {
  public:
    typedef int category;
    class facet;
    class id;
    class _Impl;
    friend class facet;
    friend class _Impl;
    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();
    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);
    template<typename _Cache>
      friend struct __use_cache;
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
    locale() throw();
    locale(const locale& __other) throw();
    explicit
    locale(const char* __s);
    locale(const locale& __base, const char* __s, category __cat);
    locale(const locale& __base, const locale& __add, category __cat);
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);
    ~locale() throw();
    const locale&
    operator=(const locale& __other) throw();
    template<typename _Facet>
      locale
      combine(const locale& __other) const;
    string
    name() const;
    bool
    operator==(const locale& __other) const throw();
    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
    static locale
    global(const locale&);
    static const locale&
    classic();
  private:
    _Impl* _M_impl;
    static _Impl* _S_classic;
    static _Impl* _S_global;
    static const char* const* const _S_categories;
    enum { _S_categories_size = 6 + 0 };
    static __gthread_once_t _S_once;
    explicit
    locale(_Impl*) throw();
    static void
    _S_initialize();
    static void
    _S_initialize_once() throw();
    static category
    _S_normalize_category(category);
    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;
    mutable _Atomic_word _M_refcount;
    static __c_locale _S_c_locale;
    static const char _S_c_name[2];
    static __gthread_once_t _S_once;
    static void
    _S_initialize_once();
  protected:
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }
    virtual
    ~facet();
    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);
    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();
    static void
    _S_destroy_c_locale(__c_locale& __cloc);
    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);
    static __c_locale
    _S_get_c_locale();
    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }
    void
    _M_remove_reference() const throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }
    facet(const facet&);
    facet&
    operator=(const facet&);
  };
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;
    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);
    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();
    mutable size_t _M_index;
    static _Atomic_word _S_refcount;
    void
    operator=(const id&);
    id(const id&);
  public:
    id() { }
    size_t
    _M_id() const throw();
  };
  class locale::_Impl
  {
  public:
    friend class locale;
    friend class locale::facet;
    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();
    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);
    template<typename _Cache>
      friend struct __use_cache;
  private:
    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];
    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }
    void
    _M_remove_reference() throw()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
   try
     { delete this; }
   catch(...)
     { }
 }
    }
    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();
   ~_Impl() throw();
    _Impl(const _Impl&);
    void
    operator=(const _Impl&);
    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])
 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }
    void
    _M_replace_categories(const _Impl*, category);
    void
    _M_replace_category(const _Impl*, const locale::id* const*);
    void
    _M_replace_facet(const _Impl*, const locale::id*);
    void
    _M_install_facet(const locale::id*, const facet*);
    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }
    void
    _M_install_cache(const facet*, size_t);
  };
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
    protected:
      __c_locale _M_c_locale_collate;
    public:
      static locale::id id;
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }
      int
      _M_compare(const _CharT*, const _CharT*) const throw();
      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();
  protected:
      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };
  template<typename _CharT>
    locale::id collate<_CharT>::id;
  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();
  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();
  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();
  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();
  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }
    protected:
      virtual
      ~collate_byname() { }
    };
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);
      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }
  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size
       && dynamic_cast<const _Facet*>(__facets[__i]));
    }
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();
      return dynamic_cast<const _Facet&>(*__facets[__i]);
    }
  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }
  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }
  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {
      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);
      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();
      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;
   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;
   __p++;
   __q++;
 }
    }
  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;
      const string_type __str(__lo, __hi);
      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();
      size_t __len = (__hi - __lo) * 2;
      _CharT* __c = new _CharT[__len];
      try
 {
   for (;;)
     {
       size_t __res = _M_transform(__c, __p, __len);
       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }
       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;
       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }
      delete [] __c;
      return __ret;
    }
  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }
  extern template class collate<char>;
  extern template class collate_byname<char>;
  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);
  extern template
    bool
    has_facet<collate<char> >(const locale&);
  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;
  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);
}
       
       
typedef __darwin_wctrans_t wctrans_t;
static inline int
iswblank(wint_t _wc)
{
 return (__istype(_wc, 0x00020000L));
}
static inline int
iswascii(wint_t _wc)
{
 return ((_wc & ~0x7F) == 0);
}
static inline int
iswhexnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00010000L));
}
static inline int
iswideogram(wint_t _wc)
{
 return (__istype(_wc, 0x00080000L));
}
static inline int
iswnumber(wint_t _wc)
{
 return (__istype(_wc, 0x00000400L));
}
static inline int
iswphonogram(wint_t _wc)
{
 return (__istype(_wc, 0x00200000L));
}
static inline int
iswrune(wint_t _wc)
{
 return (__istype(_wc, 0xFFFFFFF0L));
}
static inline int
iswspecial(wint_t _wc)
{
 return (__istype(_wc, 0x00100000L));
}
extern "C" {
wint_t nextwctype(wint_t, wctype_t);
wint_t towctrans(wint_t, wctrans_t);
wctrans_t
 wctrans(const char *);
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;
  using ::iswalnum;
  using ::iswalpha;
  using ::iswblank;
  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
namespace std
{

  using std::iswblank;

}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  struct ctype_base
  {
    typedef const int* __to_type;
    typedef unsigned long mask;
    static const mask upper = 0x00008000L;
    static const mask lower = 0x00001000L;
    static const mask alpha = 0x00000100L;
    static const mask digit = 0x00000400L;
    static const mask xdigit = 0x00010000L;
    static const mask space = 0x00004000L;
    static const mask print = 0x00040000L;
    static const mask graph = 0x00000100L | 0x00000400L | 0x00002000L;
    static const mask cntrl = 0x00000200L;
    static const mask punct = 0x00002000L;
    static const mask alnum = 0x00000100L | 0x00000400L;
  };
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };
  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }
  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }
  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }
  inline _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }
  inline _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }
  inline _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }
  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }
  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };
  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }
  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }
  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }
  inline _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }
  inline _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }
  inline _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }
  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }
  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };
  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }
  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }
  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }
  inline _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }
  inline _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }
  inline _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }
  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }
  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
  class ios_base
  {
  public:
    class failure : public exception
    {
    public:
      explicit
      failure(const string& __str) throw();
      virtual
      ~failure() throw();
      virtual const char*
      what() const throw();
    private:
      string _M_msg;
    };
    typedef _Ios_Fmtflags fmtflags;
    static const fmtflags boolalpha = _S_boolalpha;
    static const fmtflags dec = _S_dec;
    static const fmtflags fixed = _S_fixed;
    static const fmtflags hex = _S_hex;
    static const fmtflags internal = _S_internal;
    static const fmtflags left = _S_left;
    static const fmtflags oct = _S_oct;
    static const fmtflags right = _S_right;
    static const fmtflags scientific = _S_scientific;
    static const fmtflags showbase = _S_showbase;
    static const fmtflags showpoint = _S_showpoint;
    static const fmtflags showpos = _S_showpos;
    static const fmtflags skipws = _S_skipws;
    static const fmtflags unitbuf = _S_unitbuf;
    static const fmtflags uppercase = _S_uppercase;
    static const fmtflags adjustfield = _S_adjustfield;
    static const fmtflags basefield = _S_basefield;
    static const fmtflags floatfield = _S_floatfield;
    typedef _Ios_Iostate iostate;
    static const iostate badbit = _S_badbit;
    static const iostate eofbit = _S_eofbit;
    static const iostate failbit = _S_failbit;
    static const iostate goodbit = _S_goodbit;
    typedef _Ios_Openmode openmode;
    static const openmode app = _S_app;
    static const openmode ate = _S_ate;
    static const openmode binary = _S_bin;
    static const openmode in = _S_in;
    static const openmode out = _S_out;
    static const openmode trunc = _S_trunc;
    typedef _Ios_Seekdir seekdir;
    static const seekdir beg = _S_beg;
    static const seekdir cur = _S_cur;
    static const seekdir end = _S_end;
    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;
    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
    typedef void (*event_callback) (event, ios_base&, int);
    void
    register_callback(event_callback __fn, int __index);
  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;
    struct _Callback_list
    {
      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;
      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }
      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }
      int
      _M_remove_reference()
      { return __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1); }
    };
     _Callback_list* _M_callbacks;
    void
    _M_call_callbacks(event __ev) throw();
    void
    _M_dispose_callbacks(void) throw();
    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };
    _Words _M_word_zero;
    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];
    int _M_word_size;
    _Words* _M_word;
    _Words&
    _M_grow_words(int __index, bool __iword);
    locale _M_ios_locale;
    void
    _M_init() throw();
  public:
    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();
    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };
    fmtflags
    flags() const
    { return _M_flags; }
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }
    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
    streamsize
    precision() const
    { return _M_precision; }
    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }
    streamsize
    width() const
    { return _M_width; }
    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
    static bool
    sync_with_stdio(bool __sync = true);
    locale
    imbue(const locale& __loc) throw();
    locale
    getloc() const
    { return _M_ios_locale; }
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
    static int
    xalloc() throw();
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
    virtual ~ios_base();
  protected:
    ios_base() throw ();
  private:
    ios_base(const ios_base&);
    ios_base&
    operator=(const ios_base&);
  };
  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }
  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }
  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }
  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }
  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }
  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }
  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }
  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }
  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }
  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }
  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }
  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }
  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }
  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }
  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }
  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }
  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }
  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }
  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }
  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }
  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }
  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;
      friend streamsize
      __copy_streambufs_eof<>(__streambuf_type*, __streambuf_type*, bool&);
      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);
      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);
      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);
      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);
      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);
    protected:
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;
      locale _M_buf_locale;
  public:
      virtual
      ~basic_streambuf()
      { }
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
      locale
      getloc() const
      { return _M_buf_locale; }
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }
      int
      pubsync() { return this->sync(); }
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }
    protected:
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
      char_type*
      eback() const { return _M_in_beg; }
      char_type*
      gptr() const { return _M_in_cur; }
      char_type*
      egptr() const { return _M_in_end; }
      void
      gbump(int __n) { _M_in_cur += __n; }
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
      char_type*
      pbase() const { return _M_out_beg; }
      char_type*
      pptr() const { return _M_out_cur; }
      char_type*
      epptr() const { return _M_out_end; }
      void
      pbump(int __n) { _M_out_cur += __n; }
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
      virtual void
      imbue(const locale&)
      { }
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
      virtual int
      sync() { return 0; }
      virtual streamsize
      showmanyc() { return 0; }
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
      virtual int_type
      underflow()
      { return traits_type::eof(); }
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }
    public:
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }
    private:
      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }
      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };
  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);
  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->gbump(__len);
     }
   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }
  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->pbump(__len);
     }
   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }
  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }
  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }
  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);
  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;
      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);
      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);
      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);
    private:
      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;
    public:
      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }
      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }
      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }
      char_type
      operator*() const
      {
 return traits_type::to_char_type(_M_get());
      }
      istreambuf_iterator&
      operator++()
      {
 ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }
      istreambuf_iterator
      operator++(int)
      {
 ;
 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }
      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }
    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }
      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };
  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }
  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }
  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;
      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);
    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;
    public:
      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }
      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }
      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }
      ostreambuf_iterator&
      operator*()
      { return *this; }
      ostreambuf_iterator&
      operator++(int)
      { return *this; }
      ostreambuf_iterator&
      operator++()
      { return *this; }
      bool
      failed() const throw()
      { return _M_failed; }
      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };
  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }
  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }
  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }
  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }
  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }
   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();
  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();
  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();
  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();
  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };
  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);
  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }
  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:
      typedef _CharT char_type;
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }
    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }
      virtual
      ~__ctype_abstract_base() { }
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
      virtual char_type
      do_toupper(char_type) const = 0;
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
      virtual char_type
      do_tolower(char_type) const = 0;
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
      virtual char_type
      do_widen(char) const = 0;
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;
      static locale::id id;
      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }
   protected:
      virtual
      ~ctype();
      virtual bool
      do_is(mask __m, char_type __c) const;
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
      virtual char_type
      do_toupper(char_type __c) const;
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
      virtual char_type
      do_tolower(char_type __c) const;
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
      virtual char_type
      do_widen(char __c) const;
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
      virtual char
      do_narrow(char_type, char __dfault) const;
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };
  template<typename _CharT>
    locale::id ctype<_CharT>::id;
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:
      typedef char char_type;
    protected:
      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;
    public:
      static locale::id id;
      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
      inline bool
      is(mask __m, char __c) const;
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }
      const mask*
      table() const throw()
      { return _M_table; }
      static const mask*
      classic_table() throw();
    protected:
      virtual
      ~ctype();
      virtual char_type
      do_toupper(char_type) const;
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
      virtual char_type
      do_tolower(char_type) const;
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
      virtual char_type
      do_widen(char __c) const
      { return __c; }
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:
      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;
    protected:
      __c_locale _M_c_locale_ctype;
      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];
      mask _M_bit[16];
      __wmask_type _M_wmask[16];
    public:
      static locale::id id;
      explicit
      ctype(size_t __refs = 0);
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);
    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();
      virtual
      ~ctype();
      virtual bool
      do_is(mask __m, char_type __c) const;
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
      virtual char_type
      do_toupper(char_type) const;
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
      virtual char_type
      do_tolower(char_type) const;
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
      virtual char_type
      do_widen(char) const;
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
      virtual char
      do_narrow(char_type, char __dfault) const;
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
      void
      _M_initialize_ctype() throw();
    };
  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);
    protected:
      virtual
      ~ctype_byname() { };
    };
  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);
    protected:
      virtual
      ~ctype_byname();
    };
  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);
    protected:
      virtual
      ~ctype_byname();
    };
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  bool
  ctype<char>::
  is(mask __m, char __c) const
  {
    if (_M_table)
      return _M_table[static_cast<unsigned char>(__c)] & __m;
    else
      return __istype(__c, __m);
  }
  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    if (_M_table)
      while (__low < __high)
 *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    else
      for (;__low < __high; ++__vec, ++__low)
 {
   *__vec = __maskrune (*__low, upper | lower | alpha | digit | xdigit
          | space | print | graph | cntrl | punct | alnum);
 }
    return __high;
  }
  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    if (_M_table)
      while (__low < __high
      && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
 ++__low;
    else
      while (__low < __high && !this->is(__m, *__low))
 ++__low;
    return __low;
  }
  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    if (_M_table)
      while (__low < __high
      && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
 ++__low;
    else
      while (__low < __high && this->is(__m, *__low) != 0)
 ++__low;
    return __low;
  }
  inline bool
  ctype<wchar_t>::
  do_is(mask __m, wchar_t __c) const
  {
    return __istype (__c, __m);
  }
  inline const wchar_t*
  ctype<wchar_t>::
  do_is(const wchar_t* __lo, const wchar_t* __hi, mask* __vec) const
  {
    for (; __lo < __hi; ++__vec, ++__lo)
      *__vec = __maskrune (*__lo, upper | lower | alpha | digit | xdigit
      | space | print | graph | cntrl | punct | alnum);
    return __hi;
  }
  inline const wchar_t*
  ctype<wchar_t>::
  do_scan_is(mask __m, const wchar_t* __lo, const wchar_t* __hi) const
  {
    while (__lo < __hi && ! __istype (*__lo, __m))
      ++__lo;
    return __lo;
  }
  inline const wchar_t*
  ctype<wchar_t>::
  do_scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
  {
    while (__lo < __hi && __istype (*__lo, __m))
      ++__lo;
    return __lo;
  }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  class __num_base
  {
  public:
    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };
    static const char* _S_atoms_out;
    static const char* _S_atoms_in;
    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };
    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };
  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      _CharT _M_atoms_out[__num_base::_S_oend];
      _CharT _M_atoms_in[__num_base::_S_iend];
      bool _M_allocated;
      __numpunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_truename(__null), _M_truename_size(0), _M_falsename(__null),
      _M_falsename_size(0), _M_decimal_point(_CharT()),
      _M_thousands_sep(_CharT()), _M_allocated(false)
      { }
      ~__numpunct_cache();
      void
      _M_cache(const locale& __loc);
    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);
      explicit
      __numpunct_cache(const __numpunct_cache&);
    };
  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      typedef __numpunct_cache<_CharT> __cache_type;
    protected:
      __cache_type* _M_data;
    public:
      static locale::id id;
      explicit
      numpunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(); }
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_numpunct(__cloc); }
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
      string
      grouping() const
      { return this->do_grouping(); }
      string_type
      truename() const
      { return this->do_truename(); }
      string_type
      falsename() const
      { return this->do_falsename(); }
    protected:
      virtual
      ~numpunct();
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }
      void
      _M_initialize_numpunct(__c_locale __cloc = __null);
    };
  template<typename _CharT>
    locale::id numpunct<_CharT>::id;
  template<>
    numpunct<char>::~numpunct();
  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);
  template<>
    numpunct<wchar_t>::~numpunct();
  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);
  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }
    protected:
      virtual
      ~numpunct_byname() { }
    };

  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef _InIter iter_type;
      static locale::id id;
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
    protected:
      virtual ~num_get() { }
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;
      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;
      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }
      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;
      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }
      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }
      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }
      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }
      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }
      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;
    };
  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      static locale::id id;
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }
    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;
      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;
      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;
      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;
      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;
      virtual
      ~num_put() { };
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;
    };
  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;

  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }
  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }
  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }
  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }
  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }
  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }
  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }
  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }
  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }
  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }
  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }
  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }
  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };
  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = __null;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };
  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);
      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   _M_grouping_size = __np.grouping().size();
   __grouping = new char[_M_grouping_size];
   __np.grouping().copy(__grouping, _M_grouping_size);
   _M_grouping = __grouping;
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(_M_grouping[0]) > 0
        && (_M_grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));
   _M_truename_size = __np.truename().size();
   __truename = new _CharT[_M_truename_size];
   __np.truename().copy(__truename, _M_truename_size);
   _M_truename = __truename;
   _M_falsename_size = __np.falsename().size();
   __falsename = new _CharT[_M_falsename_size];
   __np.falsename().copy(__falsename, _M_falsename_size);
   _M_falsename = __falsename;
   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();
   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();
      bool __testeof = __beg == __end;
      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }
      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }
      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;
      if (!__lc->_M_allocated)
 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {
  __xtrc += 'e';
  __found_sci = true;
  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;
     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {
     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {
      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {
   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {
      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {
      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;
      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }
     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      if (__found_grouping.size())
        {
   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);
          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();
 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);
 bool __testeof = __beg == __end;
 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }
 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;
     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }
 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);
 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;
 if (!__lc->_M_allocated)
   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;
       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {
       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {
    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;
    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 if (__found_grouping.size())
   {
     __found_grouping += static_cast<char>(__sep_pos);
     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }
 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;
 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {
   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {
       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);
   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }
       const char_type __c = *__beg;
       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];
       if (!__testf && __donet)
  break;
       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];
       if (!__testt && __donef)
  break;
       if (!__testt && !__testf)
  break;
       ++__n;
       ++__beg;
       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {
       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {
      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);
      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;
      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);
      __io.flags(__fmt);
      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }
  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {
      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }

  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {
   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {
   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {
   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();
 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));
 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;
 if (__lc->_M_use_grouping)
   {
     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }
 if (__builtin_expect(__dec, true))
   {
     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {
  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];
  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }
 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);
 return std::__write(__s, __cs, __len);
      }
  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {
      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);
      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();
 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;
 int __len;
 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);
 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);
 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);
 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }
 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {
     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));
     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }
     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;
     __ws = __ws2;
   }
 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);
 return std::__write(__s, __ws, __len);
      }
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);
   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;
   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));
       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);
       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));
      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;
      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }

  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;
      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }
      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {
          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }
 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }
  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;
      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }
      while (__first != __last)
 *__s++ = *__first++;
      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }
      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }
      return __s;
    }
  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;
  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);
  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);
  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);
  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);
  extern template
    bool
    has_facet<ctype<char> >(const locale&);
  extern template
    bool
    has_facet<numpunct<char> >(const locale&);
  extern template
    bool
    has_facet<num_put<char> >(const locale&);
  extern template
    bool
    has_facet<num_get<char> >(const locale&);
  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;
  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);
  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);
  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);
  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);
 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);
}
       
       
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  using ::clock_t;
  using ::time_t;
  using ::tm;
  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };
  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {
      static const _CharT* _S_timezones[14];
      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;
      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;
      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;
      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;
      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;
      bool _M_allocated;
      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(__null), _M_date_era_format(__null), _M_time_format(__null),
      _M_time_era_format(__null), _M_date_time_format(__null),
      _M_date_time_era_format(__null), _M_am(__null), _M_pm(__null),
      _M_am_pm_format(__null), _M_day1(__null), _M_day2(__null), _M_day3(__null),
      _M_day4(__null), _M_day5(__null), _M_day6(__null), _M_day7(__null),
      _M_aday1(__null), _M_aday2(__null), _M_aday3(__null), _M_aday4(__null),
      _M_aday5(__null), _M_aday6(__null), _M_aday7(__null), _M_month01(__null),
      _M_month02(__null), _M_month03(__null), _M_month04(__null), _M_month05(__null),
      _M_month06(__null), _M_month07(__null), _M_month08(__null), _M_month09(__null),
      _M_month10(__null), _M_month11(__null), _M_month12(__null), _M_amonth01(__null),
      _M_amonth02(__null), _M_amonth03(__null), _M_amonth04(__null),
      _M_amonth05(__null), _M_amonth06(__null), _M_amonth07(__null),
      _M_amonth08(__null), _M_amonth09(__null), _M_amonth10(__null),
      _M_amonth11(__null), _M_amonth12(__null), _M_allocated(false)
      { }
      ~__timepunct_cache();
      void
      _M_cache(const locale& __loc);
    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);
      explicit
      __timepunct_cache(const __timepunct_cache&);
    };
  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {
 }
    }
  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];
  template<>
    const wchar_t*
    __timepunct_cache<wchar_t>::_S_timezones[14];
  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];
  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:
      typedef _CharT __char_type;
      typedef basic_string<_CharT> __string_type;
      typedef __timepunct_cache<_CharT> __cache_type;
    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;
    public:
      static locale::id id;
      explicit
      __timepunct(size_t __refs = 0);
      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);
      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const throw ();
      void
      _M_date_formats(const _CharT** __date) const
      {
 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }
      void
      _M_time_formats(const _CharT** __time) const
      {
 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }
      void
      _M_date_time_formats(const _CharT** __dt) const
      {
 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }
      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }
      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }
      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }
      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }
      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }
      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }
    protected:
      virtual
      ~__timepunct();
      void
      _M_initialize_timepunct(__c_locale __cloc = __null);
    };
  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;
  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);
  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const throw ();
  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);
  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
     const tm*) const throw ();
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(__null)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }
  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }
  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(__null)
    {
      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
 {
   const size_t __len = __builtin_strlen(__s) + 1;
   char* __tmp = new char[__len];
   __builtin_memcpy(__tmp, __s, __len);
   _M_name_timepunct = __tmp;
 }
      else
 _M_name_timepunct = _S_get_c_name();
      try
 { _M_initialize_timepunct(__cloc); }
      catch(...)
 {
   if (_M_name_timepunct != _S_get_c_name())
     delete [] _M_name_timepunct;
   throw;
 }
    }
  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:
      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> __string_type;
      static locale::id id;
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
      dateorder
      date_order() const
      { return this->do_date_order(); }
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }
    protected:
      virtual
      ~time_get() { }
      virtual dateorder
      do_date_order() const;
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;
      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;
      iter_type
      _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
          const _CharT** __names, size_t __indexlen,
          ios_base& __io, ios_base::iostate& __err) const;
      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };
  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;
  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:
      typedef _CharT char_type;
      typedef _InIter iter_type;
      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }
    protected:
      virtual
      ~time_get_byname() { }
    };
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      static locale::id id;
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }
    protected:
      virtual
      ~time_put()
      { }
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };
  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;
  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };
    protected:
      virtual
      ~time_put_byname() { }
    };
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };
    static const pattern _S_default_pattern;
    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };
    static const char* _S_atoms;
    __attribute__ ((__const__)) static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn) throw ();
  };
  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;
      _CharT _M_atoms[money_base::_S_end];
      bool _M_allocated;
      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(__null), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(__null), _M_curr_symbol_size(0),
      _M_positive_sign(__null), _M_positive_sign_size(0),
      _M_negative_sign(__null), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }
      ~__moneypunct_cache();
      void
      _M_cache(const locale& __loc);
    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);
      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };
  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }
  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;
    private:
      __cache_type* _M_data;
    public:
      static const bool intl = _Intl;
      static locale::id id;
      explicit
      moneypunct(size_t __refs = 0) : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(); }
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(__null)
      { _M_initialize_moneypunct(__cloc, __s); }
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
      string
      grouping() const
      { return this->do_grouping(); }
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
      int
      frac_digits() const
      { return this->do_frac_digits(); }
      pattern
      pos_format() const
      { return this->do_pos_format(); }
      pattern
      neg_format() const
      { return this->do_neg_format(); }
    protected:
      virtual
      ~moneypunct();
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }
       void
       _M_initialize_moneypunct(__c_locale __cloc = __null,
    const char* __name = __null);
    };
  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;
  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;
  template<>
    moneypunct<char, true>::~moneypunct();
  template<>
    moneypunct<char, false>::~moneypunct();
  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);
  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);
  template<>
    moneypunct<wchar_t, true>::~moneypunct();
  template<>
    moneypunct<wchar_t, false>::~moneypunct();
  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
       const char*);
  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
        const char*);
  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      static const bool intl = _Intl;
      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }
    protected:
      virtual
      ~moneypunct_byname() { }
    };
  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;

  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;
      static locale::id id;
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }
    protected:
      virtual
      ~money_get() { }
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;
      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };
  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:
      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;
      static locale::id id;
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }
    protected:
      virtual
      ~money_put() { }
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;
      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };
  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;

  struct messages_base
  {
    typedef int catalog;
  };
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
    protected:
      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;
    public:
      static locale::id id;
      explicit
      messages(size_t __refs = 0);
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
      void
      close(catalog __c) const
      { return this->do_close(__c); }
    protected:
      virtual
      ~messages();
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;
      virtual void
      do_close(catalog) const;
      char*
      _M_convert_to_char(const string_type& __msg) const
      {
 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }
      string_type
      _M_convert_from_char(char*) const
      {
 return string_type();
      }
     };
  template<typename _CharT>
    locale::id messages<_CharT>::id;
  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;
  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;
   template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;
      explicit
      messages_byname(const char* __s, size_t __refs = 0);
    protected:
      virtual
      ~messages_byname()
      { }
    };
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _CharT>
     messages<_CharT>::messages(size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }
  template<typename _CharT>
     messages<_CharT>::messages(__c_locale, const char*, size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }
  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char*) const
    { return this->do_open(__s, __loc); }
  template<typename _CharT>
    messages<_CharT>::~messages()
    { _S_destroy_c_locale(_M_c_locale_messages); }
  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>&, const locale&) const
    { return 0; }
  template<typename _CharT>
    typename messages<_CharT>::string_type
    messages<_CharT>::do_get(catalog, int, int,
        const string_type& __dfault) const
    { return __dfault; }
  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }
   template<typename _CharT>
     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
     : messages<_CharT>(__refs)
     {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_messages);
     this->_S_create_c_locale(this->_M_c_locale_messages, __s);
   }
     }
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:
      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }
      int
      encoding() const throw()
      { return this->do_encoding(); }
      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }
      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }
      int
      max_length() const throw()
      { return this->do_max_length(); }
    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }
      virtual
      ~__codecvt_abstract_base() { }
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;
      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;
      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;
      virtual int
      do_encoding() const throw() = 0;
      virtual bool
      do_always_noconv() const throw() = 0;
      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;
      virtual int
      do_max_length() const throw() = 0;
    };
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:
      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
    protected:
      __c_locale _M_c_locale_codecvt;
    public:
      static locale::id id;
      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs) { }
      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);
    protected:
      virtual
      ~codecvt() { }
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;
      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;
      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;
      virtual int
      do_encoding() const throw();
      virtual bool
      do_always_noconv() const throw();
      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;
      virtual int
      do_max_length() const throw();
    };
  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;
  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
    public:
      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;
    protected:
      __c_locale _M_c_locale_codecvt;
    public:
      static locale::id id;
      explicit
      codecvt(size_t __refs = 0);
      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);
    protected:
      virtual
      ~codecvt();
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;
      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;
      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;
      virtual int
      do_encoding() const throw();
      virtual bool
      do_always_noconv() const throw();
      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;
      virtual int
      do_max_length() const throw();
  };
  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
    public:
      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;
    protected:
      __c_locale _M_c_locale_codecvt;
    public:
      static locale::id id;
      explicit
      codecvt(size_t __refs = 0);
      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);
    protected:
      virtual
      ~codecvt();
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;
      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;
      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;
      virtual
      int do_encoding() const throw();
      virtual
      bool do_always_noconv() const throw();
      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;
      virtual int
      do_max_length() const throw();
    };
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }
    protected:
      virtual
      ~codecvt_byname() { }
    };
  extern template class codecvt_byname<char, char, mbstate_t>;
  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);
  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);
  extern template class codecvt_byname<wchar_t, char, mbstate_t>;
  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);
  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = __null;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };
  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;
      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);
      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();
      char* __grouping = 0;
      _CharT* __curr_symbol = 0;
      _CharT* __positive_sign = 0;
      _CharT* __negative_sign = 0;
      try
 {
   _M_grouping_size = __mp.grouping().size();
   __grouping = new char[_M_grouping_size];
   __mp.grouping().copy(__grouping, _M_grouping_size);
   _M_grouping = __grouping;
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(_M_grouping[0]) > 0
        && (_M_grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));
   _M_curr_symbol_size = __mp.curr_symbol().size();
   __curr_symbol = new _CharT[_M_curr_symbol_size];
   __mp.curr_symbol().copy(__curr_symbol, _M_curr_symbol_size);
   _M_curr_symbol = __curr_symbol;
   _M_positive_sign_size = __mp.positive_sign().size();
   __positive_sign = new _CharT[_M_positive_sign_size];
   __mp.positive_sign().copy(__positive_sign, _M_positive_sign_size);
   _M_positive_sign = __positive_sign;
   _M_negative_sign_size = __mp.negative_sign().size();
   __negative_sign = new _CharT[_M_negative_sign_size];
   __mp.negative_sign().copy(__negative_sign, _M_negative_sign_size);
   _M_negative_sign = __negative_sign;
   _M_pos_format = __mp.pos_format();
   _M_neg_format = __mp.neg_format();
   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(money_base::_S_atoms,
       money_base::_S_atoms + money_base::_S_end, _M_atoms);
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __curr_symbol;
   delete [] __positive_sign;
   delete [] __negative_sign;
   throw;
 }
    }

  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;
 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;
 bool __negative = false;
 size_type __sign_size = 0;
 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);
 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);
 int __last_pos = 0;
 int __n = 0;
 bool __testvalid = true;
 bool __testdecfound = false;
 string __res;
 __res.reserve(32);
 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:
  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || (__mandatory_sign
      && (static_cast<part>(__p.field[3])
          == money_base::sign)))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, ++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:
  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)
    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:
  for (; __beg != __end; ++__beg)
    {
      const char_type __c = *__beg;
      const char_type* __q = __traits_type::find(__lit_zero,
              10, __c);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (__c == __lc->_M_decimal_point
        && !__testdecfound)
        {
   if (__lc->_M_frac_digits <= 0)
     break;
   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && __c == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {
       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:
  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:
  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }
 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, ++__i);
     if (__i != __sign_size)
       __testvalid = false;
   }
 if (__testvalid)
   {
     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }
     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');
     if (__grouping_tmp.size())
       {
  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __err |= ios_base::failbit;
       }
     if (__testdecfound && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }
 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);
 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __digits) const
    {
      typedef typename string::size_type size_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   __digits.resize(__len);
   __ctype.widen(__str.data(), __str.data() + __len, &__digits[0]);
 }
      return __beg;
    }
  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;
 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;
 const char_type* __beg = __digits.data();
 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (!(*__beg == __lit[money_base::_S_minus]))
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }
 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {
     string_type __value;
     __value.reserve(2 * __len);
     long __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      __value.assign(2 * __paddec, char_type());
       _CharT* __vend =
        std::__add_grouping(&__value[0], __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.erase(__vend - &__value[0]);
      }
    else
    __value.assign(__beg, __paddec);
       }
     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {
      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }
     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);
     string_type __res;
     __res.reserve(2 * __len);
     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);
     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:
      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:
      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }
     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);
     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)
    __res.append(__width - __len, __fill);
  else
    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }
     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);
      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);
 }
      string_type __digits(__len, char_type());
      __ctype.widen(__cs, __cs + __len, &__digits[0]);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }

  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);
      ios_base::iostate __tmperr = ios_base::goodbit;
      for (size_t __i = 0; __beg != __end && __i < __len && !__tmperr; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {
       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':
    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,
       7, __io, __tmperr);
    break;
  case 'A':
    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,
       7, __io, __tmperr);
    break;
  case 'h':
  case 'b':
    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months1, 12, __io, __tmperr);
    break;
  case 'B':
    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months2, 12, __io, __tmperr);
    break;
  case 'c':
    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dt[0]);
    break;
  case 'd':
    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
      __io, __tmperr);
    break;
  case 'e':
    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,
        1, __io, __tmperr);
    else
      __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,
        2, __io, __tmperr);
    break;
  case 'D':
    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'H':
    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
      __io, __tmperr);
    break;
  case 'I':
    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
      __io, __tmperr);
    break;
  case 'm':
    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':
    __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
      __io, __tmperr);
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'R':
    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'S':
    __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 60, 2,
      __io, __tmperr);
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'T':
    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'x':
    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dates[0]);
    break;
  case 'X':
    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':
  case 'Y':
    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_year = __mem < 0 ? __mem + 100 : __mem - 1900;
    break;
  case 'Z':
    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __tmperr);
        if (__beg != __end && !__tmperr && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __tmperr);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __tmperr);
   }
      }
    else
      __tmperr |= ios_base::failbit;
    break;
  default:
    __tmperr |= ios_base::failbit;
  }
     }
   else
     {
       if (__format[__i] == *__beg)
  ++__beg;
       else
  __tmperr |= ios_base::failbit;
     }
 }
      if (__tmperr)
 __err |= ios_base::failbit;
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);
      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, ++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;
      else if (__len == 4 && __i == 2)
 __member = __value - 100;
      else
 __err |= ios_base::failbit;
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;
      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }
      while (__nmatches > 1)
 {
   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg, ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (!(__name[__pos] == *__beg))
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }
      if (__nmatches == 1)
 {
   ++__beg, ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, ++__pos;
   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      int* __matches = static_cast<int*>(__builtin_alloca(2 * sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t* __matches_lengths = 0;
      size_t __pos = 0;
      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < 2 * __indexlen; ++__i)
     if (__c == __names[__i][0]
  || __c == __ctype.toupper(__names[__i][0]))
       __matches[__nmatches++] = __i;
 }
      if (__nmatches)
 {
   ++__beg, ++__pos;
   __matches_lengths
     = static_cast<size_t*>(__builtin_alloca(sizeof(size_t)
          * __nmatches));
   for (size_t __i = 0; __i < __nmatches; ++__i)
     __matches_lengths[__i]
       = __traits_type::length(__names[__matches[__i]]);
 }
      for (; __beg != __end; ++__beg, ++__pos)
 {
   size_t __nskipped = 0;
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < __nmatches;)
     {
       const char_type* __name = __names[__matches[__i]];
       if (__pos >= __matches_lengths[__i])
  ++__nskipped, ++__i;
       else if (!(__name[__pos] == __c))
  {
    --__nmatches;
    __matches[__i] = __matches[__nmatches];
    __matches_lengths[__i] = __matches_lengths[__nmatches];
  }
       else
  ++__i;
     }
   if (__nskipped == __nmatches)
     break;
 }
      if ((__nmatches == 1 && __matches_lengths[0] == __pos)
   || (__nmatches == 2 && (__matches_lengths[0] == __pos
      || __matches_lengths[1] == __pos)))
 __member = (__matches[0] >= __indexlen
      ? __matches[0] - __indexlen : __matches[0]);
      else
 __err |= ios_base::failbit;
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[14];
      __tp._M_days_abbreviated(__days);
      __tp._M_days(__days + 7);
      int __tmpwday;
      ios_base::iostate __tmperr = ios_base::goodbit;
      __beg = _M_extract_wday_or_month(__beg, __end, __tmpwday, __days, 7,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_wday = __tmpwday;
      else
 __err |= ios_base::failbit;
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[24];
      __tp._M_months_abbreviated(__months);
      __tp._M_months(__months + 12);
      int __tmpmon;
      ios_base::iostate __tmperr = ios_base::goodbit;
      __beg = _M_extract_wday_or_month(__beg, __end, __tmpmon, __months, 12,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_mon = __tmpmon;
      else
 __err |= ios_base::failbit;
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      int __tmpyear;
      ios_base::iostate __tmperr = ios_base::goodbit;
      __beg = _M_extract_num(__beg, __end, __tmpyear, 0, 9999, 4,
        __io, __tmperr);
      if (!__tmperr)
 __tm->tm_year = __tmpyear < 0 ? __tmpyear + 100 : __tmpyear - 1900;
      else
 __err |= ios_base::failbit;
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }
  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const size_t __maxlen = 128;
      char_type __res[__maxlen];
      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }
      __tp._M_put(__res, __maxlen, __fmt, __tm);
      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }
  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class money_get<char>;
  extern template class money_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;
  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);
  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);
  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);
  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);
  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);
  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);
  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);
  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);
  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);
  extern template
    bool
    has_facet<money_put<char> >(const locale&);
  extern template
    bool
    has_facet<money_get<char> >(const locale&);
  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);
  extern template
    bool
    has_facet<time_put<char> >(const locale&);
  extern template
    bool
    has_facet<time_get<char> >(const locale&);
  extern template
    bool
    has_facet<messages<char> >(const locale&);
  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class money_get<wchar_t>;
  extern template class money_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;
  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);
  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);
  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);
  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);
  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);
  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);
  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);
  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);
  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);
}
namespace boost {
    namespace io {
        template<class Tr>
        class CompatTraits;
        template<class Alloc>
        class CompatAlloc;
    }
}
namespace boost { namespace io { namespace detail {
    typedef ::std:: locale locale_t;
} } }
       
       
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;
    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;
      const __ctype_type* _M_ctype;
      const __num_put_type* _M_num_put;
      const __num_get_type* _M_num_get;
    public:
      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }
      bool
      operator!() const
      { return this->fail(); }
      iostate
      rdstate() const
      { return _M_streambuf_state; }
      void
      clear(iostate __state = goodbit);
      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }
      void
      _M_setstate(iostate __state)
      {
 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }
      bool
      good() const
      { return this->rdstate() == 0; }
      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }
      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
      iostate
      exceptions() const
      { return _M_exception; }
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }
      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }
      virtual
      ~basic_ios() { }
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }
      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
      basic_ios&
      copyfmt(const basic_ios& __rhs);
      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
      locale
      imbue(const locale& __loc);
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }
    protected:
      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }
      void
      init(basic_streambuf<_CharT, _Traits>* __sb);
      void
      _M_cache_locale(const locale& __loc);
    };
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }
  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }
  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {
      if (this != &__rhs)
 {
   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];
   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();
   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;
   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);
   _M_call_callbacks(copyfmt_event);
   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {
      ios_base::_M_init();
      _M_cache_locale(_M_ios_locale);
      _M_fill = _CharT();
      _M_fill_init = false;
      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }
  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;
      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;
      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }
  extern template class basic_ios<char>;
  extern template class basic_ios<wchar_t>;
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }
      virtual
      ~basic_ostream() { }
      class sentry;
      friend class sentry;
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {
 return __pf(*this);
      }
      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }
      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {
 __pf(*this);
 return *this;
      }
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }
      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }
      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }
      __ostream_type&
      operator<<(short __n);
      __ostream_type&
      operator<<(unsigned short __n)
      {
 return _M_insert(static_cast<unsigned long>(__n));
      }
      __ostream_type&
      operator<<(int __n);
      __ostream_type&
      operator<<(unsigned int __n)
      {
 return _M_insert(static_cast<unsigned long>(__n));
      }
      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }
      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }
      __ostream_type&
      operator<<(float __f)
      {
 return _M_insert(static_cast<double>(__f));
      }
      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
      __ostream_type&
      operator<<(__streambuf_type* __sb);
      __ostream_type&
      put(char_type __c);
      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
      __ostream_type&
      write(const char_type* __s, streamsize __n);
      __ostream_type&
      flush();
      pos_type
      tellp();
      __ostream_type&
      seekp(pos_type);
       __ostream_type&
      seekp(off_type, ios_base::seekdir);
    protected:
      basic_ostream()
      { this->init(0); }
      template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __v);
    };
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {
      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;
    public:
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
      ~sentry()
      {
 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {
     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
      explicit
      operator bool() const
      { return _M_ok; }
    };
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }
  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }
  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)
    { return (__os << __x); }
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {
      if (__os.tie() && __os.good())
 __os.tie()->flush();
      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }
  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {
      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {
      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {
      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {
       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);
       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {
       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);
       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {
   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);
       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }
  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);
  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);
  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);
  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);
  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);
  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);
  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);
  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);
}
namespace boost {
    namespace io {
        template<class Tr>
        class CompatTraits
        {
        public:
            typedef Tr compatible_type;
        };
        template<class Alloc>
        class CompatAlloc
        {
        public:
            typedef Alloc compatible_type;
        };
    }
}
namespace boost {
    template <class Ch,
        class Tr = ::std:: char_traits<Ch>, class Alloc = std::allocator<Ch> >
    class basic_format;
    typedef basic_format<char > format;
    typedef basic_format<wchar_t > wformat;
    namespace io {
        enum format_error_bits { bad_format_string_bit = 1,
                                 too_few_args_bit = 2, too_many_args_bit = 4,
                                 out_of_range_bit = 8,
                                 all_error_bits = 255, no_error_bits=0 };
    }
}
namespace boost {
namespace io {
namespace detail {
  template<class Ch, class Tr> struct stream_format_state;
    template<class Ch, class Tr, class Alloc> struct format_item;
    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    modify_item_body (basic_format<Ch, Tr, Alloc>& self,
                      int itemN, T manipulator);
    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    bind_arg_body (basic_format<Ch, Tr, Alloc>& self,
                   int argN, const T& val);
    template<class Ch, class Tr, class T>
    void apply_manip_body (stream_format_state<Ch, Tr>& self,
                           T manipulator);
    template<class Ch, class Tr, class Alloc, class T>
    void distribute (basic_format<Ch,Tr, Alloc>& self, T x);
    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    feed (basic_format<Ch,Tr, Alloc>& self, T x);
}
}
}
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
}
       
       
       
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;
    protected:
      streamsize _M_gcount;
    public:
      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }
      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }
      class sentry;
      friend class sentry;
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }
      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }
      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }
      __istream_type&
      operator>>(short& __n);
      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }
      __istream_type&
      operator>>(int& __n);
      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }
      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }
      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }
      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }
      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }
      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }
      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
      __istream_type&
      operator>>(__streambuf_type* __sb);
      streamsize
      gcount() const
      { return _M_gcount; }
      int_type
      get();
      __istream_type&
      get(char_type& __c);
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
      __istream_type&
      ignore();
      __istream_type&
      ignore(streamsize __n);
      __istream_type&
      ignore(streamsize __n, int_type __delim);
      int_type
      peek();
      __istream_type&
      read(char_type* __s, streamsize __n);
      streamsize
      readsome(char_type* __s, streamsize __n);
      __istream_type&
      putback(char_type __c);
      __istream_type&
      unget();
      int
      sync();
      pos_type
      tellg();
      __istream_type&
      seekg(pos_type);
      __istream_type&
      seekg(off_type, ios_base::seekdir);
    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }
      template<typename _ValueT>
        __istream_type&
        _M_extract(_ValueT& __v);
    };
  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);
  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);
  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);
  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);
  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);
  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {
      bool _M_ok;
    public:
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
      explicit
      operator bool() const
      { return _M_ok; }
    };
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);
  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);
  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);
  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:
      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }
      virtual
      ~basic_iostream() { }
    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>&& __is, _Tp& __x)
    { return (__is >> __x); }
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();
       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }
      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }
  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);
       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {
      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);
       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();
       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();
       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();
       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);
       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }
      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }
       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }
       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }
  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {
      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }
  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
           ios_base::in);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {
       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::in);
       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {
       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::in);
       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;
      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {
       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();
       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;
      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();
      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();
       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }
  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);
  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);
  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);
  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);
  extern template class basic_iostream<char>;
  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);
  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);
  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);
  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);
  extern template class basic_iostream<wchar_t>;
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;
  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;
  static ios_base::Init __ioinit;
}
namespace boost
{
namespace detail
{
inline void current_function_helper()
{
}
}
}
    namespace boost
    {
      namespace assertion
      {
        namespace detail
        {
          inline void assertion_failed_msg(char const * expr, char const * msg, char const * function,
            char const * file, long line)
          {
            std::cerr
              << "***** Internal Program Error - assertion (" << expr << ") failed in "
              << function << ":\n"
              << file << '(' << line << "): " << msg << std::endl;
            std::abort();
          }
        }
      }
    }
       
       
       
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _IIter, typename _Predicate>
    bool
    all_of(_IIter, _IIter, _Predicate);
  template<typename _IIter, typename _Predicate>
    bool
    any_of(_IIter, _IIter, _Predicate);
  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);
  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);
  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);
  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);
  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);
  template<typename _IIter, typename _Size, typename _OIter>
    _OIter
    copy_n(_IIter, _Size, _OIter);
  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);
  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);
  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);
  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);
  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);
  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);
  template<typename _IIter, typename _Predicate>
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);
  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);
  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);
  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);
  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);
  template<typename _RAIter>
    bool
    is_heap(_RAIter, _RAIter);
  template<typename _RAIter, typename _Compare>
    bool
    is_heap(_RAIter, _RAIter, _Compare);
  template<typename _RAIter>
    _RAIter
    is_heap_until(_RAIter, _RAIter);
  template<typename _RAIter, typename _Compare>
    _RAIter
    is_heap_until(_RAIter, _RAIter, _Compare);
  template<typename _IIter, typename _Predicate>
    bool
    is_partitioned(_IIter, _IIter, _Predicate);
  template<typename _FIter>
    bool
    is_sorted(_FIter, _FIter);
  template<typename _FIter, typename _Compare>
    bool
    is_sorted(_FIter, _FIter, _Compare);
  template<typename _FIter>
    _FIter
    is_sorted_until(_FIter, _FIter);
  template<typename _FIter, typename _Compare>
    _FIter
    is_sorted_until(_FIter, _FIter, _Compare);
  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);
  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);
  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);
  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);
  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);
  template<typename _Tp>
    const _Tp&
    max(const _Tp&, const _Tp&);
  template<typename _Tp, typename _Compare>
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);
  template<typename _Tp>
    const _Tp&
    min(const _Tp&, const _Tp&);
  template<typename _Tp, typename _Compare>
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);
  template<typename _Tp>
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&);
  template<typename _Tp, typename _Compare>
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);
  template<typename _FIter>
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);
  template<typename _FIter, typename _Compare>
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);
  template<typename _Tp>
    _Tp
    min(initializer_list<_Tp>);
  template<typename _Tp, typename _Compare>
    _Tp
    min(initializer_list<_Tp>, _Compare);
  template<typename _Tp>
    _Tp
    max(initializer_list<_Tp>);
  template<typename _Tp, typename _Compare>
    _Tp
    max(initializer_list<_Tp>, _Compare);
  template<typename _Tp>
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);
  template<typename _Tp, typename _Compare>
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);
  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);
  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);
  template<typename _IIter, typename _Predicate>
    bool
    none_of(_IIter, _IIter, _Predicate);
  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);
  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);
  template<typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate>
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);
  template<typename _FIter, typename _Predicate>
    _FIter
    partition_point(_FIter, _FIter, _Predicate);
  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);
  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);
  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);
  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);
  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);
  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);
  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);
  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);
  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);
  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);
  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);
  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);
  template<typename _BIter>
    void
    reverse(_BIter, _BIter);
  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);
  template<typename _FIter>
    void
    rotate(_FIter, _FIter, _FIter);
  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
  template<typename _RAIter, typename _UGenerator>
    void
    shuffle(_RAIter, _RAIter, _UGenerator&);
  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);
  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);
  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);
  template<typename _Tp>
    void
    swap(_Tp&, _Tp&);
  template<typename _Tp, size_t _Nm>
    void
    swap(_Tp (&)[_Nm], _Tp (&)[_Nm]);
  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);
  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);
  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);
  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);
  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);
  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);
  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);
  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);
  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);
  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);
  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);
  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);
  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);
  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);
  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);
  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);
  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);
  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);
  template<typename _FIter>
    _FIter
    max_element(_FIter, _FIter);
  template<typename _FIter, typename _Compare>
    _FIter
    max_element(_FIter, _FIter, _Compare);
  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);
  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);
  template<typename _FIter>
    _FIter
    min_element(_FIter, _FIter);
  template<typename _FIter, typename _Compare>
    _FIter
    min_element(_FIter, _FIter, _Compare);
  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);
  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);
  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);
  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);
  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);
  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);
  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);
  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,
     _Generator&&);
  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);
  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);
  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);
  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);
  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);
  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);
  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);
  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);
  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);
  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);
  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);
  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);
  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);
  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);
  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);
  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);
  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);
  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);
  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);
  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);
  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);
  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _RandomAccessIterator, typename _Distance>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__first[__parent] < __first[__child])
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }
  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first[__parent], __first[__child]))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }
  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    { return std::__is_heap_until(__first, __n) == __n; }
  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    { return std::__is_heap_until(__first, __n, __comp) == __n; }
  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }
  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }
  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && *(__first + __parent) < __value)
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;
     
     
      ;
      ;
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value));
    }
  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,
  _Distance __topIndex, _Tp __value, _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex
      && __comp(*(__first + __parent), __value))
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;
     
      ;
      ;
      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value), __comp);
    }
  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value));
    }
  template<typename _RandomAccessIterator>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value));
    }
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
     
     
      ;
      ;
      --__last;
      std::__pop_heap(__first, __last, __last);
    }
  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(*(__first + __secondChild),
       *(__first + (__secondChild - 1))))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)));
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value), __comp);
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value), __comp);
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
     
      ;
      ;
      --__last;
      std::__pop_heap(__first, __last, __last, __comp);
    }
  template<typename _RandomAccessIterator>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;
     
     
      ;
      if (__last - __first < 2)
 return;
      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value));
   if (__parent == 0)
     return;
   __parent--;
 }
    }
  template<typename _RandomAccessIterator, typename _Compare>
    void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;
     
      ;
      if (__last - __first < 2)
 return;
      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
  template<typename _RandomAccessIterator>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
     
     
      ;
      ;
      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last);
 }
    }
  template<typename _RandomAccessIterator, typename _Compare>
    void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
     
      ;
      ;
      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
     
     
      ;
      return __first + std::__is_heap_until(__first, std::distance(__first,
           __last));
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
     
      ;
      return __first + std::__is_heap_until(__first, std::distance(__first,
           __last),
         __comp);
    }
  template<typename _RandomAccessIterator>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }
  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp)
    { return std::is_heap_until(__first, __last, __comp) == __last; }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;
      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }
  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {
     
    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;
    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;
    public:
      size_type
      size() const
      { return _M_len; }
      size_type
      requested_size() const
      { return _M_original_len; }
      iterator
      begin()
      { return _M_buffer; }
      iterator
      end()
      { return _M_buffer + _M_len; }
      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);
      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }
    private:
      _Temporary_buffer(const _Temporary_buffer&);
      void
      operator=(const _Temporary_buffer&);
    };
  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if(_M_buffer)
     std::__uninitialized_construct_range(_M_buffer, _M_buffer + _M_len,
       *__first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }
}
       
       
extern "C" {
 typedef float float_t;
 typedef double double_t;
extern int __math_errhandling ( void );
extern int __fpclassifyf(float );
extern int __fpclassifyd(double );
extern int __fpclassify (long double);
 static __inline__ int __inline_isfinitef (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isfinited (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isfinite (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isinff (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isinfd (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isinf (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isnanf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnand (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnan (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormalf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormald (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_isnormal (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_signbitf (float ) __attribute__ ((always_inline));
 static __inline__ int __inline_signbitd (double ) __attribute__ ((always_inline));
 static __inline__ int __inline_signbit (long double) __attribute__ ((always_inline));
 static __inline__ int __inline_isinff( float __x ) { return __builtin_fabsf(__x) == __builtin_inff(); }
 static __inline__ int __inline_isinfd( double __x ) { return __builtin_fabs(__x) == __builtin_inf(); }
 static __inline__ int __inline_isinf( long double __x ) { return __builtin_fabsl(__x) == __builtin_infl(); }
 static __inline__ int __inline_isfinitef( float __x ) { return __x == __x && __builtin_fabsf(__x) != __builtin_inff(); }
 static __inline__ int __inline_isfinited( double __x ) { return __x == __x && __builtin_fabs(__x) != __builtin_inf(); }
 static __inline__ int __inline_isfinite( long double __x ) { return __x == __x && __builtin_fabsl(__x) != __builtin_infl(); }
 static __inline__ int __inline_isnanf( float __x ) { return __x != __x; }
 static __inline__ int __inline_isnand( double __x ) { return __x != __x; }
 static __inline__ int __inline_isnan( long double __x ) { return __x != __x; }
 static __inline__ int __inline_signbitf( float __x ) { union{ float __f; unsigned int __u; }__u; __u.__f = __x; return (int)(__u.__u >> 31); }
 static __inline__ int __inline_signbitd( double __x ) { union{ double __f; unsigned int __u[2]; }__u; __u.__f = __x; return (int)(__u.__u[1] >> 31); }
 static __inline__ int __inline_signbit( long double __x ){ union{ long double __ld; struct{ unsigned int __m[2]; short __sexp; }__p; }__u; __u.__ld = __x; return (int) (((unsigned short) __u.__p.__sexp) >> 15); }
 static __inline__ int __inline_isnormalf( float __x ) { float fabsf = __builtin_fabsf(__x); if( __x != __x ) return 0; return fabsf < __builtin_inff() && fabsf >= 1.17549435082228750797e-38F; }
 static __inline__ int __inline_isnormald( double __x ) { double fabsf = __builtin_fabs(__x); if( __x != __x ) return 0; return fabsf < __builtin_inf() && fabsf >= ((double)2.22507385850720138309e-308L); }
 static __inline__ int __inline_isnormal( long double __x ) { long double fabsf = __builtin_fabsl(__x); if( __x != __x ) return 0; return fabsf < __builtin_infl() && fabsf >= 3.36210314311209350626e-4932L; }
extern double acos( double );
extern float acosf( float );
extern double asin( double );
extern float asinf( float );
extern double atan( double );
extern float atanf( float );
extern double atan2( double, double );
extern float atan2f( float, float );
extern double cos( double );
extern float cosf( float );
extern double sin( double );
extern float sinf( float );
extern double tan( double );
extern float tanf( float );
extern double acosh( double );
extern float acoshf( float );
extern double asinh( double );
extern float asinhf( float );
extern double atanh( double );
extern float atanhf( float );
extern double cosh( double );
extern float coshf( float );
extern double sinh( double );
extern float sinhf( float );
extern double tanh( double );
extern float tanhf( float );
extern double exp ( double );
extern float expf ( float );
extern double exp2 ( double );
extern float exp2f ( float );
extern double expm1 ( double );
extern float expm1f ( float );
extern double log ( double );
extern float logf ( float );
extern double log10 ( double );
extern float log10f ( float );
extern double log2 ( double );
extern float log2f ( float );
extern double log1p ( double );
extern float log1pf ( float );
extern double logb ( double );
extern float logbf ( float );
extern double modf ( double, double * );
extern float modff ( float, float * );
extern double ldexp ( double, int );
extern float ldexpf ( float, int );
extern double frexp ( double, int * );
extern float frexpf ( float, int * );
extern int ilogb ( double );
extern int ilogbf ( float );
extern double scalbn ( double, int );
extern float scalbnf ( float, int );
extern double scalbln ( double, long int );
extern float scalblnf ( float, long int );
extern double fabs( double );
extern float fabsf( float );
extern double cbrt( double );
extern float cbrtf( float );
extern double hypot ( double, double );
extern float hypotf ( float, float );
extern double pow ( double, double );
extern float powf ( float, float );
extern double sqrt( double );
extern float sqrtf( float );
extern double erf( double );
extern float erff( float );
extern double erfc( double );
extern float erfcf( float );
extern double lgamma( double );
extern float lgammaf( float );
extern double tgamma( double );
extern float tgammaf( float );
extern double ceil ( double );
extern float ceilf ( float );
extern double floor ( double );
extern float floorf ( float );
extern double nearbyint ( double );
extern float nearbyintf ( float );
extern double rint ( double );
extern float rintf ( float );
extern long int lrint ( double );
extern long int lrintf ( float );
extern double round ( double );
extern float roundf ( float );
extern long int lround ( double );
extern long int lroundf ( float );
    extern long long int llrint ( double );
    extern long long int llrintf ( float );
    extern long long int llround ( double );
    extern long long int llroundf ( float );
extern double trunc ( double );
extern float truncf ( float );
extern double fmod ( double, double );
extern float fmodf ( float, float );
extern double remainder ( double, double );
extern float remainderf ( float, float );
extern double remquo ( double, double, int * );
extern float remquof ( float, float, int * );
extern double copysign ( double, double );
extern float copysignf ( float, float );
extern double nan( const char * );
extern float nanf( const char * );
extern double nextafter ( double, double );
extern float nextafterf ( float, float );
extern double fdim ( double, double );
extern float fdimf ( float, float );
extern double fmax ( double, double );
extern float fmaxf ( float, float );
extern double fmin ( double, double );
extern float fminf ( float, float );
extern double fma ( double, double, double );
extern float fmaf ( float, float, float );
extern long double acosl(long double);
extern long double asinl(long double);
extern long double atanl(long double);
extern long double atan2l(long double, long double);
extern long double cosl(long double);
extern long double sinl(long double);
extern long double tanl(long double);
extern long double acoshl(long double);
extern long double asinhl(long double);
extern long double atanhl(long double);
extern long double coshl(long double);
extern long double sinhl(long double);
extern long double tanhl(long double);
extern long double expl(long double);
extern long double exp2l(long double);
extern long double expm1l(long double);
extern long double logl(long double);
extern long double log10l(long double);
extern long double log2l(long double);
extern long double log1pl(long double);
extern long double logbl(long double);
extern long double modfl(long double, long double *);
extern long double ldexpl(long double, int);
extern long double frexpl(long double, int *);
extern int ilogbl(long double);
extern long double scalbnl(long double, int);
extern long double scalblnl(long double, long int);
extern long double fabsl(long double);
extern long double cbrtl(long double);
extern long double hypotl(long double, long double);
extern long double powl(long double, long double);
extern long double sqrtl(long double);
extern long double erfl(long double);
extern long double erfcl(long double);
extern long double lgammal(long double);
extern long double tgammal(long double);
extern long double ceill(long double);
extern long double floorl(long double);
extern long double nearbyintl(long double);
extern long double rintl(long double);
extern long int lrintl(long double);
extern long double roundl(long double);
extern long int lroundl(long double);
    extern long long int llrintl(long double);
    extern long long int llroundl(long double);
extern long double truncl(long double);
extern long double fmodl(long double, long double);
extern long double remainderl(long double, long double);
extern long double remquol(long double, long double, int *);
extern long double copysignl(long double, long double);
extern long double nanl(const char *);
extern long double nextafterl(long double, long double);
extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);
extern long double fdiml(long double, long double);
extern long double fmaxl(long double, long double);
extern long double fminl(long double, long double);
extern long double fmal(long double, long double, long double);
extern double __inf( void );
extern float __inff( void );
extern long double __infl( void );
extern float __nan( void );
extern double j0 ( double );
extern double j1 ( double );
extern double jn ( int, double );
extern double y0 ( double );
extern double y1 ( double );
extern double yn ( int, double );
extern double scalb ( double, double );
extern int signgam;
extern long int rinttol ( double );
extern long int roundtol ( double );
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Tp>
    _Tp __cmath_power(_Tp, unsigned int);
  template<typename _Tp>
    inline _Tp
    __pow_helper(_Tp __x, int __n)
    {
      return __n < 0
        ? _Tp(1)/__cmath_power(__x, -__n)
        : __cmath_power(__x, __n);
    }
  inline double
  abs(double __x)
  { return __builtin_fabs(__x); }
  inline float
  abs(float __x)
  { return __builtin_fabsf(__x); }
  inline long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }
  using ::acos;
  inline float
  acos(float __x)
  { return __builtin_acosf(__x); }
  inline long double
  acos(long double __x)
  { return __builtin_acosl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }
  using ::asin;
  inline float
  asin(float __x)
  { return __builtin_asinf(__x); }
  inline long double
  asin(long double __x)
  { return __builtin_asinl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }
  using ::atan;
  inline float
  atan(float __x)
  { return __builtin_atanf(__x); }
  inline long double
  atan(long double __x)
  { return __builtin_atanl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }
  using ::atan2;
  inline float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }
  inline long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }
  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<
    typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value
        && __is_arithmetic<_Up>::__value,
        _Tp>::__type, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }
  using ::ceil;
  inline float
  ceil(float __x)
  { return __builtin_ceilf(__x); }
  inline long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }
  using ::cos;
  inline float
  cos(float __x)
  { return __builtin_cosf(__x); }
  inline long double
  cos(long double __x)
  { return __builtin_cosl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }
  using ::cosh;
  inline float
  cosh(float __x)
  { return __builtin_coshf(__x); }
  inline long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }
  using ::exp;
  inline float
  exp(float __x)
  { return __builtin_expf(__x); }
  inline long double
  exp(long double __x)
  { return __builtin_expl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }
  using ::fabs;
  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }
  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }
  using ::floor;
  inline float
  floor(float __x)
  { return __builtin_floorf(__x); }
  inline long double
  floor(long double __x)
  { return __builtin_floorl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }
  using ::fmod;
  inline float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }
  inline long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }
  using ::frexp;
  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }
  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }
  using ::ldexp;
  inline float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }
  inline long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
  ldexp(_Tp __x, int __exp)
  { return __builtin_ldexp(__x, __exp); }
  using ::log;
  inline float
  log(float __x)
  { return __builtin_logf(__x); }
  inline long double
  log(long double __x)
  { return __builtin_logl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }
  using ::log10;
  inline float
  log10(float __x)
  { return __builtin_log10f(__x); }
  inline long double
  log10(long double __x)
  { return __builtin_log10l(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }
  using ::modf;
  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }
  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }
  using ::pow;
  inline float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }
  inline long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
  template<typename _Tp, typename _Up>
    inline
    typename __gnu_cxx::__promote_2<
    typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value
        && __is_arithmetic<_Up>::__value,
        _Tp>::__type, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }
  using ::sin;
  inline float
  sin(float __x)
  { return __builtin_sinf(__x); }
  inline long double
  sin(long double __x)
  { return __builtin_sinl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }
  using ::sinh;
  inline float
  sinh(float __x)
  { return __builtin_sinhf(__x); }
  inline long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }
  using ::sqrt;
  inline float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }
  inline long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }
  using ::tan;
  inline float
  tan(float __x)
  { return __builtin_tanf(__x); }
  inline long double
  tan(long double __x)
  { return __builtin_tanl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }
  using ::tanh;
  inline float
  tanh(float __x)
  { return __builtin_tanhf(__x); }
  inline long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
        double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    fpclassify(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_fpclassify(1, 2, 4,
      5, 3, __type(__f));
    }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isfinite(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isfinite(__type(__f));
    }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isinf(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isinf(__type(__f));
    }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnan(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnan(__type(__f));
    }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isnormal(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isnormal(__type(__f));
    }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    signbit(_Tp __f)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_signbit(__type(__f));
    }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreater(__type(__f1), __type(__f2));
    }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isgreaterequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isgreaterequal(__type(__f1), __type(__f2));
    }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isless(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isless(__type(__f1), __type(__f2));
    }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessequal(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessequal(__type(__f1), __type(__f2));
    }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    islessgreater(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_islessgreater(__type(__f1), __type(__f2));
    }
  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_arithmetic<_Tp>::__value,
        int>::__type
    isunordered(_Tp __f1, _Tp __f2)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __builtin_isunordered(__type(__f1), __type(__f2));
    }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Tp>
    inline _Tp
    __cmath_power(_Tp __x, unsigned int __n)
    {
      _Tp __y = __n % 2 ? __x : _Tp(1);
      while (__n >>= 1)
        {
          __x = __x * __x;
          if (__n % 2)
            __y = __y * __x;
        }
      return __y;
    }
}
namespace std
{

  using ::double_t;
  using ::float_t;
  using ::acosh;
  using ::acoshf;
  using ::acoshl;
  using ::asinh;
  using ::asinhf;
  using ::asinhl;
  using ::atanh;
  using ::atanhf;
  using ::atanhl;
  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;
  using ::copysign;
  using ::copysignf;
  using ::copysignl;
  using ::erf;
  using ::erff;
  using ::erfl;
  using ::erfc;
  using ::erfcf;
  using ::erfcl;
  using ::exp2;
  using ::exp2f;
  using ::exp2l;
  using ::expm1;
  using ::expm1f;
  using ::expm1l;
  using ::fdim;
  using ::fdimf;
  using ::fdiml;
  using ::fma;
  using ::fmaf;
  using ::fmal;
  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;
  using ::fmin;
  using ::fminf;
  using ::fminl;
  using ::hypot;
  using ::hypotf;
  using ::hypotl;
  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;
  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;
  using ::llrint;
  using ::llrintf;
  using ::llrintl;
  using ::llround;
  using ::llroundf;
  using ::llroundl;
  using ::log1p;
  using ::log1pf;
  using ::log1pl;
  using ::log2;
  using ::log2f;
  using ::log2l;
  using ::logb;
  using ::logbf;
  using ::logbl;
  using ::lrint;
  using ::lrintf;
  using ::lrintl;
  using ::lround;
  using ::lroundf;
  using ::lroundl;
  using ::nan;
  using ::nanf;
  using ::nanl;
  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;
  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;
  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;
  using ::remainder;
  using ::remainderf;
  using ::remainderl;
  using ::remquo;
  using ::remquof;
  using ::remquol;
  using ::rint;
  using ::rintf;
  using ::rintl;
  using ::round;
  using ::roundf;
  using ::roundl;
  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;
  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;
  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;
  using ::trunc;
  using ::truncf;
  using ::truncl;
  using std::signbit;
  using std::fpclassify;
  using std::isfinite;
  using std::isinf;
  using std::isnan;
  using std::isnormal;
  using std::isgreater;
  using std::isgreaterequal;
  using std::isless;
  using std::islessequal;
  using std::islessgreater;
  using std::isunordered;
  using std::acos;
  inline float
  acosh(float __x)
  { return __builtin_acoshf(__x); }
  inline long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    acosh(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return acosh(__type(__x));
    }
  using std::asin;
  inline float
  asinh(float __x)
  { return __builtin_asinhf(__x); }
  inline long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    asinh(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return asinh(__type(__x));
    }
  using std::atan;
  using std::atan2;
  inline float
  atanh(float __x)
  { return __builtin_atanhf(__x); }
  inline long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    atanh(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return atanh(__type(__x));
    }
  inline float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }
  inline long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    cbrt(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return cbrt(__type(__x));
    }
  using std::ceil;
  inline float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }
  inline long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }
  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }
  using std::cos;
  using std::cosh;
  inline float
  erf(float __x)
  { return __builtin_erff(__x); }
  inline long double
  erf(long double __x)
  { return __builtin_erfl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    erf(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return erf(__type(__x));
    }
  inline float
  erfc(float __x)
  { return __builtin_erfcf(__x); }
  inline long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    erfc(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return erfc(__type(__x));
    }
  using std::exp;
  inline float
  exp2(float __x)
  { return __builtin_exp2f(__x); }
  inline long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    exp2(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return exp2(__type(__x));
    }
  inline float
  expm1(float __x)
  { return __builtin_expm1f(__x); }
  inline long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    expm1(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return expm1(__type(__x));
    }
  using std::fabs;
  inline float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }
  inline long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }
  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }
  using std::floor;
  inline float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }
  inline long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }
  template<typename _Tp, typename _Up, typename _Vp>
    inline typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }
  inline float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }
  inline long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }
  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }
  inline float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }
  inline long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }
  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }
  using std::fmod;
  using std::frexp;
  inline float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }
  inline long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }
  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }
  inline int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }
  inline int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }
  template<typename _Tp>
    inline int
    ilogb(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return ilogb(__type(__x));
    }
  using std::ldexp;
  inline float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }
  inline long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    lgamma(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return lgamma(__type(__x));
    }
  inline long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }
  inline long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }
  template<typename _Tp>
    inline long long
    llrint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return llrint(__type(__x));
    }
  inline long long
  llround(float __x)
  { return __builtin_llroundf(__x); }
  inline long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }
  template<typename _Tp>
    inline long long
    llround(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return llround(__type(__x));
    }
  using std::log;
  using std::log10;
  inline float
  log1p(float __x)
  { return __builtin_log1pf(__x); }
  inline long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    log1p(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return log1p(__type(__x));
    }
  inline float
  log2(float __x)
  { return __builtin_log2f(__x); }
  inline long double
  log2(long double __x)
  { return __builtin_log2l(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    log2(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return log2(__type(__x));
    }
  inline float
  logb(float __x)
  { return __builtin_logbf(__x); }
  inline long double
  logb(long double __x)
  { return __builtin_logbl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    logb(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return logb(__type(__x));
    }
  inline long
  lrint(float __x)
  { return __builtin_lrintf(__x); }
  inline long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }
  template<typename _Tp>
    inline long
    lrint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return lrint(__type(__x));
    }
  inline long
  lround(float __x)
  { return __builtin_lroundf(__x); }
  inline long
  lround(long double __x)
  { return __builtin_lroundl(__x); }
  template<typename _Tp>
    inline long
    lround(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return lround(__type(__x));
    }
  inline float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }
  inline long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    nearbyint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return nearbyint(__type(__x));
    }
  inline float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }
  inline long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }
  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }
  inline float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }
  inline long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    nexttoward(_Tp __x, long double __y)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return nexttoward(__type(__x), __y);
    }
  inline float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }
  inline long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }
  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }
  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }
  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }
  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }
  inline float
  rint(float __x)
  { return __builtin_rintf(__x); }
  inline long double
  rint(long double __x)
  { return __builtin_rintl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    rint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return rint(__type(__x));
    }
  inline float
  round(float __x)
  { return __builtin_roundf(__x); }
  inline long double
  round(long double __x)
  { return __builtin_roundl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    round(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return round(__type(__x));
    }
  inline float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }
  inline long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    scalbln(_Tp __x, long __ex)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return scalbln(__type(__x), __ex);
    }
  inline float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }
  inline long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    scalbn(_Tp __x, int __ex)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return scalbn(__type(__x), __ex);
    }
  using std::sin;
  using std::sinh;
  using std::sqrt;
  using std::tan;
  using std::tanh;
  inline float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }
  inline long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    tgamma(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return tgamma(__type(__x));
    }
  inline float
  trunc(float __x)
  { return __builtin_truncf(__x); }
  inline long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    trunc(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return trunc(__type(__x));
    }

}
       
       
       
       
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };
  enum float_denorm_style
  {
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
  };
  struct __numeric_limits_base
  {
    static const bool is_specialized = false;
    static const int digits = 0;
    static const int digits10 = 0;
    static const int max_digits10 = 0;
    static const bool is_signed = false;
    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 0;
    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;
    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;
    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
  };
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {
      static _Tp min() throw() { return static_cast<_Tp>(0); }
      static _Tp max() throw() { return static_cast<_Tp>(0); }
      static _Tp lowest() throw() { return static_cast<_Tp>(0); }
      static _Tp epsilon() throw() { return static_cast<_Tp>(0); }
      static _Tp round_error() throw() { return static_cast<_Tp>(0); }
      static _Tp infinity() throw() { return static_cast<_Tp>(0); }
      static _Tp quiet_NaN() throw() { return static_cast<_Tp>(0); }
      static _Tp signaling_NaN() throw() { return static_cast<_Tp>(0); }
      static _Tp denorm_min() throw() { return static_cast<_Tp>(0); }
    };
  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };
  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };
  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;
      static bool min() throw()
      { return false; }
      static bool max() throw()
      { return true; }
      static bool lowest() throw()
      { return min(); }
      static const int digits = 1;
      static const int digits10 = 0;
      static const int max_digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static bool epsilon() throw()
      { return false; }
      static bool round_error() throw()
      { return false; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static bool infinity() throw()
      { return false; }
      static bool quiet_NaN() throw()
      { return false; }
      static bool signaling_NaN() throw()
      { return false; }
      static bool denorm_min() throw()
      { return false; }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;
      static char min() throw()
      { return (((char)(-1) < 0) ? (char)1 << (sizeof(char) * 8 - ((char)(-1) < 0)) : (char)0); }
      static char max() throw()
      { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }
      static char lowest() throw()
      { return min(); }
      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643 / 2136);
      static const int max_digits10 = 0;
      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char epsilon() throw()
      { return 0; }
      static char round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static char infinity() throw()
      { return char(); }
      static char quiet_NaN() throw()
      { return char(); }
      static char signaling_NaN() throw()
      { return char(); }
      static char denorm_min() throw()
      { return static_cast<char>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;
      static signed char min() throw()
      { return -127 - 1; }
      static signed char max() throw()
      { return 127; }
      static signed char lowest() throw()
      { return min(); }
      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10 = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643 / 2136);
      static const int max_digits10 = 0;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static signed char epsilon() throw()
      { return 0; }
      static signed char round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static signed char infinity() throw()
      { return static_cast<signed char>(0); }
      static signed char quiet_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char signaling_NaN() throw()
      { return static_cast<signed char>(0); }
      static signed char denorm_min() throw()
      { return static_cast<signed char>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;
      static unsigned char min() throw()
      { return 0; }
      static unsigned char max() throw()
      { return 127 * 2U + 1; }
      static unsigned char lowest() throw()
      { return min(); }
      static const int digits = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643 / 2136);
      static const int max_digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned char epsilon() throw()
      { return 0; }
      static unsigned char round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static unsigned char infinity() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char quiet_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char signaling_NaN() throw()
      { return static_cast<unsigned char>(0); }
      static unsigned char denorm_min() throw()
      { return static_cast<unsigned char>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;
      static wchar_t min() throw()
      { return (((wchar_t)(-1) < 0) ? (wchar_t)1 << (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) : (wchar_t)0); }
      static wchar_t max() throw()
      { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }
      static wchar_t lowest() throw()
      { return min(); }
      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10 = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643 / 2136);
      static const int max_digits10 = 0;
      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static wchar_t epsilon() throw()
      { return 0; }
      static wchar_t round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static wchar_t infinity() throw()
      { return wchar_t(); }
      static wchar_t quiet_NaN() throw()
      { return wchar_t(); }
      static wchar_t signaling_NaN() throw()
      { return wchar_t(); }
      static wchar_t denorm_min() throw()
      { return wchar_t(); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<char16_t>
    {
      static const bool is_specialized = true;
      static char16_t min() throw()
      { return (((char16_t)(-1) < 0) ? (char16_t)1 << (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) : (char16_t)0); }
      static char16_t max() throw()
      { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }
      static char16_t lowest() throw()
      { return min(); }
      static const int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static const int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643 / 2136);
      static const int max_digits10 = 0;
      static const bool is_signed = ((char16_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char16_t epsilon() throw()
      { return 0; }
      static char16_t round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static char16_t infinity() throw()
      { return char16_t(); }
      static char16_t quiet_NaN() throw()
      { return char16_t(); }
      static char16_t signaling_NaN() throw()
      { return char16_t(); }
      static char16_t denorm_min() throw()
      { return char16_t(); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<char32_t>
    {
      static const bool is_specialized = true;
      static char32_t min() throw()
      { return (((char32_t)(-1) < 0) ? (char32_t)1 << (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) : (char32_t)0); }
      static char32_t max() throw()
      { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }
      static char32_t lowest() throw()
      { return min(); }
      static const int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static const int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643 / 2136);
      static const int max_digits10 = 0;
      static const bool is_signed = ((char32_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static char32_t epsilon() throw()
      { return 0; }
      static char32_t round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static char32_t infinity() throw()
      { return char32_t(); }
      static char32_t quiet_NaN() throw()
      { return char32_t(); }
      static char32_t signaling_NaN() throw()
      { return char32_t(); }
      static char32_t denorm_min() throw()
      { return char32_t(); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;
      static short min() throw()
      { return -32767 - 1; }
      static short max() throw()
      { return 32767; }
      static short lowest() throw()
      { return min(); }
      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643 / 2136);
      static const int max_digits10 = 0;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static short epsilon() throw()
      { return 0; }
      static short round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static short infinity() throw()
      { return short(); }
      static short quiet_NaN() throw()
      { return short(); }
      static short signaling_NaN() throw()
      { return short(); }
      static short denorm_min() throw()
      { return short(); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;
      static unsigned short min() throw()
      { return 0; }
      static unsigned short max() throw()
      { return 32767 * 2U + 1; }
      static unsigned short lowest() throw()
      { return min(); }
      static const int digits = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643 / 2136);
      static const int max_digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned short epsilon() throw()
      { return 0; }
      static unsigned short round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static unsigned short infinity() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short quiet_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short signaling_NaN() throw()
      { return static_cast<unsigned short>(0); }
      static unsigned short denorm_min() throw()
      { return static_cast<unsigned short>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;
      static int min() throw()
      { return -2147483647 - 1; }
      static int max() throw()
      { return 2147483647; }
      static int lowest() throw()
      { return min(); }
      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643 / 2136);
      static const int max_digits10 = 0;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static int epsilon() throw()
      { return 0; }
      static int round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static int infinity() throw()
      { return static_cast<int>(0); }
      static int quiet_NaN() throw()
      { return static_cast<int>(0); }
      static int signaling_NaN() throw()
      { return static_cast<int>(0); }
      static int denorm_min() throw()
      { return static_cast<int>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;
      static unsigned int min() throw()
      { return 0; }
      static unsigned int max() throw()
      { return 2147483647 * 2U + 1; }
      static unsigned int lowest() throw()
      { return min(); }
      static const int digits = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643 / 2136);
      static const int max_digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned int epsilon() throw()
      { return 0; }
      static unsigned int round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static unsigned int infinity() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int quiet_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int signaling_NaN() throw()
      { return static_cast<unsigned int>(0); }
      static unsigned int denorm_min() throw()
      { return static_cast<unsigned int>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;
      static long min() throw()
      { return -9223372036854775807L - 1; }
      static long max() throw()
      { return 9223372036854775807L; }
      static long lowest() throw()
      { return min(); }
      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643 / 2136);
      static const int max_digits10 = 0;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long epsilon() throw()
      { return 0; }
      static long round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static long infinity() throw()
      { return static_cast<long>(0); }
      static long quiet_NaN() throw()
      { return static_cast<long>(0); }
      static long signaling_NaN() throw()
      { return static_cast<long>(0); }
      static long denorm_min() throw()
      { return static_cast<long>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;
      static unsigned long min() throw()
      { return 0; }
      static unsigned long max() throw()
      { return 9223372036854775807L * 2UL + 1; }
      static unsigned long lowest() throw()
      { return min(); }
      static const int digits = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643 / 2136);
      static const int max_digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long epsilon() throw()
      { return 0; }
      static unsigned long round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static unsigned long infinity() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long quiet_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long signaling_NaN() throw()
      { return static_cast<unsigned long>(0); }
      static unsigned long denorm_min() throw()
      { return static_cast<unsigned long>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;
      static long long min() throw()
      { return -9223372036854775807LL - 1; }
      static long long max() throw()
      { return 9223372036854775807LL; }
      static long long lowest() throw()
      { return min(); }
      static const int digits = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10 = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643 / 2136);
      static const int max_digits10 = 0;
      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static long long epsilon() throw()
      { return 0; }
      static long long round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static long long infinity() throw()
      { return static_cast<long long>(0); }
      static long long quiet_NaN() throw()
      { return static_cast<long long>(0); }
      static long long signaling_NaN() throw()
      { return static_cast<long long>(0); }
      static long long denorm_min() throw()
      { return static_cast<long long>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;
      static unsigned long long min() throw()
      { return 0; }
      static unsigned long long max() throw()
      { return 9223372036854775807LL * 2ULL + 1; }
      static unsigned long long lowest() throw()
      { return min(); }
      static const int digits = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10 = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643 / 2136);
      static const int max_digits10 = 0;
      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;
      static unsigned long long epsilon() throw()
      { return 0; }
      static unsigned long long round_error() throw()
      { return 0; }
      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;
      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm = denorm_absent;
      static const bool has_denorm_loss = false;
      static unsigned long long infinity() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long quiet_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long signaling_NaN() throw()
      { return static_cast<unsigned long long>(0); }
      static unsigned long long denorm_min() throw()
      { return static_cast<unsigned long long>(0); }
      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;
      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_toward_zero;
    };
  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;
      static float min() throw()
      { return 1.17549435082228750797e-38F; }
      static float max() throw()
      { return 3.40282346638528859812e+38F; }
      static float lowest() throw()
      { return -3.40282346638528859812e+38F; }
      static const int digits = 24;
      static const int digits10 = 6;
      static const int max_digits10
  = (2 + (24) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static float epsilon() throw()
      { return 1.19209289550781250000e-7F; }
      static float round_error() throw()
      { return 0.5F; }
      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;
      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;
      static float infinity() throw()
      { return __builtin_huge_valf (); }
      static float quiet_NaN() throw()
      { return __builtin_nanf (""); }
      static float signaling_NaN() throw()
      { return __builtin_nansf (""); }
      static float denorm_min() throw()
      { return 1.40129846432481707092e-45F; }
      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };
  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;
      static double min() throw()
      { return ((double)2.22507385850720138309e-308L); }
      static double max() throw()
      { return ((double)1.79769313486231570815e+308L); }
      static double lowest() throw()
      { return -((double)1.79769313486231570815e+308L); }
      static const int digits = 53;
      static const int digits10 = 15;
      static const int max_digits10
  = (2 + (53) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static double epsilon() throw()
      { return ((double)2.22044604925031308085e-16L); }
      static double round_error() throw()
      { return 0.5; }
      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;
      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss = false;
      static double infinity() throw()
      { return __builtin_huge_val(); }
      static double quiet_NaN() throw()
      { return __builtin_nan (""); }
      static double signaling_NaN() throw()
      { return __builtin_nans (""); }
      static double denorm_min() throw()
      { return ((double)4.94065645841246544177e-324L); }
      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };
  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;
      static long double min() throw()
      { return 3.36210314311209350626e-4932L; }
      static long double max() throw()
      { return 1.18973149535723176502e+4932L; }
      static long double lowest() throw()
      { return -1.18973149535723176502e+4932L; }
      static const int digits = 64;
      static const int digits10 = 18;
      static const int max_digits10
  = (2 + (64) * 643 / 2136);
      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;
      static long double epsilon() throw()
      { return 1.08420217248550443401e-19L; }
      static long double round_error() throw()
      { return 0.5L; }
      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;
      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;
      static long double infinity() throw()
      { return __builtin_huge_vall (); }
      static long double quiet_NaN() throw()
      { return __builtin_nanl (""); }
      static long double signaling_NaN() throw()
      { return __builtin_nansl (""); }
      static long double denorm_min() throw()
      { return 3.64519953188247460253e-4951L; }
      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;
      static const bool traps = false;
      static const bool tinyness_before = false;
      static const float_round_style round_style = round_to_nearest;
    };
}
namespace std
{
  template<typename _RealType, size_t __bits,
    typename _UniformRandomNumberGenerator>
    _RealType
    generate_canonical(_UniformRandomNumberGenerator& __g);
  namespace __detail
  {
    template<typename _UIntType, size_t __w,
      bool = __w < static_cast<size_t>
     (std::numeric_limits<_UIntType>::digits)>
      struct _Shift
      { static const _UIntType __value = 0; };
    template<typename _UIntType, size_t __w>
      struct _Shift<_UIntType, __w, true>
      { static const _UIntType __value = _UIntType(1) << __w; };
    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c, bool>
      struct _Mod;
    template<typename _Tp, _Tp __m, _Tp __a = 1, _Tp __c = 0>
      inline _Tp
      __mod(_Tp __x)
      { return _Mod<_Tp, __m, __a, __c, __m == 0>::__calc(__x); }
    template<typename _Engine, typename _DInputType>
      struct _Adaptor
      {
      public:
 _Adaptor(_Engine& __g)
 : _M_g(__g) { }
 _DInputType
 min() const
 { return _DInputType(0); }
 _DInputType
 max() const
 { return _DInputType(1); }
 _DInputType
 operator()()
 {
   return std::generate_canonical<_DInputType,
                             std::numeric_limits<_DInputType>::digits,
                             _Engine>(_M_g);
 }
      private:
 _Engine& _M_g;
      };
  }
  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    class linear_congruential_engine
    {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
      "substituting _UIntType not an unsigned integral type");
      static_assert(__m == 0u || (__a < __m && __c < __m),
      "template argument substituting __m out of bounds");
    public:
      typedef _UIntType result_type;
      static const result_type multiplier = __a;
      static const result_type increment = __c;
      static const result_type modulus = __m;
      static const result_type default_seed = 1u;
      explicit
      linear_congruential_engine(result_type __s = default_seed)
      { seed(__s); }
      template<typename _Sseq, typename = typename
 std::enable_if<!std::is_same<_Sseq, linear_congruential_engine>::value>
        ::type>
        explicit
        linear_congruential_engine(_Sseq& __q)
        { seed(__q); }
      void
      seed(result_type __s = default_seed);
      template<typename _Sseq>
        typename std::enable_if<std::is_class<_Sseq>::value>::type
        seed(_Sseq& __q);
      result_type
      min() const
      { return __c == 0u ? 1u : 0u; }
      result_type
      max() const
      { return __m - 1u; }
      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }
      result_type
      operator()()
      {
 _M_x = __detail::__mod<_UIntType, __m, __a, __c>(_M_x);
 return _M_x;
      }
      friend bool
      operator==(const linear_congruential_engine& __lhs,
   const linear_congruential_engine& __rhs)
      { return __lhs._M_x == __rhs._M_x; }
      template<typename _UIntType1, _UIntType1 __a1, _UIntType1 __c1,
        _UIntType1 __m1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::linear_congruential_engine<_UIntType1,
     __a1, __c1, __m1>&);
      template<typename _UIntType1, _UIntType1 __a1, _UIntType1 __c1,
        _UIntType1 __m1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::linear_congruential_engine<_UIntType1, __a1,
     __c1, __m1>&);
    private:
      _UIntType _M_x;
    };
  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    inline bool
    operator!=(const std::linear_congruential_engine<_UIntType, __a,
        __c, __m>& __lhs,
        const std::linear_congruential_engine<_UIntType, __a,
        __c, __m>& __rhs)
    { return !(__lhs == __rhs); }
  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t,
    _UIntType __c, size_t __l, _UIntType __f>
    class mersenne_twister_engine
    {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
      "substituting _UIntType not an unsigned integral type");
      static_assert(1u <= __m && __m <= __n,
      "template argument substituting __m out of bounds");
      static_assert(__r <= __w, "template argument substituting "
      "__r out of bound");
      static_assert(__u <= __w, "template argument substituting "
      "__u out of bound");
      static_assert(__s <= __w, "template argument substituting "
      "__s out of bound");
      static_assert(__t <= __w, "template argument substituting "
      "__t out of bound");
      static_assert(__l <= __w, "template argument substituting "
      "__l out of bound");
      static_assert(__w <= std::numeric_limits<_UIntType>::digits,
      "template argument substituting __w out of bound");
      static_assert(__a <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __a out of bound");
      static_assert(__b <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __b out of bound");
      static_assert(__c <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __c out of bound");
      static_assert(__d <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __d out of bound");
      static_assert(__f <= (__detail::_Shift<_UIntType, __w>::__value - 1),
      "template argument substituting __f out of bound");
    public:
      typedef _UIntType result_type;
      static const size_t word_size = __w;
      static const size_t state_size = __n;
      static const size_t shift_size = __m;
      static const size_t mask_bits = __r;
      static const result_type xor_mask = __a;
      static const size_t tempering_u = __u;
      static const result_type tempering_d = __d;
      static const size_t tempering_s = __s;
      static const result_type tempering_b = __b;
      static const size_t tempering_t = __t;
      static const result_type tempering_c = __c;
      static const size_t tempering_l = __l;
      static const result_type initialization_multiplier = __f;
      static const result_type default_seed = 5489u;
      explicit
      mersenne_twister_engine(result_type __sd = default_seed)
      { seed(__sd); }
      template<typename _Sseq, typename = typename
        std::enable_if<!std::is_same<_Sseq, mersenne_twister_engine>::value>
        ::type>
        explicit
        mersenne_twister_engine(_Sseq& __q)
        { seed(__q); }
      void
      seed(result_type __sd = default_seed);
      template<typename _Sseq>
 typename std::enable_if<std::is_class<_Sseq>::value>::type
        seed(_Sseq& __q);
      result_type
      min() const
      { return 0; };
      result_type
      max() const
      { return __detail::_Shift<_UIntType, __w>::__value - 1; }
      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }
      result_type
      operator()();
      friend bool
      operator==(const mersenne_twister_engine& __lhs,
   const mersenne_twister_engine& __rhs)
      { return std::equal(__lhs._M_x, __lhs._M_x + state_size, __rhs._M_x); }
      template<typename _UIntType1,
        size_t __w1, size_t __n1,
        size_t __m1, size_t __r1,
        _UIntType1 __a1, size_t __u1,
        _UIntType1 __d1, size_t __s1,
        _UIntType1 __b1, size_t __t1,
        _UIntType1 __c1, size_t __l1, _UIntType1 __f1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::mersenne_twister_engine<_UIntType1, __w1, __n1,
     __m1, __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1,
     __l1, __f1>&);
      template<typename _UIntType1,
        size_t __w1, size_t __n1,
        size_t __m1, size_t __r1,
        _UIntType1 __a1, size_t __u1,
        _UIntType1 __d1, size_t __s1,
        _UIntType1 __b1, size_t __t1,
        _UIntType1 __c1, size_t __l1, _UIntType1 __f1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::mersenne_twister_engine<_UIntType1, __w1, __n1, __m1,
     __r1, __a1, __u1, __d1, __s1, __b1, __t1, __c1,
     __l1, __f1>&);
    private:
      _UIntType _M_x[state_size];
      size_t _M_p;
    };
  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t,
    _UIntType __c, size_t __l, _UIntType __f>
    inline bool
    operator!=(const std::mersenne_twister_engine<_UIntType, __w, __n, __m,
        __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __lhs,
        const std::mersenne_twister_engine<_UIntType, __w, __n, __m,
        __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __rhs)
    { return !(__lhs == __rhs); }
  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    class subtract_with_carry_engine
    {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
      "substituting _UIntType not an unsigned integral type");
      static_assert(0u < __s && __s < __r,
      "template argument substituting __s out of bounds");
      static_assert(0u < __w && __w <= std::numeric_limits<_UIntType>::digits,
      "template argument substituting __w out of bounds");
    public:
      typedef _UIntType result_type;
      static const size_t word_size = __w;
      static const size_t short_lag = __s;
      static const size_t long_lag = __r;
      static const result_type default_seed = 19780503u;
      explicit
      subtract_with_carry_engine(result_type __sd = default_seed)
      { seed(__sd); }
      template<typename _Sseq, typename = typename
        std::enable_if<!std::is_same<_Sseq, subtract_with_carry_engine>::value>
        ::type>
        explicit
        subtract_with_carry_engine(_Sseq& __q)
        { seed(__q); }
      void
      seed(result_type __sd = default_seed);
      template<typename _Sseq>
 typename std::enable_if<std::is_class<_Sseq>::value>::type
        seed(_Sseq& __q);
      result_type
      min() const
      { return 0; }
      result_type
      max() const
      { return __detail::_Shift<_UIntType, __w>::__value - 1; }
      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }
      result_type
      operator()();
      friend bool
      operator==(const subtract_with_carry_engine& __lhs,
   const subtract_with_carry_engine& __rhs)
      { return std::equal(__lhs._M_x, __lhs._M_x + long_lag, __rhs._M_x); }
      template<typename _UIntType1, size_t __w1, size_t __s1, size_t __r1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::subtract_with_carry_engine<_UIntType1, __w1,
     __s1, __r1>&);
      template<typename _UIntType1, size_t __w1, size_t __s1, size_t __r1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::subtract_with_carry_engine<_UIntType1, __w1,
     __s1, __r1>&);
    private:
      _UIntType _M_x[long_lag];
      _UIntType _M_carry;
      size_t _M_p;
    };
  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    inline bool
    operator!=(const std::subtract_with_carry_engine<_UIntType, __w,
        __s, __r>& __lhs,
        const std::subtract_with_carry_engine<_UIntType, __w,
        __s, __r>& __rhs)
    { return !(__lhs == __rhs); }
  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    class discard_block_engine
    {
      static_assert(1 <= __r && __r <= __p,
      "template argument substituting __r out of bounds");
    public:
      typedef typename _RandomNumberEngine::result_type result_type;
      static const size_t block_size = __p;
      static const size_t used_block = __r;
      discard_block_engine()
      : _M_b(), _M_n(0) { }
      explicit
      discard_block_engine(const _RandomNumberEngine& __rne)
      : _M_b(__rne), _M_n(0) { }
      explicit
      discard_block_engine(_RandomNumberEngine&& __rne)
      : _M_b(std::move(__rne)), _M_n(0) { }
      explicit
      discard_block_engine(result_type __s)
      : _M_b(__s), _M_n(0) { }
      template<typename _Sseq, typename = typename
 std::enable_if<!std::is_same<_Sseq, discard_block_engine>::value
         && !std::is_same<_Sseq, _RandomNumberEngine>::value>
        ::type>
        explicit
        discard_block_engine(_Sseq& __q)
 : _M_b(__q), _M_n(0)
        { }
      void
      seed()
      {
 _M_b.seed();
 _M_n = 0;
      }
      void
      seed(result_type __s)
      {
 _M_b.seed(__s);
 _M_n = 0;
      }
      template<typename _Sseq>
        void
        seed(_Sseq& __q)
        {
   _M_b.seed(__q);
   _M_n = 0;
 }
      const _RandomNumberEngine&
      base() const
      { return _M_b; }
      result_type
      min() const
      { return _M_b.min(); }
      result_type
      max() const
      { return _M_b.max(); }
      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }
      result_type
      operator()();
      friend bool
      operator==(const discard_block_engine& __lhs,
   const discard_block_engine& __rhs)
      { return __lhs._M_b == __rhs._M_b && __lhs._M_n == __rhs._M_n; }
      template<typename _RandomNumberEngine1, size_t __p1, size_t __r1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::discard_block_engine<_RandomNumberEngine1,
     __p1, __r1>&);
      template<typename _RandomNumberEngine1, size_t __p1, size_t __r1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::discard_block_engine<_RandomNumberEngine1,
     __p1, __r1>&);
    private:
      _RandomNumberEngine _M_b;
      size_t _M_n;
    };
  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    inline bool
    operator!=(const std::discard_block_engine<_RandomNumberEngine, __p,
        __r>& __lhs,
        const std::discard_block_engine<_RandomNumberEngine, __p,
        __r>& __rhs)
    { return !(__lhs == __rhs); }
  template<typename _RandomNumberEngine, size_t __w, typename _UIntType>
    class independent_bits_engine
    {
      static_assert(std::is_unsigned<_UIntType>::value, "template argument "
      "substituting _UIntType not an unsigned integral type");
      static_assert(0u < __w && __w <= std::numeric_limits<_UIntType>::digits,
      "template argument substituting __w out of bounds");
    public:
      typedef _UIntType result_type;
      independent_bits_engine()
      : _M_b() { }
      explicit
      independent_bits_engine(const _RandomNumberEngine& __rne)
      : _M_b(__rne) { }
      explicit
      independent_bits_engine(_RandomNumberEngine&& __rne)
      : _M_b(std::move(__rne)) { }
      explicit
      independent_bits_engine(result_type __s)
      : _M_b(__s) { }
      template<typename _Sseq, typename = typename
 std::enable_if<!std::is_same<_Sseq, independent_bits_engine>::value
         && !std::is_same<_Sseq, _RandomNumberEngine>::value>
               ::type>
        explicit
        independent_bits_engine(_Sseq& __q)
        : _M_b(__q)
        { }
      void
      seed()
      { _M_b.seed(); }
      void
      seed(result_type __s)
      { _M_b.seed(__s); }
      template<typename _Sseq>
        void
        seed(_Sseq& __q)
        { _M_b.seed(__q); }
      const _RandomNumberEngine&
      base() const
      { return _M_b; }
      result_type
      min() const
      { return 0U; }
      result_type
      max() const
      { return __detail::_Shift<_UIntType, __w>::__value - 1; }
      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }
      result_type
      operator()();
      friend bool
      operator==(const independent_bits_engine& __lhs,
   const independent_bits_engine& __rhs)
      { return __lhs._M_b == __rhs._M_b; }
      template<typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>& __is,
     std::independent_bits_engine<_RandomNumberEngine,
     __w, _UIntType>& __x)
 {
   __is >> __x._M_b;
   return __is;
 }
    private:
      _RandomNumberEngine _M_b;
    };
  template<typename _RandomNumberEngine, size_t __w, typename _UIntType>
    inline bool
    operator!=(const std::independent_bits_engine<_RandomNumberEngine, __w,
        _UIntType>& __lhs,
        const std::independent_bits_engine<_RandomNumberEngine, __w,
        _UIntType>& __rhs)
    { return !(__lhs == __rhs); }
  template<typename _RandomNumberEngine, size_t __w, typename _UIntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const std::independent_bits_engine<_RandomNumberEngine,
        __w, _UIntType>& __x)
    {
      __os << __x.base();
      return __os;
    }
  template<typename _RandomNumberEngine, size_t __k>
    class shuffle_order_engine
    {
      static_assert(1u <= __k, "template argument substituting "
      "__k out of bound");
    public:
      typedef typename _RandomNumberEngine::result_type result_type;
      static const size_t table_size = __k;
      shuffle_order_engine()
      : _M_b()
      { _M_initialize(); }
      explicit
      shuffle_order_engine(const _RandomNumberEngine& __rne)
      : _M_b(__rne)
      { _M_initialize(); }
      explicit
      shuffle_order_engine(_RandomNumberEngine&& __rne)
      : _M_b(std::move(__rne))
      { _M_initialize(); }
      explicit
      shuffle_order_engine(result_type __s)
      : _M_b(__s)
      { _M_initialize(); }
      template<typename _Sseq, typename = typename
 std::enable_if<!std::is_same<_Sseq, shuffle_order_engine>::value
         && !std::is_same<_Sseq, _RandomNumberEngine>::value>
        ::type>
        explicit
        shuffle_order_engine(_Sseq& __q)
        : _M_b(__q)
        { _M_initialize(); }
      void
      seed()
      {
 _M_b.seed();
 _M_initialize();
      }
      void
      seed(result_type __s)
      {
 _M_b.seed(__s);
 _M_initialize();
      }
      template<typename _Sseq>
        void
        seed(_Sseq& __q)
        {
   _M_b.seed(__q);
   _M_initialize();
 }
      const _RandomNumberEngine&
      base() const
      { return _M_b; }
      result_type
      min() const
      { return _M_b.min(); }
      result_type
      max() const
      { return _M_b.max(); }
      void
      discard(unsigned long long __z)
      {
 for (; __z != 0ULL; --__z)
   (*this)();
      }
      result_type
      operator()();
      friend bool
      operator==(const shuffle_order_engine& __lhs,
   const shuffle_order_engine& __rhs)
      { return __lhs._M_b == __rhs._M_b; }
      template<typename _RandomNumberEngine1, size_t __k1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::shuffle_order_engine<_RandomNumberEngine1,
     __k1>&);
      template<typename _RandomNumberEngine1, size_t __k1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::shuffle_order_engine<_RandomNumberEngine1, __k1>&);
    private:
      void _M_initialize()
      {
 for (size_t __i = 0; __i < __k; ++__i)
   _M_v[__i] = _M_b();
 _M_y = _M_b();
      }
      _RandomNumberEngine _M_b;
      result_type _M_v[__k];
      result_type _M_y;
    };
  template<typename _RandomNumberEngine, size_t __k>
    inline bool
    operator!=(const std::shuffle_order_engine<_RandomNumberEngine,
        __k>& __lhs,
        const std::shuffle_order_engine<_RandomNumberEngine,
        __k>& __rhs)
    { return !(__lhs == __rhs); }
  typedef linear_congruential_engine<uint_fast32_t, 16807UL, 0UL, 2147483647UL>
  minstd_rand0;
  typedef linear_congruential_engine<uint_fast32_t, 48271UL, 0UL, 2147483647UL>
  minstd_rand;
  typedef mersenne_twister_engine<
    uint_fast32_t,
    32, 624, 397, 31,
    0x9908b0dfUL, 11,
    0xffffffffUL, 7,
    0x9d2c5680UL, 15,
    0xefc60000UL, 18, 1812433253UL> mt19937;
  typedef mersenne_twister_engine<
    uint_fast64_t,
    64, 312, 156, 31,
    0xb5026f5aa96619e9ULL, 29,
    0x5555555555555555ULL, 17,
    0x71d67fffeda60000ULL, 37,
    0xfff7eee000000000ULL, 43,
    6364136223846793005ULL> mt19937_64;
  typedef subtract_with_carry_engine<uint_fast32_t, 24, 10, 24>
    ranlux24_base;
  typedef subtract_with_carry_engine<uint_fast64_t, 48, 5, 12>
    ranlux48_base;
  typedef discard_block_engine<ranlux24_base, 223, 23> ranlux24;
  typedef discard_block_engine<ranlux48_base, 389, 11> ranlux48;
  typedef shuffle_order_engine<minstd_rand0, 256> knuth_b;
  typedef minstd_rand0 default_random_engine;
  class random_device
  {
  public:
    typedef unsigned int result_type;
    explicit
    random_device(const std::string& __token = "/dev/urandom")
    {
      if ((__token != "/dev/urandom" && __token != "/dev/random")
   || !(_M_file = std::fopen(__token.c_str(), "rb")))
 std::__throw_runtime_error(("random_device::" "random_device(const std::string&)"));
    }
    ~random_device()
    { std::fclose(_M_file); }
    result_type
    min() const
    { return std::numeric_limits<result_type>::min(); }
    result_type
    max() const
    { return std::numeric_limits<result_type>::max(); }
    double
    entropy() const
    { return 0.0; }
    result_type
    operator()()
    {
      result_type __ret;
      std::fread(reinterpret_cast<void*>(&__ret), sizeof(result_type),
   1, _M_file);
      return __ret;
    }
    random_device(const random_device&) = delete;
    void operator=(const random_device&) = delete;
  private:
    FILE* _M_file;
  };
  template<typename _IntType = int>
    class uniform_int_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");
    public:
      typedef _IntType result_type;
      struct param_type
      {
 typedef uniform_int_distribution<_IntType> distribution_type;
 explicit
 param_type(_IntType __a = 0,
     _IntType __b = std::numeric_limits<_IntType>::max())
 : _M_a(__a), _M_b(__b)
 {
   ;
 }
 result_type
 a() const
 { return _M_a; }
 result_type
 b() const
 { return _M_b; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }
      private:
 _IntType _M_a;
 _IntType _M_b;
      };
    public:
      explicit
      uniform_int_distribution(_IntType __a = 0,
      _IntType __b = std::numeric_limits<_IntType>::max())
      : _M_param(__a, __b)
      { }
      explicit
      uniform_int_distribution(const param_type& __p)
      : _M_param(__p)
      { }
      void
      reset() { }
      result_type
      a() const
      { return _M_param.a(); }
      result_type
      b() const
      { return _M_param.b(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return this->a(); }
      result_type
      max() const
      { return this->b(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, this->param()); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);
      param_type _M_param;
    };
  template<typename _IntType>
    inline bool
    operator==(const std::uniform_int_distribution<_IntType>& __d1,
        const std::uniform_int_distribution<_IntType>& __d2)
    { return __d1.param() == __d2.param(); }
  template<typename _IntType>
    inline bool
    operator!=(const std::uniform_int_distribution<_IntType>& __d1,
        const std::uniform_int_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>&,
        const std::uniform_int_distribution<_IntType>&);
  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>&,
        std::uniform_int_distribution<_IntType>&);
  template<typename _RealType = double>
    class uniform_real_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct param_type
      {
 typedef uniform_real_distribution<_RealType> distribution_type;
 explicit
 param_type(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
 : _M_a(__a), _M_b(__b)
 {
   ;
 }
 result_type
 a() const
 { return _M_a; }
 result_type
 b() const
 { return _M_b; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }
      private:
 _RealType _M_a;
 _RealType _M_b;
      };
    public:
      explicit
      uniform_real_distribution(_RealType __a = _RealType(0),
    _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }
      explicit
      uniform_real_distribution(const param_type& __p)
      : _M_param(__p)
      { }
      void
      reset() { }
      result_type
      a() const
      { return _M_param.a(); }
      result_type
      b() const
      { return _M_param.b(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return this->a(); }
      result_type
      max() const
      { return this->b(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, this->param()); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 {
   __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
     __aurng(__urng);
   return (__aurng() * (__p.b() - __p.a())) + __p.a();
 }
    private:
      param_type _M_param;
    };
  template<typename _IntType>
    inline bool
    operator==(const std::uniform_real_distribution<_IntType>& __d1,
        const std::uniform_real_distribution<_IntType>& __d2)
    { return __d1.param() == __d2.param(); }
  template<typename _IntType>
    inline bool
    operator!=(const std::uniform_real_distribution<_IntType>& __d1,
        const std::uniform_real_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>&,
        const std::uniform_real_distribution<_RealType>&);
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>&,
        std::uniform_real_distribution<_RealType>&);
  template<typename _RealType = double>
    class normal_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct param_type
      {
 typedef normal_distribution<_RealType> distribution_type;
 explicit
 param_type(_RealType __mean = _RealType(0),
     _RealType __stddev = _RealType(1))
 : _M_mean(__mean), _M_stddev(__stddev)
 {
   ;
 }
 _RealType
 mean() const
 { return _M_mean; }
 _RealType
 stddev() const
 { return _M_stddev; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return (__p1._M_mean == __p2._M_mean
    && __p1._M_stddev == __p2._M_stddev); }
      private:
 _RealType _M_mean;
 _RealType _M_stddev;
      };
    public:
      explicit
      normal_distribution(result_type __mean = result_type(0),
     result_type __stddev = result_type(1))
      : _M_param(__mean, __stddev), _M_saved_available(false)
      { }
      explicit
      normal_distribution(const param_type& __p)
      : _M_param(__p), _M_saved_available(false)
      { }
      void
      reset()
      { _M_saved_available = false; }
      _RealType
      mean() const
      { return _M_param.mean(); }
      _RealType
      stddev() const
      { return _M_param.stddev(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return std::numeric_limits<result_type>::min(); }
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);
      template<typename _RealType1>
 friend bool
        operator==(const std::normal_distribution<_RealType1>& __d1,
     const std::normal_distribution<_RealType1>& __d2);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::normal_distribution<_RealType1>&);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::normal_distribution<_RealType1>&);
    private:
      param_type _M_param;
      result_type _M_saved;
      bool _M_saved_available;
    };
  template<typename _RealType>
    inline bool
    operator!=(const std::normal_distribution<_RealType>& __d1,
        const std::normal_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType = double>
    class lognormal_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct param_type
      {
 typedef lognormal_distribution<_RealType> distribution_type;
 explicit
 param_type(_RealType __m = _RealType(0),
     _RealType __s = _RealType(1))
 : _M_m(__m), _M_s(__s)
 { }
 _RealType
 m() const
 { return _M_m; }
 _RealType
 s() const
 { return _M_s; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_m == __p2._M_m && __p1._M_s == __p2._M_s; }
      private:
 _RealType _M_m;
 _RealType _M_s;
      };
      explicit
      lognormal_distribution(_RealType __m = _RealType(0),
        _RealType __s = _RealType(1))
      : _M_param(__m, __s), _M_nd()
      { }
      explicit
      lognormal_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }
      void
      reset()
      { _M_nd.reset(); }
      _RealType
      m() const
      { return _M_param.m(); }
      _RealType
      s() const
      { return _M_param.s(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return result_type(0); }
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
        { return std::exp(__p.s() * _M_nd(__urng) + __p.m()); }
      template<typename _RealType1>
        friend bool
        operator==(const std::lognormal_distribution<_RealType1>& __d1,
     const std::lognormal_distribution<_RealType1>& __d2)
        { return (__d1.param() == __d2.param()
    && __d1._M_nd == __d2._M_nd); }
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::lognormal_distribution<_RealType1>&);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::lognormal_distribution<_RealType1>&);
    private:
      param_type _M_param;
      std::normal_distribution<result_type> _M_nd;
    };
  template<typename _RealType>
    inline bool
    operator!=(const std::lognormal_distribution<_RealType>& __d1,
        const std::lognormal_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType = double>
    class gamma_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct param_type
      {
 typedef gamma_distribution<_RealType> distribution_type;
 friend class gamma_distribution<_RealType>;
 explicit
 param_type(_RealType __alpha_val = _RealType(1),
     _RealType __beta_val = _RealType(1))
 : _M_alpha(__alpha_val), _M_beta(__beta_val)
 {
   ;
   _M_initialize();
 }
 _RealType
 alpha() const
 { return _M_alpha; }
 _RealType
 beta() const
 { return _M_beta; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return (__p1._M_alpha == __p2._M_alpha
    && __p1._M_beta == __p2._M_beta); }
      private:
 void
 _M_initialize();
 _RealType _M_alpha;
 _RealType _M_beta;
 _RealType _M_malpha, _M_a2;
      };
    public:
      explicit
      gamma_distribution(_RealType __alpha_val = _RealType(1),
    _RealType __beta_val = _RealType(1))
      : _M_param(__alpha_val, __beta_val), _M_nd()
      { }
      explicit
      gamma_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }
      void
      reset()
      { _M_nd.reset(); }
      _RealType
      alpha() const
      { return _M_param.alpha(); }
      _RealType
      beta() const
      { return _M_param.beta(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return result_type(0); }
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);
      template<typename _RealType1>
        friend bool
        operator==(const std::gamma_distribution<_RealType1>& __d1,
     const std::gamma_distribution<_RealType1>& __d2)
        { return (__d1.param() == __d2.param()
    && __d1._M_nd == __d2._M_nd); }
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::gamma_distribution<_RealType1>&);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::gamma_distribution<_RealType1>&);
    private:
      param_type _M_param;
      std::normal_distribution<result_type> _M_nd;
    };
   template<typename _RealType>
    inline bool
     operator!=(const std::gamma_distribution<_RealType>& __d1,
  const std::gamma_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType = double>
    class chi_squared_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct param_type
      {
 typedef chi_squared_distribution<_RealType> distribution_type;
 explicit
 param_type(_RealType __n = _RealType(1))
 : _M_n(__n)
 { }
 _RealType
 n() const
 { return _M_n; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_n == __p2._M_n; }
      private:
 _RealType _M_n;
      };
      explicit
      chi_squared_distribution(_RealType __n = _RealType(1))
      : _M_param(__n), _M_gd(__n / 2)
      { }
      explicit
      chi_squared_distribution(const param_type& __p)
      : _M_param(__p), _M_gd(__p.n() / 2)
      { }
      void
      reset()
      { _M_gd.reset(); }
      _RealType
      n() const
      { return _M_param.n(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return result_type(0); }
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return 2 * _M_gd(__urng); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
        {
   typedef typename std::gamma_distribution<result_type>::param_type
     param_type;
   return 2 * _M_gd(__urng, param_type(__p.n() / 2));
 }
      template<typename _RealType1>
        friend bool
        operator==(const std::chi_squared_distribution<_RealType1>& __d1,
     const std::chi_squared_distribution<_RealType1>& __d2)
        { return __d1.param() == __d2.param() && __d1._M_gd == __d2._M_gd; }
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::chi_squared_distribution<_RealType1>&);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::chi_squared_distribution<_RealType1>&);
    private:
      param_type _M_param;
      std::gamma_distribution<result_type> _M_gd;
    };
  template<typename _RealType>
    inline bool
    operator!=(const std::chi_squared_distribution<_RealType>& __d1,
        const std::chi_squared_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType = double>
    class cauchy_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct param_type
      {
 typedef cauchy_distribution<_RealType> distribution_type;
 explicit
 param_type(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
 : _M_a(__a), _M_b(__b)
 { }
 _RealType
 a() const
 { return _M_a; }
 _RealType
 b() const
 { return _M_b; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }
      private:
 _RealType _M_a;
 _RealType _M_b;
      };
      explicit
      cauchy_distribution(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }
      explicit
      cauchy_distribution(const param_type& __p)
      : _M_param(__p)
      { }
      void
      reset()
      { }
      _RealType
      a() const
      { return _M_param.a(); }
      _RealType
      b() const
      { return _M_param.b(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return std::numeric_limits<result_type>::min(); }
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);
    private:
      param_type _M_param;
    };
  template<typename _RealType>
    inline bool
    operator==(const std::cauchy_distribution<_RealType>& __d1,
        const std::cauchy_distribution<_RealType>& __d2)
    { return __d1.param() == __d2.param(); }
  template<typename _RealType>
    inline bool
    operator!=(const std::cauchy_distribution<_RealType>& __d1,
        const std::cauchy_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>&,
        const std::cauchy_distribution<_RealType>&);
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>&,
        std::cauchy_distribution<_RealType>&);
  template<typename _RealType = double>
    class fisher_f_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct param_type
      {
 typedef fisher_f_distribution<_RealType> distribution_type;
 explicit
 param_type(_RealType __m = _RealType(1),
     _RealType __n = _RealType(1))
 : _M_m(__m), _M_n(__n)
 { }
 _RealType
 m() const
 { return _M_m; }
 _RealType
 n() const
 { return _M_n; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_m == __p2._M_m && __p1._M_n == __p2._M_n; }
      private:
 _RealType _M_m;
 _RealType _M_n;
      };
      explicit
      fisher_f_distribution(_RealType __m = _RealType(1),
       _RealType __n = _RealType(1))
      : _M_param(__m, __n), _M_gd_x(__m / 2), _M_gd_y(__n / 2)
      { }
      explicit
      fisher_f_distribution(const param_type& __p)
      : _M_param(__p), _M_gd_x(__p.m() / 2), _M_gd_y(__p.n() / 2)
      { }
      void
      reset()
      {
 _M_gd_x.reset();
 _M_gd_y.reset();
      }
      _RealType
      m() const
      { return _M_param.m(); }
      _RealType
      n() const
      { return _M_param.n(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return result_type(0); }
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return (_M_gd_x(__urng) * n()) / (_M_gd_y(__urng) * m()); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
        {
   typedef typename std::gamma_distribution<result_type>::param_type
     param_type;
   return ((_M_gd_x(__urng, param_type(__p.m() / 2)) * n())
    / (_M_gd_y(__urng, param_type(__p.n() / 2)) * m()));
 }
      template<typename _RealType1>
        friend bool
        operator==(const std::fisher_f_distribution<_RealType1>& __d1,
     const std::fisher_f_distribution<_RealType1>& __d2)
        { return (__d1.param() == __d2.param()
    && __d1._M_gd_x == __d2._M_gd_x
    && __d1._M_gd_y == __d2._M_gd_y); }
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::fisher_f_distribution<_RealType1>&);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::fisher_f_distribution<_RealType1>&);
    private:
      param_type _M_param;
      std::gamma_distribution<result_type> _M_gd_x, _M_gd_y;
    };
  template<typename _RealType>
    inline bool
    operator!=(const std::fisher_f_distribution<_RealType>& __d1,
        const std::fisher_f_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType = double>
    class student_t_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct param_type
      {
 typedef student_t_distribution<_RealType> distribution_type;
 explicit
 param_type(_RealType __n = _RealType(1))
 : _M_n(__n)
 { }
 _RealType
 n() const
 { return _M_n; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_n == __p2._M_n; }
      private:
 _RealType _M_n;
      };
      explicit
      student_t_distribution(_RealType __n = _RealType(1))
      : _M_param(__n), _M_nd(), _M_gd(__n / 2, 2)
      { }
      explicit
      student_t_distribution(const param_type& __p)
      : _M_param(__p), _M_nd(), _M_gd(__p.n() / 2, 2)
      { }
      void
      reset()
      {
 _M_nd.reset();
 _M_gd.reset();
      }
      _RealType
      n() const
      { return _M_param.n(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return std::numeric_limits<result_type>::min(); }
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
        operator()(_UniformRandomNumberGenerator& __urng)
        { return _M_nd(__urng) * std::sqrt(n() / _M_gd(__urng)); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
        {
   typedef typename std::gamma_distribution<result_type>::param_type
     param_type;
   const result_type __g = _M_gd(__urng, param_type(__p.n() / 2, 2));
   return _M_nd(__urng) * std::sqrt(__p.n() / __g);
        }
      template<typename _RealType1>
        friend bool
        operator==(const std::student_t_distribution<_RealType1>& __d1,
     const std::student_t_distribution<_RealType1>& __d2)
        { return (__d1.param() == __d2.param()
    && __d1._M_nd == __d2._M_nd && __d1._M_gd == __d2._M_gd); }
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::student_t_distribution<_RealType1>&);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::student_t_distribution<_RealType1>&);
    private:
      param_type _M_param;
      std::normal_distribution<result_type> _M_nd;
      std::gamma_distribution<result_type> _M_gd;
    };
  template<typename _RealType>
    inline bool
    operator!=(const std::student_t_distribution<_RealType>& __d1,
        const std::student_t_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  class bernoulli_distribution
  {
  public:
    typedef bool result_type;
    struct param_type
    {
      typedef bernoulli_distribution distribution_type;
      explicit
      param_type(double __p = 0.5)
      : _M_p(__p)
      {
 ;
      }
      double
      p() const
      { return _M_p; }
      friend bool
      operator==(const param_type& __p1, const param_type& __p2)
      { return __p1._M_p == __p2._M_p; }
    private:
      double _M_p;
    };
  public:
    explicit
    bernoulli_distribution(double __p = 0.5)
    : _M_param(__p)
    { }
    explicit
    bernoulli_distribution(const param_type& __p)
    : _M_param(__p)
    { }
    void
    reset() { }
    double
    p() const
    { return _M_param.p(); }
    param_type
    param() const
    { return _M_param; }
    void
    param(const param_type& __param)
    { _M_param = __param; }
    result_type
    min() const
    { return std::numeric_limits<result_type>::min(); }
    result_type
    max() const
    { return std::numeric_limits<result_type>::max(); }
    template<typename _UniformRandomNumberGenerator>
      result_type
      operator()(_UniformRandomNumberGenerator& __urng)
      { return this->operator()(__urng, this->param()); }
    template<typename _UniformRandomNumberGenerator>
      result_type
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);
 if ((__aurng() - __aurng.min())
      < __p.p() * (__aurng.max() - __aurng.min()))
   return true;
 return false;
      }
  private:
    param_type _M_param;
  };
  inline bool
  operator==(const std::bernoulli_distribution& __d1,
      const std::bernoulli_distribution& __d2)
  { return __d1.param() == __d2.param(); }
  inline bool
  operator!=(const std::bernoulli_distribution& __d1,
      const std::bernoulli_distribution& __d2)
  { return !(__d1 == __d2); }
  template<typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>&,
        const std::bernoulli_distribution&);
  template<typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        std::bernoulli_distribution& __x)
    {
      double __p;
      __is >> __p;
      __x.param(bernoulli_distribution::param_type(__p));
      return __is;
    }
  template<typename _IntType = int>
    class binomial_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");
    public:
      typedef _IntType result_type;
      struct param_type
      {
 typedef binomial_distribution<_IntType> distribution_type;
 friend class binomial_distribution<_IntType>;
 explicit
 param_type(_IntType __t = _IntType(1), double __p = 0.5)
 : _M_t(__t), _M_p(__p)
 {
   ;
   _M_initialize();
 }
 _IntType
 t() const
 { return _M_t; }
 double
 p() const
 { return _M_p; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_t == __p2._M_t && __p1._M_p == __p2._M_p; }
      private:
 void
 _M_initialize();
 _IntType _M_t;
 double _M_p;
 double _M_q;
 double _M_d1, _M_d2, _M_s1, _M_s2, _M_c,
        _M_a1, _M_a123, _M_s, _M_lf, _M_lp1p;
 bool _M_easy;
      };
      explicit
      binomial_distribution(_IntType __t = _IntType(1),
       double __p = 0.5)
      : _M_param(__t, __p), _M_nd()
      { }
      explicit
      binomial_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }
      void
      reset()
      { _M_nd.reset(); }
      _IntType
      t() const
      { return _M_param.t(); }
      double
      p() const
      { return _M_param.p(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return 0; }
      result_type
      max() const
      { return _M_param.t(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);
      template<typename _IntType1>
 friend bool
        operator==(const std::binomial_distribution<_IntType1>& __d1,
     const std::binomial_distribution<_IntType1>& __d2)
 { return __d1.param() == __d2.param() && __d1._M_nd == __d2._M_nd; }
      template<typename _IntType1,
        typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::binomial_distribution<_IntType1>&);
      template<typename _IntType1,
        typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::binomial_distribution<_IntType1>&);
    private:
      template<typename _UniformRandomNumberGenerator>
 result_type
 _M_waiting(_UniformRandomNumberGenerator& __urng, _IntType __t);
      param_type _M_param;
      std::normal_distribution<double> _M_nd;
    };
  template<typename _IntType>
    inline bool
    operator!=(const std::binomial_distribution<_IntType>& __d1,
        const std::binomial_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _IntType = int>
    class geometric_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");
    public:
      typedef _IntType result_type;
      struct param_type
      {
 typedef geometric_distribution<_IntType> distribution_type;
 friend class geometric_distribution<_IntType>;
 explicit
 param_type(double __p = 0.5)
 : _M_p(__p)
 {
   ;
   _M_initialize();
 }
 double
 p() const
 { return _M_p; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_p == __p2._M_p; }
      private:
 void
 _M_initialize()
 { _M_log_p = std::log(_M_p); }
 double _M_p;
 double _M_log_p;
      };
      explicit
      geometric_distribution(double __p = 0.5)
      : _M_param(__p)
      { }
      explicit
      geometric_distribution(const param_type& __p)
      : _M_param(__p)
      { }
      void
      reset() { }
      double
      p() const
      { return _M_param.p(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return 0; }
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);
    private:
      param_type _M_param;
    };
  template<typename _IntType>
    inline bool
    operator==(const std::geometric_distribution<_IntType>& __d1,
        const std::geometric_distribution<_IntType>& __d2)
    { return __d1.param() == __d2.param(); }
  template<typename _IntType>
    inline bool
    operator!=(const std::geometric_distribution<_IntType>& __d1,
        const std::geometric_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>&,
        const std::geometric_distribution<_IntType>&);
  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>&,
        std::geometric_distribution<_IntType>&);
  template<typename _IntType = int>
    class negative_binomial_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");
    public:
      typedef _IntType result_type;
      struct param_type
      {
 typedef negative_binomial_distribution<_IntType> distribution_type;
 explicit
 param_type(_IntType __k = 1, double __p = 0.5)
 : _M_k(__k), _M_p(__p)
 { }
 _IntType
 k() const
 { return _M_k; }
 double
 p() const
 { return _M_p; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_k == __p2._M_k && __p1._M_p == __p2._M_p; }
      private:
 _IntType _M_k;
 double _M_p;
      };
      explicit
      negative_binomial_distribution(_IntType __k = 1, double __p = 0.5)
      : _M_param(__k, __p), _M_gd(__k, __p / (1.0 - __p))
      { }
      explicit
      negative_binomial_distribution(const param_type& __p)
      : _M_param(__p), _M_gd(__p.k(), __p.p() / (1.0 - __p.p()))
      { }
      void
      reset()
      { _M_gd.reset(); }
      _IntType
      k() const
      { return _M_param.k(); }
      double
      p() const
      { return _M_param.p(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return result_type(0); }
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
        operator()(_UniformRandomNumberGenerator& __urng);
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);
      template<typename _IntType1>
        friend bool
        operator==(const std::negative_binomial_distribution<_IntType1>& __d1,
     const std::negative_binomial_distribution<_IntType1>& __d2)
        { return __d1.param() == __d2.param() && __d1._M_gd == __d2._M_gd; }
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::negative_binomial_distribution<_IntType1>&);
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::negative_binomial_distribution<_IntType1>&);
    private:
      param_type _M_param;
      std::gamma_distribution<double> _M_gd;
    };
  template<typename _IntType>
    inline bool
    operator!=(const std::negative_binomial_distribution<_IntType>& __d1,
        const std::negative_binomial_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _IntType = int>
    class poisson_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");
    public:
      typedef _IntType result_type;
      struct param_type
      {
 typedef poisson_distribution<_IntType> distribution_type;
 friend class poisson_distribution<_IntType>;
 explicit
 param_type(double __mean = 1.0)
 : _M_mean(__mean)
 {
   ;
   _M_initialize();
 }
 double
 mean() const
 { return _M_mean; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_mean == __p2._M_mean; }
      private:
 void
 _M_initialize();
 double _M_mean;
 double _M_lm_thr;
 double _M_lfm, _M_sm, _M_d, _M_scx, _M_1cx, _M_c2b, _M_cb;
      };
      explicit
      poisson_distribution(double __mean = 1.0)
      : _M_param(__mean), _M_nd()
      { }
      explicit
      poisson_distribution(const param_type& __p)
      : _M_param(__p), _M_nd()
      { }
      void
      reset()
      { _M_nd.reset(); }
      double
      mean() const
      { return _M_param.mean(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return 0; }
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);
      template<typename _IntType1>
        friend bool
        operator==(const std::poisson_distribution<_IntType1>& __d1,
     const std::poisson_distribution<_IntType1>& __d2)
        { return __d1.param() == __d2.param() && __d1._M_nd == __d2._M_nd; }
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::poisson_distribution<_IntType1>&);
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::poisson_distribution<_IntType1>&);
    private:
      param_type _M_param;
      std::normal_distribution<double> _M_nd;
    };
  template<typename _IntType>
    inline bool
    operator!=(const std::poisson_distribution<_IntType>& __d1,
        const std::poisson_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType = double>
    class exponential_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct param_type
      {
 typedef exponential_distribution<_RealType> distribution_type;
 explicit
 param_type(_RealType __lambda = _RealType(1))
 : _M_lambda(__lambda)
 {
   ;
 }
 _RealType
 lambda() const
 { return _M_lambda; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_lambda == __p2._M_lambda; }
      private:
 _RealType _M_lambda;
      };
    public:
      explicit
      exponential_distribution(const result_type& __lambda = result_type(1))
      : _M_param(__lambda)
      { }
      explicit
      exponential_distribution(const param_type& __p)
      : _M_param(__p)
      { }
      void
      reset() { }
      _RealType
      lambda() const
      { return _M_param.lambda(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return result_type(0); }
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, this->param()); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 {
   __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
     __aurng(__urng);
   return -std::log(__aurng()) / __p.lambda();
 }
    private:
      param_type _M_param;
    };
  template<typename _RealType>
    inline bool
    operator==(const std::exponential_distribution<_RealType>& __d1,
        const std::exponential_distribution<_RealType>& __d2)
    { return __d1.param() == __d2.param(); }
  template<typename _RealType>
    inline bool
    operator!=(const std::exponential_distribution<_RealType>& __d1,
        const std::exponential_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>&,
        const std::exponential_distribution<_RealType>&);
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>&,
        std::exponential_distribution<_RealType>&);
  template<typename _RealType = double>
    class weibull_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct param_type
      {
 typedef weibull_distribution<_RealType> distribution_type;
 explicit
 param_type(_RealType __a = _RealType(1),
     _RealType __b = _RealType(1))
 : _M_a(__a), _M_b(__b)
 { }
 _RealType
 a() const
 { return _M_a; }
 _RealType
 b() const
 { return _M_b; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }
      private:
 _RealType _M_a;
 _RealType _M_b;
      };
      explicit
      weibull_distribution(_RealType __a = _RealType(1),
      _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }
      explicit
      weibull_distribution(const param_type& __p)
      : _M_param(__p)
      { }
      void
      reset()
      { }
      _RealType
      a() const
      { return _M_param.a(); }
      _RealType
      b() const
      { return _M_param.b(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return result_type(0); }
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);
    private:
      param_type _M_param;
    };
  template<typename _RealType>
    inline bool
    operator==(const std::weibull_distribution<_RealType>& __d1,
        const std::weibull_distribution<_RealType>& __d2)
    { return __d1.param() == __d2.param(); }
  template<typename _RealType>
    inline bool
    operator!=(const std::weibull_distribution<_RealType>& __d1,
        const std::weibull_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>&,
        const std::weibull_distribution<_RealType>&);
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>&,
        std::weibull_distribution<_RealType>&);
  template<typename _RealType = double>
    class extreme_value_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct param_type
      {
 typedef extreme_value_distribution<_RealType> distribution_type;
 explicit
 param_type(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
 : _M_a(__a), _M_b(__b)
 { }
 _RealType
 a() const
 { return _M_a; }
 _RealType
 b() const
 { return _M_b; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }
      private:
 _RealType _M_a;
 _RealType _M_b;
      };
      explicit
      extreme_value_distribution(_RealType __a = _RealType(0),
     _RealType __b = _RealType(1))
      : _M_param(__a, __b)
      { }
      explicit
      extreme_value_distribution(const param_type& __p)
      : _M_param(__p)
      { }
      void
      reset()
      { }
      _RealType
      a() const
      { return _M_param.a(); }
      _RealType
      b() const
      { return _M_param.b(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return std::numeric_limits<result_type>::min(); }
      result_type
      max() const
      { return std::numeric_limits<result_type>::max(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);
    private:
      param_type _M_param;
    };
  template<typename _RealType>
    inline bool
    operator==(const std::extreme_value_distribution<_RealType>& __d1,
        const std::extreme_value_distribution<_RealType>& __d2)
    { return __d1.param() == __d2.param(); }
  template<typename _RealType>
    inline bool
    operator!=(const std::extreme_value_distribution<_RealType>& __d1,
        const std::extreme_value_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>&,
        const std::extreme_value_distribution<_RealType>&);
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>&,
        std::extreme_value_distribution<_RealType>&);
  template<typename _IntType = int>
    class discrete_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");
    public:
      typedef _IntType result_type;
      struct param_type
      {
 typedef discrete_distribution<_IntType> distribution_type;
 friend class discrete_distribution<_IntType>;
 param_type()
 : _M_prob(), _M_cp()
 { _M_initialize(); }
 template<typename _InputIterator>
   param_type(_InputIterator __wbegin,
       _InputIterator __wend)
   : _M_prob(__wbegin, __wend), _M_cp()
   { _M_initialize(); }
 param_type(initializer_list<double> __wil)
 : _M_prob(__wil.begin(), __wil.end()), _M_cp()
 { _M_initialize(); }
 template<typename _Func>
   param_type(size_t __nw, double __xmin, double __xmax,
       _Func __fw);
 std::vector<double>
 probabilities() const
 { return _M_prob; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_prob == __p2._M_prob; }
      private:
 void
 _M_initialize();
 std::vector<double> _M_prob;
 std::vector<double> _M_cp;
      };
      discrete_distribution()
      : _M_param()
      { }
      template<typename _InputIterator>
 discrete_distribution(_InputIterator __wbegin,
         _InputIterator __wend)
 : _M_param(__wbegin, __wend)
 { }
      discrete_distribution(initializer_list<double> __wl)
      : _M_param(__wl)
      { }
      template<typename _Func>
 discrete_distribution(size_t __nw, double __xmin, double __xmax,
         _Func __fw)
 : _M_param(__nw, __xmin, __xmax, __fw)
 { }
      explicit
      discrete_distribution(const param_type& __p)
      : _M_param(__p)
      { }
      void
      reset()
      { }
      std::vector<double>
      probabilities() const
      { return _M_param.probabilities(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return result_type(0); }
      result_type
      max() const
      { return this->_M_param._M_prob.size() - 1; }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::discrete_distribution<_IntType1>&);
      template<typename _IntType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::discrete_distribution<_IntType1>&);
    private:
      param_type _M_param;
    };
  template<typename _IntType>
    inline bool
    operator==(const std::discrete_distribution<_IntType>& __d1,
        const std::discrete_distribution<_IntType>& __d2)
    { return __d1.param() == __d2.param(); }
  template<typename _IntType>
    inline bool
    operator!=(const std::discrete_distribution<_IntType>& __d1,
        const std::discrete_distribution<_IntType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType = double>
    class piecewise_constant_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct param_type
      {
 typedef piecewise_constant_distribution<_RealType> distribution_type;
 friend class piecewise_constant_distribution<_RealType>;
 param_type()
 : _M_int(), _M_den(), _M_cp()
 { _M_initialize(); }
 template<typename _InputIteratorB, typename _InputIteratorW>
   param_type(_InputIteratorB __bfirst,
       _InputIteratorB __bend,
       _InputIteratorW __wbegin);
 template<typename _Func>
   param_type(initializer_list<_RealType> __bi, _Func __fw);
 template<typename _Func>
   param_type(size_t __nw, _RealType __xmin, _RealType __xmax,
       _Func __fw);
 std::vector<_RealType>
 intervals() const
 { return _M_int; }
 std::vector<double>
 densities() const
 { return _M_den; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_int == __p2._M_int && __p1._M_den == __p2._M_den; }
      private:
 void
 _M_initialize();
 std::vector<_RealType> _M_int;
 std::vector<double> _M_den;
 std::vector<double> _M_cp;
      };
      explicit
      piecewise_constant_distribution()
      : _M_param()
      { }
      template<typename _InputIteratorB, typename _InputIteratorW>
 piecewise_constant_distribution(_InputIteratorB __bfirst,
     _InputIteratorB __bend,
     _InputIteratorW __wbegin)
 : _M_param(__bfirst, __bend, __wbegin)
 { }
      template<typename _Func>
 piecewise_constant_distribution(initializer_list<_RealType> __bl,
     _Func __fw)
 : _M_param(__bl, __fw)
 { }
      template<typename _Func>
 piecewise_constant_distribution(size_t __nw,
     _RealType __xmin, _RealType __xmax,
     _Func __fw)
 : _M_param(__nw, __xmin, __xmax, __fw)
 { }
      explicit
      piecewise_constant_distribution(const param_type& __p)
      : _M_param(__p)
      { }
      void
      reset()
      { }
      std::vector<_RealType>
      intervals() const
      { return _M_param.intervals(); }
      std::vector<double>
      densities() const
      { return _M_param.densities(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return this->_M_param._M_int.front(); }
      result_type
      max() const
      { return this->_M_param._M_int.back(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::piecewise_constant_distribution<_RealType1>&);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::piecewise_constant_distribution<_RealType1>&);
    private:
      param_type _M_param;
    };
  template<typename _RealType>
    inline bool
    operator==(const std::piecewise_constant_distribution<_RealType>& __d1,
        const std::piecewise_constant_distribution<_RealType>& __d2)
    { return __d1.param() == __d2.param(); }
  template<typename _RealType>
    inline bool
    operator!=(const std::piecewise_constant_distribution<_RealType>& __d1,
        const std::piecewise_constant_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  template<typename _RealType = double>
    class piecewise_linear_distribution
    {
      static_assert(std::is_floating_point<_RealType>::value,
      "template argument not a floating point type");
    public:
      typedef _RealType result_type;
      struct param_type
      {
 typedef piecewise_linear_distribution<_RealType> distribution_type;
 friend class piecewise_linear_distribution<_RealType>;
 param_type()
 : _M_int(), _M_den(), _M_cp(), _M_m()
 { _M_initialize(); }
 template<typename _InputIteratorB, typename _InputIteratorW>
   param_type(_InputIteratorB __bfirst,
       _InputIteratorB __bend,
       _InputIteratorW __wbegin);
 template<typename _Func>
   param_type(initializer_list<_RealType> __bl, _Func __fw);
 template<typename _Func>
   param_type(size_t __nw, _RealType __xmin, _RealType __xmax,
       _Func __fw);
 std::vector<_RealType>
 intervals() const
 { return _M_int; }
 std::vector<double>
 densities() const
 { return _M_den; }
 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return (__p1._M_int == __p2._M_int
    && __p1._M_den == __p2._M_den); }
      private:
 void
 _M_initialize();
 std::vector<_RealType> _M_int;
 std::vector<double> _M_den;
 std::vector<double> _M_cp;
 std::vector<double> _M_m;
      };
      explicit
      piecewise_linear_distribution()
      : _M_param()
      { }
      template<typename _InputIteratorB, typename _InputIteratorW>
 piecewise_linear_distribution(_InputIteratorB __bfirst,
          _InputIteratorB __bend,
          _InputIteratorW __wbegin)
 : _M_param(__bfirst, __bend, __wbegin)
 { }
      template<typename _Func>
 piecewise_linear_distribution(initializer_list<_RealType> __bl,
          _Func __fw)
 : _M_param(__bl, __fw)
 { }
      template<typename _Func>
 piecewise_linear_distribution(size_t __nw,
          _RealType __xmin, _RealType __xmax,
          _Func __fw)
 : _M_param(__nw, __xmin, __xmax, __fw)
 { }
      explicit
      piecewise_linear_distribution(const param_type& __p)
      : _M_param(__p)
      { }
      void
      reset()
      { }
      std::vector<_RealType>
      intervals() const
      { return _M_param.intervals(); }
      std::vector<double>
      densities() const
      { return _M_param.densities(); }
      param_type
      param() const
      { return _M_param; }
      void
      param(const param_type& __param)
      { _M_param = __param; }
      result_type
      min() const
      { return this->_M_param._M_int.front(); }
      result_type
      max() const
      { return this->_M_param._M_int.back(); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
 { return this->operator()(__urng, this->param()); }
      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_ostream<_CharT, _Traits>&
 operator<<(std::basic_ostream<_CharT, _Traits>&,
     const std::piecewise_linear_distribution<_RealType1>&);
      template<typename _RealType1, typename _CharT, typename _Traits>
 friend std::basic_istream<_CharT, _Traits>&
 operator>>(std::basic_istream<_CharT, _Traits>&,
     std::piecewise_linear_distribution<_RealType1>&);
    private:
      param_type _M_param;
    };
  template<typename _RealType>
    inline bool
    operator==(const std::piecewise_linear_distribution<_RealType>& __d1,
        const std::piecewise_linear_distribution<_RealType>& __d2)
    { return __d1.param() == __d2.param(); }
  template<typename _RealType>
    inline bool
    operator!=(const std::piecewise_linear_distribution<_RealType>& __d1,
        const std::piecewise_linear_distribution<_RealType>& __d2)
    { return !(__d1 == __d2); }
  class seed_seq
  {
  public:
    typedef uint_least32_t result_type;
    seed_seq()
    : _M_v()
    { }
    template<typename _IntType>
      seed_seq(std::initializer_list<_IntType> il);
    template<typename _InputIterator>
      seed_seq(_InputIterator __begin, _InputIterator __end);
    template<typename _RandomAccessIterator>
      void
      generate(_RandomAccessIterator __begin, _RandomAccessIterator __end);
    size_t size() const
    { return _M_v.size(); }
    template<typename OutputIterator>
      void
      param(OutputIterator __dest) const
      { std::copy(_M_v.begin(), _M_v.end(), __dest); }
  private:
    std::vector<result_type> _M_v;
  };
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _ForwardIterator, typename _Tp>
    void
    iota(_ForwardIterator __first, _ForwardIterator __last, _Tp __value)
    {
     
     
      ;
      for (; __first != __last; ++__first)
 {
   *__first = __value;
   ++__value;
 }
    }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _InputIterator, typename _Tp>
    inline _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)
    {
     
      ;
      for (; __first != __last; ++__first)
 __init = __init + *__first;
      return __init;
    }
  template<typename _InputIterator, typename _Tp, typename _BinaryOperation>
    inline _Tp
    accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,
        _BinaryOperation __binary_op)
    {
     
      ;
      for (; __first != __last; ++__first)
 __init = __binary_op(__init, *__first);
      return __init;
    }
  template<typename _InputIterator1, typename _InputIterator2, typename _Tp>
    inline _Tp
    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
    _InputIterator2 __first2, _Tp __init)
    {
     
     
      ;
      for (; __first1 != __last1; ++__first1, ++__first2)
 __init = __init + (*__first1 * *__first2);
      return __init;
    }
  template<typename _InputIterator1, typename _InputIterator2, typename _Tp,
    typename _BinaryOperation1, typename _BinaryOperation2>
    inline _Tp
    inner_product(_InputIterator1 __first1, _InputIterator1 __last1,
    _InputIterator2 __first2, _Tp __init,
    _BinaryOperation1 __binary_op1,
    _BinaryOperation2 __binary_op2)
    {
     
     
      ;
      for (; __first1 != __last1; ++__first1, ++__first2)
 __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));
      return __init;
    }
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    partial_sum(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
     
     
      ;
      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   __value = __value + *__first;
   *++__result = __value;
 }
      return ++__result;
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryOperation>
    _OutputIterator
    partial_sum(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, _BinaryOperation __binary_op)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
     
     
      ;
      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   __value = __binary_op(__value, *__first);
   *++__result = __value;
 }
      return ++__result;
    }
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    adjacent_difference(_InputIterator __first,
   _InputIterator __last, _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
     
     
      ;
      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   _ValueType __tmp = *__first;
   *++__result = __tmp - __value;
   __value = std::move(__tmp);
 }
      return ++__result;
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryOperation>
    _OutputIterator
    adjacent_difference(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result, _BinaryOperation __binary_op)
    {
      typedef typename iterator_traits<_InputIterator>::value_type _ValueType;
     
     
      ;
      if (__first == __last)
 return __result;
      _ValueType __value = *__first;
      *__result = __value;
      while (++__first != __last)
 {
   _ValueType __tmp = *__first;
   *++__result = __binary_op(__tmp, __value);
   __value = std::move(__tmp);
 }
      return ++__result;
    }
}
namespace std
{
  namespace __detail
  {
    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c, bool>
      struct _Mod
      {
 static _Tp
 __calc(_Tp __x)
 {
   if (__a == 1)
     __x %= __m;
   else
     {
       static const _Tp __q = __m / __a;
       static const _Tp __r = __m % __a;
       _Tp __t1 = __a * (__x % __q);
       _Tp __t2 = __r * (__x / __q);
       if (__t1 >= __t2)
  __x = __t1 - __t2;
       else
  __x = __m - __t2 + __t1;
     }
   if (__c != 0)
     {
       const _Tp __d = __m - __x;
       if (__d > __c)
  __x += __c;
       else
  __x = __c - __d;
     }
   return __x;
 }
      };
    template<typename _Tp, _Tp __m, _Tp __a, _Tp __c>
      struct _Mod<_Tp, __m, __a, __c, true>
      {
 static _Tp
 __calc(_Tp __x)
 { return __a * __x + __c; }
      };
    template<typename _InputIterator, typename _OutputIterator,
      typename _UnaryOperation>
      _OutputIterator
      __transform(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _UnaryOperation __unary_op)
      {
 for (; __first != __last; ++__first, ++__result)
   *__result = __unary_op(*__first);
 return __result;
      }
  }
  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    const _UIntType
    linear_congruential_engine<_UIntType, __a, __c, __m>::multiplier;
  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    const _UIntType
    linear_congruential_engine<_UIntType, __a, __c, __m>::increment;
  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    const _UIntType
    linear_congruential_engine<_UIntType, __a, __c, __m>::modulus;
  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    const _UIntType
    linear_congruential_engine<_UIntType, __a, __c, __m>::default_seed;
  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    void
    linear_congruential_engine<_UIntType, __a, __c, __m>::
    seed(result_type __s)
    {
      if ((__detail::__mod<_UIntType, __m>(__c) == 0)
   && (__detail::__mod<_UIntType, __m>(__s) == 0))
 _M_x = 1;
      else
 _M_x = __detail::__mod<_UIntType, __m>(__s);
    }
  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>
    template<typename _Sseq>
      typename std::enable_if<std::is_class<_Sseq>::value>::type
      linear_congruential_engine<_UIntType, __a, __c, __m>::
      seed(_Sseq& __q)
      {
 const _UIntType __k0 = __m == 0 ? std::numeric_limits<_UIntType>::digits
                                 : std::__lg(__m);
 const _UIntType __k = (__k0 + 31) / 32;
 uint_least32_t __arr[__k + 3];
 __q.generate(__arr + 0, __arr + __k + 3);
 _UIntType __factor = 1u;
 _UIntType __sum = 0u;
 for (size_t __j = 0; __j < __k; ++__j)
   {
     __sum += __arr[__j + 3] * __factor;
     __factor *= __detail::_Shift<_UIntType, 32>::__value;
   }
 seed(__sum);
      }
  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const linear_congruential_engine<_UIntType,
      __a, __c, __m>& __lcr)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os << __lcr._M_x;
      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }
  template<typename _UIntType, _UIntType __a, _UIntType __c, _UIntType __m,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        linear_congruential_engine<_UIntType, __a, __c, __m>& __lcr)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec);
      __is >> __lcr._M_x;
      __is.flags(__flags);
      return __is;
    }
  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    const size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::word_size;
  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    const size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::state_size;
  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    const size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::shift_size;
  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    const size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::mask_bits;
  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    const _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::xor_mask;
  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    const size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_u;
  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    const _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_d;
  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    const size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_s;
  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    const _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_b;
  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    const size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_t;
  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    const _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_c;
  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    const size_t
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::tempering_l;
  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    const _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::
                                              initialization_multiplier;
  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    const _UIntType
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::default_seed;
  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    void
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::
    seed(result_type __sd)
    {
      _M_x[0] = __detail::__mod<_UIntType,
 __detail::_Shift<_UIntType, __w>::__value>(__sd);
      for (size_t __i = 1; __i < state_size; ++__i)
 {
   _UIntType __x = _M_x[__i - 1];
   __x ^= __x >> (__w - 2);
   __x *= __f;
   __x += __detail::__mod<_UIntType, __n>(__i);
   _M_x[__i] = __detail::__mod<_UIntType,
     __detail::_Shift<_UIntType, __w>::__value>(__x);
 }
      _M_p = state_size;
    }
  template<typename _UIntType,
    size_t __w, size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    template<typename _Sseq>
      typename std::enable_if<std::is_class<_Sseq>::value>::type
      mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
         __s, __b, __t, __c, __l, __f>::
      seed(_Sseq& __q)
      {
 const _UIntType __upper_mask = (~_UIntType()) << __r;
 const size_t __k = (__w + 31) / 32;
 uint_least32_t __arr[__n * __k];
 __q.generate(__arr + 0, __arr + __n * __k);
 bool __zero = true;
 for (size_t __i = 0; __i < state_size; ++__i)
   {
     _UIntType __factor = 1u;
     _UIntType __sum = 0u;
     for (size_t __j = 0; __j < __k; ++__j)
       {
  __sum += __arr[__k * __i + __j] * __factor;
  __factor *= __detail::_Shift<_UIntType, 32>::__value;
       }
     _M_x[__i] = __detail::__mod<_UIntType,
       __detail::_Shift<_UIntType, __w>::__value>(__sum);
     if (__zero)
       {
  if (__i == 0)
    {
      if ((_M_x[0] & __upper_mask) != 0u)
        __zero = false;
    }
  else if (_M_x[__i] != 0u)
    __zero = false;
       }
   }
        if (__zero)
          _M_x[0] = __detail::_Shift<_UIntType, __w - 1>::__value;
      }
  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f>
    typename
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::result_type
    mersenne_twister_engine<_UIntType, __w, __n, __m, __r, __a, __u, __d,
       __s, __b, __t, __c, __l, __f>::
    operator()()
    {
      if (_M_p >= state_size)
 {
   const _UIntType __upper_mask = (~_UIntType()) << __r;
   const _UIntType __lower_mask = ~__upper_mask;
   for (size_t __k = 0; __k < (__n - __m); ++__k)
     {
       _UIntType __y = ((_M_x[__k] & __upper_mask)
          | (_M_x[__k + 1] & __lower_mask));
       _M_x[__k] = (_M_x[__k + __m] ^ (__y >> 1)
      ^ ((__y & 0x01) ? __a : 0));
     }
   for (size_t __k = (__n - __m); __k < (__n - 1); ++__k)
     {
       _UIntType __y = ((_M_x[__k] & __upper_mask)
          | (_M_x[__k + 1] & __lower_mask));
       _M_x[__k] = (_M_x[__k + (__m - __n)] ^ (__y >> 1)
      ^ ((__y & 0x01) ? __a : 0));
     }
   _UIntType __y = ((_M_x[__n - 1] & __upper_mask)
      | (_M_x[0] & __lower_mask));
   _M_x[__n - 1] = (_M_x[__m - 1] ^ (__y >> 1)
      ^ ((__y & 0x01) ? __a : 0));
   _M_p = 0;
 }
      result_type __z = _M_x[_M_p++];
      __z ^= (__z >> __u) & __d;
      __z ^= (__z << __s) & __b;
      __z ^= (__z << __t) & __c;
      __z ^= (__z >> __l);
      return __z;
    }
  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const mersenne_twister_engine<_UIntType, __w, __n, __m,
        __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__space);
      for (size_t __i = 0; __i < __n - 1; ++__i)
 __os << __x._M_x[__i] << __space;
      __os << __x._M_x[__n - 1];
      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }
  template<typename _UIntType, size_t __w,
    size_t __n, size_t __m, size_t __r,
    _UIntType __a, size_t __u, _UIntType __d, size_t __s,
    _UIntType __b, size_t __t, _UIntType __c, size_t __l,
    _UIntType __f, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        mersenne_twister_engine<_UIntType, __w, __n, __m,
        __r, __a, __u, __d, __s, __b, __t, __c, __l, __f>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      for (size_t __i = 0; __i < __n; ++__i)
 __is >> __x._M_x[__i];
      __is.flags(__flags);
      return __is;
    }
  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    const size_t
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::word_size;
  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    const size_t
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::short_lag;
  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    const size_t
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::long_lag;
  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    const _UIntType
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::default_seed;
  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    void
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::
    seed(result_type __value)
    {
      std::linear_congruential_engine<result_type, 40014u, 0u, 2147483563u>
 __lcg(__value == 0u ? default_seed : __value);
      const size_t __n = (__w + 31) / 32;
      for (size_t __i = 0; __i < long_lag; ++__i)
 {
   _UIntType __sum = 0u;
   _UIntType __factor = 1u;
   for (size_t __j = 0; __j < __n; ++__j)
     {
       __sum += __detail::__mod<uint_least32_t,
         __detail::_Shift<uint_least32_t, 32>::__value>
    (__lcg()) * __factor;
       __factor *= __detail::_Shift<_UIntType, 32>::__value;
     }
   _M_x[__i] = __detail::__mod<_UIntType,
     __detail::_Shift<_UIntType, __w>::__value>(__sum);
 }
      _M_carry = (_M_x[long_lag - 1] == 0) ? 1 : 0;
      _M_p = 0;
    }
  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    template<typename _Sseq>
      typename std::enable_if<std::is_class<_Sseq>::value>::type
      subtract_with_carry_engine<_UIntType, __w, __s, __r>::
      seed(_Sseq& __q)
      {
 const size_t __k = (__w + 31) / 32;
 uint_least32_t __arr[__r * __k];
 __q.generate(__arr + 0, __arr + __r * __k);
 for (size_t __i = 0; __i < long_lag; ++__i)
   {
     _UIntType __sum = 0u;
     _UIntType __factor = 1u;
     for (size_t __j = 0; __j < __k; ++__j)
       {
  __sum += __arr[__k * __i + __j] * __factor;
  __factor *= __detail::_Shift<_UIntType, 32>::__value;
       }
     _M_x[__i] = __detail::__mod<_UIntType,
       __detail::_Shift<_UIntType, __w>::__value>(__sum);
   }
 _M_carry = (_M_x[long_lag - 1] == 0) ? 1 : 0;
 _M_p = 0;
      }
  template<typename _UIntType, size_t __w, size_t __s, size_t __r>
    typename subtract_with_carry_engine<_UIntType, __w, __s, __r>::
      result_type
    subtract_with_carry_engine<_UIntType, __w, __s, __r>::
    operator()()
    {
      long __ps = _M_p - short_lag;
      if (__ps < 0)
 __ps += long_lag;
      _UIntType __xi;
      if (_M_x[__ps] >= _M_x[_M_p] + _M_carry)
 {
   __xi = _M_x[__ps] - _M_x[_M_p] - _M_carry;
   _M_carry = 0;
 }
      else
 {
   __xi = (__detail::_Shift<_UIntType, __w>::__value
    - _M_x[_M_p] - _M_carry + _M_x[__ps]);
   _M_carry = 1;
 }
      _M_x[_M_p] = __xi;
      if (++_M_p >= long_lag)
 _M_p = 0;
      return __xi;
    }
  template<typename _UIntType, size_t __w, size_t __s, size_t __r,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const subtract_with_carry_engine<_UIntType,
      __w, __s, __r>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__space);
      for (size_t __i = 0; __i < __r; ++__i)
 __os << __x._M_x[__i] << __space;
      __os << __x._M_carry;
      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }
  template<typename _UIntType, size_t __w, size_t __s, size_t __r,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        subtract_with_carry_engine<_UIntType, __w, __s, __r>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      for (size_t __i = 0; __i < __r; ++__i)
 __is >> __x._M_x[__i];
      __is >> __x._M_carry;
      __is.flags(__flags);
      return __is;
    }
  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    const size_t
    discard_block_engine<_RandomNumberEngine, __p, __r>::block_size;
  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    const size_t
    discard_block_engine<_RandomNumberEngine, __p, __r>::used_block;
  template<typename _RandomNumberEngine, size_t __p, size_t __r>
    typename discard_block_engine<_RandomNumberEngine,
      __p, __r>::result_type
    discard_block_engine<_RandomNumberEngine, __p, __r>::
    operator()()
    {
      if (_M_n >= used_block)
 {
   _M_b.discard(block_size - _M_n);
   _M_n = 0;
 }
      ++_M_n;
      return _M_b();
    }
  template<typename _RandomNumberEngine, size_t __p, size_t __r,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const discard_block_engine<_RandomNumberEngine,
        __p, __r>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__space);
      __os << __x.base() << __space << __x._M_n;
      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }
  template<typename _RandomNumberEngine, size_t __p, size_t __r,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        discard_block_engine<_RandomNumberEngine, __p, __r>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      __is >> __x._M_b >> __x._M_n;
      __is.flags(__flags);
      return __is;
    }
  template<typename _RandomNumberEngine, size_t __w, typename _UIntType>
    typename independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::
      result_type
    independent_bits_engine<_RandomNumberEngine, __w, _UIntType>::
    operator()()
    {
      const long double __r = static_cast<long double>(_M_b.max())
       - static_cast<long double>(_M_b.min()) + 1.0L;
      const result_type __m = std::log(__r) / std::log(2.0L);
      result_type __n, __n0, __y0, __y1, __s0, __s1;
      for (size_t __i = 0; __i < 2; ++__i)
 {
   __n = (__w + __m - 1) / __m + __i;
   __n0 = __n - __w % __n;
   const result_type __w0 = __w / __n;
   const result_type __w1 = __w0 + 1;
   __s0 = result_type(1) << __w0;
   __s1 = result_type(1) << __w1;
   __y0 = __s0 * (__r / __s0);
   __y1 = __s1 * (__r / __s1);
   if (__r - __y0 <= __y0 / __n)
     break;
 }
      result_type __sum = 0;
      for (size_t __k = 0; __k < __n0; ++__k)
 {
   result_type __u;
   do
     __u = _M_b() - _M_b.min();
   while (__u >= __y0);
   __sum = __s0 * __sum + __u % __s0;
 }
      for (size_t __k = __n0; __k < __n; ++__k)
 {
   result_type __u;
   do
     __u = _M_b() - _M_b.min();
   while (__u >= __y1);
   __sum = __s1 * __sum + __u % __s1;
 }
      return __sum;
    }
  template<typename _RandomNumberEngine, size_t __k>
    const size_t
    shuffle_order_engine<_RandomNumberEngine, __k>::table_size;
  template<typename _RandomNumberEngine, size_t __k>
    typename shuffle_order_engine<_RandomNumberEngine, __k>::result_type
    shuffle_order_engine<_RandomNumberEngine, __k>::
    operator()()
    {
      size_t __j = __k * ((_M_y - _M_b.min())
     / (_M_b.max() - _M_b.min() + 1.0L));
      _M_y = _M_v[__j];
      _M_v[__j] = _M_b();
      return _M_y;
    }
  template<typename _RandomNumberEngine, size_t __k,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const shuffle_order_engine<_RandomNumberEngine, __k>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::dec | __ios_base::fixed | __ios_base::left);
      __os.fill(__space);
      __os << __x.base();
      for (size_t __i = 0; __i < __k; ++__i)
 __os << __space << __x._M_v[__i];
      __os << __space << __x._M_y;
      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }
  template<typename _RandomNumberEngine, size_t __k,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        shuffle_order_engine<_RandomNumberEngine, __k>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      __is >> __x._M_b;
      for (size_t __i = 0; __i < __k; ++__i)
 __is >> __x._M_v[__i];
      __is >> __x._M_y;
      __is.flags(__flags);
      return __is;
    }
  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename uniform_int_distribution<_IntType>::result_type
      uniform_int_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 typedef typename std::make_unsigned<typename
   _UniformRandomNumberGenerator::result_type>::type __urntype;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::conditional<(sizeof(__urntype) > sizeof(__utype)),
   __urntype, __utype>::type __uctype;
 result_type __ret;
 const __urntype __urnmin = __urng.min();
 const __urntype __urnmax = __urng.max();
 const __urntype __urnrange = __urnmax - __urnmin;
 const __uctype __urange = __param.b() - __param.a();
 const __uctype __udenom = (__urnrange <= __urange
       ? 1 : __urnrange / (__urange + 1));
 do
   __ret = (__urntype(__urng()) - __urnmin) / __udenom;
 while (__ret > __param.b() - __param.a());
 return __ret + __param.a();
      }
  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const uniform_int_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os << __x.a() << __space << __x.b();
      __os.flags(__flags);
      __os.fill(__fill);
      return __os;
    }
  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        uniform_int_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      _IntType __a, __b;
      __is >> __a >> __b;
      __x.param(typename uniform_int_distribution<_IntType>::
  param_type(__a, __b));
      __is.flags(__flags);
      return __is;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const uniform_real_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);
      __os << __x.a() << __space << __x.b();
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        uniform_real_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);
      _RealType __a, __b;
      __is >> __a >> __b;
      __x.param(typename uniform_real_distribution<_RealType>::
  param_type(__a, __b));
      __is.flags(__flags);
      return __is;
    }
  template<typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const bernoulli_distribution& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<double>::max_digits10);
      __os << __x.p();
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename geometric_distribution<_IntType>::result_type
      geometric_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 const double __naf =
   (1 - std::numeric_limits<double>::epsilon()) / 2;
 const double __thr =
   std::numeric_limits<_IntType>::max() + __naf;
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);
 double __cand;
 do
   __cand = std::ceil(std::log(__aurng()) / __param._M_log_p);
 while (__cand >= __thr);
 return result_type(__cand + __naf);
      }
  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const geometric_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<double>::max_digits10);
      __os << __x.p();
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        geometric_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);
      double __p;
      __is >> __p;
      __x.param(typename geometric_distribution<_IntType>::param_type(__p));
      __is.flags(__flags);
      return __is;
    }
  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename negative_binomial_distribution<_IntType>::result_type
      negative_binomial_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng)
      {
 const double __y = _M_gd(__urng);
 std::poisson_distribution<result_type> __poisson(__y);
 return __poisson(__urng);
      }
  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename negative_binomial_distribution<_IntType>::result_type
      negative_binomial_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 typedef typename std::gamma_distribution<result_type>::param_type
   param_type;
 const double __y =
   _M_gd(__urng, param_type(__p.k(), __p.p() / (1.0 - __p.p())));
 std::poisson_distribution<result_type> __poisson(__y);
 return __poisson(__urng);
      }
  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const negative_binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<double>::max_digits10);
      __os << __x.k() << __space << __x.p()
    << __space << __x._M_gd;
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        negative_binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);
      _IntType __k;
      double __p;
      __is >> __k >> __p >> __x._M_gd;
      __x.param(typename negative_binomial_distribution<_IntType>::
  param_type(__k, __p));
      __is.flags(__flags);
      return __is;
    }
  template<typename _IntType>
    void
    poisson_distribution<_IntType>::param_type::
    _M_initialize()
    {
      if (_M_mean >= 12)
 {
   const double __m = std::floor(_M_mean);
   _M_lm_thr = std::log(_M_mean);
   _M_lfm = std::lgamma(__m + 1);
   _M_sm = std::sqrt(__m);
   const double __pi_4 = 0.7853981633974483096156608458198757L;
   const double __dx = std::sqrt(2 * __m * std::log(32 * __m
             / __pi_4));
   _M_d = std::round(std::max(6.0, std::min(__m, __dx)));
   const double __cx = 2 * __m + _M_d;
   _M_scx = std::sqrt(__cx / 2);
   _M_1cx = 1 / __cx;
   _M_c2b = std::sqrt(__pi_4 * __cx) * std::exp(_M_1cx);
   _M_cb = 2 * __cx * std::exp(-_M_d * _M_1cx * (1 + _M_d / 2))
  / _M_d;
 }
      else
 _M_lm_thr = std::exp(-_M_mean);
      }
  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename poisson_distribution<_IntType>::result_type
      poisson_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);
 if (__param.mean() >= 12)
   {
     double __x;
     const double __naf =
       (1 - std::numeric_limits<double>::epsilon()) / 2;
     const double __thr =
       std::numeric_limits<_IntType>::max() + __naf;
     const double __m = std::floor(__param.mean());
     const double __spi_2 = 1.2533141373155002512078826424055226L;
     const double __c1 = __param._M_sm * __spi_2;
     const double __c2 = __param._M_c2b + __c1;
     const double __c3 = __c2 + 1;
     const double __c4 = __c3 + 1;
     const double __e178 = 1.0129030479320018583185514777512983L;
     const double __c5 = __c4 + __e178;
     const double __c = __param._M_cb + __c5;
     const double __2cx = 2 * (2 * __m + __param._M_d);
     bool __reject = true;
     do
       {
  const double __u = __c * __aurng();
  const double __e = -std::log(__aurng());
  double __w = 0.0;
  if (__u <= __c1)
    {
      const double __n = _M_nd(__urng);
      const double __y = -std::abs(__n) * __param._M_sm - 1;
      __x = std::floor(__y);
      __w = -__n * __n / 2;
      if (__x < -__m)
        continue;
    }
  else if (__u <= __c2)
    {
      const double __n = _M_nd(__urng);
      const double __y = 1 + std::abs(__n) * __param._M_scx;
      __x = std::ceil(__y);
      __w = __y * (2 - __y) * __param._M_1cx;
      if (__x > __param._M_d)
        continue;
    }
  else if (__u <= __c3)
    __x = -1;
  else if (__u <= __c4)
    __x = 0;
  else if (__u <= __c5)
    __x = 1;
  else
    {
      const double __v = -std::log(__aurng());
      const double __y = __param._M_d
         + __v * __2cx / __param._M_d;
      __x = std::ceil(__y);
      __w = -__param._M_d * __param._M_1cx * (1 + __y / 2);
    }
  __reject = (__w - __e - __x * __param._M_lm_thr
       > __param._M_lfm - std::lgamma(__x + __m + 1));
  __reject |= __x + __m >= __thr;
       } while (__reject);
     return result_type(__x + __m + __naf);
   }
 else
   {
     _IntType __x = 0;
     double __prod = 1.0;
     do
       {
  __prod *= __aurng();
  __x += 1;
       }
     while (__prod > __param._M_lm_thr);
     return __x - 1;
   }
      }
  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const poisson_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<double>::max_digits10);
      __os << __x.mean() << __space << __x._M_nd;
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        poisson_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);
      double __mean;
      __is >> __mean >> __x._M_nd;
      __x.param(typename poisson_distribution<_IntType>::param_type(__mean));
      __is.flags(__flags);
      return __is;
    }
  template<typename _IntType>
    void
    binomial_distribution<_IntType>::param_type::
    _M_initialize()
    {
      const double __p12 = _M_p <= 0.5 ? _M_p : 1.0 - _M_p;
      _M_easy = true;
      if (_M_t * __p12 >= 8)
 {
   _M_easy = false;
   const double __np = std::floor(_M_t * __p12);
   const double __pa = __np / _M_t;
   const double __1p = 1 - __pa;
   const double __pi_4 = 0.7853981633974483096156608458198757L;
   const double __d1x =
     std::sqrt(__np * __1p * std::log(32 * __np
          / (81 * __pi_4 * __1p)));
   _M_d1 = std::round(std::max(1.0, __d1x));
   const double __d2x =
     std::sqrt(__np * __1p * std::log(32 * _M_t * __1p
          / (__pi_4 * __pa)));
   _M_d2 = std::round(std::max(1.0, __d2x));
   const double __spi_2 = 1.2533141373155002512078826424055226L;
   _M_s1 = std::sqrt(__np * __1p) * (1 + _M_d1 / (4 * __np));
   _M_s2 = std::sqrt(__np * __1p) * (1 + _M_d2 / (4 * _M_t * __1p));
   _M_c = 2 * _M_d1 / __np;
   _M_a1 = std::exp(_M_c) * _M_s1 * __spi_2;
   const double __a12 = _M_a1 + _M_s2 * __spi_2;
   const double __s1s = _M_s1 * _M_s1;
   _M_a123 = __a12 + (std::exp(_M_d1 / (_M_t * __1p))
        * 2 * __s1s / _M_d1
        * std::exp(-_M_d1 * _M_d1 / (2 * __s1s)));
   const double __s2s = _M_s2 * _M_s2;
   _M_s = (_M_a123 + 2 * __s2s / _M_d2
    * std::exp(-_M_d2 * _M_d2 / (2 * __s2s)));
   _M_lf = (std::lgamma(__np + 1)
     + std::lgamma(_M_t - __np + 1));
   _M_lp1p = std::log(__pa / __1p);
   _M_q = -std::log(1 - (__p12 - __pa) / __1p);
 }
      else
 _M_q = -std::log(1 - __p12);
    }
  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename binomial_distribution<_IntType>::result_type
      binomial_distribution<_IntType>::
      _M_waiting(_UniformRandomNumberGenerator& __urng, _IntType __t)
      {
 _IntType __x = 0;
 double __sum = 0.0;
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);
 do
   {
     const double __e = -std::log(__aurng());
     __sum += __e / (__t - __x);
     __x += 1;
   }
 while (__sum <= _M_param._M_q);
 return __x - 1;
      }
  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename binomial_distribution<_IntType>::result_type
      binomial_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 result_type __ret;
 const _IntType __t = __param.t();
 const double __p = __param.p();
 const double __p12 = __p <= 0.5 ? __p : 1.0 - __p;
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);
 if (!__param._M_easy)
   {
     double __x;
     const double __naf =
       (1 - std::numeric_limits<double>::epsilon()) / 2;
     const double __thr =
       std::numeric_limits<_IntType>::max() + __naf;
     const double __np = std::floor(__t * __p12);
     const double __spi_2 = 1.2533141373155002512078826424055226L;
     const double __a1 = __param._M_a1;
     const double __a12 = __a1 + __param._M_s2 * __spi_2;
     const double __a123 = __param._M_a123;
     const double __s1s = __param._M_s1 * __param._M_s1;
     const double __s2s = __param._M_s2 * __param._M_s2;
     bool __reject;
     do
       {
  const double __u = __param._M_s * __aurng();
  double __v;
  if (__u <= __a1)
    {
      const double __n = _M_nd(__urng);
      const double __y = __param._M_s1 * std::abs(__n);
      __reject = __y >= __param._M_d1;
      if (!__reject)
        {
   const double __e = -std::log(__aurng());
   __x = std::floor(__y);
   __v = -__e - __n * __n / 2 + __param._M_c;
        }
    }
  else if (__u <= __a12)
    {
      const double __n = _M_nd(__urng);
      const double __y = __param._M_s2 * std::abs(__n);
      __reject = __y >= __param._M_d2;
      if (!__reject)
        {
   const double __e = -std::log(__aurng());
   __x = std::floor(-__y);
   __v = -__e - __n * __n / 2;
        }
    }
  else if (__u <= __a123)
    {
      const double __e1 = -std::log(__aurng());
      const double __e2 = -std::log(__aurng());
      const double __y = __param._M_d1
         + 2 * __s1s * __e1 / __param._M_d1;
      __x = std::floor(__y);
      __v = (-__e2 + __param._M_d1 * (1 / (__t - __np)
          -__y / (2 * __s1s)));
      __reject = false;
    }
  else
    {
      const double __e1 = -std::log(__aurng());
      const double __e2 = -std::log(__aurng());
      const double __y = __param._M_d2
         + 2 * __s2s * __e1 / __param._M_d2;
      __x = std::floor(-__y);
      __v = -__e2 - __param._M_d2 * __y / (2 * __s2s);
      __reject = false;
    }
  __reject = __reject || __x < -__np || __x > __t - __np;
  if (!__reject)
    {
      const double __lfx =
        std::lgamma(__np + __x + 1)
        + std::lgamma(__t - (__np + __x) + 1);
      __reject = __v > __param._M_lf - __lfx
        + __x * __param._M_lp1p;
    }
  __reject |= __x + __np >= __thr;
       }
     while (__reject);
     __x += __np + __naf;
     const _IntType __z = _M_waiting(__urng, __t - _IntType(__x));
     __ret = _IntType(__x) + __z;
   }
 else
   __ret = _M_waiting(__urng, __t);
 if (__p12 != __p)
   __ret = __t - __ret;
 return __ret;
      }
  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<double>::max_digits10);
      __os << __x.t() << __space << __x.p()
    << __space << __x._M_nd;
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _IntType,
    typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      _IntType __t;
      double __p;
      __is >> __t >> __p >> __x._M_nd;
      __x.param(typename binomial_distribution<_IntType>::
  param_type(__t, __p));
      __is.flags(__flags);
      return __is;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const exponential_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<_RealType>::max_digits10);
      __os << __x.lambda();
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        exponential_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      _RealType __lambda;
      __is >> __lambda;
      __x.param(typename exponential_distribution<_RealType>::
  param_type(__lambda));
      __is.flags(__flags);
      return __is;
    }
  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename normal_distribution<_RealType>::result_type
      normal_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 result_type __ret;
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 if (_M_saved_available)
   {
     _M_saved_available = false;
     __ret = _M_saved;
   }
 else
   {
     result_type __x, __y, __r2;
     do
       {
  __x = result_type(2.0) * __aurng() - 1.0;
  __y = result_type(2.0) * __aurng() - 1.0;
  __r2 = __x * __x + __y * __y;
       }
     while (__r2 > 1.0 || __r2 == 0.0);
     const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
     _M_saved = __x * __mult;
     _M_saved_available = true;
     __ret = __y * __mult;
   }
 __ret = __ret * __param.stddev() + __param.mean();
 return __ret;
      }
  template<typename _RealType>
    bool
    operator==(const std::normal_distribution<_RealType>& __d1,
        const std::normal_distribution<_RealType>& __d2)
    {
      if (__d1._M_param == __d2._M_param
   && __d1._M_saved_available == __d2._M_saved_available)
 {
   if (__d1._M_saved_available
       && __d1._M_saved == __d2._M_saved)
     return true;
   else if(!__d1._M_saved_available)
     return true;
   else
     return false;
 }
      else
 return false;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const normal_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);
      __os << __x.mean() << __space << __x.stddev()
    << __space << __x._M_saved_available;
      if (__x._M_saved_available)
 __os << __space << __x._M_saved;
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        normal_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      double __mean, __stddev;
      __is >> __mean >> __stddev
    >> __x._M_saved_available;
      if (__x._M_saved_available)
 __is >> __x._M_saved;
      __x.param(typename normal_distribution<_RealType>::
  param_type(__mean, __stddev));
      __is.flags(__flags);
      return __is;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const lognormal_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);
      __os << __x.m() << __space << __x.s()
    << __space << __x._M_nd;
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        lognormal_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      _RealType __m, __s;
      __is >> __m >> __s >> __x._M_nd;
      __x.param(typename lognormal_distribution<_RealType>::
  param_type(__m, __s));
      __is.flags(__flags);
      return __is;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const chi_squared_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);
      __os << __x.n() << __space << __x._M_gd;
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        chi_squared_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      _RealType __n;
      __is >> __n >> __x._M_gd;
      __x.param(typename chi_squared_distribution<_RealType>::
  param_type(__n));
      __is.flags(__flags);
      return __is;
    }
  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename cauchy_distribution<_RealType>::result_type
      cauchy_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 _RealType __u;
 do
   __u = __aurng();
 while (__u == 0.5);
 const _RealType __pi = 3.1415926535897932384626433832795029L;
 return __p.a() + __p.b() * std::tan(__pi * __u);
      }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const cauchy_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);
      __os << __x.a() << __space << __x.b();
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        cauchy_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      _RealType __a, __b;
      __is >> __a >> __b;
      __x.param(typename cauchy_distribution<_RealType>::
  param_type(__a, __b));
      __is.flags(__flags);
      return __is;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const fisher_f_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);
      __os << __x.m() << __space << __x.n()
    << __space << __x._M_gd_x << __space << __x._M_gd_y;
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        fisher_f_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      _RealType __m, __n;
      __is >> __m >> __n >> __x._M_gd_x >> __x._M_gd_y;
      __x.param(typename fisher_f_distribution<_RealType>::
  param_type(__m, __n));
      __is.flags(__flags);
      return __is;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const student_t_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);
      __os << __x.n() << __space << __x._M_nd << __space << __x._M_gd;
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        student_t_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      _RealType __n;
      __is >> __n >> __x._M_nd >> __x._M_gd;
      __x.param(typename student_t_distribution<_RealType>::param_type(__n));
      __is.flags(__flags);
      return __is;
    }
  template<typename _RealType>
    void
    gamma_distribution<_RealType>::param_type::
    _M_initialize()
    {
      _M_malpha = _M_alpha < 1.0 ? _M_alpha + _RealType(1.0) : _M_alpha;
      const _RealType __a1 = _M_malpha - _RealType(1.0) / _RealType(3.0);
      _M_a2 = _RealType(1.0) / std::sqrt(_RealType(9.0) * __a1);
    }
  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename gamma_distribution<_RealType>::result_type
      gamma_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 result_type __u, __v, __n;
 const result_type __a1 = (__param._M_malpha
      - _RealType(1.0) / _RealType(3.0));
 do
   {
     do
       {
  __n = _M_nd(__urng);
  __v = result_type(1.0) + __param._M_a2 * __n;
       }
     while (__v <= 0.0);
     __v = __v * __v * __v;
     __u = __aurng();
   }
 while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
        && (std::log(__u) > (0.5 * __n * __n + __a1
        * (1.0 - __v + std::log(__v)))));
 if (__param.alpha() == __param._M_malpha)
   return __a1 * __v * __param.beta();
 else
   {
     do
       __u = __aurng();
     while (__u == 0.0);
     return (std::pow(__u, result_type(1.0) / __param.alpha())
      * __a1 * __v * __param.beta());
   }
      }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const gamma_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);
      __os << __x.alpha() << __space << __x.beta()
    << __space << __x._M_nd;
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        gamma_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      _RealType __alpha_val, __beta_val;
      __is >> __alpha_val >> __beta_val >> __x._M_nd;
      __x.param(typename gamma_distribution<_RealType>::
  param_type(__alpha_val, __beta_val));
      __is.flags(__flags);
      return __is;
    }
  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename weibull_distribution<_RealType>::result_type
      weibull_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 return __p.b() * std::pow(-std::log(__aurng()),
      result_type(1) / __p.a());
      }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const weibull_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);
      __os << __x.a() << __space << __x.b();
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        weibull_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      _RealType __a, __b;
      __is >> __a >> __b;
      __x.param(typename weibull_distribution<_RealType>::
  param_type(__a, __b));
      __is.flags(__flags);
      return __is;
    }
  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename extreme_value_distribution<_RealType>::result_type
      extreme_value_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __p)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
   __aurng(__urng);
 return __p.a() - __p.b() * std::log(-std::log(__aurng()));
      }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const extreme_value_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);
      __os << __x.a() << __space << __x.b();
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        extreme_value_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      _RealType __a, __b;
      __is >> __a >> __b;
      __x.param(typename extreme_value_distribution<_RealType>::
  param_type(__a, __b));
      __is.flags(__flags);
      return __is;
    }
  template<typename _IntType>
    void
    discrete_distribution<_IntType>::param_type::
    _M_initialize()
    {
      if (_M_prob.size() < 2)
 {
   _M_prob.clear();
   _M_prob.push_back(1.0);
   return;
 }
      const double __sum = std::accumulate(_M_prob.begin(),
        _M_prob.end(), 0.0);
      __detail::__transform(_M_prob.begin(), _M_prob.end(), _M_prob.begin(),
     std::bind2nd(std::divides<double>(), __sum));
      _M_cp.reserve(_M_prob.size());
      std::partial_sum(_M_prob.begin(), _M_prob.end(),
         std::back_inserter(_M_cp));
      _M_cp[_M_cp.size() - 1] = 1.0;
    }
  template<typename _IntType>
    template<typename _Func>
      discrete_distribution<_IntType>::param_type::
      param_type(size_t __nw, double __xmin, double __xmax, _Func __fw)
      : _M_prob(), _M_cp()
      {
 const size_t __n = __nw == 0 ? 1 : __nw;
 const double __delta = (__xmax - __xmin) / __n;
 _M_prob.reserve(__n);
 for (size_t __k = 0; __k < __nw; ++__k)
   _M_prob.push_back(__fw(__xmin + __k * __delta + 0.5 * __delta));
 _M_initialize();
      }
  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename discrete_distribution<_IntType>::result_type
      discrete_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);
 const double __p = __aurng();
 auto __pos = std::lower_bound(__param._M_cp.begin(),
          __param._M_cp.end(), __p);
 return __pos - __param._M_cp.begin();
      }
  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const discrete_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<double>::max_digits10);
      std::vector<double> __prob = __x.probabilities();
      __os << __prob.size();
      for (auto __dit = __prob.begin(); __dit != __prob.end(); ++__dit)
 __os << __space << *__dit;
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        discrete_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      size_t __n;
      __is >> __n;
      std::vector<double> __prob_vec;
      __prob_vec.reserve(__n);
      for (; __n != 0; --__n)
 {
   double __prob;
   __is >> __prob;
   __prob_vec.push_back(__prob);
 }
      __x.param(typename discrete_distribution<_IntType>::
  param_type(__prob_vec.begin(), __prob_vec.end()));
      __is.flags(__flags);
      return __is;
    }
  template<typename _RealType>
    void
    piecewise_constant_distribution<_RealType>::param_type::
    _M_initialize()
    {
      if (_M_int.size() < 2)
 {
   _M_int.clear();
   _M_int.reserve(2);
   _M_int.push_back(_RealType(0));
   _M_int.push_back(_RealType(1));
   _M_den.clear();
   _M_den.push_back(1.0);
   return;
 }
      const double __sum = std::accumulate(_M_den.begin(),
        _M_den.end(), 0.0);
      __detail::__transform(_M_den.begin(), _M_den.end(), _M_den.begin(),
       std::bind2nd(std::divides<double>(), __sum));
      _M_cp.reserve(_M_den.size());
      std::partial_sum(_M_den.begin(), _M_den.end(),
         std::back_inserter(_M_cp));
      _M_cp[_M_cp.size() - 1] = 1.0;
      for (size_t __k = 0; __k < _M_den.size(); ++__k)
 _M_den[__k] /= _M_int[__k + 1] - _M_int[__k];
    }
  template<typename _RealType>
    template<typename _InputIteratorB, typename _InputIteratorW>
      piecewise_constant_distribution<_RealType>::param_type::
      param_type(_InputIteratorB __bbegin,
   _InputIteratorB __bend,
   _InputIteratorW __wbegin)
      : _M_int(), _M_den(), _M_cp()
      {
 if (__bbegin != __bend)
   {
     for (;;)
       {
  _M_int.push_back(*__bbegin);
  ++__bbegin;
  if (__bbegin == __bend)
    break;
  _M_den.push_back(*__wbegin);
  ++__wbegin;
       }
   }
 _M_initialize();
      }
  template<typename _RealType>
    template<typename _Func>
      piecewise_constant_distribution<_RealType>::param_type::
      param_type(initializer_list<_RealType> __bl, _Func __fw)
      : _M_int(), _M_den(), _M_cp()
      {
 _M_int.reserve(__bl.size());
 for (auto __biter = __bl.begin(); __biter != __bl.end(); ++__biter)
   _M_int.push_back(*__biter);
 _M_den.reserve(_M_int.size() - 1);
 for (size_t __k = 0; __k < _M_int.size() - 1; ++__k)
   _M_den.push_back(__fw(0.5 * (_M_int[__k + 1] + _M_int[__k])));
 _M_initialize();
      }
  template<typename _RealType>
    template<typename _Func>
      piecewise_constant_distribution<_RealType>::param_type::
      param_type(size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw)
      : _M_int(), _M_den(), _M_cp()
      {
 const size_t __n = __nw == 0 ? 1 : __nw;
 const _RealType __delta = (__xmax - __xmin) / __n;
 _M_int.reserve(__n + 1);
 for (size_t __k = 0; __k <= __nw; ++__k)
   _M_int.push_back(__xmin + __k * __delta);
 _M_den.reserve(__n);
 for (size_t __k = 0; __k < __nw; ++__k)
   _M_den.push_back(__fw(_M_int[__k] + 0.5 * __delta));
 _M_initialize();
      }
  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename piecewise_constant_distribution<_RealType>::result_type
      piecewise_constant_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);
 const double __p = __aurng();
 auto __pos = std::lower_bound(__param._M_cp.begin(),
          __param._M_cp.end(), __p);
 const size_t __i = __pos - __param._M_cp.begin();
 const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.0;
 return __param._M_int[__i] + (__p - __pref) / __param._M_den[__i];
      }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const piecewise_constant_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);
      std::vector<_RealType> __int = __x.intervals();
      __os << __int.size() - 1;
      for (auto __xit = __int.begin(); __xit != __int.end(); ++__xit)
 __os << __space << *__xit;
      std::vector<double> __den = __x.densities();
      for (auto __dit = __den.begin(); __dit != __den.end(); ++__dit)
 __os << __space << *__dit;
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        piecewise_constant_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      size_t __n;
      __is >> __n;
      std::vector<_RealType> __int_vec;
      __int_vec.reserve(__n + 1);
      for (size_t __i = 0; __i <= __n; ++__i)
 {
   _RealType __int;
   __is >> __int;
   __int_vec.push_back(__int);
 }
      std::vector<double> __den_vec;
      __den_vec.reserve(__n);
      for (size_t __i = 0; __i < __n; ++__i)
 {
   double __den;
   __is >> __den;
   __den_vec.push_back(__den);
 }
      __x.param(typename piecewise_constant_distribution<_RealType>::
   param_type(__int_vec.begin(), __int_vec.end(), __den_vec.begin()));
      __is.flags(__flags);
      return __is;
    }
  template<typename _RealType>
    void
    piecewise_linear_distribution<_RealType>::param_type::
    _M_initialize()
    {
      if (_M_int.size() < 2)
 {
   _M_int.clear();
   _M_int.reserve(2);
   _M_int.push_back(_RealType(0));
   _M_int.push_back(_RealType(1));
   _M_den.clear();
   _M_den.reserve(2);
   _M_den.push_back(1.0);
   _M_den.push_back(1.0);
   return;
 }
      double __sum = 0.0;
      _M_cp.reserve(_M_int.size() - 1);
      _M_m.reserve(_M_int.size() - 1);
      for (size_t __k = 0; __k < _M_int.size() - 1; ++__k)
 {
   const _RealType __delta = _M_int[__k + 1] - _M_int[__k];
   __sum += 0.5 * (_M_den[__k + 1] + _M_den[__k]) * __delta;
   _M_cp.push_back(__sum);
   _M_m.push_back((_M_den[__k + 1] - _M_den[__k]) / __delta);
 }
      __detail::__transform(_M_den.begin(), _M_den.end(), _M_den.begin(),
     std::bind2nd(std::divides<double>(), __sum));
      __detail::__transform(_M_cp.begin(), _M_cp.end(), _M_cp.begin(),
       std::bind2nd(std::divides<double>(), __sum));
      __detail::__transform(_M_m.begin(), _M_m.end(), _M_m.begin(),
       std::bind2nd(std::divides<double>(), __sum));
      _M_cp[_M_cp.size() - 1] = 1.0;
     }
  template<typename _RealType>
    template<typename _InputIteratorB, typename _InputIteratorW>
      piecewise_linear_distribution<_RealType>::param_type::
      param_type(_InputIteratorB __bbegin,
   _InputIteratorB __bend,
   _InputIteratorW __wbegin)
      : _M_int(), _M_den(), _M_cp(), _M_m()
      {
 for (; __bbegin != __bend; ++__bbegin, ++__wbegin)
   {
     _M_int.push_back(*__bbegin);
     _M_den.push_back(*__wbegin);
   }
 _M_initialize();
      }
  template<typename _RealType>
    template<typename _Func>
      piecewise_linear_distribution<_RealType>::param_type::
      param_type(initializer_list<_RealType> __bl, _Func __fw)
      : _M_int(), _M_den(), _M_cp(), _M_m()
      {
 _M_int.reserve(__bl.size());
 _M_den.reserve(__bl.size());
 for (auto __biter = __bl.begin(); __biter != __bl.end(); ++__biter)
   {
     _M_int.push_back(*__biter);
     _M_den.push_back(__fw(*__biter));
   }
 _M_initialize();
      }
  template<typename _RealType>
    template<typename _Func>
      piecewise_linear_distribution<_RealType>::param_type::
      param_type(size_t __nw, _RealType __xmin, _RealType __xmax, _Func __fw)
      : _M_int(), _M_den(), _M_cp(), _M_m()
      {
 const size_t __n = __nw == 0 ? 1 : __nw;
 const _RealType __delta = (__xmax - __xmin) / __n;
 _M_int.reserve(__n + 1);
 _M_den.reserve(__n + 1);
 for (size_t __k = 0; __k <= __nw; ++__k)
   {
     _M_int.push_back(__xmin + __k * __delta);
     _M_den.push_back(__fw(_M_int[__k] + __delta));
   }
 _M_initialize();
      }
  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename piecewise_linear_distribution<_RealType>::result_type
      piecewise_linear_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 __detail::_Adaptor<_UniformRandomNumberGenerator, double>
   __aurng(__urng);
 const double __p = __aurng();
 if (__param._M_m.empty())
   return __p;
 auto __pos = std::lower_bound(__param._M_cp.begin(),
          __param._M_cp.end(), __p);
 const size_t __i = __pos - __param._M_cp.begin();
 const double __pref = __i > 0 ? __param._M_cp[__i - 1] : 0.0;
 const double __a = 0.5 * __param._M_m[__i];
 const double __b = __param._M_den[__i];
 const double __cm = __p - __pref;
 _RealType __x = __param._M_int[__i];
 if (__a == 0)
   __x += __cm / __b;
 else
   {
     const double __d = __b * __b + 4.0 * __a * __cm;
     __x += 0.5 * (std::sqrt(__d) - __b) / __a;
          }
        return __x;
      }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
        const piecewise_linear_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);
      std::vector<_RealType> __int = __x.intervals();
      __os << __int.size() - 1;
      for (auto __xit = __int.begin(); __xit != __int.end(); ++__xit)
 __os << __space << *__xit;
      std::vector<double> __den = __x.densities();
      for (auto __dit = __den.begin(); __dit != __den.end(); ++__dit)
 __os << __space << *__dit;
      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }
  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
        piecewise_linear_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::ios_base __ios_base;
      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);
      size_t __n;
      __is >> __n;
      std::vector<_RealType> __int_vec;
      __int_vec.reserve(__n + 1);
      for (size_t __i = 0; __i <= __n; ++__i)
 {
   _RealType __int;
   __is >> __int;
   __int_vec.push_back(__int);
 }
      std::vector<double> __den_vec;
      __den_vec.reserve(__n + 1);
      for (size_t __i = 0; __i <= __n; ++__i)
 {
   double __den;
   __is >> __den;
   __den_vec.push_back(__den);
 }
      __x.param(typename piecewise_linear_distribution<_RealType>::
   param_type(__int_vec.begin(), __int_vec.end(), __den_vec.begin()));
      __is.flags(__flags);
      return __is;
    }
  template<typename _IntType>
    seed_seq::seed_seq(std::initializer_list<_IntType> __il)
    {
      for (auto __iter = __il.begin(); __iter != __il.end(); ++__iter)
 _M_v.push_back(__detail::__mod<result_type,
         __detail::_Shift<result_type, 32>::__value>(*__iter));
    }
  template<typename _InputIterator>
    seed_seq::seed_seq(_InputIterator __begin, _InputIterator __end)
    {
      for (_InputIterator __iter = __begin; __iter != __end; ++__iter)
 _M_v.push_back(__detail::__mod<result_type,
         __detail::_Shift<result_type, 32>::__value>(*__iter));
    }
  template<typename _RandomAccessIterator>
    void
    seed_seq::generate(_RandomAccessIterator __begin,
         _RandomAccessIterator __end)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
        _Type;
      if (__begin == __end)
 return;
      std::fill(__begin, __end, _Type(0x8b8b8b8bu));
      const size_t __n = __end - __begin;
      const size_t __s = _M_v.size();
      const size_t __t = (__n >= 623) ? 11
         : (__n >= 68) ? 7
         : (__n >= 39) ? 5
         : (__n >= 7) ? 3
         : (__n - 1) / 2;
      const size_t __p = (__n - __t) / 2;
      const size_t __q = __p + __t;
      const size_t __m = std::max(__s + 1, __n);
      for (size_t __k = 0; __k < __m; ++__k)
 {
   _Type __arg = (__begin[__k % __n]
    ^ __begin[(__k + __p) % __n]
    ^ __begin[(__k - 1) % __n]);
   _Type __r1 = __arg ^ (__arg << 27);
   __r1 = __detail::__mod<_Type, __detail::_Shift<_Type, 32>::__value,
                          1664525u, 0u>(__r1);
   _Type __r2 = __r1;
   if (__k == 0)
     __r2 += __s;
   else if (__k <= __s)
     __r2 += __k % __n + _M_v[__k - 1];
   else
     __r2 += __k % __n;
   __r2 = __detail::__mod<_Type,
            __detail::_Shift<_Type, 32>::__value>(__r2);
   __begin[(__k + __p) % __n] += __r1;
   __begin[(__k + __q) % __n] += __r2;
   __begin[__k % __n] = __r2;
 }
      for (size_t __k = __m; __k < __m + __n; ++__k)
 {
   _Type __arg = (__begin[__k % __n]
    + __begin[(__k + __p) % __n]
    + __begin[(__k - 1) % __n]);
   _Type __r3 = __arg ^ (__arg << 27);
   __r3 = __detail::__mod<_Type, __detail::_Shift<_Type, 32>::__value,
                          1566083941u, 0u>(__r3);
   _Type __r4 = __r3 - __k % __n;
   __r4 = __detail::__mod<_Type,
            __detail::_Shift<_Type, 32>::__value>(__r4);
   __begin[(__k + __p) % __n] ^= __r4;
   __begin[(__k + __q) % __n] ^= __r3;
   __begin[__k % __n] = __r4;
 }
    }
  template<typename _RealType, size_t __bits,
    typename _UniformRandomNumberGenerator>
    _RealType
    generate_canonical(_UniformRandomNumberGenerator& __urng)
    {
      const size_t __b
 = std::min(static_cast<size_t>(std::numeric_limits<_RealType>::digits),
                   __bits);
      const long double __r = static_cast<long double>(__urng.max())
       - static_cast<long double>(__urng.min()) + 1.0L;
      const size_t __log2r = std::log(__r) / std::log(2.0L);
      size_t __k = std::max<size_t>(1UL, (__b + __log2r - 1UL) / __log2r);
      _RealType __sum = _RealType(0);
      _RealType __tmp = _RealType(1);
      for (; __k != 0; --__k)
 {
   __sum += _RealType(__urng() - __urng.min()) * __tmp;
   __tmp *= __r;
 }
      return __sum / __tmp;
    }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Iterator>
    void
    __move_median_first(_Iterator __a, _Iterator __b, _Iterator __c)
    {
     
      if (*__a < *__b)
 {
   if (*__b < *__c)
     std::iter_swap(__a, __b);
   else if (*__a < *__c)
     std::iter_swap(__a, __c);
 }
      else if (*__a < *__c)
 return;
      else if (*__b < *__c)
 std::iter_swap(__a, __c);
      else
 std::iter_swap(__a, __b);
    }
  template<typename _Iterator, typename _Compare>
    void
    __move_median_first(_Iterator __a, _Iterator __b, _Iterator __c,
   _Compare __comp)
    {
     
      if (__comp(*__a, *__b))
 {
   if (__comp(*__b, *__c))
     std::iter_swap(__a, __b);
   else if (__comp(*__a, *__c))
     std::iter_swap(__a, __c);
 }
      else if (__comp(*__a, *__c))
 return;
      else if (__comp(*__b, *__c))
 std::iter_swap(__a, __c);
      else
 std::iter_swap(__a, __b);
    }
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    __find(_InputIterator __first, _InputIterator __last,
    const _Tp& __val, input_iterator_tag)
    {
      while (__first != __last && !(*__first == __val))
 ++__first;
      return __first;
    }
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !bool(__pred(*__first)))
 ++__first;
      return __first;
    }
  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __find(_RandomAccessIterator __first, _RandomAccessIterator __last,
    const _Tp& __val, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;
      for (; __trip_count > 0; --__trip_count)
 {
   if (*__first == __val)
     return __first;
   ++__first;
   if (*__first == __val)
     return __first;
   ++__first;
   if (*__first == __val)
     return __first;
   ++__first;
   if (*__first == __val)
     return __first;
   ++__first;
 }
      switch (__last - __first)
 {
 case 3:
   if (*__first == __val)
     return __first;
   ++__first;
 case 2:
   if (*__first == __val)
     return __first;
   ++__first;
 case 1:
   if (*__first == __val)
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }
  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;
      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(*__first))
     return __first;
   ++__first;
   if (__pred(*__first))
     return __first;
   ++__first;
   if (__pred(*__first))
     return __first;
   ++__first;
   if (__pred(*__first))
     return __first;
   ++__first;
 }
      switch (__last - __first)
 {
 case 3:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(*__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && bool(__pred(*__first)))
 ++__first;
      return __first;
    }
  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if_not(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;
      for (; __trip_count > 0; --__trip_count)
 {
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 }
      switch (__last - __first)
 {
 case 3:
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 case 2:
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 case 1:
   if (!bool(__pred(*__first)))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        std::forward_iterator_tag)
    {
      __first = std::find(__first, __last, __val);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && *__i == __val)
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::find(++__i, __last, __val);
 }
      return __last;
    }
  template<typename _RandomAccessIter, typename _Integer, typename _Tp>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;
      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;
      if (__tailSize < __pattSize)
        return __last;
      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;
      while (1)
 {
   while (!(*__lookAhead == __val))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        *__backTrack == __val; --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::forward_iterator_tag)
    {
      while (__first != __last && !bool(__binary_pred(*__first, __val)))
        ++__first;
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && bool(__binary_pred(*__i, __val)))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = ++__i;
   while (__first != __last
   && !bool(__binary_pred(*__first, __val)))
     ++__first;
 }
      return __last;
    }
  template<typename _RandomAccessIter, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    _RandomAccessIter
    __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
        _Integer __count, const _Tp& __val,
        _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;
      _DistanceType __tailSize = __last - __first;
      const _DistanceType __pattSize = __count;
      if (__tailSize < __pattSize)
        return __last;
      const _DistanceType __skipOffset = __pattSize - 1;
      _RandomAccessIter __lookAhead = __first + __skipOffset;
      __tailSize -= __pattSize;
      while (1)
 {
   while (!bool(__binary_pred(*__lookAhead, __val)))
     {
       if (__tailSize < __pattSize)
  return __last;
       __lookAhead += __pattSize;
       __tailSize -= __pattSize;
     }
   _DistanceType __remainder = __skipOffset;
   for (_RandomAccessIter __backTrack = __lookAhead - 1;
        __binary_pred(*__backTrack, __val); --__backTrack)
     {
       if (--__remainder == 0)
  return (__lookAhead - __skipOffset);
     }
   if (__remainder > __tailSize)
     return __last;
   __lookAhead += __remainder;
   __tailSize -= __remainder;
 }
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2, __last2);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;
      else
 {
   _ForwardIterator1 __result = __last1;
   while (1)
     {
       _ForwardIterator1 __new_result
  = std::search(__first1, __last1, __first2,
      __last2, __comp);
       if (__new_result == __last1)
  return __result;
       else
  {
    __result = __new_result;
    __first1 = __new_result;
    ++__first1;
  }
     }
 }
    }
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag)
    {
     
     
      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;
      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1),
             __rlast1,
             _RevIterator2(__last2),
             __rlast2);
      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {
     
     
      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;
      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::search(_RevIterator1(__last1), __rlast1,
         _RevIterator2(__last2), __rlast2,
         __comp);
      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
     
     
     
      ;
      ;
      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2));
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {
     
     
     
      ;
      ;
      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __comp);
    }
  template<typename _InputIterator, typename _Predicate>
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }
  template<typename _InputIterator, typename _Predicate>
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if(__first, __last, __pred); }
  template<typename _InputIterator, typename _Predicate>
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
  _Predicate __pred)
    {
     
     
      ;
      return std::__find_if_not(__first, __last, __pred,
    std::__iterator_category(__first));
    }
  template<typename _InputIterator, typename _Predicate>
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      return std::none_of(__first, __last, __pred);
    }
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {
     
     
      ;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__pred(*__middle))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {
     
     
     
      ;
      for (; __first != __last; ++__first)
 if (!(*__first == __value))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {
     
     
     
      ;
      for (; __first != __last; ++__first)
 if (!bool(__pred(*__first)))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {
     
     
     
      ;
      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag)
    {
      for (; __n > 0; --__n)
 {
   *__result = *__first;
   ++__first;
   ++__result;
 }
      return __result;
    }
  template<typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator>
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {
     
     
      return std::__copy_n(__first, __n, __result,
      std::__iterator_category(__first));
    }
  template<typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate>
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred)
    {
     
     
     
     
      ;
      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__out_true = *__first;
     ++__out_true;
   }
 else
   {
     *__out_false = *__first;
     ++__out_false;
   }
      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {
     
     
      ;
      __first = std::find(__first, __last, __value);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!(*__first == __value))
          {
            *__result = std::move(*__first);
            ++__result;
          }
      return __result;
    }
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {
     
     
      ;
      __first = std::find_if(__first, __last, __pred);
      if(__first == __last)
        return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for(; __first != __last; ++__first)
        if(!bool(__pred(*__first)))
          {
            *__result = std::move(*__first);
            ++__result;
          }
      return __result;
    }
  template<typename _ForwardIterator>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {
     
     
      ;
      __first = std::adjacent_find(__first, __last);
      if (__first == __last)
 return __last;
      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!(*__dest == *__first))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
           _BinaryPredicate __binary_pred)
    {
     
     
      ;
      __first = std::adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;
      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__dest, *__first)))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result,
    forward_iterator_tag, output_iterator_tag)
    {
      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!(*__first == *__next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }
  template<typename _InputIterator, typename _OutputIterator>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result,
    input_iterator_tag, output_iterator_tag)
    {
      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!(__value == *__first))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
  template<typename _InputIterator, typename _ForwardIterator>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result,
    input_iterator_tag, forward_iterator_tag)
    {
      *__result = *__first;
      while (++__first != __last)
 if (!(*__result == *__first))
   *++__result = *__first;
      return ++__result;
    }
  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {
     
      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!bool(__binary_pred(*__first, *__next)))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {
     
      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      *__result = __value;
      while (++__first != __last)
 if (!bool(__binary_pred(__value, *__first)))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {
     
      *__result = *__first;
      while (++__first != __last)
 if (!bool(__binary_pred(*__result, *__first)))
   *++__result = *__first;
      return ++__result;
    }
  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }
  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {
     
      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {
     
     
      ;
      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }
  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }
  template<typename _ForwardIterator>
    void
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle || __last == __middle)
 return;
      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);
      __first2 = __middle;
      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
    }
  template<typename _BidirectionalIterator>
    void
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
     
      if (__first == __middle || __last == __middle)
 return;
      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());
      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }
      if (__first == __middle)
 std::__reverse(__middle, __last, bidirectional_iterator_tag());
      else
 std::__reverse(__first, __middle, bidirectional_iterator_tag());
    }
  template<typename _RandomAccessIterator>
    void
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {
     
      if (__first == __middle || __last == __middle)
 return;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;
      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return;
 }
      _RandomAccessIterator __p = __first;
      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*__p);
    std::move(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = std::move(__t);
    return;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*(__p + __n - 1));
    std::move_backward(__p, __p + __n - 1, __p + __n);
    *__p = std::move(__t);
    return;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return;
       std::swap(__n, __k);
     }
 }
    }
  template<typename _ForwardIterator>
    inline void
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {
     
      ;
      ;
      typedef typename iterator_traits<_ForwardIterator>::iterator_category
 _IterType;
      std::__rotate(__first, __middle, __last, _IterType());
    }
  template<typename _ForwardIterator, typename _OutputIterator>
    _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                _ForwardIterator __last, _OutputIterator __result)
    {
     
     
      ;
      ;
      return std::copy(__first, __middle,
                       std::copy(__middle, __last, __result));
    }
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;
      while (__pred(*__first))
 if (++__first == __last)
   return __first;
      _ForwardIterator __next = __first;
      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }
      return __first;
    }
  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
  template<typename _ForwardIterator, typename _Predicate, typename _Distance>
    _ForwardIterator
    __inplace_stable_partition(_ForwardIterator __first,
          _ForwardIterator __last,
          _Predicate __pred, _Distance __len)
    {
      if (__len == 1)
 return __pred(*__first) ? __last : __first;
      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __begin = std::__inplace_stable_partition(__first,
         __middle,
         __pred,
         __len / 2);
      _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last,
              __pred,
              __len
              - __len / 2);
      std::rotate(__begin, __middle, __end);
      std::advance(__begin, std::distance(__middle, __end));
      return __begin;
    }
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;
   for (; __first != __last; ++__first)
     if (__pred(*__first))
       {
  *__result1 = std::move(*__first);
  ++__result1;
       }
     else
       {
  *__result2 = std::move(*__first);
  ++__result2;
       }
   std::move(__buffer, __result2, __result1);
   return __result1;
 }
      else
 {
   _ForwardIterator __middle = __first;
   std::advance(__middle, __len / 2);
   _ForwardIterator __begin =
     std::__stable_partition_adaptive(__first, __middle, __pred,
          __len / 2, __buffer,
          __buffer_size);
   _ForwardIterator __end =
     std::__stable_partition_adaptive(__middle, __last, __pred,
          __len - __len / 2,
          __buffer, __buffer_size);
   std::rotate(__begin, __middle, __end);
   std::advance(__begin, std::distance(__middle, __end));
   return __begin;
 }
    }
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {
     
     
      ;
      if (__first == __last)
 return __first;
      else
 {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;
   typedef typename iterator_traits<_ForwardIterator>::difference_type
     _DistanceType;
   _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first,
        __last);
 if (__buf.size() > 0)
   return
     std::__stable_partition_adaptive(__first, __last, __pred,
       _DistanceType(__buf.requested_size()),
       __buf.begin(),
       _DistanceType(__buf.size()));
 else
   return
     std::__inplace_stable_partition(__first, __last, __pred,
      _DistanceType(__buf.requested_size()));
 }
    }
  template<typename _RandomAccessIterator>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last)
    {
      std::make_heap(__first, __middle);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (*__i < *__first)
   std::__pop_heap(__first, __middle, __i);
    }
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(*__i, *__first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }
  template<typename _InputIterator, typename _RandomAccessIterator>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
     
     
     
     
      ;
      ;
      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last);
      while (__first != __last)
 {
   if (*__first < *__result_first)
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first));
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last);
      return __result_real_last;
    }
  template<typename _InputIterator, typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _OutputValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
     
     
     
     
     
      ;
      ;
      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while(__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }
      std::make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(*__first, *__result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first),
          __comp);
   ++__first;
 }
      std::sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
  template<typename _RandomAccessIterator>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__val < *__next)
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, *__next))
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }
  template<typename _RandomAccessIterator>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last)
    {
      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (*__i < *__first)
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i);
 }
    }
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(*__i, *__first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i, __comp);
 }
    }
  template<typename _RandomAccessIterator>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i);
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i, __comp);
    }
  enum { _S_threshold = 16 };
  template<typename _RandomAccessIterator>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold));
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last);
 }
      else
 std::__insertion_sort(__first, __last);
    }
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }
  template<typename _RandomAccessIterator, typename _Tp>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last, const _Tp& __pivot)
    {
      while (true)
 {
   while (*__first < __pivot)
     ++__first;
   --__last;
   while (__pivot < *__last)
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
  template<typename _RandomAccessIterator, typename _Tp, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     const _Tp& __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(*__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, *__last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_first(__first, __mid, (__last - 1));
      return std::__unguarded_partition(__first + 1, __last, *__first);
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_first(__first, __mid, (__last - 1), __comp);
      return std::__unguarded_partition(__first + 1, __last, *__first, __comp);
    }
  template<typename _RandomAccessIterator, typename _Size>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last);
   std::__introsort_loop(__cut, __last, __depth_limit);
   __last = __cut;
 }
    }
  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }
  template<typename _RandomAccessIterator, typename _Size>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last);
       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last);
    }
  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);
       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
     
     
      ;
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
     
     
      ;
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__val < *__middle)
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
     
     
      ;
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
  template<typename _ForwardIterator, typename _Tp>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
     
     
     
      ;
      ;
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__val < *__middle)
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val,
  _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;
     
     
     
      ;
      ;
      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle, __left, __right;
      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__comp(*__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp(__val, *__middle))
     __len = __half;
   else
     {
       __left = std::lower_bound(__first, __middle, __val, __comp);
       std::advance(__first, __len);
       __right = std::upper_bound(++__middle, __first, __val, __comp);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
     
     
      ;
      ;
      _ForwardIterator __i = std::lower_bound(__first, __last, __val);
      return __i != __last && !(__val < *__i);
    }
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
                  const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
     
     
      ;
      ;
      _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);
      return __i != __last && !bool(__comp(__val, *__i));
    }
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (*__last2 < *__last1)
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    _BidirectionalIterator3
    __merge_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 return std::copy_backward(__first2, __last2, __result);
      if (__first2 == __last2)
 return std::copy_backward(__first1, __last1, __result);
      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(*__last2, *__last1))
     {
       *--__result = *__last1;
       if (__first1 == __last1)
  return std::copy_backward(__first2, ++__last2, __result);
       --__last1;
     }
   else
     {
       *--__result = *__last2;
       if (__first2 == __last2)
  return std::copy_backward(__first1, ++__last1, __result);
       --__last2;
     }
 }
    }
  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   __buffer_end = std::move(__middle, __last, __buffer);
   std::move_backward(__first, __middle, __last);
   return std::move(__buffer, __buffer_end, __first);
 }
      else if (__len1 <= __buffer_size)
 {
   __buffer_end = std::move(__first, __middle, __buffer);
   std::move(__middle, __last, __first);
   return std::move_backward(__buffer, __buffer_end, __last);
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }
  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::merge(std::make_move_iterator(__buffer),
    std::make_move_iterator(__buffer_end),
    std::make_move_iterator(__middle),
    std::make_move_iterator(__last),
    __first);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__merge_backward(std::make_move_iterator(__first),
    std::make_move_iterator(__middle),
    std::make_move_iterator(__buffer),
    std::make_move_iterator(__buffer_end),
    __last);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last,
           *__first_cut);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle,
          *__second_cut);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer, __buffer_size);
 }
    }
  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
                     _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::merge(std::make_move_iterator(__buffer),
    std::make_move_iterator(__buffer_end),
    std::make_move_iterator(__middle),
    std::make_move_iterator(__last),
    __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__merge_backward(std::make_move_iterator(__first),
    std::make_move_iterator(__middle),
    std::make_move_iterator(__buffer),
    std::make_move_iterator(__buffer_end),
    __last,__comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut = std::lower_bound(__middle, __last, *__first_cut,
           __comp);
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut = std::upper_bound(__first, __middle, *__second_cut,
          __comp);
       __len11 = std::distance(__first, __first_cut);
     }
   _BidirectionalIterator __new_middle =
     std::__rotate_adaptive(__first_cut, __middle, __second_cut,
       __len1 - __len11, __len22, __buffer,
       __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }
  template<typename _BidirectionalIterator, typename _Distance>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (*__middle < *__first)
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22);
    }
  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
                           _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;
      if (__len1 + __len2 == 2)
 {
   if (__comp(*__middle, *__first))
     std::iter_swap(__first, __middle);
   return;
 }
      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut = std::lower_bound(__middle, __last, *__first_cut,
       __comp);
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut = std::upper_bound(__first, __middle, *__second_cut,
      __comp);
   __len11 = std::distance(__first, __first_cut);
 }
      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }
  template<typename _BidirectionalIterator>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;
     
     
      ;
      ;
      if (__first == __middle || __middle == __last)
 return;
      _DistanceType __len1 = std::distance(__first, __middle);
      _DistanceType __len2 = std::distance(__middle, __last);
      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1, __len2);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()));
    }
  template<typename _BidirectionalIterator, typename _Compare>
    void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
          _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
          _DistanceType;
     
     
      ;
      ;
      if (__first == __middle || __middle == __last)
 return;
      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);
      _Temporary_buffer<_BidirectionalIterator, _ValueType> __buf(__first,
          __last);
      if (__buf.begin() == 0)
 std::__merge_without_buffer(__first, __middle, __last, __len1,
        __len2, __comp);
      else
 std::__merge_adaptive(__first, __middle, __last, __len1, __len2,
         __buf.begin(), _DistanceType(__buf.size()),
         __comp);
    }
  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result,
        _Distance __step_size)
    {
      const _Distance __two_step = 2 * __step_size;
      while (__last - __first >= __two_step)
 {
   __result = std::merge(
   std::make_move_iterator(__first),
   std::make_move_iterator(__first + __step_size),
   std::make_move_iterator(__first + __step_size),
   std::make_move_iterator(__first + __two_step),
   __result);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::merge(std::make_move_iterator(__first),
       std::make_move_iterator(__first + __step_size),
       std::make_move_iterator(__first + __step_size),
       std::make_move_iterator(__last),
       __result);
    }
  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;
      while (__last - __first >= __two_step)
 {
   __result = std::merge(
   std::make_move_iterator(__first),
   std::make_move_iterator(__first + __step_size),
   std::make_move_iterator(__first + __step_size),
   std::make_move_iterator(__first + __two_step),
   __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);
      std::merge(std::make_move_iterator(__first),
       std::make_move_iterator(__first + __step_size),
       std::make_move_iterator(__first + __step_size),
       std::make_move_iterator(__last),
       __result, __comp);
    }
  template<typename _RandomAccessIterator, typename _Distance>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last);
    }
  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
  enum { _S_chunk_size = 7 };
  template<typename _RandomAccessIterator, typename _Pointer>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;
      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size);
      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer, __step_size);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first, __step_size);
   __step_size *= 2;
 }
    }
  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
                             _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;
      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);
      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }
  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle,
          __buffer, __buffer_size);
   std::__stable_sort_adaptive(__middle, __last,
          __buffer, __buffer_size);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer);
   std::__merge_sort_with_buffer(__middle, __last, __buffer);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size);
    }
  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
                           _Pointer __buffer, _Distance __buffer_size,
                           _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }
  template<typename _RandomAccessIterator>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle);
      std::__inplace_stable_sort(__middle, __last);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle);
    }
  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
  template<typename _InputIterator1, typename _InputIterator2>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
     
     
     
     
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 if (*__first2 < *__first1)
   return false;
 else if(*__first1 < *__first2)
   ++__first1;
 else
   ++__first1, ++__first2;
      return __first2 == __last2;
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
     
     
     
     
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first2, *__first1))
   return false;
 else if(__comp(*__first1, *__first2))
   ++__first1;
 else
   ++__first1, ++__first2;
      return __first2 == __last2;
    }
  template<typename _BidirectionalIterator>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {
     
     
      ;
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;
      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__i < *__ii)
     {
       _BidirectionalIterator __j = __last;
       while (!(*__i < *--__j))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {
     
     
      ;
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;
      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__i, *__ii))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*__i, *--__j)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
  template<typename _BidirectionalIterator>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {
     
     
      ;
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;
      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (*__ii < *__i)
     {
       _BidirectionalIterator __j = __last;
       while (!(*--__j < *__i))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {
     
     
      ;
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;
      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(*__ii, *__i))
     {
       _BidirectionalIterator __j = __last;
       while (!bool(__comp(*--__j, *__i)))
  {}
       std::iter_swap(__i, __j);
       std::reverse(__ii, __last);
       return true;
     }
   if (__i == __first)
     {
       std::reverse(__first, __last);
       return false;
     }
 }
    }
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {
     
     
     
      ;
      for (; __first != __last; ++__first, ++__result)
 if (*__first == __old_value)
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {
     
     
     
      ;
      for (; __first != __last; ++__first, ++__result)
 if (__pred(*__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
  template<typename _ForwardIterator>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }
  template<typename _ForwardIterator, typename _Compare>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }
  template<typename _ForwardIterator>
    _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {
     
     
      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next)
 if (*__next < *__first)
   return __next;
      return __next;
    }
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {
     
     
      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, ++__next)
 if (__comp(*__next, *__first))
   return __next;
      return __next;
    }
  template<typename _Tp>
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {
     
      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
                : pair<const _Tp&, const _Tp&>(__a, __b);
    }
  template<typename _Tp, typename _Compare>
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
                       : pair<const _Tp&, const _Tp&>(__a, __b);
    }
  template<typename _ForwardIterator>
    pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {
     
     
      ;
      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);
      _ForwardIterator __min, __max;
      if (*__next < *__first)
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }
      __first = __next;
      ++__first;
      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (*__first < *__min)
  __min = __first;
       else if (!(*__first < *__max))
  __max = __first;
       break;
     }
   if (*__next < *__first)
     {
       if (*__next < *__min)
  __min = __next;
       if (!(*__first < *__max))
  __max = __first;
     }
   else
     {
       if (*__first < *__min)
  __min = __first;
       if (!(*__next < *__max))
  __max = __next;
     }
   __first = __next;
   ++__first;
 }
      return std::make_pair(__min, __max);
    }
  template<typename _ForwardIterator, typename _Compare>
    pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp)
    {
     
     
      ;
      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);
      _ForwardIterator __min, __max;
      if (__comp(*__next, *__first))
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }
      __first = __next;
      ++__first;
      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (__comp(*__first, *__min))
  __min = __first;
       else if (!__comp(*__first, *__max))
  __max = __first;
       break;
     }
   if (__comp(*__next, *__first))
     {
       if (__comp(*__next, *__min))
  __min = __next;
       if (!__comp(*__first, *__max))
  __max = __first;
     }
   else
     {
       if (__comp(*__first, *__min))
  __min = __first;
       if (!__comp(*__next, *__max))
  __max = __next;
     }
   __first = __next;
   ++__first;
 }
      return std::make_pair(__min, __max);
    }
  template<typename _Tp>
    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }
  template<typename _Tp, typename _Compare>
    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }
  template<typename _Tp>
    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }
  template<typename _Tp, typename _Compare>
    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }
  template<typename _Tp>
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }
  template<typename _Tp, typename _Compare>
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }
  template<typename _RandomAccessIterator,
    typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _UniformRandomNumberGenerator& __g)
    {
     
      ;
      if (__first == __last)
 return;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;
      __distr_type __d;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {
     
      ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return std::move(__f);
    }
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {
     
     
      ;
      return std::__find(__first, __last, __val,
           std::__iterator_category(__first));
    }
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
     
     
      ;
      return std::__find_if(__first, __last, __pred,
       std::__iterator_category(__first));
    }
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {
     
     
     
      ;
      ;
      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {
     
     
     
      ;
      ;
      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
  template<typename _ForwardIterator>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {
     
     
      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (*__first == *__next)
     return __first;
   __first = __next;
 }
      return __last;
    }
  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {
     
     
      ;
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while(++__next != __last)
 {
   if (__binary_pred(*__first, *__next))
     return __first;
   __first = __next;
 }
      return __last;
    }
  template<typename _InputIterator, typename _Tp>
    typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {
     
     
      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (*__first == __value)
   ++__n;
      return __n;
    }
  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
     
     
      ;
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(*__first))
   ++__n;
      return __n;
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
     
     
     
      ;
      ;
      if (__first1 == __last1 || __first2 == __last2)
 return __first1;
      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::find(__first1, __last1, *__first2);
      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;
      for (;;)
 {
   __first1 = std::find(__first1, __last1, *__first2);
   if (__first1 == __last1)
     return __last1;
   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;
   while (*__current == *__p)
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {
     
     
     
      ;
      ;
      if (__first1 == __last1 || __first2 == __last2)
 return __first1;
      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   return __first1;
 }
      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;
      for (;;)
 {
   while (__first1 != __last1
   && !bool(__predicate(*__first1, *__first2)))
     ++__first1;
   if (__first1 == __last1)
     return __last1;
   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;
   while (__predicate(*__current, *__p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {
     
     
      ;
      if (__count <= 0)
 return __first;
      if (__count == 1)
 return std::find(__first, __last, __val);
      return std::__search_n(__first, __last, __count, __val,
        std::__iterator_category(__first));
    }
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
           typename _BinaryPredicate>
    _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {
     
     
      ;
      if (__count <= 0)
 return __first;
      if (__count == 1)
 {
   while (__first != __last && !bool(__binary_pred(*__first, __val)))
     ++__first;
   return __first;
 }
      return std::__search_n(__first, __last, __count, __val, __binary_pred,
        std::__iterator_category(__first));
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {
     
     
      ;
      for (; __first != __last; ++__first, ++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {
     
     
     
      ;
      for (; __first1 != __last1; ++__first1, ++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {
     
     
     
      ;
      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {
     
     
     
      ;
      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {
     
     
      ;
      for (; __first != __last; ++__first)
 *__first = __gen();
    }
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {
     
      for (; __n > 0; --__n, ++__first)
 *__first = __gen();
      return __first;
    }
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {
     
     
     
      ;
      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {
     
     
      ;
      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result, __binary_pred,
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
     
      ;
      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   std::iter_swap(__i, __first + (std::rand() % ((__i - __first) + 1)));
    }
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _RandomNumberGenerator&& __rand)
    {
     
      ;
      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __rand((__i - __first) + 1));
    }
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {
     
     
      ;
      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
     
     
      ;
      ;
      std::__heap_select(__first, __middle, __last);
      std::sort_heap(__first, __middle);
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
     
     
      ;
      ;
      std::__heap_select(__first, __middle, __last, __comp);
      std::sort_heap(__first, __middle, __comp);
    }
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
     
     
      ;
      ;
      if (__first == __last || __nth == __last)
 return;
      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2);
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
     
     
      ;
      ;
      if (__first == __last || __nth == __last)
 return;
      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2, __comp);
    }
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
     
     
      ;
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2);
   std::__final_insertion_sort(__first, __last);
 }
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
     
     
      ;
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2, __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
     
     
     
     
     
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
     
     
     
     
     
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
     
     
      ;
      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()));
    }
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;
     
     
      ;
      _Temporary_buffer<_RandomAccessIterator, _ValueType> __buf(__first,
         __last);
      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
     
     
     
     
     
     
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (*__first1 < *__first2)
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (*__first2 < *__first1)
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
     
     
     
     
     
     
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(*__first1, *__first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(*__first2, *__first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2, std::copy(__first1, __last1,
          __result));
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
     
     
     
     
     
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   ++__first1;
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
     
     
     
     
     
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   ++__first1;
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
     
     
     
     
     
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
     
     
     
     
     
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
     
     
     
     
     
     
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 if (*__first1 < *__first2)
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (*__first2 < *__first1)
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2, std::copy(__first1,
          __last1, __result));
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_InputIterator2>::value_type
 _ValueType2;
     
     
     
     
     
     
      ;
      ;
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(*__first1, *__first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(*__first2, *__first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
  template<typename _ForwardIterator>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last)
    {
     
     
      ;
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__first < *__result)
   __result = __first;
      return __result;
    }
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {
     
     
      ;
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__first, *__result))
   __result = __first;
      return __result;
    }
  template<typename _ForwardIterator>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {
     
     
      ;
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (*__result < *__first)
   __result = __first;
      return __result;
    }
  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {
     
     
      ;
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(*__result, *__first))
   __result = __first;
      return __result;
    }
}
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
}
namespace boost {
  template <class T>
  struct type {};
}
       
namespace mpl_ { namespace aux {} }
namespace boost { namespace mpl { using namespace mpl_;
namespace aux { using namespace mpl_::aux; }
}}
namespace mpl_ {
template< int N > struct int_;
}
namespace boost { namespace mpl { using ::mpl_::int_; } }
namespace mpl_ {
struct integral_c_tag { static const int value = 0; };
}
namespace boost { namespace mpl { using ::mpl_::integral_c_tag; } }
namespace mpl_ {
template< int N >
struct int_
{
    static const int value = N;
    typedef int_ type;
    typedef int value_type;
    typedef integral_c_tag tag;
    typedef mpl_::int_< static_cast<int>((value + 1)) > next;
    typedef mpl_::int_< static_cast<int>((value - 1)) > prior;
    operator int() const { return static_cast<int>(this->value); }
};
template< int N >
int const mpl_::int_< N >::value;
}
namespace boost { namespace mpl { namespace aux {
template< typename F > struct template_arity;
}}}
namespace mpl_ {
template< bool C_ > struct bool_;
typedef bool_<true> true_;
typedef bool_<false> false_;
}
namespace boost { namespace mpl { using ::mpl_::bool_; } }
namespace boost { namespace mpl { using ::mpl_::true_; } }
namespace boost { namespace mpl { using ::mpl_::false_; } }
namespace mpl_ {
template< bool C_ > struct bool_
{
    static const bool value = C_;
    typedef integral_c_tag tag;
    typedef bool_ type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};
template< bool C_ >
bool const bool_<C_>::value;
}
namespace mpl_ {
template< typename T, T N > struct integral_c;
}
namespace boost { namespace mpl { using ::mpl_::integral_c; } }
namespace mpl_ {
template< typename T, T N >
struct integral_c
{
    static const T value = N;
    typedef integral_c type;
    typedef T value_type;
    typedef integral_c_tag tag;
    typedef integral_c< T, static_cast<T>((value + 1)) > next;
    typedef integral_c< T, static_cast<T>((value - 1)) > prior;
    operator T() const { return static_cast<T>(this->value); }
};
template< typename T, T N >
T const integral_c< T, N >::value;
}
namespace mpl_ {
template< bool C >
struct integral_c<bool, C>
{
    static const bool value = C;
    typedef integral_c_tag tag;
    typedef integral_c type;
    typedef bool value_type;
    operator bool() const { return this->value; }
};
}
namespace boost{
template <class T, T val>
struct integral_constant : public mpl::integral_c<T, val>
{
   typedef integral_constant<T,val> type;
};
template<> struct integral_constant<bool,true> : public mpl::true_
{
   typedef integral_constant<bool,true> type;
};
template<> struct integral_constant<bool,false> : public mpl::false_
{
   typedef integral_constant<bool,false> type;
};
typedef integral_constant<bool,true> true_type;
typedef integral_constant<bool,false> false_type;
}
namespace boost {
template< typename T, typename U > struct is_same : public ::boost::integral_constant<bool,false> { public: };
template< typename T > struct is_same< T,T > : public ::boost::integral_constant<bool,true> { public: };
}
namespace boost {
template< typename T > struct is_lvalue_reference : public ::boost::integral_constant<bool,false> { public: };
template< typename T > struct is_lvalue_reference< T& > : public ::boost::integral_constant<bool,true> { public: };
}
namespace boost {
template< typename T > struct is_rvalue_reference : public ::boost::integral_constant<bool,false> { public: };
template< typename T > struct is_rvalue_reference< T&& > : public ::boost::integral_constant<bool,true> { public: };
}
namespace boost {
namespace type_traits {
typedef char yes_type;
struct no_type
{
   char padding[8];
};
}
}
namespace boost {
namespace type_traits {
template <bool b1, bool b2, bool b3 = false, bool b4 = false, bool b5 = false, bool b6 = false, bool b7 = false>
struct ice_or;
template <bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
struct ice_or
{
    static const bool value = true;
};
template <>
struct ice_or<false, false, false, false, false, false, false>
{
    static const bool value = false;
};
}
}
namespace boost {
namespace type_traits {
template <bool b1, bool b2, bool b3 = true, bool b4 = true, bool b5 = true, bool b6 = true, bool b7 = true>
struct ice_and;
template <bool b1, bool b2, bool b3, bool b4, bool b5, bool b6, bool b7>
struct ice_and
{
    static const bool value = false;
};
template <>
struct ice_and<true, true, true, true, true, true, true>
{
    static const bool value = true;
};
}
}
namespace boost {
namespace type_traits {
template <bool b>
struct ice_not
{
    static const bool value = true;
};
template <>
struct ice_not<true>
{
    static const bool value = false;
};
}
}
namespace boost {
namespace type_traits {
template <int b1, int b2>
struct ice_eq
{
    static const bool value = (b1 == b2);
};
template <int b1, int b2>
struct ice_ne
{
    static const bool value = (b1 != b2);
};
template <int b1, int b2> bool const ice_eq<b1,b2>::value;
template <int b1, int b2> bool const ice_ne<b1,b2>::value;
}
}
namespace boost {
namespace detail {
template <typename T>
struct is_reference_impl
{
   static const bool value = (::boost::type_traits::ice_or< ::boost::is_lvalue_reference<T>::value, ::boost::is_rvalue_reference<T>::value >::value);
};
}
template< typename T > struct is_reference : public ::boost::integral_constant<bool,::boost::detail::is_reference_impl<T>::value> { public: };
}
namespace boost {
namespace detail {
template <typename T> struct cv_traits_imp {};
template <typename T>
struct cv_traits_imp<T*>
{
    static const bool is_const = false;
    static const bool is_volatile = false;
    typedef T unqualified_type;
};
template <typename T>
struct cv_traits_imp<const T*>
{
    static const bool is_const = true;
    static const bool is_volatile = false;
    typedef T unqualified_type;
};
template <typename T>
struct cv_traits_imp<volatile T*>
{
    static const bool is_const = false;
    static const bool is_volatile = true;
    typedef T unqualified_type;
};
template <typename T>
struct cv_traits_imp<const volatile T*>
{
    static const bool is_const = true;
    static const bool is_volatile = true;
    typedef T unqualified_type;
};
}
}
namespace boost {
namespace detail{
template <class T>
struct is_volatile_rval_filter
{
   static const bool value = ::boost::detail::cv_traits_imp<T*>::is_volatile;
};
template <class T>
struct is_volatile_rval_filter<T&&>
{
   static const bool value = false;
};
}
template< typename T > struct is_volatile : public ::boost::integral_constant<bool,::boost::detail::is_volatile_rval_filter<T>::value> { public: };
template< typename T > struct is_volatile< T& > : public ::boost::integral_constant<bool,false> { public: };
}
       
namespace mpl_ {
template< std::size_t N > struct size_t;
}
namespace boost { namespace mpl { using ::mpl_::size_t; } }
namespace mpl_ {
template< std::size_t N >
struct size_t
{
    static const std::size_t value = N;
    typedef size_t type;
    typedef std::size_t value_type;
    typedef integral_c_tag tag;
    typedef mpl_::size_t< static_cast<std::size_t>((value + 1)) > next;
    typedef mpl_::size_t< static_cast<std::size_t>((value - 1)) > prior;
    operator std::size_t() const { return static_cast<std::size_t>(this->value); }
};
template< std::size_t N >
std::size_t const mpl_::size_t< N >::value;
}
       
namespace boost {
template <typename T> struct alignment_of;
namespace detail {
template <typename T>
struct alignment_of_hack
{
    char c;
    T t;
    alignment_of_hack();
};
template <unsigned A, unsigned S>
struct alignment_logic
{
    static const std::size_t value = A < S ? A : S;
};
template< typename T >
struct alignment_of_impl
{
   static const std::size_t value = __alignof__(T);
};
}
template< typename T > struct alignment_of : public ::boost::integral_constant<std::size_t,::boost::detail::alignment_of_impl<T>::value> { public: };
template <typename T>
struct alignment_of<T&>
    : public alignment_of<T*>
{
};
template<> struct alignment_of<void> : public ::boost::integral_constant<std::size_t,0> { public: };
template<> struct alignment_of<void const> : public ::boost::integral_constant<std::size_t,0> { public: };
template<> struct alignment_of<void volatile> : public ::boost::integral_constant<std::size_t,0> { public: };
template<> struct alignment_of<void const volatile> : public ::boost::integral_constant<std::size_t,0> { public: };
}
namespace boost {
template< typename T > struct is_void : public ::boost::integral_constant<bool,false> { public: };
template<> struct is_void< void > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_void< void const > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_void< void volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_void< void const volatile > : public ::boost::integral_constant<bool,true> { public: };
}
namespace boost {
template< typename T > struct is_integral : public ::boost::integral_constant<bool,false> { public: };
template<> struct is_integral< unsigned char > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned char const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned char volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned char const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< unsigned short > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned short const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned short volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned short const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< unsigned int > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned int const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned int volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned int const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< unsigned long > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned long const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned long volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< unsigned long const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< signed char > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed char const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed char volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed char const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< signed short > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed short const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed short volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed short const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< signed int > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed int const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed int volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed int const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< signed long > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed long const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed long volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< signed long const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< bool > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< bool const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< bool volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< bool const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< char > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< char const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< char volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< char const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< wchar_t > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< wchar_t const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< wchar_t volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< wchar_t const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< ::boost::ulong_long_type > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::ulong_long_type const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::ulong_long_type volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::ulong_long_type const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_integral< ::boost::long_long_type > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::long_long_type const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::long_long_type volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_integral< ::boost::long_long_type const volatile > : public ::boost::integral_constant<bool,true> { public: };
}
namespace boost {
template< typename T > struct is_float : public ::boost::integral_constant<bool,false> { public: };
template<> struct is_float< float > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< float const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< float volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< float const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_float< double > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< double const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< double volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< double const volatile > : public ::boost::integral_constant<bool,true> { public: };
template<> struct is_float< long double > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< long double const > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< long double volatile > : public ::boost::integral_constant<bool,true> { public: }; template<> struct is_float< long double const volatile > : public ::boost::integral_constant<bool,true> { public: };
}
namespace boost {
namespace detail {
template< typename T >
struct is_arithmetic_impl
{
    static const bool value = (::boost::type_traits::ice_or< ::boost::is_integral<T>::value, ::boost::is_float<T>::value >::value);
};
}
template< typename T > struct is_arithmetic : public ::boost::integral_constant<bool,::boost::detail::is_arithmetic_impl<T>::value> { public: };
}
namespace boost {
template< typename T > struct is_enum : public ::boost::integral_constant<bool,__is_enum(T)> { public: };
}
namespace boost {
namespace type_traits {
template <typename T>
struct is_mem_fun_pointer_impl
{
    static const bool value = false;
};
template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() > { static const bool value = true; };
template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) > { static const bool value = true; };
template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() const > { static const bool value = true; };
template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() volatile > { static const bool value = true; };
template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)() const volatile > { static const bool value = true; };
template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) const > { static const bool value = true; };
template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) volatile > { static const bool value = true; };
template <class R, class T >
struct is_mem_fun_pointer_impl<R (T::*)( ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) > { static const bool value = true; };
template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) > { static const bool value = true; };
template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) const > { static const bool value = true; };
template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) volatile > { static const bool value = true; };
template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0) const volatile > { static const bool value = true; };
template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) const > { static const bool value = true; };
template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0>
struct is_mem_fun_pointer_impl<R (T::*)( T0 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) > { static const bool value = true; };
template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24) const volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) const > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) volatile > { static const bool value = true; };
template <class R, class T , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_mem_fun_pointer_impl<R (T::*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...) const volatile > { static const bool value = true; };
}
}













       
namespace boost {
namespace detail{
template <class T>
struct rvalue_ref_filter_rem_cv
{
   typedef typename boost::detail::cv_traits_imp<T*>::unqualified_type type;
};
template <class T>
struct rvalue_ref_filter_rem_cv<T&&>
{
   typedef T&& type;
};
}
template< typename T > struct remove_cv { public: typedef typename boost::detail::rvalue_ref_filter_rem_cv<T>::type type; };
template< typename T > struct remove_cv<T&> { public: typedef T& type; };
template< typename T, std::size_t N > struct remove_cv<T const[N]> { public: typedef T type[N]; };
template< typename T, std::size_t N > struct remove_cv<T volatile[N]> { public: typedef T type[N]; };
template< typename T, std::size_t N > struct remove_cv<T const volatile[N]> { public: typedef T type[N]; };
}
namespace boost {
template< typename T > struct is_member_function_pointer : public ::boost::integral_constant<bool,::boost::type_traits::is_mem_fun_pointer_impl<typename remove_cv<T>::type>::value> { public: };
}
namespace boost {
template< typename T > struct is_member_pointer : public ::boost::integral_constant<bool,::boost::is_member_function_pointer<T>::value> { public: };
template< typename T, typename U > struct is_member_pointer< U T::* > : public ::boost::integral_constant<bool,true> { public: };
template< typename T, typename U > struct is_member_pointer< U T::*const > : public ::boost::integral_constant<bool,true> { public: };
template< typename T, typename U > struct is_member_pointer< U T::*volatile > : public ::boost::integral_constant<bool,true> { public: };
template< typename T, typename U > struct is_member_pointer< U T::*const volatile > : public ::boost::integral_constant<bool,true> { public: };
}
namespace boost {
namespace detail {
template< typename T > struct is_pointer_helper
{
    static const bool value = false;
};
template< typename T > struct is_pointer_helper<T*> { static const bool value = true; };
template< typename T >
struct is_pointer_impl
{
    static const bool value = (::boost::type_traits::ice_and< ::boost::detail::is_pointer_helper<typename remove_cv<T>::type>::value , ::boost::type_traits::ice_not< ::boost::is_member_pointer<T>::value >::value >::value);
};
}
template< typename T > struct is_pointer : public ::boost::integral_constant<bool,::boost::detail::is_pointer_impl<T>::value> { public: };
}
namespace boost {
namespace detail {
template <typename T>
struct is_scalar_impl
{
   static const bool value = (::boost::type_traits::ice_or< ::boost::is_arithmetic<T>::value, ::boost::is_enum<T>::value, ::boost::is_pointer<T>::value, ::boost::is_member_pointer<T>::value >::value);
};
template <> struct is_scalar_impl<void>{ static const bool value = false; };
template <> struct is_scalar_impl<void const>{ static const bool value = false; };
template <> struct is_scalar_impl<void volatile>{ static const bool value = false; };
template <> struct is_scalar_impl<void const volatile>{ static const bool value = false; };
}
template< typename T > struct is_scalar : public ::boost::integral_constant<bool,::boost::detail::is_scalar_impl<T>::value> { public: };
}
       
namespace boost {
template< typename T > struct is_POD;
namespace detail {
template <typename T> struct is_pod_impl
{
    static const bool value = (::boost::type_traits::ice_or< ::boost::is_scalar<T>::value, ::boost::is_void<T>::value, __is_pod(T) >::value);
};
template <typename T, std::size_t sz>
struct is_pod_impl<T[sz]>
    : public is_pod_impl<T>
{
};
template<> struct is_pod_impl< void > { public: static const bool value = (true); };
template<> struct is_pod_impl< void const > { public: static const bool value = (true); };
template<> struct is_pod_impl< void volatile > { public: static const bool value = (true); };
template<> struct is_pod_impl< void const volatile > { public: static const bool value = (true); };
}
template< typename T > struct is_POD : public ::boost::integral_constant<bool,::boost::detail::is_pod_impl<T>::value> { public: };
template< typename T > struct is_pod : public ::boost::integral_constant<bool,::boost::detail::is_pod_impl<T>::value> { public: };
}
namespace boost {
namespace detail {
template <typename T>
struct has_trivial_ctor_impl
{
   static const bool value = (::boost::type_traits::ice_or< ::boost::is_pod<T>::value, ((__has_trivial_constructor(T) ) && ! ::boost::is_volatile<T>::value) >::value);
};
}
template< typename T > struct has_trivial_constructor : public ::boost::integral_constant<bool,::boost::detail::has_trivial_ctor_impl<T>::value> { public: };
template< typename T > struct has_trivial_default_constructor : public ::boost::integral_constant<bool,::boost::detail::has_trivial_ctor_impl<T>::value> { public: };
}
namespace boost {
namespace detail{
template <class T>
struct has_nothrow_constructor_imp{
   static const bool value = (__has_nothrow_constructor(T) );
};
}
template< typename T > struct has_nothrow_constructor : public ::boost::integral_constant<bool,::boost::detail::has_nothrow_constructor_imp<T>::value> { public: };
template< typename T > struct has_nothrow_default_constructor : public ::boost::integral_constant<bool,::boost::detail::has_nothrow_constructor_imp<T>::value> { public: };
template<> struct has_nothrow_constructor< void > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_constructor< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_constructor< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_constructor< void volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_default_constructor< void > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_default_constructor< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_default_constructor< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_default_constructor< void volatile > : public ::boost::integral_constant<bool,false> { public: };
}
namespace boost { namespace mpl { namespace aux {
template< typename T > struct value_type_wknd
{
    typedef typename T::value_type type;
};
}}}
namespace mpl_ {
struct void_;
}
namespace boost { namespace mpl { using ::mpl_::void_; } }
namespace mpl_ {
struct na
{
    typedef na type;
    enum { value = 0 };
};
}
namespace boost { namespace mpl { using ::mpl_::na; } }
namespace boost { namespace mpl {
template< typename T >
struct is_na
    : false_
{
};
template<>
struct is_na<na>
    : true_
{
};
template< typename T >
struct is_not_na
    : true_
{
};
template<>
struct is_not_na<na>
    : false_
{
};
template< typename T, typename U > struct if_na
{
    typedef T type;
};
template< typename U > struct if_na<na,U>
{
    typedef U type;
};
}}
namespace boost { namespace mpl {
template<
      typename T = na
    , typename Tag = void_
    , typename Arity = int_< aux::template_arity<T>::value >
    >
struct lambda;
}}
namespace boost { namespace mpl {
template<
      bool C
    , typename T1
    , typename T2
    >
struct if_c
{
    typedef T1 type;
};
template<
      typename T1
    , typename T2
    >
struct if_c<false,T1,T2>
{
    typedef T2 type;
};
template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = na
    >
struct if_
{
 private:
    typedef if_c<
          static_cast<bool>(T1::value)
        , T2
        , T3
        > almost_type_;
 public:
    typedef typename almost_type_::type type;
   
};
template<> struct if_< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : if_< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< if_< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef if_< na , na , na > result_; typedef if_< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< if_< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< if_< na , na , na > > : int_<-1> { }; }
}}
       
namespace boost {
namespace detail {
class alignment_dummy;
typedef void (*function_ptr)();
typedef int (alignment_dummy::*member_ptr);
typedef int (alignment_dummy::*member_function_ptr)();
template <bool found, std::size_t target, class TestType>
struct lower_alignment_helper
{
    typedef char type;
    enum { value = true };
};
template <std::size_t target, class TestType>
struct lower_alignment_helper<false,target,TestType>
{
    enum { value = (alignment_of<TestType>::value == target) };
    typedef typename mpl::if_c<value, TestType, char>::type type;
};
template <typename T>
struct has_one_T
{
  T data;
};
template <std::size_t target>
union lower_alignment
{
    enum { found0 = false };
    typename lower_alignment_helper< found0,target,char >::type t0; enum { found1 = lower_alignment_helper<found0,target,char >::value }; typename lower_alignment_helper< found1,target,short >::type t1; enum { found2 = lower_alignment_helper<found1,target,short >::value }; typename lower_alignment_helper< found2,target,int >::type t2; enum { found3 = lower_alignment_helper<found2,target,int >::value }; typename lower_alignment_helper< found3,target,long >::type t3; enum { found4 = lower_alignment_helper<found3,target,long >::value }; typename lower_alignment_helper< found4,target,::boost::long_long_type >::type t4; enum { found5 = lower_alignment_helper<found4,target,::boost::long_long_type >::value }; typename lower_alignment_helper< found5,target,float >::type t5; enum { found6 = lower_alignment_helper<found5,target,float >::value }; typename lower_alignment_helper< found6,target,double >::type t6; enum { found7 = lower_alignment_helper<found6,target,double >::value }; typename lower_alignment_helper< found7,target,long double >::type t7; enum { found8 = lower_alignment_helper<found7,target,long double >::value }; typename lower_alignment_helper< found8,target,void* >::type t8; enum { found9 = lower_alignment_helper<found8,target,void* >::value }; typename lower_alignment_helper< found9,target,function_ptr >::type t9; enum { found10 = lower_alignment_helper<found9,target,function_ptr >::value }; typename lower_alignment_helper< found10,target,member_ptr >::type t10; enum { found11 = lower_alignment_helper<found10,target,member_ptr >::value }; typename lower_alignment_helper< found11,target,member_function_ptr >::type t11; enum { found12 = lower_alignment_helper<found11,target,member_function_ptr >::value }; typename lower_alignment_helper< found12,target,boost::detail::has_one_T< char > >::type t12; enum { found13 = lower_alignment_helper<found12,target,boost::detail::has_one_T< char > >::value }; typename lower_alignment_helper< found13,target,boost::detail::has_one_T< short > >::type t13; enum { found14 = lower_alignment_helper<found13,target,boost::detail::has_one_T< short > >::value }; typename lower_alignment_helper< found14,target,boost::detail::has_one_T< int > >::type t14; enum { found15 = lower_alignment_helper<found14,target,boost::detail::has_one_T< int > >::value }; typename lower_alignment_helper< found15,target,boost::detail::has_one_T< long > >::type t15; enum { found16 = lower_alignment_helper<found15,target,boost::detail::has_one_T< long > >::value }; typename lower_alignment_helper< found16,target,boost::detail::has_one_T< ::boost::long_long_type > >::type t16; enum { found17 = lower_alignment_helper<found16,target,boost::detail::has_one_T< ::boost::long_long_type > >::value }; typename lower_alignment_helper< found17,target,boost::detail::has_one_T< float > >::type t17; enum { found18 = lower_alignment_helper<found17,target,boost::detail::has_one_T< float > >::value }; typename lower_alignment_helper< found18,target,boost::detail::has_one_T< double > >::type t18; enum { found19 = lower_alignment_helper<found18,target,boost::detail::has_one_T< double > >::value }; typename lower_alignment_helper< found19,target,boost::detail::has_one_T< long double > >::type t19; enum { found20 = lower_alignment_helper<found19,target,boost::detail::has_one_T< long double > >::value }; typename lower_alignment_helper< found20,target,boost::detail::has_one_T< void* > >::type t20; enum { found21 = lower_alignment_helper<found20,target,boost::detail::has_one_T< void* > >::value }; typename lower_alignment_helper< found21,target,boost::detail::has_one_T< function_ptr > >::type t21; enum { found22 = lower_alignment_helper<found21,target,boost::detail::has_one_T< function_ptr > >::value }; typename lower_alignment_helper< found22,target,boost::detail::has_one_T< member_ptr > >::type t22; enum { found23 = lower_alignment_helper<found22,target,boost::detail::has_one_T< member_ptr > >::value }; typename lower_alignment_helper< found23,target,boost::detail::has_one_T< member_function_ptr > >::type t23; enum { found24 = lower_alignment_helper<found23,target,boost::detail::has_one_T< member_function_ptr > >::value };
};
union max_align
{
    char t0; short t1; int t2; long t3; ::boost::long_long_type t4; float t5; double t6; long double t7; void* t8; function_ptr t9; member_ptr t10; member_function_ptr t11; boost::detail::has_one_T< char > t12; boost::detail::has_one_T< short > t13; boost::detail::has_one_T< int > t14; boost::detail::has_one_T< long > t15; boost::detail::has_one_T< ::boost::long_long_type > t16; boost::detail::has_one_T< float > t17; boost::detail::has_one_T< double > t18; boost::detail::has_one_T< long double > t19; boost::detail::has_one_T< void* > t20; boost::detail::has_one_T< function_ptr > t21; boost::detail::has_one_T< member_ptr > t22; boost::detail::has_one_T< member_function_ptr > t23;
};
template<std::size_t TAlign, std::size_t Align>
struct is_aligned
{
    static const bool value = (TAlign >= Align) & (TAlign % Align == 0);
};
}
template<std::size_t Align>
struct is_pod< ::boost::detail::lower_alignment<Align> >
{
        static const std::size_t value = true;
};
namespace detail{
template <std::size_t Align>
class type_with_alignment_imp
{
    typedef ::boost::detail::lower_alignment<Align> t1;
    typedef typename mpl::if_c<
          ::boost::detail::is_aligned< ::boost::alignment_of<t1>::value,Align >::value
        , t1
        , ::boost::detail::max_align
        >::type align_t;
    static const std::size_t found = alignment_of<align_t>::value;
    static_assert(found >= Align, "found >= Align");
    static_assert(found % Align == 0, "found % Align == 0");
 public:
    typedef align_t type;
};
}
template <std::size_t Align>
class type_with_alignment
  : public ::boost::detail::type_with_alignment_imp<Align>
{
};
namespace align {
struct __attribute__((__aligned__(2))) a2 {};
struct __attribute__((__aligned__(4))) a4 {};
struct __attribute__((__aligned__(8))) a8 {};
struct __attribute__((__aligned__(16))) a16 {};
struct __attribute__((__aligned__(32))) a32 {};
}
template<> class type_with_alignment<1> { public: typedef char type; };
template<> class type_with_alignment<2> { public: typedef align::a2 type; };
template<> class type_with_alignment<4> { public: typedef align::a4 type; };
template<> class type_with_alignment<8> { public: typedef align::a8 type; };
template<> class type_with_alignment<16> { public: typedef align::a16 type; };
template<> class type_with_alignment<32> { public: typedef align::a32 type; };
namespace detail {
template<> struct is_pod_impl< ::boost::align::a2 > { public: static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a4 > { public: static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a8 > { public: static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a16 > { public: static const bool value = (true); };
template<> struct is_pod_impl< ::boost::align::a32 > { public: static const bool value = (true); };
}
}
namespace boost {
namespace detail{
template <class T>
struct remove_rvalue_ref
{
   typedef T type;
};
template <class T>
struct remove_rvalue_ref<T&&>
{
   typedef T type;
};
}
template< typename T > struct remove_reference { public: typedef typename boost::detail::remove_rvalue_ref<T>::type type; };
template< typename T > struct remove_reference<T&> { public: typedef T type; };
}
namespace boost { namespace mpl { namespace aux {
template< typename T > struct nested_type_wknd
    : T::type
{
};
}}}
namespace boost { namespace mpl {
namespace aux {
template< long C_ >
struct not_impl
    : bool_<!C_>
{
};
}
template<
      typename T = na
    >
struct not_
    : aux::not_impl<
          ::boost::mpl::aux::nested_type_wknd<T>::value
        >
{
   
};
template<> struct not_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : not_< T1 > { }; }; template< typename Tag > struct lambda< not_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef not_< na > result_; typedef not_< na > type; }; namespace aux { template< typename T1 > struct template_arity< not_< T1 > > : int_<1> { }; template<> struct template_arity< not_< na > > : int_<-1> { }; }
}}
namespace boost {
namespace detail {
template <typename T>
struct has_trivial_copy_impl
{
   static const bool value = ((__has_trivial_copy(T) ) && !is_reference<T>::value && ! ::boost::is_volatile<T>::value);
};
}
template< typename T > struct has_trivial_copy : public ::boost::integral_constant<bool,::boost::detail::has_trivial_copy_impl<T>::value> { public: };
template< typename T > struct has_trivial_copy_constructor : public ::boost::integral_constant<bool,::boost::detail::has_trivial_copy_impl<T>::value> { public: };
template<> struct has_trivial_copy< void > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_copy< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_copy< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_copy< void volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_copy_constructor< void > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_copy_constructor< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_copy_constructor< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_trivial_copy_constructor< void volatile > : public ::boost::integral_constant<bool,false> { public: };
}
namespace boost {
namespace detail{
template <class T>
struct has_nothrow_copy_imp{
   static const bool value = ((__has_nothrow_copy(T) ) && !is_volatile<T>::value && !is_reference<T>::value);
};
}
template< typename T > struct has_nothrow_copy : public ::boost::integral_constant<bool,::boost::detail::has_nothrow_copy_imp<T>::value> { public: };
template< typename T > struct has_nothrow_copy_constructor : public ::boost::integral_constant<bool,::boost::detail::has_nothrow_copy_imp<T>::value> { public: };
template<> struct has_nothrow_copy< void > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_copy< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_copy< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_copy< void volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_copy_constructor< void > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_copy_constructor< void const > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_copy_constructor< void const volatile > : public ::boost::integral_constant<bool,false> { public: };
template<> struct has_nothrow_copy_constructor< void volatile > : public ::boost::integral_constant<bool,false> { public: };
}
namespace mpl_ {
struct void_ { typedef void_ type; };
}
namespace boost { namespace mpl {
template< typename T >
struct is_void_
    : false_
{
};
template<>
struct is_void_<void_>
    : true_
{
};
template< typename T >
struct is_not_void_
    : true_
{
};
template<>
struct is_not_void_<void_>
    : false_
{
};
template<> struct is_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_void_< T1 > { }; }; template< typename Tag > struct lambda< is_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_void_< na > result_; typedef is_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_void_< na > > : int_<-1> { }; }
template<> struct is_not_void_< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_not_void_< T1 > { }; }; template< typename Tag > struct lambda< is_not_void_< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_not_void_< na > result_; typedef is_not_void_< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_not_void_< T1 > > : int_<1> { }; template<> struct template_arity< is_not_void_< na > > : int_<-1> { }; }
}}
namespace boost {
namespace detail {
template <typename RefT>
class reference_content
{
private:
    RefT content_;
public:
    ~reference_content()
    {
    }
    reference_content(RefT r)
        : content_( r )
    {
    }
    reference_content(const reference_content& operand)
        : content_( operand.content_ )
    {
    }
private:
    reference_content& operator=(const reference_content&);
public:
    RefT get() const
    {
        return content_;
    }
};
template <typename T = mpl::void_> struct make_reference_content;
template <typename T>
struct make_reference_content
{
    typedef T type;
};
template <typename T>
struct make_reference_content< T& >
{
    typedef reference_content<T&> type;
};
template <>
struct make_reference_content< mpl::void_ >
{
    template <typename T>
    struct apply
        : make_reference_content<T>
    {
    };
    typedef mpl::void_ type;
};
}
template <typename T>
struct has_nothrow_copy<
      ::boost::detail::reference_content< T& >
    >
    : mpl::true_
{
};
}
namespace boost {
namespace detail { struct none_helper{}; }
typedef int detail::none_helper::*none_t ;
}
namespace boost {
none_t const none = (static_cast<none_t>(0)) ;
}
       
namespace boost_swap_impl
{
  template<class T>
  void swap_impl(T& left, T& right)
  {
    using namespace std;
    swap(left,right);
  }
  template<class T, std::size_t N>
  void swap_impl(T (& left)[N], T (& right)[N])
  {
    for (std::size_t i = 0; i < N; ++i)
    {
      ::boost_swap_impl::swap_impl(left[i], right[i]);
    }
  }
}
namespace boost
{
  template<class T1, class T2>
  void swap(T1& left, T2& right)
  {
    ::boost_swap_impl::swap_impl(left, right);
  }
}
namespace boost
{
namespace detail
{
template<class T> struct addr_impl_ref
{
    T & v_;
    inline addr_impl_ref( T & v ): v_( v ) {}
    inline operator T& () const { return v_; }
private:
    addr_impl_ref & operator=(const addr_impl_ref &);
};
template<class T> struct addressof_impl
{
    static inline T * f( T & v, long )
    {
        return reinterpret_cast<T*>(
            &const_cast<char&>(reinterpret_cast<const volatile char &>(v)));
    }
    static inline T * f( T * v, int )
    {
        return v;
    }
};
}
template<class T> T * addressof( T & v )
{
    return boost::detail::addressof_impl<T>::f( boost::detail::addr_impl_ref<T>( v ), 0 );
}
}
       
       
#pragma GCC visibility push(default)
extern "C++" {
namespace __cxxabiv1
{
  class __class_type_info;
}
namespace std
{
  class type_info
  {
  public:
    virtual ~type_info();
    const char* name() const
    { return __name[0] == '*' ? __name + 1 : __name; }
    bool before(const type_info& __arg) const
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }
    bool operator==(const type_info& __arg) const
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
    bool operator!=(const type_info& __arg) const
    { return !operator==(__arg); }
    virtual bool __is_pointer_p() const;
    virtual bool __is_function_p() const;
    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;
    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;
  protected:
    const char *__name;
    explicit type_info(const char *__n): __name(__n) { }
  private:
    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };
  class bad_cast : public exception
  {
  public:
    bad_cast() throw() { }
    virtual ~bad_cast() throw();
    virtual const char* what() const throw();
  };
  class bad_typeid : public exception
  {
  public:
    bad_typeid () throw() { }
    virtual ~bad_typeid() throw();
    virtual const char* what() const throw();
  };
}
#pragma GCC visibility pop
}
       
namespace std
{
  template<typename _Tp>
    struct __add_c_ref
    { typedef const _Tp& type; };
  template<typename _Tp>
    struct __add_c_ref<_Tp&>
    { typedef _Tp& type; };
  template<typename _Tp>
    struct __add_ref
    { typedef _Tp& type; };
  template<typename _Tp>
    struct __add_ref<_Tp&>
    { typedef _Tp& type; };
  template<std::size_t _Idx, typename _Head, bool _IsEmpty>
    struct _Head_base;
  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      _Head_base()
      : _Head() { }
      _Head_base(const _Head& __h)
      : _Head(__h) { }
      template<typename _UHead>
        _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }
      _Head& _M_head() { return *this; }
      const _Head& _M_head() const { return *this; }
      void _M_swap_impl(_Head&) { }
    };
  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      _Head_base()
      : _M_head_impl() { }
      _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }
      template<typename _UHead>
        _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }
      _Head& _M_head() { return _M_head_impl; }
      const _Head& _M_head() const { return _M_head_impl; }
      void
      _M_swap_impl(_Head& __h)
      {
 using std::swap;
 swap(__h, _M_head_impl);
      }
      _Head _M_head_impl;
    };
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;
  template<std::size_t _Idx>
    struct _Tuple_impl<_Idx>
    {
    protected:
      void _M_swap_impl(_Tuple_impl&) { }
    };
  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head, std::is_empty<_Head>::value>
    {
      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head, std::is_empty<_Head>::value> _Base;
      _Head& _M_head() { return _Base::_M_head(); }
      const _Head& _M_head() const { return _Base::_M_head(); }
      _Inherited& _M_tail() { return *this; }
      const _Inherited& _M_tail() const { return *this; }
      _Tuple_impl()
      : _Inherited(), _Base() { }
      explicit
      _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }
      template<typename _UHead, typename... _UTail>
        explicit
        _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }
      _Tuple_impl(const _Tuple_impl& __in)
      : _Inherited(__in._M_tail()), _Base(__in._M_head()) { }
      _Tuple_impl(_Tuple_impl&& __in)
      : _Inherited(std::move(__in._M_tail())),
 _Base(std::forward<_Head>(__in._M_head())) { }
      template<typename... _UElements>
        _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__in._M_tail()), _Base(__in._M_head()) { }
      template<typename... _UElements>
        _Tuple_impl(_Tuple_impl<_Idx, _UElements...>&& __in)
 : _Inherited(std::move(__in._M_tail())),
   _Base(std::move(__in._M_head())) { }
      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head() = __in._M_head();
 _M_tail() = __in._M_tail();
 return *this;
      }
      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      {
 _M_head() = std::move(__in._M_head());
 _M_tail() = std::move(__in._M_tail());
 return *this;
      }
      template<typename... _UElements>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head() = __in._M_head();
   _M_tail() = __in._M_tail();
   return *this;
 }
      template<typename... _UElements>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UElements...>&& __in)
        {
   _M_head() = std::move(__in._M_head());
   _M_tail() = std::move(__in._M_tail());
   return *this;
 }
    protected:
      void
      _M_swap_impl(_Tuple_impl& __in)
      {
 _Base::_M_swap_impl(__in._M_head());
 _Inherited::_M_swap_impl(__in._M_tail());
      }
    };
  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;
    public:
      tuple()
      : _Inherited() { }
      explicit
      tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }
      template<typename... _UElements>
        explicit
        tuple(_UElements&&... __elements)
 : _Inherited(std::forward<_UElements>(__elements)...) { }
      tuple(const tuple& __in)
      : _Inherited(static_cast<const _Inherited&>(__in)) { }
      tuple(tuple&& __in)
      : _Inherited(static_cast<_Inherited&&>(__in)) { }
      template<typename... _UElements>
        tuple(const tuple<_UElements...>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }
      template<typename... _UElements>
        tuple(tuple<_UElements...>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }
      template<typename... _UElements>
        tuple(tuple<_UElements...>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }
      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }
      tuple&
      operator=(tuple&& __in)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }
      template<typename... _UElements>
        tuple&
        operator=(const tuple<_UElements...>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }
      template<typename... _UElements>
        tuple&
        operator=(tuple<_UElements...>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }
      void
      swap(tuple& __in)
      { _Inherited::_M_swap_impl(__in); }
    };
  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) { }
    };
  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;
    public:
      tuple()
      : _Inherited() { }
      explicit
      tuple(const _T1& __a1, const _T2& __a2)
      : _Inherited(__a1, __a2) { }
      template<typename _U1, typename _U2>
        explicit
        tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }
      tuple(const tuple& __in)
      : _Inherited(static_cast<const _Inherited&>(__in)) { }
      tuple(tuple&& __in)
      : _Inherited(static_cast<_Inherited&&>(__in)) { }
      template<typename _U1, typename _U2>
        tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }
      template<typename _U1, typename _U2>
        tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }
      template<typename _U1, typename _U2>
        tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }
      template<typename _U1, typename _U2>
        tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }
      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }
      tuple&
      operator=(tuple&& __in)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }
      template<typename _U1, typename _U2>
        tuple&
        operator=(const tuple<_U1, _U2>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }
      template<typename _U1, typename _U2>
        tuple&
        operator=(tuple<_U1, _U2>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }
      template<typename _U1, typename _U2>
        tuple&
        operator=(const pair<_U1, _U2>& __in)
        {
   this->_M_head() = __in.first;
   this->_M_tail()._M_head() = __in.second;
   return *this;
 }
      template<typename _U1, typename _U2>
        tuple&
        operator=(pair<_U1, _U2>&& __in)
        {
   this->_M_head() = std::move(__in.first);
   this->_M_tail()._M_head() = std::move(__in.second);
   return *this;
 }
      void
      swap(tuple& __in)
      {
 using std::swap;
 swap(this->_M_head(), __in._M_head());
 swap(this->_M_tail()._M_head(), __in._M_tail()._M_head());
      }
    };
  template<std::size_t __i, typename _Tp>
    struct tuple_element;
  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };
  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };
  template<typename _Tp>
    struct tuple_size;
  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...> >
    {
      static const std::size_t value = sizeof...(_Elements);
    };
  template<typename... _Elements>
    const std::size_t tuple_size<tuple<_Elements...> >::value;
  template<std::size_t __i, typename _Head, typename... _Tail>
    inline typename __add_ref<_Head>::type
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t)
    { return __t._M_head(); }
  template<std::size_t __i, typename _Head, typename... _Tail>
    inline typename __add_c_ref<_Head>::type
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t)
    { return __t._M_head(); }
  template<std::size_t __i, typename... _Elements>
    inline typename __add_ref<
                      typename tuple_element<__i, tuple<_Elements...> >::type
                    >::type
    get(tuple<_Elements...>& __t)
    { return __get_helper<__i>(__t); }
  template<std::size_t __i, typename... _Elements>
    inline typename __add_c_ref<
                      typename tuple_element<__i, tuple<_Elements...> >::type
                    >::type
    get(const tuple<_Elements...>& __t)
    { return __get_helper<__i>(__t); }
  template<std::size_t __check_equal_size, std::size_t __i, std::size_t __j,
    typename _Tp, typename _Up>
    struct __tuple_compare;
  template<std::size_t __i, std::size_t __j, typename _Tp, typename _Up>
    struct __tuple_compare<0, __i, __j, _Tp, _Up>
    {
      static bool __eq(const _Tp& __t, const _Up& __u)
      {
 return (get<__i>(__t) == get<__i>(__u) &&
  __tuple_compare<0, __i + 1, __j, _Tp, _Up>::__eq(__t, __u));
      }
      static bool __less(const _Tp& __t, const _Up& __u)
      {
 return ((get<__i>(__t) < get<__i>(__u))
  || !(get<__i>(__u) < get<__i>(__t)) &&
  __tuple_compare<0, __i + 1, __j, _Tp, _Up>::__less(__t, __u));
      }
    };
  template<std::size_t __i, typename _Tp, typename _Up>
    struct __tuple_compare<0, __i, __i, _Tp, _Up>
    {
      static bool __eq(const _Tp&, const _Up&)
      { return true; }
      static bool __less(const _Tp&, const _Up&)
      { return false; }
    };
  template<typename... _TElements, typename... _UElements>
    bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      typedef tuple<_TElements...> _Tp;
      typedef tuple<_UElements...> _Up;
      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Up>::value,
       0, tuple_size<_Tp>::value, _Tp, _Up>::__eq(__t, __u));
    }
  template<typename... _TElements, typename... _UElements>
    bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      typedef tuple<_TElements...> _Tp;
      typedef tuple<_UElements...> _Up;
      return (__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Up>::value,
       0, tuple_size<_Tp>::value, _Tp, _Up>::__less(__t, __u));
    }
  template<typename... _TElements, typename... _UElements>
    inline bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }
  template<typename... _TElements, typename... _UElements>
    inline bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }
  template<typename... _TElements, typename... _UElements>
    inline bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }
  template<typename... _TElements, typename... _UElements>
    inline bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }
  template<typename... _Elements>
    inline tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }
  template<std::size_t...> struct __index_holder { };
  template<std::size_t __i, typename _IdxHolder, typename... _Elements>
    struct __index_holder_impl;
  template<std::size_t __i, std::size_t... _Indexes, typename _IdxHolder,
    typename... _Elements>
    struct __index_holder_impl<__i, __index_holder<_Indexes...>,
          _IdxHolder, _Elements...>
    {
      typedef typename __index_holder_impl<__i + 1,
        __index_holder<_Indexes..., __i>,
        _Elements...>::type type;
    };
  template<std::size_t __i, std::size_t... _Indexes>
    struct __index_holder_impl<__i, __index_holder<_Indexes...> >
    { typedef __index_holder<_Indexes...> type; };
  template<typename... _Elements>
    struct __make_index_holder
    : __index_holder_impl<0, __index_holder<>, _Elements...> { };
  template<typename... _TElements, std::size_t... _TIdx,
    typename... _UElements, std::size_t... _UIdx>
    inline tuple<_TElements..., _UElements...>
    __tuple_cat_helper(const tuple<_TElements...>& __t,
         const __index_holder<_TIdx...>&,
                       const tuple<_UElements...>& __u,
         const __index_holder<_UIdx...>&)
    { return tuple<_TElements..., _UElements...>(get<_TIdx>(__t)...,
       get<_UIdx>(__u)...); }
  template<typename... _TElements, std::size_t... _TIdx,
    typename... _UElements, std::size_t... _UIdx>
    inline tuple<_TElements..., _UElements...>
    __tuple_cat_helper(tuple<_TElements...>&& __t,
         const __index_holder<_TIdx...>&,
         const tuple<_UElements...>& __u,
         const __index_holder<_UIdx...>&)
    { return tuple<_TElements..., _UElements...>
 (std::move(get<_TIdx>(__t))..., get<_UIdx>(__u)...); }
  template<typename... _TElements, std::size_t... _TIdx,
    typename... _UElements, std::size_t... _UIdx>
    inline tuple<_TElements..., _UElements...>
    __tuple_cat_helper(const tuple<_TElements...>& __t,
         const __index_holder<_TIdx...>&,
         tuple<_UElements...>&& __u,
         const __index_holder<_UIdx...>&)
    { return tuple<_TElements..., _UElements...>
 (get<_TIdx>(__t)..., std::move(get<_UIdx>(__u))...); }
  template<typename... _TElements, std::size_t... _TIdx,
    typename... _UElements, std::size_t... _UIdx>
    inline tuple<_TElements..., _UElements...>
    __tuple_cat_helper(tuple<_TElements...>&& __t,
         const __index_holder<_TIdx...>&,
         tuple<_UElements...>&& __u,
         const __index_holder<_UIdx...>&)
    { return tuple<_TElements..., _UElements...>
 (std::move(get<_TIdx>(__t))..., std::move(get<_UIdx>(__u))...); }
  template<typename... _TElements, typename... _UElements>
    inline tuple<_TElements..., _UElements...>
    tuple_cat(const tuple<_TElements...>& __t, const tuple<_UElements...>& __u)
    {
      return __tuple_cat_helper(__t, typename
    __make_index_holder<_TElements...>::type(),
    __u, typename
    __make_index_holder<_UElements...>::type());
    }
  template<typename... _TElements, typename... _UElements>
    inline tuple<_TElements..., _UElements...>
    tuple_cat(tuple<_TElements...>&& __t, const tuple<_UElements...>& __u)
    {
      return __tuple_cat_helper(std::move(__t), typename
     __make_index_holder<_TElements...>::type(),
     __u, typename
     __make_index_holder<_UElements...>::type());
    }
  template<typename... _TElements, typename... _UElements>
    inline tuple<_TElements..., _UElements...>
    tuple_cat(const tuple<_TElements...>& __t, tuple<_UElements...>&& __u)
    {
      return __tuple_cat_helper(__t, typename
    __make_index_holder<_TElements...>::type(),
    std::move(__u), typename
    __make_index_holder<_UElements...>::type());
    }
  template<typename... _TElements, typename... _UElements>
    inline tuple<_TElements..., _UElements...>
    tuple_cat(tuple<_TElements...>&& __t, tuple<_UElements...>&& __u)
    {
      return __tuple_cat_helper(std::move(__t), typename
    __make_index_holder<_TElements...>::type(),
    std::move(__u), typename
    __make_index_holder<_UElements...>::type());
    }
  template<typename... _Elements>
    inline tuple<_Elements&...>
    tie(_Elements&... __args)
    { return tuple<_Elements&...>(__args...); }
  template<typename... _Elements>
    inline void
    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    { __x.swap(__y); }
  struct _Swallow_assign
  {
    template<class _Tp>
      _Swallow_assign&
      operator=(const _Tp&)
      { return *this; }
  };
  namespace
  {
    _Swallow_assign ignore;
  };
}
namespace std
{
  template<typename _MemberPointer>
    class _Mem_fn;
  template<typename _Tp>
    class _Has_result_type_helper : __sfinae_types
    {
      template<typename _Up>
        struct _Wrap_type
 { };
      template<typename _Up>
        static __one __test(_Wrap_type<typename _Up::result_type>*);
      template<typename _Up>
        static __two __test(...);
    public:
      static const bool value = sizeof(__test<_Tp>(0)) == 1;
    };
  template<typename _Tp>
    struct _Has_result_type
    : integral_constant<bool,
       _Has_result_type_helper<typename remove_cv<_Tp>::type>::value>
    { };
  template<bool _Has_result_type, typename _Functor>
    struct _Maybe_get_result_type
    { };
  template<typename _Functor>
    struct _Maybe_get_result_type<true, _Functor>
    {
      typedef typename _Functor::result_type result_type;
    };
  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<_Has_result_type<_Functor>::value, _Functor>
    { };
  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...)>
    {
      typedef _Res result_type;
    };
  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>
    {
      typedef _Res result_type;
    };
  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>
    {
      typedef _Res result_type;
    };
  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>
    {
      typedef _Res result_type;
    };
  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>
    {
      typedef _Res result_type;
    };
  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>
    {
      typedef _Res result_type;
    };
  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)const volatile>
    {
      typedef _Res result_type;
    };
  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>
    { };
  template<typename _Signature>
    class result_of;
  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    {
      typedef
        decltype( std::declval<_Functor>()(std::declval<_ArgTypes>()...) )
        type;
    };
  template<typename _Tp>
    struct _Derives_from_unary_function : __sfinae_types
    {
    private:
      template<typename _T1, typename _Res>
        static __one __test(const volatile unary_function<_T1, _Res>*);
      static __two __test(...);
    public:
      static const bool value = sizeof(__test((_Tp*)0)) == 1;
    };
  template<typename _Tp>
    struct _Derives_from_binary_function : __sfinae_types
    {
    private:
      template<typename _T1, typename _T2, typename _Res>
        static __one __test(const volatile binary_function<_T1, _T2, _Res>*);
      static __two __test(...);
    public:
      static const bool value = sizeof(__test((_Tp*)0)) == 1;
    };
  template<typename _Tp, bool _IsFunctionType = is_function<_Tp>::value>
    struct _Function_to_function_pointer
    {
      typedef _Tp type;
    };
  template<typename _Tp>
    struct _Function_to_function_pointer<_Tp, true>
    {
      typedef _Tp* type;
    };
  template<typename _Functor, typename... _Args>
    inline
    typename enable_if<
             (!is_member_pointer<_Functor>::value
              && !is_function<_Functor>::value
              && !is_function<typename remove_pointer<_Functor>::type>::value),
             typename result_of<_Functor(_Args...)>::type
           >::type
    __invoke(_Functor& __f, _Args&&... __args)
    {
      return __f(std::forward<_Args>(__args)...);
    }
  template<typename _Functor, typename... _Args>
    inline
    typename enable_if<
             (is_pointer<_Functor>::value
              && is_function<typename remove_pointer<_Functor>::type>::value),
             typename result_of<_Functor(_Args...)>::type
           >::type
    __invoke(_Functor __f, _Args&&... __args)
    {
      return __f(std::forward<_Args>(__args)...);
    }
  template<bool _Unary, bool _Binary, typename _Tp>
    struct _Reference_wrapper_base_impl;
  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, false, _Tp>
    : _Weak_result_type<_Tp>
    { };
  template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, false, _Tp>
    : unary_function<typename _Tp::argument_type,
       typename _Tp::result_type>
    { };
  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, true, _Tp>
    : binary_function<typename _Tp::first_argument_type,
        typename _Tp::second_argument_type,
        typename _Tp::result_type>
    { };
   template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, true, _Tp>
    : unary_function<typename _Tp::argument_type,
       typename _Tp::result_type>,
      binary_function<typename _Tp::first_argument_type,
        typename _Tp::second_argument_type,
        typename _Tp::result_type>
    {
      typedef typename _Tp::result_type result_type;
    };
  template<typename _Tp>
    struct _Reference_wrapper_base
    : _Reference_wrapper_base_impl<
      _Derives_from_unary_function<_Tp>::value,
      _Derives_from_binary_function<_Tp>::value,
      _Tp>
    { };
  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1)>
    : unary_function<_T1, _Res>
    { };
  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };
  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(*)(_T1)>
    : unary_function<_T1, _Res>
    { };
  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };
  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)()>
    : unary_function<_T1*, _Res>
    { };
  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>
    : binary_function<_T1*, _T2, _Res>
    { };
  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const>
    : unary_function<const _T1*, _Res>
    { };
  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>
    : binary_function<const _T1*, _T2, _Res>
    { };
  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>
    : unary_function<volatile _T1*, _Res>
    { };
  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>
    : binary_function<volatile _T1*, _T2, _Res>
    { };
  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>
    : unary_function<const volatile _T1*, _Res>
    { };
  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>
    : binary_function<const volatile _T1*, _T2, _Res>
    { };
  template<typename _Tp>
    class reference_wrapper
    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>
    {
      typedef typename _Function_to_function_pointer<_Tp>::type
        _M_func_type;
      _Tp* _M_data;
    public:
      typedef _Tp type;
      reference_wrapper(_Tp& __indata): _M_data(&__indata)
      { }
      reference_wrapper(_Tp&&) = delete;
      reference_wrapper(const reference_wrapper<_Tp>& __inref):
      _M_data(__inref._M_data)
      { }
      reference_wrapper&
      operator=(const reference_wrapper<_Tp>& __inref)
      {
        _M_data = __inref._M_data;
        return *this;
      }
      operator _Tp&() const
      { return this->get(); }
      _Tp&
      get() const
      { return *_M_data; }
      template<typename... _Args>
        typename result_of<_M_func_type(_Args...)>::type
        operator()(_Args&&... __args) const
        {
   return __invoke(get(), std::forward<_Args>(__args)...);
 }
    };
  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(_Tp& __t)
    { return reference_wrapper<_Tp>(__t); }
  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t)
    { return reference_wrapper<const _Tp>(__t); }
  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t)
    { return ref(__t.get()); }
  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t)
    { return cref(__t.get()); }
  template<typename _Tp, bool>
    struct _Mem_fn_const_or_non
    {
      typedef const _Tp& type;
    };
  template<typename _Tp>
    struct _Mem_fn_const_or_non<_Tp, false>
    {
      typedef _Tp& type;
    };
  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };
  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };
  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };
  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...);
      template<typename _Tp>
        _Res
        _M_call(_Tp& __object, const volatile _Class *,
                _ArgTypes... __args) const
        { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }
      template<typename _Tp>
        _Res
        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const
        { return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }
    public:
      typedef _Res result_type;
      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }
      _Res
      operator()(_Class& __object, _ArgTypes... __args) const
      { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }
      _Res
      operator()(_Class* __object, _ArgTypes... __args) const
      { return (__object->*__pmf)(std::forward<_ArgTypes>(__args)...); }
      template<typename _Tp>
        _Res
 operator()(_Tp& __object, _ArgTypes... __args) const
        {
          return _M_call(__object, &__object,
              std::forward<_ArgTypes>(__args)...);
        }
    private:
      _Functor __pmf;
    };
  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const>
    : public _Maybe_unary_or_binary_function<_Res, const _Class*,
          _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...) const;
      template<typename _Tp>
        _Res
        _M_call(_Tp& __object, const volatile _Class *,
                _ArgTypes... __args) const
        { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }
      template<typename _Tp>
        _Res
        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const
        { return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }
    public:
      typedef _Res result_type;
      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }
      _Res
      operator()(const _Class& __object, _ArgTypes... __args) const
      { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }
      _Res
      operator()(const _Class* __object, _ArgTypes... __args) const
      { return (__object->*__pmf)(std::forward<_ArgTypes>(__args)...); }
      template<typename _Tp>
        _Res operator()(_Tp& __object, _ArgTypes... __args) const
        {
          return _M_call(__object, &__object,
              std::forward<_ArgTypes>(__args)...);
        }
    private:
      _Functor __pmf;
    };
  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) volatile>
    : public _Maybe_unary_or_binary_function<_Res, volatile _Class*,
          _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...) volatile;
      template<typename _Tp>
        _Res
        _M_call(_Tp& __object, const volatile _Class *,
                _ArgTypes... __args) const
        { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }
      template<typename _Tp>
        _Res
        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const
        { return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }
    public:
      typedef _Res result_type;
      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }
      _Res
      operator()(volatile _Class& __object, _ArgTypes... __args) const
      { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }
      _Res
      operator()(volatile _Class* __object, _ArgTypes... __args) const
      { return (__object->*__pmf)(std::forward<_ArgTypes>(__args)...); }
      template<typename _Tp>
        _Res
 operator()(_Tp& __object, _ArgTypes... __args) const
        {
          return _M_call(__object, &__object,
              std::forward<_ArgTypes>(__args)...);
        }
    private:
      _Functor __pmf;
    };
  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const volatile>
    : public _Maybe_unary_or_binary_function<_Res, const volatile _Class*,
          _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...) const volatile;
      template<typename _Tp>
        _Res
        _M_call(_Tp& __object, const volatile _Class *,
                _ArgTypes... __args) const
        { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }
      template<typename _Tp>
        _Res
        _M_call(_Tp& __ptr, const volatile void *, _ArgTypes... __args) const
        { return ((*__ptr).*__pmf)(std::forward<_ArgTypes>(__args)...); }
    public:
      typedef _Res result_type;
      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }
      _Res
      operator()(const volatile _Class& __object, _ArgTypes... __args) const
      { return (__object.*__pmf)(std::forward<_ArgTypes>(__args)...); }
      _Res
      operator()(const volatile _Class* __object, _ArgTypes... __args) const
      { return (__object->*__pmf)(std::forward<_ArgTypes>(__args)...); }
      template<typename _Tp>
        _Res operator()(_Tp& __object, _ArgTypes... __args) const
        {
          return _M_call(__object, &__object,
              std::forward<_ArgTypes>(__args)...);
        }
    private:
      _Functor __pmf;
    };
  template<typename _Res, typename _Class>
    class _Mem_fn<_Res _Class::*>
    {
      template<typename _Tp>
        _Res&
        _M_call(_Tp& __object, _Class *) const
        { return __object.*__pm; }
      template<typename _Tp, typename _Up>
        _Res&
        _M_call(_Tp& __object, _Up * const *) const
        { return (*__object).*__pm; }
      template<typename _Tp, typename _Up>
        const _Res&
        _M_call(_Tp& __object, const _Up * const *) const
        { return (*__object).*__pm; }
      template<typename _Tp>
        const _Res&
        _M_call(_Tp& __object, const _Class *) const
        { return __object.*__pm; }
      template<typename _Tp>
        const _Res&
        _M_call(_Tp& __ptr, const volatile void*) const
        { return (*__ptr).*__pm; }
      template<typename _Tp> static _Tp& __get_ref();
      template<typename _Tp>
        static __sfinae_types::__one __check_const(_Tp&, _Class*);
      template<typename _Tp, typename _Up>
        static __sfinae_types::__one __check_const(_Tp&, _Up * const *);
      template<typename _Tp, typename _Up>
        static __sfinae_types::__two __check_const(_Tp&, const _Up * const *);
      template<typename _Tp>
        static __sfinae_types::__two __check_const(_Tp&, const _Class*);
      template<typename _Tp>
        static __sfinae_types::__two __check_const(_Tp&, const volatile void*);
    public:
      template<typename _Tp>
        struct _Result_type
 : _Mem_fn_const_or_non<_Res,
   (sizeof(__sfinae_types::__two)
    == sizeof(__check_const<_Tp>(__get_ref<_Tp>(), (_Tp*)0)))>
        { };
      template<typename _Signature>
        struct result;
      template<typename _CVMem, typename _Tp>
        struct result<_CVMem(_Tp)>
 : public _Result_type<_Tp> { };
      template<typename _CVMem, typename _Tp>
        struct result<_CVMem(_Tp&)>
 : public _Result_type<_Tp> { };
      explicit
      _Mem_fn(_Res _Class::*__pm) : __pm(__pm) { }
      _Res&
      operator()(_Class& __object) const
      { return __object.*__pm; }
      const _Res&
      operator()(const _Class& __object) const
      { return __object.*__pm; }
      _Res&
      operator()(_Class* __object) const
      { return __object->*__pm; }
      const _Res&
      operator()(const _Class* __object) const
      { return __object->*__pm; }
      template<typename _Tp>
        typename _Result_type<_Tp>::type
        operator()(_Tp& __unknown) const
        { return _M_call(__unknown, &__unknown); }
    private:
      _Res _Class::*__pm;
    };
  template<typename _Tp, typename _Class>
    inline _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::* __pm)
    {
      return _Mem_fn<_Tp _Class::*>(__pm);
    }
  template<typename _Tp>
    struct is_bind_expression
    : public false_type { };
  template<typename _Tp>
    struct is_placeholder
    : public integral_constant<int, 0>
    { };
  template<int _Num> struct _Placeholder { };
  namespace placeholders
  {
    namespace
    {
      _Placeholder<1> _1;
      _Placeholder<2> _2;
      _Placeholder<3> _3;
      _Placeholder<4> _4;
      _Placeholder<5> _5;
      _Placeholder<6> _6;
      _Placeholder<7> _7;
      _Placeholder<8> _8;
      _Placeholder<9> _9;
      _Placeholder<10> _10;
      _Placeholder<11> _11;
      _Placeholder<12> _12;
      _Placeholder<13> _13;
      _Placeholder<14> _14;
      _Placeholder<15> _15;
      _Placeholder<16> _16;
      _Placeholder<17> _17;
      _Placeholder<18> _18;
      _Placeholder<19> _19;
      _Placeholder<20> _20;
      _Placeholder<21> _21;
      _Placeholder<22> _22;
      _Placeholder<23> _23;
      _Placeholder<24> _24;
      _Placeholder<25> _25;
      _Placeholder<26> _26;
      _Placeholder<27> _27;
      _Placeholder<28> _28;
      _Placeholder<29> _29;
    }
  }
  template<int _Num>
    struct is_placeholder<_Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };
  template<int... _Indexes>
    struct _Index_tuple
    {
      typedef _Index_tuple<_Indexes..., sizeof...(_Indexes)> __next;
    };
  template<std::size_t _Num>
    struct _Build_index_tuple
    {
      typedef typename _Build_index_tuple<_Num-1>::__type::__next __type;
    };
  template<>
    struct _Build_index_tuple<0>
    {
      typedef _Index_tuple<> __type;
    };
  struct _No_tuple_element;
  template<int __i, typename _Tuple, bool _IsSafe>
    struct _Safe_tuple_element_impl
    : tuple_element<__i, _Tuple> { };
  template<int __i, typename _Tuple>
    struct _Safe_tuple_element_impl<__i, _Tuple, false>
    {
      typedef _No_tuple_element type;
    };
 template<int __i, typename _Tuple>
   struct _Safe_tuple_element
   : _Safe_tuple_element_impl<__i, _Tuple,
                              (__i >= 0 && __i < tuple_size<_Tuple>::value)>
   { };
  template<typename _Arg,
           bool _IsBindExp = is_bind_expression<_Arg>::value,
           bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
    class _Mu;
  template<typename _Tp>
    class _Mu<reference_wrapper<_Tp>, false, false>
    {
    public:
      typedef _Tp& result_type;
      template<typename _CVRef, typename _Tuple>
        result_type
        operator()(_CVRef& __arg, _Tuple&&) const volatile
        { return __arg.get(); }
    };
  template<typename _Arg>
    class _Mu<_Arg, true, false>
    {
    public:
      template<typename _Signature> class result;
      template<typename _CVMu, typename _CVArg, typename... _Args>
        class result<_CVMu(_CVArg, tuple<_Args...>)>
 : public result_of<_CVArg(_Args...)> { };
      template<typename _CVArg, typename... _Args>
        typename result_of<_CVArg(_Args...)>::type
        operator()(_CVArg& __arg,
     tuple<_Args...>&& __tuple) const volatile
        {
   typedef typename _Build_index_tuple<sizeof...(_Args)>::__type
     _Indexes;
   return this->__call(__arg, std::move(__tuple), _Indexes());
 }
    private:
      template<typename _CVArg, typename... _Args, int... _Indexes>
        typename result_of<_CVArg(_Args...)>::type
        __call(_CVArg& __arg, tuple<_Args...>&& __tuple,
        const _Index_tuple<_Indexes...>&) const volatile
        {
   return __arg(std::forward<_Args>(get<_Indexes>(__tuple))...);
 }
    };
  template<typename _Arg>
    class _Mu<_Arg, false, true>
    {
    public:
      template<typename _Signature> class result;
      template<typename _CVMu, typename _CVArg, typename _Tuple>
        class result<_CVMu(_CVArg, _Tuple)>
        {
   typedef typename _Safe_tuple_element<(is_placeholder<_Arg>::value
      - 1), _Tuple>::type
     __base_type;
 public:
   typedef typename add_rvalue_reference<__base_type>::type type;
 };
      template<typename _Tuple>
        typename result<_Mu(_Arg, _Tuple)>::type
        operator()(const volatile _Arg&, _Tuple&& __tuple) const volatile
        {
   return std::forward<typename result<_Mu(_Arg, _Tuple)>::type>(
              ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple));
 }
    };
  template<typename _Arg>
    class _Mu<_Arg, false, false>
    {
    public:
      template<typename _Signature> struct result;
      template<typename _CVMu, typename _CVArg, typename _Tuple>
        struct result<_CVMu(_CVArg, _Tuple)>
        {
   typedef typename add_lvalue_reference<_CVArg>::type type;
 };
      template<typename _CVArg, typename _Tuple>
        _CVArg&&
        operator()(_CVArg&& __arg, _Tuple&&) const volatile
        { return std::forward<_CVArg>(__arg); }
    };
  template<typename _Tp>
    struct _Maybe_wrap_member_pointer
    {
      typedef _Tp type;
      static const _Tp&
      __do_wrap(const _Tp& __x)
      { return __x; }
    };
  template<typename _Tp, typename _Class>
    struct _Maybe_wrap_member_pointer<_Tp _Class::*>
    {
      typedef _Mem_fn<_Tp _Class::*> type;
      static type
      __do_wrap(_Tp _Class::* __pm)
      { return type(__pm); }
    };
  template<>
    struct _Maybe_wrap_member_pointer<void>
    {
      typedef void type;
    };
  template<typename _Signature>
    struct _Bind;
   template<typename _Functor, typename... _Bound_args>
    class _Bind<_Functor(_Bound_args...)>
    : public _Weak_result_type<_Functor>
    {
      typedef _Bind __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
        _Bound_indexes;
      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;
      template<typename _Result, typename... _Args, int... _Indexes>
        _Result
        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
        {
          return _M_f(_Mu<_Bound_args>()
                      (get<_Indexes>(_M_bound_args), std::move(__args))...);
        }
      template<typename _Result, typename... _Args, int... _Indexes>
        _Result
        __call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
        {
          return _M_f(_Mu<_Bound_args>()
                      (get<_Indexes>(_M_bound_args), std::move(__args))...);
        }
     public:
      explicit _Bind(_Functor __f, _Bound_args... __bound_args)
      : _M_f(std::forward<_Functor>(__f)),
 _M_bound_args(std::forward<_Bound_args>(__bound_args)...)
      { }
      template<typename... _Args, typename _Result
        = decltype( std::declval<_Functor>()(
              _Mu<_Bound_args>()( std::declval<_Bound_args&>(),
      std::declval<tuple<_Args...>&&>() )... ) )>
        _Result
        operator()(_Args&&... __args)
        {
          return this->__call<_Result>(tuple<_Args...>
           (std::forward<_Args>(__args)...),
                                       _Bound_indexes());
        }
      template<typename... _Args, typename _Result
        = decltype( std::declval<const _Functor>()(
       _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),
      std::declval<tuple<_Args...>&&>() )... ) )>
        _Result
        operator()(_Args&&... __args) const
        {
          return this->__call_c<_Result>(tuple<_Args...>
                                         (std::forward<_Args>(__args)...),
                                         _Bound_indexes());
        }
    };
  template<typename _Result, typename _Signature>
    struct _Bind_result;
  template<typename _Result, typename _Functor, typename... _Bound_args>
    class _Bind_result<_Result, _Functor(_Bound_args...)>
    {
      typedef _Bind_result __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
        _Bound_indexes;
      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;
      template<typename _Res>
        struct __enable_if_void : enable_if<is_void<_Res>::value, int> { };
      template<typename _Res>
        struct __disable_if_void : enable_if<!is_void<_Res>::value, int> { };
      template<typename _Res, typename... _Args, int... _Indexes>
        _Result
        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
            typename __disable_if_void<_Res>::type = 0)
        {
          return _M_f(_Mu<_Bound_args>()
                      (get<_Indexes>(_M_bound_args), std::move(__args))...);
        }
      template<typename _Res, typename... _Args, int... _Indexes>
        void
        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
            typename __enable_if_void<_Res>::type = 0)
        {
          _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), std::move(__args))...);
        }
      template<typename _Res, typename... _Args, int... _Indexes>
        _Result
        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
            typename __disable_if_void<_Res>::type = 0) const
        {
          return _M_f(_Mu<_Bound_args>()
                      (get<_Indexes>(_M_bound_args), std::move(__args))...);
        }
      template<typename _Res, typename... _Args, int... _Indexes>
        void
        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
            typename __enable_if_void<_Res>::type = 0) const
        {
          _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), std::move(__args))...);
        }
      template<typename _Res, typename... _Args, int... _Indexes>
        _Result
        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
            typename __disable_if_void<_Res>::type = 0) volatile
        {
          return _M_f(_Mu<_Bound_args>()
                      (get<_Indexes>(_M_bound_args), std::move(__args))...);
        }
      template<typename _Res, typename... _Args, int... _Indexes>
        void
        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
            typename __enable_if_void<_Res>::type = 0) volatile
        {
          _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), std::move(__args))...);
        }
      template<typename _Res, typename... _Args, int... _Indexes>
        _Result
        __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
            typename __disable_if_void<_Res>::type = 0) const volatile
        {
          return _M_f(_Mu<_Bound_args>()
                      (get<_Indexes>(_M_bound_args), std::move(__args))...);
        }
      template<typename _Res, typename... _Args, int... _Indexes>
        void
        __call(tuple<_Args...>&& __args,
               _Index_tuple<_Indexes...>,
            typename __enable_if_void<_Res>::type = 0) const volatile
        {
          _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), std::move(__args))...);
        }
    public:
      typedef _Result result_type;
      explicit
      _Bind_result(_Functor __f, _Bound_args... __bound_args)
      : _M_f(std::forward<_Functor>(__f)),
 _M_bound_args(std::forward<_Bound_args>(__bound_args)...)
      { }
      template<typename... _Args>
        result_type
        operator()(_Args&&... __args)
        {
          return this->__call<_Result>(
              tuple<_Args...>(std::forward<_Args>(__args)...),
              _Bound_indexes());
        }
      template<typename... _Args>
        result_type
        operator()(_Args&&... __args) const
        {
          return this->__call<_Result>(
              tuple<_Args...>(std::forward<_Args>(__args)...),
              _Bound_indexes());
        }
      template<typename... _Args>
        result_type
        operator()(_Args&&... __args) volatile
        {
          return this->__call<_Result>(
              tuple<_Args...>(std::forward<_Args>(__args)...),
              _Bound_indexes());
        }
      template<typename... _Args>
        result_type
        operator()(_Args&&... __args) const volatile
        {
          return this->__call<_Result>(
              tuple<_Args...>(std::forward<_Args>(__args)...),
              _Bound_indexes());
        }
    };
  template<typename _Signature>
    struct is_bind_expression<_Bind<_Signature> >
    : public true_type { };
  template<typename _Result, typename _Signature>
    struct is_bind_expression<_Bind_result<_Result, _Signature> >
    : public true_type { };
  template<typename _Functor, typename... _ArgTypes>
    inline
    _Bind<typename _Maybe_wrap_member_pointer<_Functor>::type(_ArgTypes...)>
    bind(_Functor __f, _ArgTypes... __args)
    {
      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;
      typedef typename __maybe_type::type __functor_type;
      typedef _Bind<__functor_type(_ArgTypes...)> __result_type;
      return __result_type(__maybe_type::__do_wrap(__f),
                           std::forward<_ArgTypes>(__args)...);
    }
  template<typename _Result, typename _Functor, typename... _ArgTypes>
    inline
    _Bind_result<_Result,
   typename _Maybe_wrap_member_pointer<_Functor>::type
                            (_ArgTypes...)>
    bind(_Functor __f, _ArgTypes... __args)
    {
      typedef _Maybe_wrap_member_pointer<_Functor> __maybe_type;
      typedef typename __maybe_type::type __functor_type;
      typedef _Bind_result<_Result, __functor_type(_ArgTypes...)>
 __result_type;
      return __result_type(__maybe_type::__do_wrap(__f),
                           std::forward<_ArgTypes>(__args)...);
    }
  class bad_function_call : public std::exception { };
  struct _M_clear_type;
  template<typename _Tp>
    struct __is_location_invariant
    : integral_constant<bool, (is_pointer<_Tp>::value
          || is_member_pointer<_Tp>::value)>
    { };
  class _Undefined_class;
  union _Nocopy_types
  {
    void* _M_object;
    const void* _M_const_object;
    void (*_M_function_pointer)();
    void (_Undefined_class::*_M_member_pointer)();
  };
  union _Any_data
  {
    void* _M_access() { return &_M_pod_data[0]; }
    const void* _M_access() const { return &_M_pod_data[0]; }
    template<typename _Tp>
      _Tp&
      _M_access()
      { return *static_cast<_Tp*>(_M_access()); }
    template<typename _Tp>
      const _Tp&
      _M_access() const
      { return *static_cast<const _Tp*>(_M_access()); }
    _Nocopy_types _M_unused;
    char _M_pod_data[sizeof(_Nocopy_types)];
  };
  enum _Manager_operation
  {
    __get_type_info,
    __get_functor_ptr,
    __clone_functor,
    __destroy_functor
  };
  template<typename _Tp>
    struct _Simple_type_wrapper
    {
      _Simple_type_wrapper(_Tp __value) : __value(__value) { }
      _Tp __value;
    };
  template<typename _Tp>
    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >
    : __is_location_invariant<_Tp>
    { };
  template<typename _Functor>
    inline _Functor&
    __callable_functor(_Functor& __f)
    { return __f; }
  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* &__p)
    { return mem_fn(__p); }
  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* const &__p)
    { return mem_fn(__p); }
  template<typename _Signature>
    class function;
  class _Function_base
  {
  public:
    static const std::size_t _M_max_size = sizeof(_Nocopy_types);
    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);
    template<typename _Functor>
      class _Base_manager
      {
      protected:
 static const bool __stored_locally =
        (__is_location_invariant<_Functor>::value
         && sizeof(_Functor) <= _M_max_size
         && __alignof__(_Functor) <= _M_max_align
         && (_M_max_align % __alignof__(_Functor) == 0));
 typedef integral_constant<bool, __stored_locally> _Local_storage;
 static _Functor*
 _M_get_pointer(const _Any_data& __source)
 {
   const _Functor* __ptr =
     __stored_locally? &__source._M_access<_Functor>()
                                 : __source._M_access<_Functor*>();
   return const_cast<_Functor*>(__ptr);
 }
 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
 {
   new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 }
 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
 {
   __dest._M_access<_Functor*>() =
     new _Functor(*__source._M_access<_Functor*>());
 }
 static void
 _M_destroy(_Any_data& __victim, true_type)
 {
   __victim._M_access<_Functor>().~_Functor();
 }
 static void
 _M_destroy(_Any_data& __victim, false_type)
 {
   delete __victim._M_access<_Functor*>();
 }
      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {
     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;
     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = _M_get_pointer(__source);
       break;
     case __clone_functor:
       _M_clone(__dest, __source, _Local_storage());
       break;
     case __destroy_functor:
       _M_destroy(__dest, _Local_storage());
       break;
     }
   return false;
 }
 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f)
 { _M_init_functor(__functor, std::move(__f), _Local_storage()); }
 template<typename _Signature>
   static bool
   _M_not_empty_function(const function<_Signature>& __f)
          { return static_cast<bool>(__f); }
 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp*& __fp)
   { return __fp; }
 template<typename _Class, typename _Tp>
   static bool
   _M_not_empty_function(_Tp _Class::* const& __mp)
   { return __mp; }
 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp&)
   { return true; }
      private:
        static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
 { new (__functor._M_access()) _Functor(std::move(__f)); }
 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
 { __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
      };
    template<typename _Functor>
      class _Ref_manager : public _Base_manager<_Functor*>
      {
 typedef _Function_base::_Base_manager<_Functor*> _Base;
    public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {
     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;
     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);
       return is_const<_Functor>::value;
       break;
     default:
       _Base::_M_manager(__dest, __source, __op);
     }
   return false;
 }
 static void
 _M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)
 {
   _Base::_M_init_functor(__functor, &__f.get());
 }
      };
    _Function_base() : _M_manager(0) { }
    ~_Function_base()
    {
      if (_M_manager)
 _M_manager(_M_functor, _M_functor, __destroy_functor);
    }
    bool _M_empty() const { return !_M_manager; }
    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
                                  _Manager_operation);
    _Any_data _M_functor;
    _Manager_type _M_manager;
  };
  template<typename _Signature, typename _Functor>
    class _Function_handler;
  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;
    public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
        return (*_Base::_M_get_pointer(__functor))(
            std::forward<_ArgTypes>(__args)...);
      }
    };
  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;
     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
        (*_Base::_M_get_pointer(__functor))(
            std::forward<_ArgTypes>(__args)...);
      }
    };
  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;
     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
        return __callable_functor(**_Base::_M_get_pointer(__functor))(
              std::forward<_ArgTypes>(__args)...);
      }
    };
  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;
     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
        __callable_functor(**_Base::_M_get_pointer(__functor))(
            std::forward<_ArgTypes>(__args)...);
      }
    };
  template<typename _Class, typename _Member, typename _Res,
           typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>
    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>
    {
      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>
        _Base;
     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
        return mem_fn(_Base::_M_get_pointer(__functor)->__value)(
            std::forward<_ArgTypes>(__args)...);
      }
    };
  template<typename _Class, typename _Member, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Member _Class::*>
    : public _Function_base::_Base_manager<
                 _Simple_type_wrapper< _Member _Class::* > >
    {
      typedef _Member _Class::* _Functor;
      typedef _Simple_type_wrapper<_Functor> _Wrapper;
      typedef _Function_base::_Base_manager<_Wrapper> _Base;
     public:
      static bool
      _M_manager(_Any_data& __dest, const _Any_data& __source,
                 _Manager_operation __op)
      {
        switch (__op)
   {
   case __get_type_info:
     __dest._M_access<const type_info*>() = &typeid(_Functor);
     break;
   case __get_functor_ptr:
     __dest._M_access<_Functor*>() =
       &_Base::_M_get_pointer(__source)->__value;
     break;
   default:
     _Base::_M_manager(__dest, __source, __op);
   }
        return false;
      }
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 mem_fn(_Base::_M_get_pointer(__functor)->__value)(
            std::forward<_ArgTypes>(__args)...);
      }
    };
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
      private _Function_base
    {
      typedef _Res _Signature_type(_ArgTypes...);
      struct _Useless { };
    public:
      typedef _Res result_type;
      explicit
      function() : _Function_base() { }
      function(_M_clear_type*) : _Function_base() { }
      function(const function& __x);
      function(function&& __x) : _Function_base()
      {
        __x.swap(*this);
      }
      template<typename _Functor>
        function(_Functor __f,
                 typename enable_if<
                           !is_integral<_Functor>::value, _Useless>::type
                   = _Useless());
      function&
      operator=(const function& __x)
      {
        function(__x).swap(*this);
        return *this;
      }
      function&
      operator=(function&& __x)
      {
        function(std::move(__x)).swap(*this);
        return *this;
      }
      function&
      operator=(_M_clear_type*)
      {
        if (_M_manager)
   {
     _M_manager(_M_functor, _M_functor, __destroy_functor);
     _M_manager = 0;
     _M_invoker = 0;
   }
        return *this;
      }
      template<typename _Functor>
        typename enable_if<!is_integral<_Functor>::value, function&>::type
 operator=(_Functor&& __f)
 {
   function(std::forward<_Functor>(__f)).swap(*this);
   return *this;
 }
      template<typename _Functor>
        typename enable_if<!is_integral<_Functor>::value, function&>::type
 operator=(reference_wrapper<_Functor> __f)
 {
   function(__f).swap(*this);
   return *this;
 }
      void swap(function& __x)
      {
 for (unsigned i = 0; i < sizeof (_M_functor._M_pod_data); ++i)
   std::swap (_M_functor._M_pod_data[i], __x._M_functor._M_pod_data[i]);
 _Manager_type __old_manager = _M_manager;
 _M_manager = __x._M_manager;
 __x._M_manager = __old_manager;
 _Invoker_type __old_invoker = _M_invoker;
 _M_invoker = __x._M_invoker;
 __x._M_invoker = __old_invoker;
      }
      explicit operator bool() const
      { return !_M_empty(); }
      _Res operator()(_ArgTypes... __args) const;
      const type_info& target_type() const;
      template<typename _Functor> _Functor* target();
      template<typename _Functor> const _Functor* target() const;
      template<typename _Res2, typename... _ArgTypes2>
 void operator==(const function<_Res2(_ArgTypes2...)>&) const = delete;
      template<typename _Res2, typename... _ArgTypes2>
 void operator!=(const function<_Res2(_ArgTypes2...)>&) const = delete;
    private:
      typedef _Res (*_Invoker_type)(const _Any_data&, _ArgTypes...);
      _Invoker_type _M_invoker;
  };
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 {
   _M_invoker = __x._M_invoker;
   _M_manager = __x._M_manager;
   __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 }
    }
  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      function<_Res(_ArgTypes...)>::
      function(_Functor __f,
        typename enable_if<
                 !is_integral<_Functor>::value, _Useless>::type)
      : _Function_base()
      {
 typedef _Function_handler<_Signature_type, _Functor> _My_handler;
 if (_My_handler::_M_not_empty_function(__f))
   {
     _M_invoker = &_My_handler::_M_invoke;
     _M_manager = &_My_handler::_M_manager;
     _My_handler::_M_init_functor(_M_functor, std::move(__f));
   }
      }
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
        __throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
    }
  template<typename _Res, typename... _ArgTypes>
    const type_info&
    function<_Res(_ArgTypes...)>::
    target_type() const
    {
      if (_M_manager)
        {
          _Any_data __typeinfo_result;
          _M_manager(__typeinfo_result, _M_functor, __get_type_info);
          return *__typeinfo_result._M_access<const type_info*>();
        }
      else
 return typeid(void);
    }
  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      _Functor*
      function<_Res(_ArgTypes...)>::
      target()
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     if (_M_manager(__ptr, _M_functor, __get_functor_ptr)
  && !is_const<_Functor>::value)
       return 0;
     else
       return __ptr._M_access<_Functor*>();
   }
 else
   return 0;
      }
  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      const _Functor*
      function<_Res(_ArgTypes...)>::
      target() const
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     _M_manager(__ptr, _M_functor, __get_functor_ptr);
     return __ptr._M_access<const _Functor*>();
   }
 else
   return 0;
      }
  template<typename _Res, typename... _Args>
    inline bool
    operator==(const function<_Res(_Args...)>& __f, _M_clear_type*)
    { return !static_cast<bool>(__f); }
  template<typename _Res, typename... _Args>
    inline bool
    operator==(_M_clear_type*, const function<_Res(_Args...)>& __f)
    { return !static_cast<bool>(__f); }
  template<typename _Res, typename... _Args>
    inline bool
    operator!=(const function<_Res(_Args...)>& __f, _M_clear_type*)
    { return static_cast<bool>(__f); }
  template<typename _Res, typename... _Args>
    inline bool
    operator!=(_M_clear_type*, const function<_Res(_Args...)>& __f)
    { return static_cast<bool>(__f); }
  template<typename _Res, typename... _Args>
    inline void
    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y)
    { __x.swap(__y); }
}
namespace boost {
template<class OptionalPointee>
inline
bool equal_pointees ( OptionalPointee const& x, OptionalPointee const& y )
{
  return (!x) != (!y) ? false : ( !x ? true : (*x) == (*y) ) ;
}
template<class OptionalPointee>
struct equal_pointees_t : std::binary_function<OptionalPointee,OptionalPointee,bool>
{
  bool operator() ( OptionalPointee const& x, OptionalPointee const& y ) const
    { return equal_pointees(x,y) ; }
} ;
template<class OptionalPointee>
inline
bool less_pointees ( OptionalPointee const& x, OptionalPointee const& y )
{
  return !y ? false : ( !x ? true : (*x) < (*y) ) ;
}
template<class OptionalPointee>
struct less_pointees_t : std::binary_function<OptionalPointee,OptionalPointee,bool>
{
  bool operator() ( OptionalPointee const& x, OptionalPointee const& y ) const
    { return less_pointees(x,y) ; }
} ;
}
       
namespace boost {
class in_place_factory_base {} ;
class in_place_factory0
  :
  public in_place_factory_base
{
public:
  explicit in_place_factory0
      ( )
  {}
  template<class T>
  void* apply(void* address
      ) const
  {
    return new(address) T( );
  }
  template<class T>
  void* apply(void* address, std::size_t n
      ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }
 
};
inline in_place_factory0 in_place()
{
  return in_place_factory0();
}
template< class A0 >
class in_place_factory1
  :
  public in_place_factory_base
{
public:
  explicit in_place_factory1
      ( A0 const& a0 )
    : m_a0 ( a0 )
  {}
  template<class T>
  void* apply(void* address
      ) const
  {
    return new(address) T( m_a0 );
  }
  template<class T>
  void* apply(void* address, std::size_t n
      ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }
  A0 const& m_a0;
};
template< class A0 >
inline in_place_factory1< A0 >
in_place( A0 const& a0 )
{
  return in_place_factory1< A0 >
      ( a0 );
}
template< class A0 , class A1 >
class in_place_factory2
  :
  public in_place_factory_base
{
public:
  explicit in_place_factory2
      ( A0 const& a0 , A1 const& a1 )
    : m_a0 ( a0 ) , m_a1 ( a1 )
  {}
  template<class T>
  void* apply(void* address
      ) const
  {
    return new(address) T( m_a0 , m_a1 );
  }
  template<class T>
  void* apply(void* address, std::size_t n
      ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }
  A0 const& m_a0; A1 const& m_a1;
};
template< class A0 , class A1 >
inline in_place_factory2< A0 , A1 >
in_place( A0 const& a0 , A1 const& a1 )
{
  return in_place_factory2< A0 , A1 >
      ( a0 , a1 );
}
template< class A0 , class A1 , class A2 >
class in_place_factory3
  :
  public in_place_factory_base
{
public:
  explicit in_place_factory3
      ( A0 const& a0 , A1 const& a1 , A2 const& a2 )
    : m_a0 ( a0 ) , m_a1 ( a1 ) , m_a2 ( a2 )
  {}
  template<class T>
  void* apply(void* address
      ) const
  {
    return new(address) T( m_a0 , m_a1 , m_a2 );
  }
  template<class T>
  void* apply(void* address, std::size_t n
      ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }
  A0 const& m_a0; A1 const& m_a1; A2 const& m_a2;
};
template< class A0 , class A1 , class A2 >
inline in_place_factory3< A0 , A1 , A2 >
in_place( A0 const& a0 , A1 const& a1 , A2 const& a2 )
{
  return in_place_factory3< A0 , A1 , A2 >
      ( a0 , a1 , a2 );
}
template< class A0 , class A1 , class A2 , class A3 >
class in_place_factory4
  :
  public in_place_factory_base
{
public:
  explicit in_place_factory4
      ( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 )
    : m_a0 ( a0 ) , m_a1 ( a1 ) , m_a2 ( a2 ) , m_a3 ( a3 )
  {}
  template<class T>
  void* apply(void* address
      ) const
  {
    return new(address) T( m_a0 , m_a1 , m_a2 , m_a3 );
  }
  template<class T>
  void* apply(void* address, std::size_t n
      ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }
  A0 const& m_a0; A1 const& m_a1; A2 const& m_a2; A3 const& m_a3;
};
template< class A0 , class A1 , class A2 , class A3 >
inline in_place_factory4< A0 , A1 , A2 , A3 >
in_place( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 )
{
  return in_place_factory4< A0 , A1 , A2 , A3 >
      ( a0 , a1 , a2 , a3 );
}
template< class A0 , class A1 , class A2 , class A3 , class A4 >
class in_place_factory5
  :
  public in_place_factory_base
{
public:
  explicit in_place_factory5
      ( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 )
    : m_a0 ( a0 ) , m_a1 ( a1 ) , m_a2 ( a2 ) , m_a3 ( a3 ) , m_a4 ( a4 )
  {}
  template<class T>
  void* apply(void* address
      ) const
  {
    return new(address) T( m_a0 , m_a1 , m_a2 , m_a3 , m_a4 );
  }
  template<class T>
  void* apply(void* address, std::size_t n
      ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }
  A0 const& m_a0; A1 const& m_a1; A2 const& m_a2; A3 const& m_a3; A4 const& m_a4;
};
template< class A0 , class A1 , class A2 , class A3 , class A4 >
inline in_place_factory5< A0 , A1 , A2 , A3 , A4 >
in_place( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 )
{
  return in_place_factory5< A0 , A1 , A2 , A3 , A4 >
      ( a0 , a1 , a2 , a3 , a4 );
}
template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 >
class in_place_factory6
  :
  public in_place_factory_base
{
public:
  explicit in_place_factory6
      ( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 )
    : m_a0 ( a0 ) , m_a1 ( a1 ) , m_a2 ( a2 ) , m_a3 ( a3 ) , m_a4 ( a4 ) , m_a5 ( a5 )
  {}
  template<class T>
  void* apply(void* address
      ) const
  {
    return new(address) T( m_a0 , m_a1 , m_a2 , m_a3 , m_a4 , m_a5 );
  }
  template<class T>
  void* apply(void* address, std::size_t n
      ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }
  A0 const& m_a0; A1 const& m_a1; A2 const& m_a2; A3 const& m_a3; A4 const& m_a4; A5 const& m_a5;
};
template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 >
inline in_place_factory6< A0 , A1 , A2 , A3 , A4 , A5 >
in_place( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 )
{
  return in_place_factory6< A0 , A1 , A2 , A3 , A4 , A5 >
      ( a0 , a1 , a2 , a3 , a4 , a5 );
}
template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 >
class in_place_factory7
  :
  public in_place_factory_base
{
public:
  explicit in_place_factory7
      ( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 )
    : m_a0 ( a0 ) , m_a1 ( a1 ) , m_a2 ( a2 ) , m_a3 ( a3 ) , m_a4 ( a4 ) , m_a5 ( a5 ) , m_a6 ( a6 )
  {}
  template<class T>
  void* apply(void* address
      ) const
  {
    return new(address) T( m_a0 , m_a1 , m_a2 , m_a3 , m_a4 , m_a5 , m_a6 );
  }
  template<class T>
  void* apply(void* address, std::size_t n
      ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }
  A0 const& m_a0; A1 const& m_a1; A2 const& m_a2; A3 const& m_a3; A4 const& m_a4; A5 const& m_a5; A6 const& m_a6;
};
template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 >
inline in_place_factory7< A0 , A1 , A2 , A3 , A4 , A5 , A6 >
in_place( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 )
{
  return in_place_factory7< A0 , A1 , A2 , A3 , A4 , A5 , A6 >
      ( a0 , a1 , a2 , a3 , a4 , a5 , a6 );
}
template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 >
class in_place_factory8
  :
  public in_place_factory_base
{
public:
  explicit in_place_factory8
      ( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 )
    : m_a0 ( a0 ) , m_a1 ( a1 ) , m_a2 ( a2 ) , m_a3 ( a3 ) , m_a4 ( a4 ) , m_a5 ( a5 ) , m_a6 ( a6 ) , m_a7 ( a7 )
  {}
  template<class T>
  void* apply(void* address
      ) const
  {
    return new(address) T( m_a0 , m_a1 , m_a2 , m_a3 , m_a4 , m_a5 , m_a6 , m_a7 );
  }
  template<class T>
  void* apply(void* address, std::size_t n
      ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }
  A0 const& m_a0; A1 const& m_a1; A2 const& m_a2; A3 const& m_a3; A4 const& m_a4; A5 const& m_a5; A6 const& m_a6; A7 const& m_a7;
};
template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 >
inline in_place_factory8< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 >
in_place( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 )
{
  return in_place_factory8< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 >
      ( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 );
}
template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 >
class in_place_factory9
  :
  public in_place_factory_base
{
public:
  explicit in_place_factory9
      ( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 )
    : m_a0 ( a0 ) , m_a1 ( a1 ) , m_a2 ( a2 ) , m_a3 ( a3 ) , m_a4 ( a4 ) , m_a5 ( a5 ) , m_a6 ( a6 ) , m_a7 ( a7 ) , m_a8 ( a8 )
  {}
  template<class T>
  void* apply(void* address
      ) const
  {
    return new(address) T( m_a0 , m_a1 , m_a2 , m_a3 , m_a4 , m_a5 , m_a6 , m_a7 , m_a8 );
  }
  template<class T>
  void* apply(void* address, std::size_t n
      ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }
  A0 const& m_a0; A1 const& m_a1; A2 const& m_a2; A3 const& m_a3; A4 const& m_a4; A5 const& m_a5; A6 const& m_a6; A7 const& m_a7; A8 const& m_a8;
};
template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 >
inline in_place_factory9< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 >
in_place( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 )
{
  return in_place_factory9< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 >
      ( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 );
}
template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 >
class in_place_factory10
  :
  public in_place_factory_base
{
public:
  explicit in_place_factory10
      ( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 )
    : m_a0 ( a0 ) , m_a1 ( a1 ) , m_a2 ( a2 ) , m_a3 ( a3 ) , m_a4 ( a4 ) , m_a5 ( a5 ) , m_a6 ( a6 ) , m_a7 ( a7 ) , m_a8 ( a8 ) , m_a9 ( a9 )
  {}
  template<class T>
  void* apply(void* address
      ) const
  {
    return new(address) T( m_a0 , m_a1 , m_a2 , m_a3 , m_a4 , m_a5 , m_a6 , m_a7 , m_a8 , m_a9 );
  }
  template<class T>
  void* apply(void* address, std::size_t n
      ) const
  {
    for(char* next = address = this->template apply<T>(address);
        !! --n;)
      this->template apply<T>(next = next+sizeof(T));
    return address;
  }
  A0 const& m_a0; A1 const& m_a1; A2 const& m_a2; A3 const& m_a3; A4 const& m_a4; A5 const& m_a5; A6 const& m_a6; A7 const& m_a7; A8 const& m_a8; A9 const& m_a9;
};
template< class A0 , class A1 , class A2 , class A3 , class A4 , class A5 , class A6 , class A7 , class A8 , class A9 >
inline in_place_factory10< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 >
in_place( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 , A5 const& a5 , A6 const& a6 , A7 const& a7 , A8 const& a8 , A9 const& a9 )
{
  return in_place_factory10< A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 , A8 , A9 >
      ( a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 );
}
}
namespace boost {
template<class T> class optional ;
template<class T> void swap ( optional<T>& , optional<T>& ) ;
template<class T> struct optional_swap_should_use_default_constructor ;
}
namespace boost_optional_detail
{
  template <class T, class Factory>
  inline void construct(Factory const& factory, void* address)
  {
    factory.template apply<T>(address);
  }
}
namespace boost {
class in_place_factory_base ;
class typed_in_place_factory_base ;
template<class T> void swap ( optional<T>& x, optional<T>& y );
namespace optional_detail {
template <class T>
class aligned_storage
{
    union
    __attribute__((may_alias))
    dummy_u
    {
        char data[ sizeof(T) ];
        typename type_with_alignment<
          ::boost::alignment_of<T>::value >::type aligner_;
    } dummy_ ;
  public:
    void const* address() const { return &dummy_; }
    void * address() { return &dummy_; }
} ;
template<class T>
struct types_when_isnt_ref
{
  typedef T const& reference_const_type ;
  typedef T & reference_type ;
  typedef T const* pointer_const_type ;
  typedef T * pointer_type ;
  typedef T const& argument_type ;
} ;
template<class T>
struct types_when_is_ref
{
  typedef typename remove_reference<T>::type raw_type ;
  typedef raw_type& reference_const_type ;
  typedef raw_type& reference_type ;
  typedef raw_type* pointer_const_type ;
  typedef raw_type* pointer_type ;
  typedef raw_type& argument_type ;
} ;
struct optional_tag {} ;
template<class T>
class optional_base : public optional_tag
{
  private :
    typedef
    typename
    ::boost::detail::make_reference_content<T>::type internal_type ;
    typedef aligned_storage<internal_type> storage_type ;
    typedef types_when_isnt_ref<T> types_when_not_ref ;
    typedef types_when_is_ref<T> types_when_ref ;
    typedef optional_base<T> this_type ;
  protected :
    typedef T value_type ;
    typedef mpl::true_ is_reference_tag ;
    typedef mpl::false_ is_not_reference_tag ;
    typedef typename is_reference<T>::type is_reference_predicate ;
  public:
    typedef typename mpl::if_<is_reference_predicate,types_when_ref,types_when_not_ref>::type types ;
  protected:
    typedef bool (this_type::*unspecified_bool_type)() const;
    typedef typename types::reference_type reference_type ;
    typedef typename types::reference_const_type reference_const_type ;
    typedef typename types::pointer_type pointer_type ;
    typedef typename types::pointer_const_type pointer_const_type ;
    typedef typename types::argument_type argument_type ;
    optional_base()
      :
      m_initialized(false) {}
    optional_base ( none_t )
      :
      m_initialized(false) {}
    optional_base ( argument_type val )
      :
      m_initialized(false)
    {
      construct(val);
    }
    optional_base ( bool cond, argument_type val )
      :
      m_initialized(false)
    {
      if ( cond )
        construct(val);
    }
    optional_base ( optional_base const& rhs )
      :
      m_initialized(false)
    {
      if ( rhs.is_initialized() )
        construct(rhs.get_impl());
    }
    template<class Expr>
    explicit optional_base ( Expr const& expr, Expr const* tag )
      :
      m_initialized(false)
    {
      construct(expr,tag);
    }
    ~optional_base() { destroy() ; }
    void assign ( optional_base const& rhs )
    {
      if (is_initialized())
      {
        if ( rhs.is_initialized() )
             assign_value(rhs.get_impl(), is_reference_predicate() );
        else destroy();
      }
      else
      {
        if ( rhs.is_initialized() )
          construct(rhs.get_impl());
      }
    }
    template<class U>
    void assign ( optional<U> const& rhs )
    {
      if (is_initialized())
      {
        if ( rhs.is_initialized() )
             assign_value(static_cast<value_type>(rhs.get()), is_reference_predicate() );
        else destroy();
      }
      else
      {
        if ( rhs.is_initialized() )
          construct(static_cast<value_type>(rhs.get()));
      }
    }
    void assign ( argument_type val )
    {
      if (is_initialized())
           assign_value(val, is_reference_predicate() );
      else construct(val);
    }
    void assign ( none_t ) { destroy(); }
    template<class Expr>
    void assign_expr ( Expr const& expr, Expr const* tag )
      {
        if (is_initialized())
             assign_expr_to_initialized(expr,tag);
        else construct(expr,tag);
      }
  public :
    void reset() { destroy(); }
    void reset ( argument_type val ) { assign(val); }
    pointer_const_type get_ptr() const { return m_initialized ? get_ptr_impl() : 0 ; }
    pointer_type get_ptr() { return m_initialized ? get_ptr_impl() : 0 ; }
    bool is_initialized() const { return m_initialized ; }
  protected :
    void construct ( argument_type val )
     {
       new (m_storage.address()) internal_type(val) ;
       m_initialized = true ;
     }
    template<class Expr>
    void construct ( Expr const& factory, in_place_factory_base const* )
     {
       static_assert(::boost::mpl::not_<is_reference_predicate>::value, "::boost::mpl::not_<is_reference_predicate>::value") ;
       boost_optional_detail::construct<value_type>(factory, m_storage.address());
       m_initialized = true ;
     }
    template<class Expr>
    void construct ( Expr const& factory, typed_in_place_factory_base const* )
     {
       static_assert(::boost::mpl::not_<is_reference_predicate>::value, "::boost::mpl::not_<is_reference_predicate>::value") ;
       factory.apply(m_storage.address()) ;
       m_initialized = true ;
     }
    template<class Expr>
    void assign_expr_to_initialized ( Expr const& factory, in_place_factory_base const* tag )
     {
       destroy();
       construct(factory,tag);
     }
    template<class Expr>
    void assign_expr_to_initialized ( Expr const& factory, typed_in_place_factory_base const* tag )
     {
       destroy();
       construct(factory,tag);
     }
    template<class Expr>
    void construct ( Expr const& expr, void const* )
     {
       new (m_storage.address()) internal_type(expr) ;
       m_initialized = true ;
     }
    template<class Expr>
    void assign_expr_to_initialized ( Expr const& expr, void const* )
     {
       assign_value(expr, is_reference_predicate());
     }
    void assign_value ( argument_type val, is_not_reference_tag ) { get_impl() = val; }
    void assign_value ( argument_type val, is_reference_tag ) { construct(val); }
    void destroy()
    {
      if ( m_initialized )
        destroy_impl(is_reference_predicate()) ;
    }
    unspecified_bool_type safe_bool() const { return m_initialized ? &this_type::is_initialized : 0 ; }
    reference_const_type get_impl() const { return dereference(get_object(), is_reference_predicate() ) ; }
    reference_type get_impl() { return dereference(get_object(), is_reference_predicate() ) ; }
    pointer_const_type get_ptr_impl() const { return cast_ptr(get_object(), is_reference_predicate() ) ; }
    pointer_type get_ptr_impl() { return cast_ptr(get_object(), is_reference_predicate() ) ; }
  private :
    internal_type const* get_object() const
    {
        union { void const* ap_pvoid; internal_type const* as_ptype; } caster = { m_storage.address() };
        return caster.as_ptype;
    }
    internal_type * get_object()
    {
        union { void* ap_pvoid; internal_type* as_ptype; } caster = { m_storage.address() };
        return caster.as_ptype;
    }
    reference_const_type dereference( internal_type const* p, is_not_reference_tag ) const { return *p ; }
    reference_type dereference( internal_type* p, is_not_reference_tag ) { return *p ; }
    reference_const_type dereference( internal_type const* p, is_reference_tag ) const { return p->get() ; }
    reference_type dereference( internal_type* p, is_reference_tag ) { return p->get() ; }
    void destroy_impl ( is_not_reference_tag ) { get_ptr_impl()->T::~T() ; m_initialized = false ; }
    void destroy_impl ( is_reference_tag ) { m_initialized = false ; }
    pointer_const_type cast_ptr( internal_type const* p, is_not_reference_tag ) const { return p ; }
    pointer_type cast_ptr( internal_type * p, is_not_reference_tag ) { return p ; }
    pointer_const_type cast_ptr( internal_type const* p, is_reference_tag ) const { return &p->get() ; }
    pointer_type cast_ptr( internal_type * p, is_reference_tag ) { return &p->get() ; }
    bool m_initialized ;
    storage_type m_storage ;
} ;
}
template<class T>
class optional : public optional_detail::optional_base<T>
{
    typedef optional_detail::optional_base<T> base ;
    typedef typename base::unspecified_bool_type unspecified_bool_type ;
  public :
    typedef optional<T> this_type ;
    typedef typename base::value_type value_type ;
    typedef typename base::reference_type reference_type ;
    typedef typename base::reference_const_type reference_const_type ;
    typedef typename base::pointer_type pointer_type ;
    typedef typename base::pointer_const_type pointer_const_type ;
    typedef typename base::argument_type argument_type ;
    optional() : base() {}
    optional( none_t none_ ) : base(none_) {}
    optional ( argument_type val ) : base(val) {}
    optional ( bool cond, argument_type val ) : base(cond,val) {}
    template<class U>
    explicit optional ( optional<U> const& rhs )
      :
      base()
    {
      if ( rhs.is_initialized() )
        this->construct(rhs.get());
    }
    template<class Expr>
    explicit optional ( Expr const& expr ) : base(expr,boost::addressof(expr)) {}
    optional ( optional const& rhs ) : base( static_cast<base const&>(rhs) ) {}
    ~optional() {}
    template<class Expr>
    optional& operator= ( Expr const& expr )
      {
        this->assign_expr(expr,boost::addressof(expr));
        return *this ;
      }
    template<class U>
    optional& operator= ( optional<U> const& rhs )
      {
        this->assign(rhs);
        return *this ;
      }
    optional& operator= ( optional const& rhs )
      {
        this->assign( static_cast<base const&>(rhs) ) ;
        return *this ;
      }
    optional& operator= ( argument_type val )
      {
        this->assign( val ) ;
        return *this ;
      }
    optional& operator= ( none_t none_ )
      {
        this->assign( none_ ) ;
        return *this ;
      }
    void swap( optional & arg )
      {
        using boost::swap;
        swap(*this, arg);
      }
    reference_const_type get() const { (__builtin_expect(!(this->is_initialized()), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/optional/optional.hpp", 630, "this->is_initialized()") : (void)0) ; return this->get_impl(); }
    reference_type get() { (__builtin_expect(!(this->is_initialized()), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/optional/optional.hpp", 631, "this->is_initialized()") : (void)0) ; return this->get_impl(); }
    reference_const_type get_value_or ( reference_const_type v ) const { return this->is_initialized() ? get() : v ; }
    reference_type get_value_or ( reference_type v ) { return this->is_initialized() ? get() : v ; }
    pointer_const_type operator->() const { (__builtin_expect(!(this->is_initialized()), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/optional/optional.hpp", 640, "this->is_initialized()") : (void)0) ; return this->get_ptr_impl() ; }
    pointer_type operator->() { (__builtin_expect(!(this->is_initialized()), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/optional/optional.hpp", 641, "this->is_initialized()") : (void)0) ; return this->get_ptr_impl() ; }
    reference_const_type operator *() const { return this->get() ; }
    reference_type operator *() { return this->get() ; }
    operator unspecified_bool_type() const { return this->safe_bool() ; }
    bool operator!() const { return !this->is_initialized() ; }
} ;
template<class T>
inline
optional<T> make_optional ( T const& v )
{
  return optional<T>(v);
}
template<class T>
inline
optional<T> make_optional ( bool cond, T const& v )
{
  return optional<T>(cond,v);
}
template<class T>
inline
typename optional<T>::reference_const_type
get ( optional<T> const& opt )
{
  return opt.get() ;
}
template<class T>
inline
typename optional<T>::reference_type
get ( optional<T>& opt )
{
  return opt.get() ;
}
template<class T>
inline
typename optional<T>::pointer_const_type
get ( optional<T> const* opt )
{
  return opt->get_ptr() ;
}
template<class T>
inline
typename optional<T>::pointer_type
get ( optional<T>* opt )
{
  return opt->get_ptr() ;
}
template<class T>
inline
typename optional<T>::reference_const_type
get_optional_value_or ( optional<T> const& opt, typename optional<T>::reference_const_type v )
{
  return opt.get_value_or(v) ;
}
template<class T>
inline
typename optional<T>::reference_type
get_optional_value_or ( optional<T>& opt, typename optional<T>::reference_type v )
{
  return opt.get_value_or(v) ;
}
template<class T>
inline
typename optional<T>::pointer_const_type
get_pointer ( optional<T> const& opt )
{
  return opt.get_ptr() ;
}
template<class T>
inline
typename optional<T>::pointer_type
get_pointer ( optional<T>& opt )
{
  return opt.get_ptr() ;
}
template<class T>
inline
bool operator == ( optional<T> const& x, optional<T> const& y )
{ return equal_pointees(x,y); }
template<class T>
inline
bool operator < ( optional<T> const& x, optional<T> const& y )
{ return less_pointees(x,y); }
template<class T>
inline
bool operator != ( optional<T> const& x, optional<T> const& y )
{ return !( x == y ) ; }
template<class T>
inline
bool operator > ( optional<T> const& x, optional<T> const& y )
{ return y < x ; }
template<class T>
inline
bool operator <= ( optional<T> const& x, optional<T> const& y )
{ return !( y < x ) ; }
template<class T>
inline
bool operator >= ( optional<T> const& x, optional<T> const& y )
{ return !( x < y ) ; }
template<class T>
inline
bool operator == ( optional<T> const& x, T const& y )
{ return equal_pointees(x, optional<T>(y)); }
template<class T>
inline
bool operator < ( optional<T> const& x, T const& y )
{ return less_pointees(x, optional<T>(y)); }
template<class T>
inline
bool operator != ( optional<T> const& x, T const& y )
{ return !( x == y ) ; }
template<class T>
inline
bool operator > ( optional<T> const& x, T const& y )
{ return y < x ; }
template<class T>
inline
bool operator <= ( optional<T> const& x, T const& y )
{ return !( y < x ) ; }
template<class T>
inline
bool operator >= ( optional<T> const& x, T const& y )
{ return !( x < y ) ; }
template<class T>
inline
bool operator == ( T const& x, optional<T> const& y )
{ return equal_pointees( optional<T>(x), y ); }
template<class T>
inline
bool operator < ( T const& x, optional<T> const& y )
{ return less_pointees( optional<T>(x), y ); }
template<class T>
inline
bool operator != ( T const& x, optional<T> const& y )
{ return !( x == y ) ; }
template<class T>
inline
bool operator > ( T const& x, optional<T> const& y )
{ return y < x ; }
template<class T>
inline
bool operator <= ( T const& x, optional<T> const& y )
{ return !( y < x ) ; }
template<class T>
inline
bool operator >= ( T const& x, optional<T> const& y )
{ return !( x < y ) ; }
template<class T>
inline
bool operator == ( optional<T> const& x, none_t )
{ return equal_pointees(x, optional<T>() ); }
template<class T>
inline
bool operator < ( optional<T> const& x, none_t )
{ return less_pointees(x,optional<T>() ); }
template<class T>
inline
bool operator != ( optional<T> const& x, none_t y )
{ return !( x == y ) ; }
template<class T>
inline
bool operator > ( optional<T> const& x, none_t y )
{ return y < x ; }
template<class T>
inline
bool operator <= ( optional<T> const& x, none_t y )
{ return !( y < x ) ; }
template<class T>
inline
bool operator >= ( optional<T> const& x, none_t y )
{ return !( x < y ) ; }
template<class T>
inline
bool operator == ( none_t x, optional<T> const& y )
{ return equal_pointees(optional<T>() ,y); }
template<class T>
inline
bool operator < ( none_t x, optional<T> const& y )
{ return less_pointees(optional<T>() ,y); }
template<class T>
inline
bool operator != ( none_t x, optional<T> const& y )
{ return !( x == y ) ; }
template<class T>
inline
bool operator > ( none_t x, optional<T> const& y )
{ return y < x ; }
template<class T>
inline
bool operator <= ( none_t x, optional<T> const& y )
{ return !( y < x ) ; }
template<class T>
inline
bool operator >= ( none_t x, optional<T> const& y )
{ return !( x < y ) ; }
namespace optional_detail {
template<bool use_default_constructor> struct swap_selector;
template<>
struct swap_selector<true>
{
    template<class T>
    static void optional_swap ( optional<T>& x, optional<T>& y )
    {
        const bool hasX = !!x;
        const bool hasY = !!y;
        if ( !hasX && !hasY )
            return;
        if( !hasX )
            x = boost::in_place();
        else if ( !hasY )
            y = boost::in_place();
        boost::swap(x.get(),y.get());
        if( !hasX )
            y = boost::none ;
        else if( !hasY )
            x = boost::none ;
    }
};
template<>
struct swap_selector<false>
{
    template<class T>
    static void optional_swap ( optional<T>& x, optional<T>& y )
    {
        const bool hasX = !!x;
        const bool hasY = !!y;
        if ( !hasX && hasY )
        {
            x = y.get();
            y = boost::none ;
        }
        else if ( hasX && !hasY )
        {
            y = x.get();
            x = boost::none ;
        }
        else if ( hasX && hasY )
        {
            boost::swap(x.get(),y.get());
        }
    }
};
}
template<class T>
struct optional_swap_should_use_default_constructor : has_nothrow_default_constructor<T> {} ;
template<class T> inline void swap ( optional<T>& x, optional<T>& y )
{
    optional_detail::swap_selector<optional_swap_should_use_default_constructor<T>::value>::optional_swap(x, y);
}
}
namespace boost
{
template < typename MemberType, int UniqueID = 0 >
class base_from_member
{
protected:
    MemberType member;
    base_from_member()
        : member()
        {}
    template < typename T0 > explicit base_from_member( T0 x0 ) : member( x0 ) {} template < typename T0 , typename T1 > explicit base_from_member( T0 x0 , T1 x1 ) : member( x0 , x1 ) {} template < typename T0 , typename T1 , typename T2 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 ) : member( x0 , x1 , x2 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 ) : member( x0 , x1 , x2 , x3 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 ) : member( x0 , x1 , x2 , x3 , x4 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 ) : member( x0 , x1 , x2 , x3 , x4 , x5 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 , T8 x8 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 ) {} template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 > explicit base_from_member( T0 x0 , T1 x1 , T2 x2 , T3 x3 , T4 x4 , T5 x5 , T6 x6 , T7 x7 , T8 x8 , T9 x9 ) : member( x0 , x1 , x2 , x3 , x4 , x5 , x6 , x7 , x8 , x9 ) {}
};
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;
    public:
      explicit
      raw_storage_iterator(_OutputIterator __x)
      : _M_iter(__x) {}
      raw_storage_iterator&
      operator*() { return *this; }
      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(&*_M_iter, __element);
 return *this;
      }
      raw_storage_iterator<_OutputIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }
      raw_storage_iterator<_OutputIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_OutputIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };
}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default"))) {
  enum _Lock_policy { _S_single, _S_mutex, _S_atomic };
  static const _Lock_policy __default_lock_policy =
  _S_atomic;
  class __concurrence_lock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_lock_error"; }
  };
  class __concurrence_unlock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_unlock_error"; }
  };
  class __concurrence_broadcast_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_broadcast_error"; }
  };
  class __concurrence_wait_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_wait_error"; }
  };
  inline void
  __throw_concurrence_lock_error()
  {
    throw __concurrence_lock_error();
  }
  inline void
  __throw_concurrence_unlock_error()
  {
    throw __concurrence_unlock_error();
  }
  inline void
  __throw_concurrence_broadcast_error()
  {
    throw __concurrence_broadcast_error();
  }
  inline void
  __throw_concurrence_wait_error()
  {
    throw __concurrence_wait_error();
  }
  class __mutex
  {
  private:
    __gthread_mutex_t _M_mutex;
    __mutex(const __mutex&);
    __mutex& operator=(const __mutex&);
  public:
    __mutex()
    {
      if (__gthread_active_p())
 {
   __gthread_mutex_t __tmp = {0x32AAABA7, {0}};
   _M_mutex = __tmp;
 }
    }
    void lock()
    {
      if (__gthread_active_p())
 {
   if (__gthread_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }
    }
    void unlock()
    {
      if (__gthread_active_p())
 {
   if (__gthread_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }
    }
    __gthread_mutex_t* gthread_mutex(void)
      { return &_M_mutex; }
  };
  class __recursive_mutex
  {
  private:
    __gthread_recursive_mutex_t _M_mutex;
    __recursive_mutex(const __recursive_mutex&);
    __recursive_mutex& operator=(const __recursive_mutex&);
  public:
    __recursive_mutex()
    {
      if (__gthread_active_p())
 {
   __gthread_recursive_mutex_t __tmp = {0x32AAABA2, {0}};
   _M_mutex = __tmp;
 }
    }
    void lock()
    {
      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }
    }
    void unlock()
    {
      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }
    }
    __gthread_recursive_mutex_t* gthread_recursive_mutex(void)
      { return &_M_mutex; }
  };
  class __scoped_lock
  {
  public:
    typedef __mutex __mutex_type;
  private:
    __mutex_type& _M_device;
    __scoped_lock(const __scoped_lock&);
    __scoped_lock& operator=(const __scoped_lock&);
  public:
    explicit __scoped_lock(__mutex_type& __name) : _M_device(__name)
    { _M_device.lock(); }
    ~__scoped_lock() throw()
    { _M_device.unlock(); }
  };
  class __cond
  {
  private:
    __gthread_cond_t _M_cond;
    __cond(const __cond&);
    __cond& operator=(const __cond&);
  public:
    __cond()
    {
      if (__gthread_active_p())
 {
   __gthread_cond_t __tmp = {0x3CB0B1BB, {0}};
   _M_cond = __tmp;
 }
    }
    void broadcast()
    {
      if (__gthread_active_p())
 {
   if (__gthread_cond_broadcast(&_M_cond) != 0)
     __throw_concurrence_broadcast_error();
 }
    }
    void wait(__mutex *mutex)
    {
      {
   if (__gthread_cond_wait(&_M_cond, mutex->gthread_mutex()) != 0)
     __throw_concurrence_wait_error();
      }
    }
    void wait_recursive(__recursive_mutex *mutex)
    {
      {
   if (__gthread_cond_wait_recursive(&_M_cond,
         mutex->gthread_recursive_mutex())
       != 0)
     __throw_concurrence_wait_error();
      }
    }
  };
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Tp>
    struct default_delete
      {
 default_delete() { }
 template<typename _Up>
   default_delete(const default_delete<_Up>&) { }
 void
 operator()(_Tp* __ptr) const
 {
   static_assert(sizeof(_Tp)>0,
   "can't delete pointer to incomplete type");
   delete __ptr;
 }
    };
  template<typename _Tp>
    struct default_delete<_Tp[]>
    {
      void
      operator()(_Tp* __ptr) const
      {
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete [] __ptr;
      }
    };
  template <typename _Tp, typename _Tp_Deleter = default_delete<_Tp> >
    class unique_ptr
    {
      typedef std::tuple<_Tp*, _Tp_Deleter> __tuple_type;
      typedef _Tp* unique_ptr::* __unspecified_pointer_type;
    public:
      typedef _Tp* pointer;
      typedef _Tp element_type;
      typedef _Tp_Deleter deleter_type;
      unique_ptr()
      : _M_t(pointer(), deleter_type())
      { static_assert(!std::is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }
      explicit
      unique_ptr(pointer __p)
      : _M_t(__p, deleter_type())
      { static_assert(!std::is_pointer<deleter_type>::value,
       "constructed with null function pointer deleter"); }
      unique_ptr(pointer __p,
          typename std::conditional<std::is_reference<deleter_type>::value,
            deleter_type, const deleter_type&>::type __d)
      : _M_t(__p, __d) { }
      unique_ptr(pointer __p,
          typename std::remove_reference<deleter_type>::type&& __d)
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!std::is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }
      unique_ptr(unique_ptr&& __u)
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }
      template<typename _Up, typename _Up_Deleter>
        unique_ptr(unique_ptr<_Up, _Up_Deleter>&& __u)
        : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter()))
 { }
      ~unique_ptr() { reset(); }
      unique_ptr&
      operator=(unique_ptr&& __u)
      {
        reset(__u.release());
        get_deleter() = std::move(__u.get_deleter());
        return *this;
      }
      template<typename _Up, typename _Up_Deleter>
        unique_ptr&
        operator=(unique_ptr<_Up, _Up_Deleter>&& __u)
 {
          reset(__u.release());
          get_deleter() = std::move(__u.get_deleter());
          return *this;
        }
      unique_ptr&
      operator=(__unspecified_pointer_type)
      {
 reset();
 return *this;
      }
      typename std::add_lvalue_reference<element_type>::type
      operator*() const
      {
 ;
 return *get();
      }
      pointer
      operator->() const
      {
 ;
 return get();
      }
      pointer
      get() const
      { return std::get<0>(_M_t); }
      deleter_type&
      get_deleter()
      { return std::get<1>(_M_t); }
      const deleter_type&
      get_deleter() const
      { return std::get<1>(_M_t); }
      explicit operator bool() const
      { return get() == pointer() ? false : true; }
      pointer
      release()
      {
 pointer __p = get();
 std::get<0>(_M_t) = pointer();
 return __p;
      }
      void
      reset(pointer __p = pointer())
      {
 using std::swap;
 swap(std::get<0>(_M_t), __p);
 if (__p != pointer())
   get_deleter()(__p);
      }
      void
      swap(unique_ptr& __u)
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }
      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
    private:
      __tuple_type _M_t;
  };
  template<typename _Tp, typename _Tp_Deleter>
    class unique_ptr<_Tp[], _Tp_Deleter>
    {
      typedef std::tuple<_Tp*, _Tp_Deleter> __tuple_type;
      typedef _Tp* unique_ptr::* __unspecified_pointer_type;
    public:
      typedef _Tp* pointer;
      typedef _Tp element_type;
      typedef _Tp_Deleter deleter_type;
      unique_ptr()
      : _M_t(pointer(), deleter_type())
      { static_assert(!std::is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }
      explicit
      unique_ptr(pointer __p)
      : _M_t(__p, deleter_type())
      { static_assert(!std::is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }
      unique_ptr(pointer __p,
          typename std::conditional<std::is_reference<deleter_type>::value,
              deleter_type, const deleter_type&>::type __d)
      : _M_t(__p, __d) { }
      unique_ptr(pointer __p,
   typename std::remove_reference<deleter_type>::type && __d)
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!std::is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }
      unique_ptr(unique_ptr&& __u)
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }
      template<typename _Up, typename _Up_Deleter>
        unique_ptr(unique_ptr<_Up, _Up_Deleter>&& __u)
 : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter()))
 { }
      ~unique_ptr() { reset(); }
      unique_ptr&
      operator=(unique_ptr&& __u)
      {
 reset(__u.release());
 get_deleter() = std::move(__u.get_deleter());
 return *this;
      }
      template<typename _Up, typename _Up_Deleter>
        unique_ptr&
        operator=(unique_ptr<_Up, _Up_Deleter>&& __u)
 {
          reset(__u.release());
          get_deleter() = std::move(__u.get_deleter());
          return *this;
        }
      unique_ptr&
      operator=(__unspecified_pointer_type)
      {
 reset();
 return *this;
      }
      typename std::add_lvalue_reference<element_type>::type
      operator[](size_t __i) const
      {
 ;
 return get()[__i];
      }
      pointer
      get() const
      { return std::get<0>(_M_t); }
      deleter_type&
      get_deleter()
      { return std::get<1>(_M_t); }
      const deleter_type&
      get_deleter() const
      { return std::get<1>(_M_t); }
      explicit operator bool() const
      { return get() == pointer() ? false : true; }
      pointer
      release()
      {
 pointer __p = get();
 std::get<0>(_M_t) = pointer();
 return __p;
      }
      void
      reset(pointer __p = pointer())
      {
 using std::swap;
 swap(std::get<0>(_M_t), __p);
 if (__p != pointer())
   get_deleter()(__p);
      }
      template<typename _Up>
        void reset(_Up) = delete;
      void
      swap(unique_ptr& __u)
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }
      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
      template<typename _Up>
        unique_ptr(_Up*, typename
     std::conditional<std::is_reference<deleter_type>::value,
     deleter_type, const deleter_type&>::type,
     typename std::enable_if<std::is_convertible<_Up*,
     pointer>::value>::type* = 0) = delete;
      template<typename _Up>
        unique_ptr(_Up*, typename std::remove_reference<deleter_type>::type&&,
     typename std::enable_if<std::is_convertible<_Up*,
     pointer>::value>::type* = 0) = delete;
      template<typename _Up>
        explicit
        unique_ptr(_Up*, typename std::enable_if<std::is_convertible<_Up*,
     pointer>::value>::type* = 0) = delete;
    private:
      __tuple_type _M_t;
  };
  template<typename _Tp, typename _Tp_Deleter>
    inline void
    swap(unique_ptr<_Tp, _Tp_Deleter>& __x,
  unique_ptr<_Tp, _Tp_Deleter>& __y)
    { __x.swap(__y); }
  template<typename _Tp, typename _Tp_Deleter,
    typename _Up, typename _Up_Deleter>
    inline bool
    operator==(const unique_ptr<_Tp, _Tp_Deleter>& __x,
        const unique_ptr<_Up, _Up_Deleter>& __y)
    { return __x.get() == __y.get(); }
  template<typename _Tp, typename _Tp_Deleter,
    typename _Up, typename _Up_Deleter>
    inline bool
    operator!=(const unique_ptr<_Tp, _Tp_Deleter>& __x,
        const unique_ptr<_Up, _Up_Deleter>& __y)
    { return !(__x.get() == __y.get()); }
  template<typename _Tp, typename _Tp_Deleter,
    typename _Up, typename _Up_Deleter>
    inline bool
    operator<(const unique_ptr<_Tp, _Tp_Deleter>& __x,
       const unique_ptr<_Up, _Up_Deleter>& __y)
    { return __x.get() < __y.get(); }
  template<typename _Tp, typename _Tp_Deleter,
    typename _Up, typename _Up_Deleter>
    inline bool
    operator<=(const unique_ptr<_Tp, _Tp_Deleter>& __x,
        const unique_ptr<_Up, _Up_Deleter>& __y)
    { return !(__y.get() < __x.get()); }
  template<typename _Tp, typename _Tp_Deleter,
    typename _Up, typename _Up_Deleter>
    inline bool
    operator>(const unique_ptr<_Tp, _Tp_Deleter>& __x,
       const unique_ptr<_Up, _Up_Deleter>& __y)
    { return __y.get() < __x.get(); }
  template<typename _Tp, typename _Tp_Deleter,
    typename _Up, typename _Up_Deleter>
    inline bool
    operator>=(const unique_ptr<_Tp, _Tp_Deleter>& __x,
        const unique_ptr<_Up, _Up_Deleter>& __y)
    { return !(__x.get() < __y.get()); }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;
      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    } __attribute__ ((__deprecated__));
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;
    public:
      typedef _Tp element_type;
      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
      ~auto_ptr() { delete _M_ptr; }
      element_type&
      operator*() const throw()
      {
 ;
 return *_M_ptr;
      }
      element_type*
      operator->() const throw()
      {
 ;
 return _M_ptr;
      }
      element_type*
      get() const throw() { return _M_ptr; }
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }
      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }
      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }
      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
    } __attribute__ ((__deprecated__));
  template<>
    class auto_ptr<void>
    {
    public:
      typedef void element_type;
    } __attribute__ ((__deprecated__));
}
namespace std
{

  class bad_weak_ptr : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "std::bad_weak_ptr"; }
  };
  inline void
  __throw_bad_weak_ptr()
  {
    throw bad_weak_ptr();
  }
  using __gnu_cxx::_Lock_policy;
  using __gnu_cxx::__default_lock_policy;
  using __gnu_cxx::_S_single;
  using __gnu_cxx::_S_mutex;
  using __gnu_cxx::_S_atomic;
  template<_Lock_policy _Lp>
    class _Mutex_base
    {
    protected:
      enum { _S_need_barriers = 0 };
    };
  template<>
    class _Mutex_base<_S_mutex>
    : public __gnu_cxx::__mutex
    {
    protected:
      enum { _S_need_barriers = 1 };
    };
  template<_Lock_policy _Lp = __default_lock_policy>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:
      _Sp_counted_base()
      : _M_use_count(1), _M_weak_count(1) { }
      virtual
      ~_Sp_counted_base()
      { }
      virtual void
      _M_dispose() = 0;
      virtual void
      _M_destroy()
      { delete this; }
      virtual void*
      _M_get_deleter(const std::type_info&) = 0;
      void
      _M_add_ref_copy()
      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }
      void
      _M_add_ref_lock();
      void
      _M_release()
      {
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
   {
     _M_dispose();
     if (_Mutex_base<_Lp>::_S_need_barriers)
       {
         __asm volatile ("":::"memory");
         __asm volatile ("":::"memory");
       }
     if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
             -1) == 1)
       _M_destroy();
   }
      }
      void
      _M_weak_add_ref()
      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }
      void
      _M_weak_release()
      {
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)
   {
     if (_Mutex_base<_Lp>::_S_need_barriers)
       {
         __asm volatile ("":::"memory");
         __asm volatile ("":::"memory");
       }
     _M_destroy();
   }
      }
      long
      _M_get_use_count() const
      {
        return const_cast<const volatile _Atomic_word&>(_M_use_count);
      }
    private:
      _Sp_counted_base(_Sp_counted_base const&);
      _Sp_counted_base& operator=(_Sp_counted_base const&);
      _Atomic_word _M_use_count;
      _Atomic_word _M_weak_count;
    };
  template<>
    inline void
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock()
    {
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   __throw_bad_weak_ptr();
 }
    }
  template<>
    inline void
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock()
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   __throw_bad_weak_ptr();
 }
    }
  template<>
    inline void
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock()
    {
      _Atomic_word __count;
      do
 {
   __count = _M_use_count;
   if (__count == 0)
     __throw_bad_weak_ptr();
 }
      while (!__sync_bool_compare_and_swap(&_M_use_count, __count,
        __count + 1));
    }

}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __shared_ptr;
  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __weak_ptr;
  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __enable_shared_from_this;
  template<typename _Tp>
    class shared_ptr;
  template<typename _Tp>
    class weak_ptr;
  template<typename _Tp>
    struct owner_less;
  template<typename _Tp>
    class enable_shared_from_this;
  template<_Lock_policy _Lp = __default_lock_policy>
    class __weak_count;
  template<_Lock_policy _Lp = __default_lock_policy>
    class __shared_count;
  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr : public _Sp_counted_base<_Lp>
    {
    public:
      _Sp_counted_ptr(_Ptr __p)
      : _M_ptr(__p) { }
      virtual void
      _M_dispose()
      { delete _M_ptr; }
      virtual void
      _M_destroy()
      { delete this; }
      virtual void*
      _M_get_deleter(const std::type_info& __ti)
      { return 0; }
      _Sp_counted_ptr(const _Sp_counted_ptr&) = delete;
      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;
    protected:
      _Ptr _M_ptr;
    };
  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_deleter : public _Sp_counted_ptr<_Ptr, _Lp>
    {
      typedef typename _Alloc::template
   rebind<_Sp_counted_deleter>::other _My_alloc_type;
      struct _My_Deleter
      : public _My_alloc_type
      {
 _Deleter _M_del;
 _My_Deleter(_Deleter __d, const _Alloc& __a)
   : _My_alloc_type(__a), _M_del(__d) { }
      };
    protected:
      typedef _Sp_counted_ptr<_Ptr, _Lp> _Base_type;
    public:
      _Sp_counted_deleter(_Ptr __p, _Deleter __d)
      : _Base_type(__p), _M_del(__d, _Alloc()) { }
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a)
      : _Base_type(__p), _M_del(__d, __a) { }
      virtual void
      _M_dispose()
      { _M_del._M_del(_Base_type::_M_ptr); }
      virtual void
      _M_destroy()
      {
 _My_alloc_type __a(_M_del);
 this->~_Sp_counted_deleter();
 __a.deallocate(this, 1);
      }
      virtual void*
      _M_get_deleter(const std::type_info& __ti)
      {
        return __ti == typeid(_Deleter) ? &_M_del._M_del : 0;
      }
    protected:
      _My_Deleter _M_del;
    };
  template<typename _Tp>
    struct _Sp_destroy_inplace
    {
      void operator()(_Tp* __p) const { if (__p) __p->~_Tp(); }
    };
  struct _Sp_make_shared_tag { };
  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_ptr_inplace
    : public _Sp_counted_deleter<_Tp*, _Sp_destroy_inplace<_Tp>, _Alloc, _Lp>
    {
      typedef _Sp_counted_deleter<_Tp*, _Sp_destroy_inplace<_Tp>, _Alloc, _Lp>
 _Base_type;
    public:
      _Sp_counted_ptr_inplace(_Alloc __a)
      : _Base_type(static_cast<_Tp*>(0), _Sp_destroy_inplace<_Tp>(), __a)
      , _M_storage()
      {
 void* __p = &_M_storage;
 ::new (__p) _Tp();
 _Base_type::_Base_type::_M_ptr = static_cast<_Tp*>(__p);
      }
      template<typename... _Args>
 _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
 : _Base_type(static_cast<_Tp*>(0), _Sp_destroy_inplace<_Tp>(), __a)
 , _M_storage()
 {
   void* __p = &_M_storage;
   ::new (__p) _Tp(std::forward<_Args>(__args)...);
   _Base_type::_Base_type::_M_ptr = static_cast<_Tp*>(__p);
 }
      virtual void
      _M_destroy()
      {
 typedef typename _Alloc::template
     rebind<_Sp_counted_ptr_inplace>::other _My_alloc_type;
 _My_alloc_type __a(_Base_type::_M_del);
 this->~_Sp_counted_ptr_inplace();
 __a.deallocate(this, 1);
      }
      virtual void*
      _M_get_deleter(const std::type_info& __ti)
      {
 return __ti == typeid(_Sp_make_shared_tag)
        ? static_cast<void*>(&_M_storage)
        : _Base_type::_M_get_deleter(__ti);
      }
    private:
      typename aligned_storage<sizeof(_Tp), alignment_of<_Tp>::value>::type
 _M_storage;
    };
  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      __shared_count() : _M_pi(0)
      { }
      template<typename _Ptr>
 __shared_count(_Ptr __p) : _M_pi(0)
 {
   try
     {
       _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
     }
   catch(...)
     {
       delete __p;
       throw;
     }
 }
      template<typename _Ptr, typename _Deleter>
 __shared_count(_Ptr __p, _Deleter __d) : _M_pi(0)
 {
   typedef std::allocator<int> _Alloc;
   typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;
   typedef std::allocator<_Sp_cd_type> _Alloc2;
   _Alloc2 __a2;
   try
     {
       _M_pi = __a2.allocate(1);
       ::new(static_cast<void*>(_M_pi)) _Sp_cd_type(__p, __d);
     }
   catch(...)
     {
       __d(__p);
       if (_M_pi)
  __a2.deallocate(static_cast<_Sp_cd_type*>(_M_pi), 1);
       throw;
     }
 }
      template<typename _Ptr, typename _Deleter, typename _Alloc>
 __shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)
 {
   typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;
   typedef typename _Alloc::template rebind<_Sp_cd_type>::other _Alloc2;
   _Alloc2 __a2(__a);
   try
     {
       _M_pi = __a2.allocate(1);
       ::new(static_cast<void*>(_M_pi)) _Sp_cd_type(__p, __d, __a);
     }
   catch(...)
     {
       __d(__p);
       if (_M_pi)
  __a2.deallocate(static_cast<_Sp_cd_type*>(_M_pi), 1);
       throw;
     }
 }
      template<typename _Tp, typename _Alloc, typename... _Args>
 __shared_count(_Sp_make_shared_tag, _Tp*, _Alloc __a, _Args&&... __args)
 : _M_pi(0)
 {
   typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
   typedef typename _Alloc::template rebind<_Sp_cp_type>::other _Alloc2;
   _Alloc2 __a2(__a);
   try
     {
       _M_pi = __a2.allocate(1);
       ::new(static_cast<void*>(_M_pi)) _Sp_cp_type(__a,
      std::forward<_Args>(__args)...);
     }
   catch(...)
     {
       if (_M_pi)
  __a2.deallocate(static_cast<_Sp_cp_type*>(_M_pi), 1);
       throw;
     }
 }
      template<typename _Tp>
 __shared_count(std::auto_ptr<_Tp>&& __r)
 : _M_pi(new _Sp_counted_ptr<_Tp*, _Lp>(__r.get()))
 { __r.release(); }
      template<typename _Tp, typename _Del>
 __shared_count(std::unique_ptr<_Tp, _Del>&& __r)
 : _M_pi(_S_create_from_up(std::move(__r)))
 { __r.release(); }
      explicit __shared_count(const __weak_count<_Lp>& __r);
      ~__shared_count()
      {
 if (_M_pi != 0)
   _M_pi->_M_release();
      }
      __shared_count(const __shared_count& __r)
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != 0)
   _M_pi->_M_add_ref_copy();
      }
      __shared_count&
      operator=(const __shared_count& __r)
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != _M_pi)
   {
     if (__tmp != 0)
       __tmp->_M_add_ref_copy();
     if (_M_pi != 0)
       _M_pi->_M_release();
     _M_pi = __tmp;
   }
 return *this;
      }
      void
      _M_swap(__shared_count& __r)
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }
      long
      _M_get_use_count() const
      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }
      bool
      _M_unique() const
      { return this->_M_get_use_count() == 1; }
      void*
      _M_get_deleter(const std::type_info& __ti) const
      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : 0; }
      bool
      _M_less(const __shared_count& __rhs) const
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }
      bool
      _M_less(const __weak_count<_Lp>& __rhs) const
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }
      friend inline bool
      operator==(const __shared_count& __a, const __shared_count& __b)
      { return __a._M_pi == __b._M_pi; }
    private:
      friend class __weak_count<_Lp>;
      template<typename _Tp, typename _Del>
 static _Sp_counted_base<_Lp>*
 _S_create_from_up(std::unique_ptr<_Tp, _Del>&& __r,
   typename std::enable_if<!std::is_reference<_Del>::value>::type* = 0)
 {
   return new _Sp_counted_deleter<_Tp*, _Del, std::allocator<_Tp>,
     _Lp>(__r.get(), __r.get_deleter());
 }
      template<typename _Tp, typename _Del>
 static _Sp_counted_base<_Lp>*
 _S_create_from_up(std::unique_ptr<_Tp, _Del>&& __r,
   typename std::enable_if<std::is_reference<_Del>::value>::type* = 0)
 {
   typedef typename std::remove_reference<_Del>::type _Del1;
   typedef std::reference_wrapper<_Del1> _Del2;
   return new _Sp_counted_deleter<_Tp*, _Del2, std::allocator<_Tp>,
     _Lp>(__r.get(), std::ref(__r.get_deleter()));
 }
      _Sp_counted_base<_Lp>* _M_pi;
    };
  template<_Lock_policy _Lp>
    class __weak_count
    {
    public:
      __weak_count() : _M_pi(0)
      { }
      __weak_count(const __shared_count<_Lp>& __r) : _M_pi(__r._M_pi)
      {
 if (_M_pi != 0)
   _M_pi->_M_weak_add_ref();
      }
      __weak_count(const __weak_count<_Lp>& __r) : _M_pi(__r._M_pi)
      {
 if (_M_pi != 0)
   _M_pi->_M_weak_add_ref();
      }
      ~__weak_count()
      {
 if (_M_pi != 0)
   _M_pi->_M_weak_release();
      }
      __weak_count<_Lp>&
      operator=(const __shared_count<_Lp>& __r)
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != 0)
   __tmp->_M_weak_add_ref();
 if (_M_pi != 0)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }
      __weak_count<_Lp>&
      operator=(const __weak_count<_Lp>& __r)
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != 0)
   __tmp->_M_weak_add_ref();
 if (_M_pi != 0)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }
      void
      _M_swap(__weak_count<_Lp>& __r)
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }
      long
      _M_get_use_count() const
      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }
      bool
      _M_less(const __weak_count& __rhs) const
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }
      bool
      _M_less(const __shared_count<_Lp>& __rhs) const
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }
      friend inline bool
      operator==(const __weak_count& __a, const __weak_count& __b)
      { return __a._M_pi == __b._M_pi; }
    private:
      friend class __shared_count<_Lp>;
      _Sp_counted_base<_Lp>* _M_pi;
    };
  template<_Lock_policy _Lp>
    inline __shared_count<_Lp>:: __shared_count(const __weak_count<_Lp>& __r)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi != 0)
 _M_pi->_M_add_ref_lock();
      else
 __throw_bad_weak_ptr();
    }
  template<_Lock_policy _Lp, typename _Tp1, typename _Tp2>
    void
    __enable_shared_from_this_helper(const __shared_count<_Lp>&,
         const __enable_shared_from_this<_Tp1,
         _Lp>*, const _Tp2*);
  template<typename _Tp1, typename _Tp2>
    void
    __enable_shared_from_this_helper(const __shared_count<>&,
         const enable_shared_from_this<_Tp1>*,
         const _Tp2*);
  template<_Lock_policy _Lp>
    inline void
    __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...)
    { }
  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
    {
    public:
      typedef _Tp element_type;
      __shared_ptr() : _M_ptr(0), _M_refcount()
      { }
      template<typename _Tp1>
 explicit __shared_ptr(_Tp1* __p) : _M_ptr(__p), _M_refcount(__p)
 {
  
   __enable_shared_from_this_helper(_M_refcount, __p, __p);
 }
      template<typename _Tp1, typename _Deleter>
 __shared_ptr(_Tp1* __p, _Deleter __d)
 : _M_ptr(__p), _M_refcount(__p, __d)
 {
  
   __enable_shared_from_this_helper(_M_refcount, __p, __p);
 }
      template<typename _Tp1, typename _Deleter, typename _Alloc>
 __shared_ptr(_Tp1* __p, _Deleter __d, const _Alloc& __a)
 : _M_ptr(__p), _M_refcount(__p, __d, __a)
 {
  
   __enable_shared_from_this_helper(_M_refcount, __p, __p);
 }
      template<typename _Tp1>
 __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p)
 : _M_ptr(__p), _M_refcount(__r._M_refcount)
 { }
      template<typename _Tp1>
 __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r)
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }
      __shared_ptr(__shared_ptr&& __r)
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
 _M_refcount._M_swap(__r._M_refcount);
 __r._M_ptr = 0;
      }
      template<typename _Tp1>
 __shared_ptr(__shared_ptr<_Tp1, _Lp>&& __r)
 : _M_ptr(__r._M_ptr), _M_refcount()
 {
  
   _M_refcount._M_swap(__r._M_refcount);
   __r._M_ptr = 0;
 }
      template<typename _Tp1>
 explicit __shared_ptr(const __weak_ptr<_Tp1, _Lp>& __r)
 : _M_refcount(__r._M_refcount)
 {
  
   _M_ptr = __r._M_ptr;
 }
      template<typename _Tp1, typename _Del>
 __shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)
 : _M_ptr(__r.get()), _M_refcount()
 {
  
   _Tp1* __tmp = __r.get();
   _M_refcount = __shared_count<_Lp>(std::move(__r));
   __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);
 }
      template<typename _Tp1>
 __shared_ptr(std::auto_ptr<_Tp1>&& __r)
 : _M_ptr(__r.get()), _M_refcount()
 {
  
   _Tp1* __tmp = __r.get();
   _M_refcount = __shared_count<_Lp>(std::move(__r));
   __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);
 }
      template<typename _Tp1>
 __shared_ptr&
 operator=(const __shared_ptr<_Tp1, _Lp>& __r)
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }
      template<typename _Tp1>
 __shared_ptr&
 operator=(std::auto_ptr<_Tp1>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }
      __shared_ptr&
      operator=(__shared_ptr&& __r)
      {
 __shared_ptr(std::move(__r)).swap(*this);
 return *this;
      }
      template<class _Tp1>
 __shared_ptr&
 operator=(__shared_ptr<_Tp1, _Lp>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }
      template<typename _Tp1, typename _Del>
 __shared_ptr&
 operator=(std::unique_ptr<_Tp1, _Del>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }
      void
      reset()
      { __shared_ptr().swap(*this); }
      template<typename _Tp1>
 void
 reset(_Tp1* __p)
 {
   ;
   __shared_ptr(__p).swap(*this);
 }
      template<typename _Tp1, typename _Deleter>
 void
 reset(_Tp1* __p, _Deleter __d)
 { __shared_ptr(__p, __d).swap(*this); }
      template<typename _Tp1, typename _Deleter, typename _Alloc>
 void
 reset(_Tp1* __p, _Deleter __d, const _Alloc& __a)
 { __shared_ptr(__p, __d, __a).swap(*this); }
      typename std::add_lvalue_reference<_Tp>::type
      operator*() const
      {
 ;
 return *_M_ptr;
      }
      _Tp*
      operator->() const
      {
 ;
 return _M_ptr;
      }
      _Tp*
      get() const
      { return _M_ptr; }
      explicit operator bool() const
      { return _M_ptr == 0 ? false : true; }
      bool
      unique() const
      { return _M_refcount._M_unique(); }
      long
      use_count() const
      { return _M_refcount._M_get_use_count(); }
      void
      swap(__shared_ptr<_Tp, _Lp>& __other)
      {
 std::swap(_M_ptr, __other._M_ptr);
 _M_refcount._M_swap(__other._M_refcount);
      }
      template<typename _Tp1>
 bool
 owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const
 { return _M_refcount._M_less(__rhs._M_refcount); }
      template<typename _Tp1>
 bool
 owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const
 { return _M_refcount._M_less(__rhs._M_refcount); }
    protected:
      template<typename _Alloc, typename... _Args>
 __shared_ptr(_Sp_make_shared_tag __tag, _Alloc __a, _Args&&... __args)
 : _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,
    std::forward<_Args>(__args)...)
 {
   void* __p = _M_refcount._M_get_deleter(typeid(__tag));
   _M_ptr = static_cast<_Tp*>(__p);
   __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);
 }
      template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
        typename... _Args>
 friend __shared_ptr<_Tp1, _Lp1>
 __allocate_shared(_Alloc __a, _Args&&... __args);
    private:
      void*
      _M_get_deleter(const std::type_info& __ti) const
      { return _M_refcount._M_get_deleter(__ti); }
      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>
 friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&);
      _Tp* _M_ptr;
      __shared_count<_Lp> _M_refcount;
    };
  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b)
    { return __a.get() == __b.get(); }
  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b)
    { return __a.get() != __b.get(); }
  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp1, _Lp>& __a,
       const __shared_ptr<_Tp2, _Lp>& __b)
    { return __a.get() < __b.get(); }
  template<typename _Sp>
    struct _Sp_less : public binary_function<_Sp, _Sp, bool>
    {
      bool
      operator()(const _Sp& __lhs, const _Sp& __rhs) const
      {
 typedef typename _Sp::element_type element_type;
 return std::less<element_type*>()(__lhs.get(), __rhs.get());
      }
    };
  template<typename _Tp, _Lock_policy _Lp>
    struct less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_less<__shared_ptr<_Tp, _Lp>>
    { };
  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp, _Lp>& __a,
       const __shared_ptr<_Tp, _Lp>& __b)
    { return __a.get() > __b.get(); }
  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp, _Lp>& __a,
        const __shared_ptr<_Tp, _Lp>& __b)
    { return __a.get() >= __b.get(); }
  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp, _Lp>& __a,
        const __shared_ptr<_Tp, _Lp>& __b)
    { return __a.get() <= __b.get(); }
  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b)
    { __a.swap(__b); }
  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)
    { return __shared_ptr<_Tp, _Lp>(__r, static_cast<_Tp*>(__r.get())); }
  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)
    { return __shared_ptr<_Tp, _Lp>(__r, const_cast<_Tp*>(__r.get())); }
  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r)
    {
      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))
 return __shared_ptr<_Tp, _Lp>(__r, __p);
      return __shared_ptr<_Tp, _Lp>();
    }
  template<typename _Tp, _Lock_policy _Lp>
    class __weak_ptr
    {
    public:
      typedef _Tp element_type;
      __weak_ptr() : _M_ptr(0), _M_refcount()
      { }
      template<typename _Tp1>
 __weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r)
 : _M_refcount(__r._M_refcount)
 {
  
   _M_ptr = __r.lock().get();
 }
      template<typename _Tp1>
 __weak_ptr(const __shared_ptr<_Tp1, _Lp>& __r)
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }
      template<typename _Tp1>
 __weak_ptr&
 operator=(const __weak_ptr<_Tp1, _Lp>& __r)
 {
   _M_ptr = __r.lock().get();
   _M_refcount = __r._M_refcount;
   return *this;
 }
      template<typename _Tp1>
 __weak_ptr&
 operator=(const __shared_ptr<_Tp1, _Lp>& __r)
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }
      __shared_ptr<_Tp, _Lp>
      lock() const
      {
 if (expired())
   return __shared_ptr<element_type, _Lp>();
 try
   {
     return __shared_ptr<element_type, _Lp>(*this);
   }
 catch(const bad_weak_ptr&)
   {
     return __shared_ptr<element_type, _Lp>();
   }
      }
      long
      use_count() const
      { return _M_refcount._M_get_use_count(); }
      bool
      expired() const
      { return _M_refcount._M_get_use_count() == 0; }
      template<typename _Tp1>
 bool
 owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const
 { return _M_refcount._M_less(__rhs._M_refcount); }
      template<typename _Tp1>
 bool
 owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const
 { return _M_refcount._M_less(__rhs._M_refcount); }
      void
      reset()
      { __weak_ptr().swap(*this); }
      void
      swap(__weak_ptr& __s)
      {
 std::swap(_M_ptr, __s._M_ptr);
 _M_refcount._M_swap(__s._M_refcount);
      }
    private:
      void
      _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount)
      {
 _M_ptr = __ptr;
 _M_refcount = __refcount;
      }
      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
      friend class __enable_shared_from_this<_Tp, _Lp>;
      friend class enable_shared_from_this<_Tp>;
      _Tp* _M_ptr;
      __weak_count<_Lp> _M_refcount;
    };
  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b)
    { __a.swap(__b); }
  template<typename _Tp, typename _Tp1>
    struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __lhs, const _Tp& __rhs) const
      { return __lhs.owner_before(__rhs); }
      bool
      operator()(const _Tp& __lhs, const _Tp1& __rhs) const
      { return __lhs.owner_before(__rhs); }
      bool
      operator()(const _Tp1& __lhs, const _Tp& __rhs) const
      { return __lhs.owner_before(__rhs); }
    };
  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>>
    { };
  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__weak_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>>
    { };
  template<typename _Tp, _Lock_policy _Lp>
    class __enable_shared_from_this
    {
    protected:
      __enable_shared_from_this() { }
      __enable_shared_from_this(const __enable_shared_from_this&) { }
      __enable_shared_from_this&
      operator=(const __enable_shared_from_this&)
      { return *this; }
      ~__enable_shared_from_this() { }
    public:
      __shared_ptr<_Tp, _Lp>
      shared_from_this()
      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }
      __shared_ptr<const _Tp, _Lp>
      shared_from_this() const
      { return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this); }
    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const
 { _M_weak_this._M_assign(__p, __n); }
      template<typename _Tp1>
 friend void
 __enable_shared_from_this_helper(const __shared_count<_Lp>& __pn,
      const __enable_shared_from_this* __pe,
      const _Tp1* __px)
 {
   if (__pe != 0)
     __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);
 }
      mutable __weak_ptr<_Tp, _Lp> _M_weak_this;
    };
  template<typename _Tp, _Lock_policy _Lp, typename _Alloc, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __allocate_shared(_Alloc __a, _Args&&... __args)
    {
      return __shared_ptr<_Tp, _Lp>(_Sp_make_shared_tag(),
   std::forward<_Alloc>(__a), std::forward<_Args>(__args)...);
    }
  template<typename _Tp, _Lock_policy _Lp, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return __allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),
      std::forward<_Args>(__args)...);
    }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>
    inline std::basic_ostream<_Ch, _Tr>&
    operator<<(std::basic_ostream<_Ch, _Tr>& __os,
        const __shared_ptr<_Tp, _Lp>& __p)
    {
      __os << __p.get();
      return __os;
    }
  template<typename _Del, typename _Tp, _Lock_policy _Lp>
    inline _Del*
    get_deleter(const __shared_ptr<_Tp, _Lp>& __p)
    {
      return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del)));
    }
  template<typename _Tp>
    class shared_ptr : public __shared_ptr<_Tp>
    {
    public:
      shared_ptr() : __shared_ptr<_Tp>() { }
      template<typename _Tp1>
 explicit shared_ptr(_Tp1* __p) : __shared_ptr<_Tp>(__p) { }
      template<typename _Tp1, typename _Deleter>
 shared_ptr(_Tp1* __p, _Deleter __d) : __shared_ptr<_Tp>(__p, __d) { }
      template<typename _Tp1, typename _Deleter, typename _Alloc>
 shared_ptr(_Tp1* __p, _Deleter __d, const _Alloc& __a)
 : __shared_ptr<_Tp>(__p, __d, __a) { }
      template<typename _Tp1>
 shared_ptr(const shared_ptr<_Tp1>& __r, _Tp* __p)
 : __shared_ptr<_Tp>(__r, __p) { }
      template<typename _Tp1>
 shared_ptr(const shared_ptr<_Tp1>& __r) : __shared_ptr<_Tp>(__r) { }
      shared_ptr(shared_ptr&& __r)
      : __shared_ptr<_Tp>(std::move(__r)) { }
      template<typename _Tp1>
 shared_ptr(shared_ptr<_Tp1>&& __r)
 : __shared_ptr<_Tp>(std::move(__r)) { }
      template<typename _Tp1>
 explicit shared_ptr(const weak_ptr<_Tp1>& __r)
 : __shared_ptr<_Tp>(__r) { }
      template<typename _Tp1>
 shared_ptr(std::auto_ptr<_Tp1>&& __r)
 : __shared_ptr<_Tp>(std::move(__r)) { }
      template<typename _Tp1, typename _Del>
 shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)
 : __shared_ptr<_Tp>(std::move(__r)) { }
      template<typename _Tp1>
 shared_ptr&
 operator=(const shared_ptr<_Tp1>& __r)
 {
   this->__shared_ptr<_Tp>::operator=(__r);
   return *this;
 }
      template<typename _Tp1>
 shared_ptr&
 operator=(std::auto_ptr<_Tp1>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }
      shared_ptr&
      operator=(shared_ptr&& __r)
      {
 this->__shared_ptr<_Tp>::operator=(std::move(__r));
 return *this;
      }
      template<class _Tp1>
 shared_ptr&
 operator=(shared_ptr<_Tp1>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }
      template<typename _Tp1, typename _Del>
 shared_ptr&
 operator=(std::unique_ptr<_Tp1, _Del>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }
    private:
      template<typename _Alloc, typename... _Args>
 shared_ptr(_Sp_make_shared_tag __tag, _Alloc __a, _Args&&... __args)
 : __shared_ptr<_Tp>(__tag, __a, std::forward<_Args>(__args)...)
 { }
      template<typename _Tp1, typename _Alloc, typename... _Args>
 friend shared_ptr<_Tp1>
 allocate_shared(_Alloc __a, _Args&&... __args);
    };
  template<typename _Tp1, typename _Tp2>
    inline bool
    operator==(const shared_ptr<_Tp1>& __a, const shared_ptr<_Tp2>& __b)
    { return __a.get() == __b.get(); }
  template<typename _Tp1, typename _Tp2>
    inline bool
    operator!=(const shared_ptr<_Tp1>& __a, const shared_ptr<_Tp2>& __b)
    { return __a.get() != __b.get(); }
  template<typename _Tp1, typename _Tp2>
    inline bool
    operator<(const shared_ptr<_Tp1>& __a, const shared_ptr<_Tp2>& __b)
    { return __a.get() < __b.get(); }
  template<typename _Tp>
    struct less<shared_ptr<_Tp>> : public _Sp_less<shared_ptr<_Tp>>
    { };
  template<typename _Tp>
    inline void
    swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>& __b)
    { __a.swap(__b); }
  template<typename _Tp, typename _Tp1>
    inline shared_ptr<_Tp>
    static_pointer_cast(const shared_ptr<_Tp1>& __r)
    { return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get())); }
  template<typename _Tp, typename _Tp1>
    inline shared_ptr<_Tp>
    const_pointer_cast(const shared_ptr<_Tp1>& __r)
    { return shared_ptr<_Tp>(__r, const_cast<_Tp*>(__r.get())); }
  template<typename _Tp, typename _Tp1>
    inline shared_ptr<_Tp>
    dynamic_pointer_cast(const shared_ptr<_Tp1>& __r)
    {
      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))
 return shared_ptr<_Tp>(__r, __p);
      return shared_ptr<_Tp>();
    }
  template<typename _Tp>
    class weak_ptr : public __weak_ptr<_Tp>
    {
    public:
      weak_ptr() : __weak_ptr<_Tp>() { }
      template<typename _Tp1>
 weak_ptr(const weak_ptr<_Tp1>& __r)
 : __weak_ptr<_Tp>(__r) { }
      template<typename _Tp1>
 weak_ptr(const shared_ptr<_Tp1>& __r)
 : __weak_ptr<_Tp>(__r) { }
      template<typename _Tp1>
 weak_ptr&
 operator=(const weak_ptr<_Tp1>& __r)
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }
      template<typename _Tp1>
 weak_ptr&
 operator=(const shared_ptr<_Tp1>& __r)
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }
      shared_ptr<_Tp>
      lock() const
      {
 if (this->expired())
   return shared_ptr<_Tp>();
 try
   {
     return shared_ptr<_Tp>(*this);
   }
 catch(const bad_weak_ptr&)
   {
     return shared_ptr<_Tp>();
   }
      }
    };
  template<typename _Tp>
    inline void
    swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __b)
    { __a.swap(__b); }
  template<typename _Tp>
    struct owner_less;
  template<typename _Tp>
    struct owner_less<shared_ptr<_Tp>>
    : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>>
    { };
  template<typename _Tp>
    struct owner_less<weak_ptr<_Tp>>
    : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>>
    { };
  template<typename _Tp>
    class enable_shared_from_this
    {
    protected:
      enable_shared_from_this() { }
      enable_shared_from_this(const enable_shared_from_this&) { }
      enable_shared_from_this&
      operator=(const enable_shared_from_this&)
      { return *this; }
      ~enable_shared_from_this() { }
    public:
      shared_ptr<_Tp>
      shared_from_this()
      { return shared_ptr<_Tp>(this->_M_weak_this); }
      shared_ptr<const _Tp>
      shared_from_this() const
      { return shared_ptr<const _Tp>(this->_M_weak_this); }
    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const
 { _M_weak_this._M_assign(__p, __n); }
      template<typename _Tp1>
 friend void
 __enable_shared_from_this_helper(const __shared_count<>& __pn,
      const enable_shared_from_this* __pe,
      const _Tp1* __px)
 {
   if (__pe != 0)
     __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);
 }
      mutable weak_ptr<_Tp> _M_weak_this;
    };
  template<typename _Tp, typename _Alloc, typename... _Args>
    inline shared_ptr<_Tp>
    allocate_shared(_Alloc __a, _Args&&... __args)
    {
      return shared_ptr<_Tp>(_Sp_make_shared_tag(), std::forward<_Alloc>(__a),
        std::forward<_Args>(__args)...);
    }
  template<typename _Tp, typename... _Args>
    inline shared_ptr<_Tp>
    make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return allocate_shared<_Tp>(std::allocator<_Tp_nc>(),
      std::forward<_Args>(__args)...);
    }
}
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
}
namespace boost
{
template<class T> inline void checked_delete(T * x)
{
    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete x;
}
template<class T> inline void checked_array_delete(T * x)
{
    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];
    (void) sizeof(type_must_be_complete);
    delete [] x;
}
template<class T> struct checked_deleter
{
    typedef void result_type;
    typedef T * argument_type;
    void operator()(T * x) const
    {
        boost::checked_delete(x);
    }
};
template<class T> struct checked_array_deleter
{
    typedef void result_type;
    typedef T * argument_type;
    void operator()(T * x) const
    {
        boost::checked_array_delete(x);
    }
};
}
       
namespace
boost
    {
    namespace
    exception_detail
        {
        template <class T>
        class
        refcount_ptr
            {
            public:
            refcount_ptr():
                px_(0)
                {
                }
            ~refcount_ptr()
                {
                release();
                }
            refcount_ptr( refcount_ptr const & x ):
                px_(x.px_)
                {
                add_ref();
                }
            refcount_ptr &
            operator=( refcount_ptr const & x )
                {
                adopt(x.px_);
                return *this;
                }
            void
            adopt( T * px )
                {
                release();
                px_=px;
                add_ref();
                }
            T *
            get() const
                {
                return px_;
                }
            private:
            T * px_;
            void
            add_ref()
                {
                if( px_ )
                    px_->add_ref();
                }
            void
            release()
                {
                if( px_ && px_->release() )
                    px_=0;
                }
            };
        }
    template <class Tag,class T>
    class error_info;
    typedef error_info<struct throw_function_,char const *> throw_function;
    typedef error_info<struct throw_file_,char const *> throw_file;
    typedef error_info<struct throw_line_,int> throw_line;
    template <>
    class
    error_info<throw_function_,char const *>
        {
        public:
        typedef char const * value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };
    template <>
    class
    error_info<throw_file_,char const *>
        {
        public:
        typedef char const * value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };
    template <>
    class
    error_info<throw_line_,int>
        {
        public:
        typedef int value_type;
        value_type v_;
        explicit
        error_info( value_type v ):
            v_(v)
            {
            }
        };
#pragma GCC visibility push (default)
    class exception;
#pragma GCC visibility pop
    template <class T>
    class shared_ptr;
    namespace
    exception_detail
        {
        class error_info_base;
        struct type_info_;
        struct
        error_info_container
            {
            virtual char const * diagnostic_information( char const * ) const = 0;
            virtual shared_ptr<error_info_base> get( type_info_ const & ) const = 0;
            virtual void set( shared_ptr<error_info_base> const &, type_info_ const & ) = 0;
            virtual void add_ref() const = 0;
            virtual bool release() const = 0;
            virtual refcount_ptr<exception_detail::error_info_container> clone() const = 0;
            protected:
            ~error_info_container() throw()
                {
                }
            };
        template <class>
        struct get_info;
        template <>
        struct get_info<throw_function>;
        template <>
        struct get_info<throw_file>;
        template <>
        struct get_info<throw_line>;
        char const * get_diagnostic_information( exception const &, char const * );
        void copy_boost_exception( exception *, exception const * );
        template <class E,class Tag,class T>
        E const & set_info( E const &, error_info<Tag,T> const & );
        template <class E>
        E const & set_info( E const &, throw_function const & );
        template <class E>
        E const & set_info( E const &, throw_file const & );
        template <class E>
        E const & set_info( E const &, throw_line const & );
        }
#pragma GCC visibility push (default)
    class
    exception
        {
        protected:
        exception():
            throw_function_(0),
            throw_file_(0),
            throw_line_(-1)
            {
            }
        virtual ~exception() throw()
            = 0
            ;
        private:
        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_function const & );
        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_file const & );
        template <class E>
        friend E const & exception_detail::set_info( E const &, throw_line const & );
        template <class E,class Tag,class T>
        friend E const & exception_detail::set_info( E const &, error_info<Tag,T> const & );
        friend char const * exception_detail::get_diagnostic_information( exception const &, char const * );
        template <class>
        friend struct exception_detail::get_info;
        friend struct exception_detail::get_info<throw_function>;
        friend struct exception_detail::get_info<throw_file>;
        friend struct exception_detail::get_info<throw_line>;
        friend void exception_detail::copy_boost_exception( exception *, exception const * );
        mutable exception_detail::refcount_ptr<exception_detail::error_info_container> data_;
        mutable char const * throw_function_;
        mutable char const * throw_file_;
        mutable int throw_line_;
        };
#pragma GCC visibility pop
    inline
    exception::
    ~exception() throw()
        {
        }
    namespace
    exception_detail
        {
        template <class E>
        E const &
        set_info( E const & x, throw_function const & y )
            {
            x.throw_function_=y.v_;
            return x;
            }
        template <class E>
        E const &
        set_info( E const & x, throw_file const & y )
            {
            x.throw_file_=y.v_;
            return x;
            }
        template <class E>
        E const &
        set_info( E const & x, throw_line const & y )
            {
            x.throw_line_=y.v_;
            return x;
            }
        }
    namespace
    exception_detail
        {
        template <class T>
        struct
        error_info_injector:
            public T,
            public exception
            {
            explicit
            error_info_injector( T const & x ):
                T(x)
                {
                }
            ~error_info_injector() throw()
                {
                }
            };
        struct large_size { char c[256]; };
        large_size dispatch_boost_exception( exception const * );
        struct small_size { };
        small_size dispatch_boost_exception( void const * );
        template <class,int>
        struct enable_error_info_helper;
        template <class T>
        struct
        enable_error_info_helper<T,sizeof(large_size)>
            {
            typedef T type;
            };
        template <class T>
        struct
        enable_error_info_helper<T,sizeof(small_size)>
            {
            typedef error_info_injector<T> type;
            };
        template <class T>
        struct
        enable_error_info_return_type
            {
            typedef typename enable_error_info_helper<T,sizeof(exception_detail::dispatch_boost_exception(static_cast<T *>(0)))>::type type;
            };
        }
    template <class T>
    inline
    typename
    exception_detail::enable_error_info_return_type<T>::type
    enable_error_info( T const & x )
        {
        typedef typename exception_detail::enable_error_info_return_type<T>::type rt;
        return rt(x);
        }
    namespace
    exception_detail
        {
        class
        clone_base
            {
            public:
            virtual clone_base const * clone() const = 0;
            virtual void rethrow() const = 0;
            virtual
            ~clone_base() throw()
                {
                }
            };
        inline
        void
        copy_boost_exception( exception * a, exception const * b )
            {
            refcount_ptr<error_info_container> data;
            if( error_info_container * d=b->data_.get() )
                data = d->clone();
            a->throw_file_ = b->throw_file_;
            a->throw_line_ = b->throw_line_;
            a->throw_function_ = b->throw_function_;
            a->data_ = data;
            }
        inline
        void
        copy_boost_exception( void *, void const * )
            {
            }
        template <class T>
        class
        clone_impl:
            public T,
            public clone_base
            {
            public:
            explicit
            clone_impl( T const & x ):
                T(x)
                {
                copy_boost_exception(this,&x);
                }
            ~clone_impl() throw()
                {
                }
            private:
            clone_base const *
            clone() const
                {
                return new clone_impl(*this);
                }
            void
            rethrow() const
                {
                throw*this;
                }
            };
        }
    template <class T>
    inline
    exception_detail::clone_impl<T>
    enable_current_exception( T const & x )
        {
        return exception_detail::clone_impl<T>(x);
        }
    }
namespace boost
{
inline void throw_exception_assert_compatibility( std::exception const & ) { }
template<class E> __attribute__((noreturn)) inline void throw_exception( E const & e )
{
    throw_exception_assert_compatibility(e);
    throw enable_current_exception(enable_error_info(e));
}
    namespace
    exception_detail
    {
        template <class E>
        __attribute__((noreturn))
        void
        throw_exception_( E const & x, char const * current_function, char const * file, int line )
        {
            boost::throw_exception(
                set_info(
                    set_info(
                        set_info(
                            boost::enable_error_info(x),
                            throw_function(current_function)),
                        throw_file(file)),
                    throw_line(line)));
        }
    }
}
namespace boost
{
class bad_weak_ptr: public std::exception
{
public:
    virtual char const * what() const throw()
    {
        return "tr1::bad_weak_ptr";
    }
};
}
namespace boost
{
namespace detail
{
typedef std::type_info sp_typeinfo;
}
}
namespace boost
{
namespace detail
{
inline int atomic_exchange_and_add( int * pw, int dv )
{
    int r;
    __asm__ __volatile__
    (
        "lock\n\t"
        "xadd %1, %0":
        "=m"( *pw ), "=r"( r ):
        "m"( *pw ), "1"( dv ):
        "memory", "cc"
    );
    return r;
}
inline void atomic_increment( int * pw )
{
    __asm__
    (
        "lock\n\t"
        "incl %0":
        "=m"( *pw ):
        "m"( *pw ):
        "cc"
    );
}
inline int atomic_conditional_increment( int * pw )
{
    int rv, tmp;
    __asm__
    (
        "movl %0, %%eax\n\t"
        "0:\n\t"
        "test %%eax, %%eax\n\t"
        "je 1f\n\t"
        "movl %%eax, %2\n\t"
        "incl %2\n\t"
        "lock\n\t"
        "cmpxchgl %2, %0\n\t"
        "jne 0b\n\t"
        "1:":
        "=m"( *pw ), "=&a"( rv ), "=&r"( tmp ):
        "m"( *pw ):
        "cc"
    );
    return rv;
}
class sp_counted_base
{
private:
    sp_counted_base( sp_counted_base const & );
    sp_counted_base & operator= ( sp_counted_base const & );
    int use_count_;
    int weak_count_;
public:
    sp_counted_base(): use_count_( 1 ), weak_count_( 1 )
    {
    }
    virtual ~sp_counted_base()
    {
    }
    virtual void dispose() = 0;
    virtual void destroy()
    {
        delete this;
    }
    virtual void * get_deleter( sp_typeinfo const & ti ) = 0;
    void add_ref_copy()
    {
        atomic_increment( &use_count_ );
    }
    bool add_ref_lock()
    {
        return atomic_conditional_increment( &use_count_ ) != 0;
    }
    void release()
    {
        if( atomic_exchange_and_add( &use_count_, -1 ) == 1 )
        {
            dispose();
            weak_release();
        }
    }
    void weak_add_ref()
    {
        atomic_increment( &weak_count_ );
    }
    void weak_release()
    {
        if( atomic_exchange_and_add( &weak_count_, -1 ) == 1 )
        {
            destroy();
        }
    }
    long use_count() const
    {
        return static_cast<int const volatile &>( use_count_ );
    }
};
}
}
       
namespace boost
{
namespace detail
{
template<class X> class sp_counted_impl_p: public sp_counted_base
{
private:
    X * px_;
    sp_counted_impl_p( sp_counted_impl_p const & );
    sp_counted_impl_p & operator= ( sp_counted_impl_p const & );
    typedef sp_counted_impl_p<X> this_type;
public:
    explicit sp_counted_impl_p( X * px ): px_( px )
    {
    }
    virtual void dispose()
    {
        boost::checked_delete( px_ );
    }
    virtual void * get_deleter( detail::sp_typeinfo const & )
    {
        return 0;
    }
};
template<class P, class D> class sp_counted_impl_pd: public sp_counted_base
{
private:
    P ptr;
    D del;
    sp_counted_impl_pd( sp_counted_impl_pd const & );
    sp_counted_impl_pd & operator= ( sp_counted_impl_pd const & );
    typedef sp_counted_impl_pd<P, D> this_type;
public:
    sp_counted_impl_pd( P p, D & d ): ptr( p ), del( d )
    {
    }
    sp_counted_impl_pd( P p ): ptr( p ), del()
    {
    }
    virtual void dispose()
    {
        del( ptr );
    }
    virtual void * get_deleter( detail::sp_typeinfo const & ti )
    {
        return ti == typeid(D)? &reinterpret_cast<char&>( del ): 0;
    }
};
template<class P, class D, class A> class sp_counted_impl_pda: public sp_counted_base
{
private:
    P p_;
    D d_;
    A a_;
    sp_counted_impl_pda( sp_counted_impl_pda const & );
    sp_counted_impl_pda & operator= ( sp_counted_impl_pda const & );
    typedef sp_counted_impl_pda<P, D, A> this_type;
public:
    sp_counted_impl_pda( P p, D & d, A a ): p_( p ), d_( d ), a_( a )
    {
    }
    sp_counted_impl_pda( P p, A a ): p_( p ), d_(), a_( a )
    {
    }
    virtual void dispose()
    {
        d_( p_ );
    }
    virtual void destroy()
    {
        typedef typename A::template rebind< this_type >::other A2;
        A2 a2( a_ );
        this->~this_type();
        a2.deallocate( this, 1 );
    }
    virtual void * get_deleter( detail::sp_typeinfo const & ti )
    {
        return ti == typeid(D)? &reinterpret_cast<char&>( d_ ): 0;
    }
};
}
}
namespace boost
{
namespace detail
{
struct sp_nothrow_tag {};
template< class D > struct sp_inplace_tag
{
};
class weak_count;
class shared_count
{
private:
    sp_counted_base * pi_;
    friend class weak_count;
public:
    shared_count(): pi_(0)
    {
    }
    template<class Y> explicit shared_count( Y * p ): pi_( 0 )
    {
        try
        {
            pi_ = new sp_counted_impl_p<Y>( p );
        }
        catch(...)
        {
            boost::checked_delete( p );
            throw;
        }
    }
    template<class P, class D> shared_count( P p, D d ): pi_(0)
    {
        try
        {
            pi_ = new sp_counted_impl_pd<P, D>(p, d);
        }
        catch(...)
        {
            d(p);
            throw;
        }
    }
    template< class P, class D > shared_count( P p, sp_inplace_tag<D> ): pi_( 0 )
    {
        try
        {
            pi_ = new sp_counted_impl_pd< P, D >( p );
        }
        catch( ... )
        {
            D()( p );
            throw;
        }
    }
    template<class P, class D, class A> shared_count( P p, D d, A a ): pi_( 0 )
    {
        typedef sp_counted_impl_pda<P, D, A> impl_type;
        typedef typename A::template rebind< impl_type >::other A2;
        A2 a2( a );
        try
        {
            pi_ = a2.allocate( 1, static_cast< impl_type* >( 0 ) );
            new( static_cast< void* >( pi_ ) ) impl_type( p, d, a );
        }
        catch(...)
        {
            d( p );
            if( pi_ != 0 )
            {
                a2.deallocate( static_cast< impl_type* >( pi_ ), 1 );
            }
            throw;
        }
    }
    template< class P, class D, class A > shared_count( P p, sp_inplace_tag< D >, A a ): pi_( 0 )
    {
        typedef sp_counted_impl_pda< P, D, A > impl_type;
        typedef typename A::template rebind< impl_type >::other A2;
        A2 a2( a );
        try
        {
            pi_ = a2.allocate( 1, static_cast< impl_type* >( 0 ) );
            new( static_cast< void* >( pi_ ) ) impl_type( p, a );
        }
        catch(...)
        {
            D()( p );
            if( pi_ != 0 )
            {
                a2.deallocate( static_cast< impl_type* >( pi_ ), 1 );
            }
            throw;
        }
    }
    template<class Y>
    explicit shared_count( std::auto_ptr<Y> & r ): pi_( new sp_counted_impl_p<Y>( r.get() ) )
    {
        r.release();
    }
    ~shared_count()
    {
        if( pi_ != 0 ) pi_->release();
    }
    shared_count(shared_count const & r): pi_(r.pi_)
    {
        if( pi_ != 0 ) pi_->add_ref_copy();
    }
    shared_count(shared_count && r): pi_(r.pi_)
    {
        r.pi_ = 0;
    }
    explicit shared_count(weak_count const & r);
    shared_count( weak_count const & r, sp_nothrow_tag );
    shared_count & operator= (shared_count const & r)
    {
        sp_counted_base * tmp = r.pi_;
        if( tmp != pi_ )
        {
            if( tmp != 0 ) tmp->add_ref_copy();
            if( pi_ != 0 ) pi_->release();
            pi_ = tmp;
        }
        return *this;
    }
    void swap(shared_count & r)
    {
        sp_counted_base * tmp = r.pi_;
        r.pi_ = pi_;
        pi_ = tmp;
    }
    long use_count() const
    {
        return pi_ != 0? pi_->use_count(): 0;
    }
    bool unique() const
    {
        return use_count() == 1;
    }
    bool empty() const
    {
        return pi_ == 0;
    }
    friend inline bool operator==(shared_count const & a, shared_count const & b)
    {
        return a.pi_ == b.pi_;
    }
    friend inline bool operator<(shared_count const & a, shared_count const & b)
    {
        return std::less<sp_counted_base *>()( a.pi_, b.pi_ );
    }
    void * get_deleter( sp_typeinfo const & ti ) const
    {
        return pi_? pi_->get_deleter( ti ): 0;
    }
};
class weak_count
{
private:
    sp_counted_base * pi_;
    friend class shared_count;
public:
    weak_count(): pi_(0)
    {
    }
    weak_count(shared_count const & r): pi_(r.pi_)
    {
        if(pi_ != 0) pi_->weak_add_ref();
    }
    weak_count(weak_count const & r): pi_(r.pi_)
    {
        if(pi_ != 0) pi_->weak_add_ref();
    }
    weak_count(weak_count && r): pi_(r.pi_)
    {
        r.pi_ = 0;
    }
    ~weak_count()
    {
        if(pi_ != 0) pi_->weak_release();
    }
    weak_count & operator= (shared_count const & r)
    {
        sp_counted_base * tmp = r.pi_;
        if( tmp != pi_ )
        {
            if(tmp != 0) tmp->weak_add_ref();
            if(pi_ != 0) pi_->weak_release();
            pi_ = tmp;
        }
        return *this;
    }
    weak_count & operator= (weak_count const & r)
    {
        sp_counted_base * tmp = r.pi_;
        if( tmp != pi_ )
        {
            if(tmp != 0) tmp->weak_add_ref();
            if(pi_ != 0) pi_->weak_release();
            pi_ = tmp;
        }
        return *this;
    }
    void swap(weak_count & r)
    {
        sp_counted_base * tmp = r.pi_;
        r.pi_ = pi_;
        pi_ = tmp;
    }
    long use_count() const
    {
        return pi_ != 0? pi_->use_count(): 0;
    }
    bool empty() const
    {
        return pi_ == 0;
    }
    friend inline bool operator==(weak_count const & a, weak_count const & b)
    {
        return a.pi_ == b.pi_;
    }
    friend inline bool operator<(weak_count const & a, weak_count const & b)
    {
        return std::less<sp_counted_base *>()(a.pi_, b.pi_);
    }
};
inline shared_count::shared_count( weak_count const & r ): pi_( r.pi_ )
{
    if( pi_ == 0 || !pi_->add_ref_lock() )
    {
        boost::throw_exception( boost::bad_weak_ptr() );
    }
}
inline shared_count::shared_count( weak_count const & r, sp_nothrow_tag ): pi_( r.pi_ )
{
    if( pi_ != 0 && !pi_->add_ref_lock() )
    {
        pi_ = 0;
    }
}
}
}
namespace boost
{
namespace detail
{
template< class Y, class T > struct sp_convertible
{
    typedef char (&yes) [1];
    typedef char (&no) [2];
    static yes f( T* );
    static no f( ... );
    enum _vt { value = sizeof( (f)( static_cast<Y*>(0) ) ) == sizeof(yes) };
};
struct sp_empty
{
};
template< bool > struct sp_enable_if_convertible_impl;
template<> struct sp_enable_if_convertible_impl<true>
{
    typedef sp_empty type;
};
template<> struct sp_enable_if_convertible_impl<false>
{
};
template< class Y, class T > struct sp_enable_if_convertible: public sp_enable_if_convertible_impl< sp_convertible< Y, T >::value >
{
};
}
}
namespace boost
{
namespace detail
{
inline void yield( unsigned k )
{
    if( k < 4 )
    {
    }
    else if( k < 16 )
    {
        __asm__ __volatile__( "rep; nop" : : : "memory" );
    }
    else if( k < 32 || k & 1 )
    {
        sched_yield();
    }
    else
    {
        struct timespec rqtp = { 0, 0 };
        rqtp.tv_sec = 0;
        rqtp.tv_nsec = 1000;
        nanosleep( &rqtp, 0 );
    }
}
}
}
namespace boost
{
namespace detail
{
class spinlock
{
public:
    int v_;
public:
    bool try_lock()
    {
        int r = __sync_lock_test_and_set( &v_, 1 );
        return r == 0;
    }
    void lock()
    {
        for( unsigned k = 0; !try_lock(); ++k )
        {
            boost::detail::yield( k );
        }
    }
    void unlock()
    {
        __sync_lock_release( &v_ );
    }
public:
    class scoped_lock
    {
    private:
        spinlock & sp_;
        scoped_lock( scoped_lock const & );
        scoped_lock & operator=( scoped_lock const & );
    public:
        explicit scoped_lock( spinlock & sp ): sp_( sp )
        {
            sp.lock();
        }
        ~scoped_lock()
        {
            sp_.unlock();
        }
    };
};
}
}
       
namespace boost
{
namespace detail
{
template< int I > class spinlock_pool
{
private:
    static spinlock pool_[ 41 ];
public:
    static spinlock & spinlock_for( void const * pv )
    {
        std::size_t i = reinterpret_cast< std::size_t >( pv ) % 41;
        return pool_[ i ];
    }
    class scoped_lock
    {
    private:
        spinlock & sp_;
        scoped_lock( scoped_lock const & );
        scoped_lock & operator=( scoped_lock const & );
    public:
        explicit scoped_lock( void const * pv ): sp_( spinlock_for( pv ) )
        {
            sp_.lock();
        }
        ~scoped_lock()
        {
            sp_.unlock();
        }
    };
};
template< int I > spinlock spinlock_pool< I >::pool_[ 41 ] =
{
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}, {0}, {0}, {0}, {0},
    {0}
};
}
}
namespace boost
{
enum memory_order
{
    memory_order_relaxed = 0,
    memory_order_acquire = 1,
    memory_order_release = 2,
    memory_order_acq_rel = 3,
    memory_order_seq_cst = 7,
    memory_order_consume = 8
};
}
       
namespace boost
{
template<class T> class shared_ptr;
template<class T> class weak_ptr;
template<class T> class enable_shared_from_this;
template<class T> class enable_shared_from_this2;
namespace detail
{
struct static_cast_tag {};
struct const_cast_tag {};
struct dynamic_cast_tag {};
struct polymorphic_cast_tag {};
template<class T> struct shared_ptr_traits
{
    typedef T & reference;
};
template<> struct shared_ptr_traits<void>
{
    typedef void reference;
};
template<> struct shared_ptr_traits<void const>
{
    typedef void reference;
};
template<> struct shared_ptr_traits<void volatile>
{
    typedef void reference;
};
template<> struct shared_ptr_traits<void const volatile>
{
    typedef void reference;
};
template< class X, class Y, class T > inline void sp_enable_shared_from_this( boost::shared_ptr<X> const * ppx, Y const * py, boost::enable_shared_from_this< T > const * pe )
{
    if( pe != 0 )
    {
        pe->_internal_accept_owner( ppx, const_cast< Y* >( py ) );
    }
}
template< class X, class Y, class T > inline void sp_enable_shared_from_this( boost::shared_ptr<X> * ppx, Y const * py, boost::enable_shared_from_this2< T > const * pe )
{
    if( pe != 0 )
    {
        pe->_internal_accept_owner( ppx, const_cast< Y* >( py ) );
    }
}
inline void sp_enable_shared_from_this( ... )
{
}
template< class T, class R > struct sp_enable_if_auto_ptr
{
};
template< class T, class R > struct sp_enable_if_auto_ptr< std::auto_ptr< T >, R >
{
    typedef R type;
};
}
template<class T> class shared_ptr
{
private:
    typedef shared_ptr<T> this_type;
public:
    typedef T element_type;
    typedef T value_type;
    typedef T * pointer;
    typedef typename boost::detail::shared_ptr_traits<T>::reference reference;
    shared_ptr(): px(0), pn()
    {
    }
    template<class Y>
    explicit shared_ptr( Y * p ): px( p ), pn( p )
    {
        boost::detail::sp_enable_shared_from_this( this, p, p );
    }
    template<class Y, class D> shared_ptr(Y * p, D d): px(p), pn(p, d)
    {
        boost::detail::sp_enable_shared_from_this( this, p, p );
    }
    template<class Y, class D, class A> shared_ptr( Y * p, D d, A a ): px( p ), pn( p, d, a )
    {
        boost::detail::sp_enable_shared_from_this( this, p, p );
    }
    template<class Y>
    explicit shared_ptr(weak_ptr<Y> const & r): pn(r.pn)
    {
        px = r.px;
    }
    template<class Y>
    shared_ptr( weak_ptr<Y> const & r, boost::detail::sp_nothrow_tag ): px( 0 ), pn( r.pn, boost::detail::sp_nothrow_tag() )
    {
        if( !pn.empty() )
        {
            px = r.px;
        }
    }
    template<class Y>
    shared_ptr( shared_ptr<Y> const & r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )
    : px( r.px ), pn( r.pn )
    {
    }
    template< class Y >
    shared_ptr( shared_ptr<Y> const & r, T * p ): px( p ), pn( r.pn )
    {
    }
    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::static_cast_tag): px(static_cast<element_type *>(r.px)), pn(r.pn)
    {
    }
    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::const_cast_tag): px(const_cast<element_type *>(r.px)), pn(r.pn)
    {
    }
    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::dynamic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
    {
        if(px == 0)
        {
            pn = boost::detail::shared_count();
        }
    }
    template<class Y>
    shared_ptr(shared_ptr<Y> const & r, boost::detail::polymorphic_cast_tag): px(dynamic_cast<element_type *>(r.px)), pn(r.pn)
    {
        if(px == 0)
        {
            boost::throw_exception(std::bad_cast());
        }
    }
    template<class Y>
    explicit shared_ptr(std::auto_ptr<Y> & r): px(r.get()), pn()
    {
        Y * tmp = r.get();
        pn = boost::detail::shared_count(r);
        boost::detail::sp_enable_shared_from_this( this, tmp, tmp );
    }
    template<class Ap>
    explicit shared_ptr( Ap r, typename boost::detail::sp_enable_if_auto_ptr<Ap, int>::type = 0 ): px( r.get() ), pn()
    {
        typename Ap::element_type * tmp = r.get();
        pn = boost::detail::shared_count( r );
        boost::detail::sp_enable_shared_from_this( this, tmp, tmp );
    }
    shared_ptr & operator=( shared_ptr const & r )
    {
        this_type(r).swap(*this);
        return *this;
    }
    template<class Y>
    shared_ptr & operator=(shared_ptr<Y> const & r)
    {
        this_type(r).swap(*this);
        return *this;
    }
    template<class Y>
    shared_ptr & operator=( std::auto_ptr<Y> & r )
    {
        this_type(r).swap(*this);
        return *this;
    }
    template<class Ap>
    typename boost::detail::sp_enable_if_auto_ptr< Ap, shared_ptr & >::type operator=( Ap r )
    {
        this_type( r ).swap( *this );
        return *this;
    }
    shared_ptr( shared_ptr && r ): px( r.px ), pn()
    {
        pn.swap( r.pn );
        r.px = 0;
    }
    template<class Y>
    shared_ptr( shared_ptr<Y> && r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )
    : px( r.px ), pn()
    {
        pn.swap( r.pn );
        r.px = 0;
    }
    shared_ptr & operator=( shared_ptr && r )
    {
        this_type( static_cast< shared_ptr && >( r ) ).swap( *this );
        return *this;
    }
    template<class Y>
    shared_ptr & operator=( shared_ptr<Y> && r )
    {
        this_type( static_cast< shared_ptr<Y> && >( r ) ).swap( *this );
        return *this;
    }
    void reset()
    {
        this_type().swap(*this);
    }
    template<class Y> void reset(Y * p)
    {
        (__builtin_expect(!(p == 0 || p != px), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/smart_ptr/shared_ptr.hpp", 387, "p == 0 || p != px") : (void)0);
        this_type(p).swap(*this);
    }
    template<class Y, class D> void reset( Y * p, D d )
    {
        this_type( p, d ).swap( *this );
    }
    template<class Y, class D, class A> void reset( Y * p, D d, A a )
    {
        this_type( p, d, a ).swap( *this );
    }
    template<class Y> void reset( shared_ptr<Y> const & r, T * p )
    {
        this_type( r, p ).swap( *this );
    }
    reference operator* () const
    {
        (__builtin_expect(!(px != 0), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/smart_ptr/shared_ptr.hpp", 408, "px != 0") : (void)0);
        return *px;
    }
    T * operator-> () const
    {
        (__builtin_expect(!(px != 0), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/smart_ptr/shared_ptr.hpp", 414, "px != 0") : (void)0);
        return px;
    }
    T * get() const
    {
        return px;
    }
    typedef T * this_type::*unspecified_bool_type;
    operator unspecified_bool_type() const
    {
        return px == 0? 0: &this_type::px;
    }
    bool operator! () const
    {
        return px == 0;
    }
    bool unique() const
    {
        return pn.unique();
    }
    long use_count() const
    {
        return pn.use_count();
    }
    void swap(shared_ptr<T> & other)
    {
        std::swap(px, other.px);
        pn.swap(other.pn);
    }
    template<class Y> bool _internal_less(shared_ptr<Y> const & rhs) const
    {
        return pn < rhs.pn;
    }
    void * _internal_get_deleter( boost::detail::sp_typeinfo const & ti ) const
    {
        return pn.get_deleter( ti );
    }
    bool _internal_equiv( shared_ptr const & r ) const
    {
        return px == r.px && pn == r.pn;
    }
private:
    template<class Y> friend class shared_ptr;
    template<class Y> friend class weak_ptr;
    T * px;
    boost::detail::shared_count pn;
};
template<class T, class U> inline bool operator==(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a.get() == b.get();
}
template<class T, class U> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a.get() != b.get();
}
template<class T, class U> inline bool operator<(shared_ptr<T> const & a, shared_ptr<U> const & b)
{
    return a._internal_less(b);
}
template<class T> inline void swap(shared_ptr<T> & a, shared_ptr<T> & b)
{
    a.swap(b);
}
template<class T, class U> shared_ptr<T> static_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::static_cast_tag());
}
template<class T, class U> shared_ptr<T> const_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::const_cast_tag());
}
template<class T, class U> shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
}
template<class T, class U> shared_ptr<T> shared_static_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::static_cast_tag());
}
template<class T, class U> shared_ptr<T> shared_dynamic_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::dynamic_cast_tag());
}
template<class T, class U> shared_ptr<T> shared_polymorphic_cast(shared_ptr<U> const & r)
{
    return shared_ptr<T>(r, boost::detail::polymorphic_cast_tag());
}
template<class T, class U> shared_ptr<T> shared_polymorphic_downcast(shared_ptr<U> const & r)
{
    (__builtin_expect(!(dynamic_cast<T *>(r.get()) == r.get()), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/smart_ptr/shared_ptr.hpp", 540, "dynamic_cast<T *>(r.get()) == r.get()") : (void)0);
    return shared_static_cast<T>(r);
}
template<class T> inline T * get_pointer(shared_ptr<T> const & p)
{
    return p.get();
}
template<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, shared_ptr<Y> const & p)
{
    os << p.get();
    return os;
}
template<class D, class T> D * get_deleter(shared_ptr<T> const & p)
{
    return static_cast<D *>(p._internal_get_deleter(typeid(D)));
}
template<class T> inline bool atomic_is_lock_free( shared_ptr<T> const * )
{
    return false;
}
template<class T> shared_ptr<T> atomic_load( shared_ptr<T> const * p )
{
    boost::detail::spinlock_pool<2>::scoped_lock lock( p );
    return *p;
}
template<class T> inline shared_ptr<T> atomic_load_explicit( shared_ptr<T> const * p, memory_order )
{
    return atomic_load( p );
}
template<class T> void atomic_store( shared_ptr<T> * p, shared_ptr<T> r )
{
    boost::detail::spinlock_pool<2>::scoped_lock lock( p );
    p->swap( r );
}
template<class T> inline void atomic_store_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order )
{
    atomic_store( p, r );
}
template<class T> shared_ptr<T> atomic_exchange( shared_ptr<T> * p, shared_ptr<T> r )
{
    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );
    sp.lock();
    p->swap( r );
    sp.unlock();
    return r;
}
template<class T> shared_ptr<T> atomic_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order )
{
    return atomic_exchange( p, r );
}
template<class T> bool atomic_compare_exchange( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w )
{
    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );
    sp.lock();
    if( p->_internal_equiv( *v ) )
    {
        p->swap( w );
        sp.unlock();
        return true;
    }
    else
    {
        shared_ptr<T> tmp( *p );
        sp.unlock();
        tmp.swap( *v );
        return false;
    }
}
template<class T> inline bool atomic_compare_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w, memory_order , memory_order )
{
    return atomic_compare_exchange( p, v, w );
}
template< class T > struct hash;
template< class T > std::size_t hash_value( boost::shared_ptr<T> const & p )
{
    return boost::hash< T* >()( p.get() );
}
}
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
}
namespace boost {
    namespace io {
        template<class Ch, class Tr=::std::char_traits<Ch>,
                 class Alloc=::std::allocator<Ch> >
        class basic_altstringbuf;
        template<class Ch, class Tr =::std::char_traits<Ch>,
                 class Alloc=::std::allocator<Ch> >
        class basic_oaltstringstream;
        template<class Ch, class Tr, class Alloc>
        class basic_altstringbuf
            : public ::std::basic_streambuf<Ch, Tr>
        {
            typedef ::std::basic_streambuf<Ch, Tr> streambuf_t;
            typedef typename CompatAlloc<Alloc>::compatible_type compat_allocator_type;
            typedef typename CompatTraits<Tr>::compatible_type compat_traits_type;
        public:
            typedef Ch char_type;
            typedef Tr traits_type;
            typedef typename compat_traits_type::int_type int_type;
            typedef typename compat_traits_type::pos_type pos_type;
            typedef typename compat_traits_type::off_type off_type;
            typedef Alloc allocator_type;
            typedef ::std::basic_string<Ch, Tr, Alloc> string_type;
            typedef typename string_type::size_type size_type;
            typedef ::std::streamsize streamsize;
            explicit basic_altstringbuf(std::ios_base::openmode mode
                                        = std::ios_base::in | std::ios_base::out)
                : putend_(__null), is_allocated_(false), mode_(mode)
                {}
            explicit basic_altstringbuf(const string_type& s,
                                        ::std::ios_base::openmode mode
                                        = ::std::ios_base::in | ::std::ios_base::out)
                : putend_(__null), is_allocated_(false), mode_(mode)
                { dealloc(); str(s); }
            virtual ~basic_altstringbuf()
                { dealloc(); }
            using streambuf_t::pbase;
            using streambuf_t::pptr;
            using streambuf_t::epptr;
            using streambuf_t::eback;
            using streambuf_t::gptr;
            using streambuf_t::egptr;
            void clear_buffer();
            void str(const string_type& s);
            Ch * begin() const;
            size_type size() const;
            size_type cur_size() const;
            Ch * pend() const
                { return ((putend_ < pptr()) ? pptr() : putend_); }
            size_type pcount() const
                { return static_cast<size_type>( pptr() - pbase()) ;}
            string_type str() const
                { return string_type(begin(), size()); }
            string_type cur_str() const
                { return string_type(begin(), cur_size()); }
        protected:
            explicit basic_altstringbuf (basic_altstringbuf * s,
                                         ::std::ios_base::openmode mode
                                         = ::std::ios_base::in | ::std::ios_base::out)
                : putend_(__null), is_allocated_(false), mode_(mode)
                { dealloc(); str(s); }
            virtual pos_type seekoff(off_type off, ::std::ios_base::seekdir way,
                                     ::std::ios_base::openmode which
                                     = ::std::ios_base::in | ::std::ios_base::out);
            virtual pos_type seekpos (pos_type pos,
                                      ::std::ios_base::openmode which
                                      = ::std::ios_base::in | ::std::ios_base::out);
            virtual int_type underflow();
            virtual int_type pbackfail(int_type meta = compat_traits_type::eof());
            virtual int_type overflow(int_type meta = compat_traits_type::eof());
            void dealloc();
        private:
            enum { alloc_min = 256};
            Ch *putend_;
            bool is_allocated_;
            ::std::ios_base::openmode mode_;
            compat_allocator_type alloc_;
        };
        template <class Ch, class Tr, class Alloc>
        class basic_oaltstringstream
            : private base_from_member< shared_ptr< basic_altstringbuf< Ch, Tr, Alloc> > >,
              public ::std::basic_ostream<Ch, Tr>
        {
            class No_Op {
            public:
                template<class T>
                const T & operator()(const T & arg) { return arg; }
            };
            typedef ::std::basic_ostream<Ch, Tr> stream_t;
            typedef boost::base_from_member<boost::shared_ptr<
                basic_altstringbuf<Ch,Tr, Alloc> > >
                pbase_type;
            typedef ::std::basic_string<Ch, Tr, Alloc> string_type;
            typedef typename string_type::size_type size_type;
            typedef basic_altstringbuf<Ch, Tr, Alloc> stringbuf_t;
        public:
            typedef Alloc allocator_type;
            basic_oaltstringstream()
                : pbase_type(new stringbuf_t), stream_t(rdbuf())
                { }
            basic_oaltstringstream(::boost::shared_ptr<stringbuf_t> buf)
                : pbase_type(buf), stream_t(rdbuf())
                { }
            basic_oaltstringstream(stringbuf_t * buf)
                : pbase_type(buf, No_Op() ), stream_t(rdbuf())
                { }
            stringbuf_t * rdbuf() const
                { return pbase_type::member.get(); }
            void clear_buffer()
                { rdbuf()->clear_buffer(); }
            Ch * begin() const
                { return rdbuf()->begin(); }
            size_type size() const
                { return rdbuf()->size(); }
            size_type cur_size() const
                { return rdbuf()->cur_size(); }
            string_type str() const
                { return rdbuf()->str(); }
            string_type cur_str() const
                { return rdbuf()->cur_str(); }
            void str(const string_type& s)
                { rdbuf()->str(s); }
        };
    }
}
namespace boost {
    namespace io {
        template<class Ch, class Tr, class Alloc>
        void basic_altstringbuf<Ch, Tr, Alloc>::
        clear_buffer () {
            const Ch * p = pptr();
            const Ch * b = pbase();
            if(p != __null && p != b) {
                seekpos(0, ::std::ios_base::out);
            }
            p = gptr();
            b = eback();
            if(p != __null && p != b) {
                seekpos(0, ::std::ios_base::in);
            }
        }
        template<class Ch, class Tr, class Alloc>
        void basic_altstringbuf<Ch, Tr, Alloc>::
        str (const string_type& s) {
            size_type sz=s.size();
            if(sz != 0 && mode_ & (::std::ios_base::in | ::std::ios_base::out) ) {
                Ch *new_ptr = alloc_.allocate(sz, is_allocated_? eback() : 0);
                dealloc();
                sz = s.copy(new_ptr, sz);
                putend_ = new_ptr + sz;
                if(mode_ & ::std::ios_base::in)
                    streambuf_t::setg(new_ptr, new_ptr, new_ptr + sz);
                if(mode_ & ::std::ios_base::out) {
                    streambuf_t::setp(new_ptr, new_ptr + sz);
                    if(mode_ & (::std::ios_base::app | ::std::ios_base::ate))
                        streambuf_t::pbump(static_cast<int>(sz));
                    if(gptr() == __null)
                        streambuf_t::setg(new_ptr, __null, new_ptr);
                }
                is_allocated_ = true;
            }
            else
                dealloc();
        }
        template<class Ch, class Tr, class Alloc>
        Ch* basic_altstringbuf<Ch, Tr, Alloc>::
        begin () const {
            if(mode_ & ::std::ios_base::out && pptr() != __null)
                return pbase();
            else if(mode_ & ::std::ios_base::in && gptr() != __null)
                return eback();
            return __null;
        }
        template<class Ch, class Tr, class Alloc>
        typename std::basic_string<Ch,Tr,Alloc>::size_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        size () const {
            if(mode_ & ::std::ios_base::out && pptr())
                return static_cast<size_type>(pend() - pbase());
            else if(mode_ & ::std::ios_base::in && gptr())
                return static_cast<size_type>(egptr() - eback());
            else
                return 0;
        }
        template<class Ch, class Tr, class Alloc>
        typename std::basic_string<Ch,Tr,Alloc>::size_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        cur_size () const {
            if(mode_ & ::std::ios_base::out && pptr())
                return static_cast<streamsize>( pptr() - pbase());
            else if(mode_ & ::std::ios_base::in && gptr())
                return static_cast<streamsize>( gptr() - eback());
            else
                return 0;
        }
        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::pos_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        seekoff (off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which) {
            if(pptr() != __null && putend_ < pptr())
                putend_ = pptr();
            if(which & ::std::ios_base::in && gptr() != __null) {
                if(way == ::std::ios_base::end)
                    off += static_cast<off_type>(putend_ - gptr());
                else if(way == ::std::ios_base::beg)
                    off += static_cast<off_type>(eback() - gptr());
                else if(way != ::std::ios_base::cur || (which & ::std::ios_base::out) )
                    return pos_type(off_type(-1));
                if(eback() <= off+gptr() && off+gptr() <= putend_ ) {
                    streambuf_t::gbump(static_cast<int>(off));
                    if(which & ::std::ios_base::out && pptr() != __null)
                        streambuf_t::pbump(static_cast<int>(gptr()-pptr()));
                }
                else
                    off = off_type(-1);
            }
            else if(which & ::std::ios_base::out && pptr() != __null) {
                if(way == ::std::ios_base::end)
                    off += static_cast<off_type>(putend_ - pptr());
                else if(way == ::std::ios_base::beg)
                    off += static_cast<off_type>(pbase() - pptr());
                else if(way != ::std::ios_base::beg)
                    return pos_type(off_type(-1));
                if(pbase() <= off+pptr() && off+pptr() <= putend_)
                    streambuf_t::pbump(static_cast<int>(off));
                else
                    off = off_type(-1);
            }
            else
                off = off_type(-1);
            return (pos_type(off));
        }
        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::pos_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        seekpos (pos_type pos, ::std::ios_base::openmode which) {
            off_type off = off_type(pos);
            if(pptr() != __null && putend_ < pptr())
                putend_ = pptr();
            if(off != off_type(-1)) {
                if(which & ::std::ios_base::in && gptr() != __null) {
                    if(0 <= off && off <= putend_ - eback()) {
                        streambuf_t::gbump(static_cast<int>(eback() - gptr() + off));
                        if(which & ::std::ios_base::out && pptr() != __null) {
                            streambuf_t::pbump(static_cast<int>(gptr()-pptr()));
                        }
                    }
                    else
                        off = off_type(-1);
                }
                else if(which & ::std::ios_base::out && pptr() != __null) {
                    if(0 <= off && off <= putend_ - eback())
                        streambuf_t::pbump(static_cast<int>(eback() - pptr() + off));
                    else
                        off = off_type(-1);
                }
                else
                    off = off_type(-1);
                return (pos_type(off));
            }
            else {
                (__builtin_expect(!(0), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/format/alt_sstream_impl.hpp", 176, "0") : (void)0);
                return pos_type(off_type(-1));
            }
        }
        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        underflow () {
            if(gptr() == __null)
                return (compat_traits_type::eof());
            else if(gptr() < egptr())
                return (compat_traits_type::to_int_type(*gptr()));
            else if(mode_ & ::std::ios_base::in && pptr() != __null
                    && (gptr() < pptr() || gptr() < putend_) )
                {
                    if(putend_ < pptr())
                        putend_ = pptr();
                    streambuf_t::setg(eback(), gptr(), putend_);
                    return (compat_traits_type::to_int_type(*gptr()));
                }
            else
                return (compat_traits_type::eof());
        }
        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        pbackfail (int_type meta) {
            if(gptr() != __null && (eback() < gptr())
               && (mode_ & (::std::ios_base::out)
                   || compat_traits_type::eq_int_type(compat_traits_type::eof(), meta)
                   || compat_traits_type::eq(compat_traits_type::to_char_type(meta), gptr()[-1]) ) ) {
                streambuf_t::gbump(-1);
                if(!compat_traits_type::eq_int_type(compat_traits_type::eof(), meta))
                    *gptr() = compat_traits_type::to_char_type(meta);
                return (compat_traits_type::not_eof(meta));
            }
            else
                return (compat_traits_type::eof());
        }
        template<class Ch, class Tr, class Alloc>
        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type
        basic_altstringbuf<Ch, Tr, Alloc>::
        overflow (int_type meta) {
            if(compat_traits_type::eq_int_type(compat_traits_type::eof(), meta))
                return compat_traits_type::not_eof(meta);
            else if(pptr() != __null && pptr() < epptr()) {
                streambuf_t::sputc(compat_traits_type::to_char_type(meta));
                return meta;
            }
            else if(! (mode_ & ::std::ios_base::out))
                return compat_traits_type::eof();
            else {
                std::size_t prev_size = pptr() == __null ? 0 : epptr() - eback();
                std::size_t new_size = prev_size;
                std::size_t add_size = new_size / 2;
                if(add_size < alloc_min)
                    add_size = alloc_min;
                Ch * newptr = __null, *oldptr = eback();
                while (0 < add_size && ((std::numeric_limits<std::size_t>::max)()
                                        - add_size < new_size) )
                    add_size /= 2;
                if(0 < add_size) {
                    new_size += add_size;
                    newptr = alloc_.allocate(new_size, is_allocated_? oldptr : 0);
                }
                if(0 < prev_size)
                    compat_traits_type::copy(newptr, oldptr, prev_size);
                if(is_allocated_)
                    alloc_.deallocate(oldptr, prev_size);
                is_allocated_=true;
                if(prev_size == 0) {
                    putend_ = newptr;
                    streambuf_t::setp(newptr, newptr + new_size);
                    if(mode_ & ::std::ios_base::in)
                        streambuf_t::setg(newptr, newptr, newptr + 1);
                    else
                        streambuf_t::setg(newptr, 0, newptr);
                }
                else {
                    putend_ = putend_ - oldptr + newptr;
                    int pptr_count = static_cast<int>(pptr()-pbase());
                    int gptr_count = static_cast<int>(gptr()-eback());
                    streambuf_t::setp(pbase() - oldptr + newptr, newptr + new_size);
                    streambuf_t::pbump(pptr_count);
                    if(mode_ & ::std::ios_base::in)
                        streambuf_t::setg(newptr, newptr + gptr_count, pptr() + 1);
                    else
                        streambuf_t::setg(newptr, 0, newptr);
                }
                streambuf_t::sputc(compat_traits_type::to_char_type(meta));
                return meta;
            }
        }
        template<class Ch, class Tr, class Alloc>
        void basic_altstringbuf<Ch, Tr, Alloc>:: dealloc() {
            if(is_allocated_)
                alloc_.deallocate(eback(), (pptr() != __null ? epptr() : egptr()) - eback());
            is_allocated_ = false;
            streambuf_t::setg(0, 0, 0);
            streambuf_t::setp(0, 0);
            putend_ = __null;
        }
    }
}
namespace boost {
namespace io {
namespace detail {
    template<class Ch, class Tr>
    struct stream_format_state
    {
        typedef ::std:: basic_ios<Ch, Tr> basic_ios;
        stream_format_state(Ch fill) { reset(fill); }
        void reset(Ch fill);
        void set_by_stream(const basic_ios& os);
        void apply_on(basic_ios & os,
                      boost::io::detail::locale_t * loc_default = 0) const;
        template<class T>
        void apply_manip(T manipulator)
            { apply_manip_body<Ch, Tr, T>( *this, manipulator) ; }
        std::streamsize width_;
        std::streamsize precision_;
        Ch fill_;
        std::ios_base::fmtflags flags_;
        std::ios_base::iostate rdstate_;
        std::ios_base::iostate exceptions_;
        boost::optional<boost::io::detail::locale_t> loc_;
    };
    template<class Ch, class Tr, class Alloc>
    struct format_item
    {
        enum pad_values { zeropad = 1, spacepad =2, centered=4, tabulation = 8 };
        enum arg_values { argN_no_posit = -1,
                          argN_tabulation = -2,
                          argN_ignored = -3
        };
        typedef ::std:: basic_ios<Ch, Tr> basic_ios;
        typedef detail::stream_format_state<Ch, Tr> stream_format_state;
        typedef ::std::basic_string<Ch, Tr, Alloc> string_type;
        format_item(Ch fill) :argN_(argN_no_posit), fmtstate_(fill),
                              truncate_(max_streamsize()), pad_scheme_(0) {}
        void reset(Ch fill);
        void compute_states();
        static std::streamsize max_streamsize() {
            return (std::numeric_limits<std::streamsize>::max)();
        }
        int argN_;
        string_type res_;
        string_type appendix_;
        stream_format_state fmtstate_;
        std::streamsize truncate_;
        unsigned int pad_scheme_;
    };
    template<class Ch, class Tr>
    void stream_format_state<Ch,Tr>:: apply_on (basic_ios & os,
                      boost::io::detail::locale_t * loc_default) const {
        if(width_ != -1)
            os.width(width_);
        if(precision_ != -1)
            os.precision(precision_);
        if(fill_ != 0)
            os.fill(fill_);
        os.flags(flags_);
        os.clear(rdstate_);
        os.exceptions(exceptions_);
        if(loc_)
            os.imbue(loc_.get());
        else if(loc_default)
            os.imbue(*loc_default);
    }
    template<class Ch, class Tr>
    void stream_format_state<Ch,Tr>:: set_by_stream(const basic_ios& os) {
        flags_ = os.flags();
        width_ = os.width();
        precision_ = os.precision();
        fill_ = os.fill();
        rdstate_ = os.rdstate();
        exceptions_ = os.exceptions();
    }
    template<class Ch, class Tr, class T>
    void apply_manip_body( stream_format_state<Ch, Tr>& self,
                           T manipulator) {
        basic_oaltstringstream<Ch, Tr> ss;
        self.apply_on( ss );
        ss << manipulator;
        self.set_by_stream( ss );
    }
    template<class Ch, class Tr> inline
    void stream_format_state<Ch,Tr>:: reset(Ch fill) {
        width_=0; precision_=6;
        fill_=fill;
        flags_ = std::ios_base::dec | std::ios_base::skipws;
        exceptions_ = std::ios_base::goodbit;
        rdstate_ = std::ios_base::goodbit;
    }
    template<class Ch, class Tr, class Alloc>
    void format_item<Ch, Tr, Alloc>::
    reset (Ch fill) {
        argN_=argN_no_posit; truncate_ = max_streamsize(); pad_scheme_ =0;
        res_.resize(0); appendix_.resize(0);
        fmtstate_.reset(fill);
    }
    template<class Ch, class Tr, class Alloc>
    void format_item<Ch, Tr, Alloc>::
    compute_states() {
        if(pad_scheme_ & zeropad) {
            if(fmtstate_.flags_ & std::ios_base::left) {
              (__builtin_expect(!(!(fmtstate_.flags_ &(std::ios_base::adjustfield ^std::ios_base::left))), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/format/internals.hpp", 179, "!(fmtstate_.flags_ &(std::ios_base::adjustfield ^std::ios_base::left))") : (void)0);
              pad_scheme_ = pad_scheme_ & (~zeropad);
            }
            else {
                pad_scheme_ &= ~spacepad;
                fmtstate_.fill_='0';
                fmtstate_.flags_ = (fmtstate_.flags_ & ~std::ios_base::adjustfield)
                    | std::ios_base::internal;
            }
        }
        if(pad_scheme_ & spacepad) {
            if(fmtstate_.flags_ & std::ios_base::showpos)
                pad_scheme_ &= ~spacepad;
        }
    }
} } }
namespace boost {
    template<class Ch, class Tr, class Alloc>
    class basic_format
    {
        typedef typename io::CompatTraits<Tr>::compatible_type compat_traits;
    public:
        typedef Ch CharT;
        typedef std::basic_string<Ch, Tr, Alloc> string_type;
        typedef typename string_type::size_type size_type;
        typedef io::detail::format_item<Ch, Tr, Alloc> format_item_t;
        typedef io::basic_altstringbuf<Ch, Tr, Alloc> internal_streambuf_t;
        explicit basic_format(const Ch* str=__null);
        explicit basic_format(const string_type& s);
        basic_format(const basic_format& x);
        basic_format& operator= (const basic_format& x);
        void swap(basic_format& x);
        explicit basic_format(const Ch* str, const std::locale & loc);
        explicit basic_format(const string_type& s, const std::locale & loc);
        io::detail::locale_t getloc() const;
        basic_format& clear();
        basic_format& clear_binds();
        basic_format& parse(const string_type&);
        size_type size() const;
        string_type str() const;
        template<class T>
        basic_format& operator%(const T& x)
            { return io::detail::feed<CharT, Tr, Alloc, const T&>(*this,x); }
        template<class T> basic_format& operator%(T& x)
            { return io::detail::feed<CharT, Tr, Alloc, T&>(*this,x); }
        basic_format& operator%(const int& x)
            { return io::detail::feed<CharT, Tr, Alloc, const int&>(*this,x); }
        basic_format& operator%(int& x)
            { return io::detail::feed<CharT, Tr, Alloc, int&>(*this,x); }
        int expected_args() const
            { return num_args_; }
        int bound_args() const;
        int fed_args() const;
        int cur_arg() const;
        int remaining_args() const;
        template<class T>
        basic_format& bind_arg(int argN, const T& val)
            { return io::detail::bind_arg_body(*this, argN, val); }
        basic_format& clear_bind(int argN);
        template<class T>
        basic_format& modify_item(int itemN, T manipulator)
            { return io::detail::modify_item_body<Ch,Tr, Alloc, T> (*this, itemN, manipulator);}
        unsigned char exceptions() const;
        unsigned char exceptions(unsigned char newexcept);
        template<class Ch2, class Tr2, class Alloc2>
        friend std::basic_ostream<Ch2, Tr2> &
        operator<<( std::basic_ostream<Ch2, Tr2> & ,
                    const basic_format<Ch2, Tr2, Alloc2>& );
        template<class Ch2, class Tr2, class Alloc2, class T>
        friend basic_format<Ch2, Tr2, Alloc2>&
        io::detail::feed (basic_format<Ch2, Tr2, Alloc2>&, T);
        template<class Ch2, class Tr2, class Alloc2, class T> friend
        void io::detail::distribute (basic_format<Ch2, Tr2, Alloc2>&, T);
        template<class Ch2, class Tr2, class Alloc2, class T> friend
        basic_format<Ch2, Tr2, Alloc2>&
        io::detail::modify_item_body (basic_format<Ch2, Tr2, Alloc2>&, int, T);
        template<class Ch2, class Tr2, class Alloc2, class T> friend
        basic_format<Ch2, Tr2, Alloc2>&
        io::detail::bind_arg_body (basic_format<Ch2, Tr2, Alloc2>&, int, const T&);
    private:
        typedef io::detail::stream_format_state<Ch, Tr> stream_format_state;
        enum style_values { ordered = 1,
                             special_needs = 4 };
        void make_or_reuse_data(std::size_t nbitems);
        std::vector<format_item_t> items_;
        std::vector<bool> bound_;
        int style_;
        int cur_arg_;
        int num_args_;
        mutable bool dumped_;
        string_type prefix_;
        unsigned char exceptions_;
        internal_streambuf_t buf_;
        boost::optional<io::detail::locale_t> loc_;
    };
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  class logic_error : public exception
  {
    string _M_msg;
  public:
    explicit
    logic_error(const string& __arg);
    virtual
    ~logic_error() throw();
    virtual const char*
    what() const throw();
  };
  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg);
  };
  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg);
  };
  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg);
  };
  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg);
  };
  class runtime_error : public exception
  {
    string _M_msg;
  public:
    explicit
    runtime_error(const string& __arg);
    virtual
    ~runtime_error() throw();
    virtual const char*
    what() const throw();
  };
  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg);
  };
  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg);
  };
  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg);
  };
}
namespace boost {
    namespace io {
        class format_error : public std::exception
        {
        public:
            format_error() {}
            virtual const char *what() const throw() {
                return "boost::format_error: "
                    "format generic failure";
            }
        };
        class bad_format_string : public format_error
        {
            std::size_t pos_, next_;
        public:
            bad_format_string(std::size_t pos, std::size_t size)
                : pos_(pos), next_(size) {}
            std::size_t get_pos() const { return pos_; }
            std::size_t get_next() const { return next_; }
            virtual const char *what() const throw() {
                return "boost::bad_format_string: format-string is ill-formed";
            }
        };
        class too_few_args : public format_error
        {
            std::size_t cur_, expected_;
        public:
            too_few_args(std::size_t cur, std::size_t expected)
                : cur_(cur), expected_(expected) {}
            std::size_t get_cur() const { return cur_; }
            std::size_t get_expected() const { return expected_; }
            virtual const char *what() const throw() {
                return "boost::too_few_args: "
                    "format-string referred to more arguments than were passed";
            }
        };
        class too_many_args : public format_error
        {
            std::size_t cur_, expected_;
        public:
            too_many_args(std::size_t cur, std::size_t expected)
                : cur_(cur), expected_(expected) {}
            std::size_t get_cur() const { return cur_; }
            std::size_t get_expected() const { return expected_; }
            virtual const char *what() const throw() {
                return "boost::too_many_args: "
                    "format-string referred to less arguments than were passed";
            }
        };
        class out_of_range : public format_error
        {
            int index_, beg_, end_;
        public:
            out_of_range(int index, int beg, int end)
                : index_(index), beg_(beg), end_(end) {}
            int get_index() const { return index_; }
            int get_beg() const { return beg_; }
            int get_end() const { return end_; }
            virtual const char *what() const throw() {
                return "boost::out_of_range: "
                    "tried to refer to an argument (or item) number which"
                    " is out of range, according to the format string";
            }
        };
    }
}
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
}
namespace boost {
    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const Ch* s)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits)
    {
        if( s)
            parse( s );
    }
    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const Ch* s, const std::locale & loc)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits), loc_(loc)
    {
        if(s) parse( s );
    }
    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const string_type& s, const std::locale & loc)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits), loc_(loc)
    {
        parse(s);
    }
    template< class Ch, class Tr, class Alloc>
    io::detail::locale_t basic_format<Ch, Tr, Alloc>::
    getloc() const {
        return loc_ ? loc_.get() : io::detail::locale_t();
    }
    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const string_type& s)
        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),
          exceptions_(io::all_error_bits)
    {
        parse(s);
    }
    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>:: basic_format(const basic_format& x)
        : items_(x.items_), bound_(x.bound_), style_(x.style_),
          cur_arg_(x.cur_arg_), num_args_(x.num_args_), dumped_(x.dumped_),
          prefix_(x.prefix_), exceptions_(x.exceptions_), loc_(x.loc_)
    {
    }
    template< class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>& basic_format<Ch, Tr, Alloc>::
    operator= (const basic_format& x) {
        if(this == &x)
            return *this;
        (basic_format<Ch, Tr, Alloc>(x)).swap(*this);
        return *this;
    }
    template< class Ch, class Tr, class Alloc>
    void basic_format<Ch, Tr, Alloc>::
    swap (basic_format & x) {
        std::swap(exceptions_, x.exceptions_);
        std::swap(style_, x.style_);
        std::swap(cur_arg_, x.cur_arg_);
        std::swap(num_args_, x.num_args_);
        std::swap(dumped_, x.dumped_);
        items_.swap(x.items_);
        prefix_.swap(x.prefix_);
        bound_.swap(x.bound_);
    }
    template< class Ch, class Tr, class Alloc>
    unsigned char basic_format<Ch,Tr, Alloc>:: exceptions() const {
        return exceptions_;
    }
    template< class Ch, class Tr, class Alloc>
    unsigned char basic_format<Ch,Tr, Alloc>:: exceptions(unsigned char newexcept) {
        unsigned char swp = exceptions_;
        exceptions_ = newexcept;
        return swp;
    }
    template<class Ch, class Tr, class Alloc>
    void basic_format<Ch, Tr, Alloc>::
    make_or_reuse_data (std::size_t nbitems) {
        Ch fill = ( std::use_facet< std::ctype<Ch> >(getloc()) ). widen(' ');
        if(items_.size() == 0)
            items_.assign( nbitems, format_item_t(fill) );
        else {
            if(nbitems>items_.size())
                items_.resize(nbitems, format_item_t(fill));
            bound_.resize(0);
            for(std::size_t i=0; i < nbitems; ++i)
                items_[i].reset(fill);
        }
        prefix_.resize(0);
    }
    template< class Ch, class Tr, class Alloc>
    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>::
    clear () {
        (__builtin_expect(!(bound_.size()==0 || num_args_ == static_cast<int>(bound_.size())), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/format/format_implementation.hpp", 135, "bound_.size()==0 || num_args_ == static_cast<int>(bound_.size())") : (void)0);
        for(unsigned long i=0; i<items_.size(); ++i) {
            if( bound_.size()==0 || items_[i].argN_<0 || !bound_[ items_[i].argN_ ] )
                items_[i].res_.resize(0);
        }
        cur_arg_=0; dumped_=false;
        if(bound_.size() != 0) {
            for(; cur_arg_ < num_args_ && bound_[cur_arg_]; ++cur_arg_)
                {}
        }
        return *this;
    }
    template< class Ch, class Tr, class Alloc>
    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>::
    clear_binds () {
        bound_.resize(0);
        clear();
        return *this;
    }
    template< class Ch, class Tr, class Alloc>
    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>::
    clear_bind (int argN) {
        if(argN<1 || argN > num_args_ || bound_.size()==0 || !bound_[argN-1] ) {
            if( exceptions() & io::out_of_range_bit)
                boost::throw_exception(io::out_of_range(argN, 1, num_args_+1 ) );
            else return *this;
        }
        bound_[argN-1]=false;
        clear();
        return *this;
    }
    template< class Ch, class Tr, class Alloc>
    int basic_format<Ch,Tr, Alloc>::
    bound_args() const {
        if(bound_.size()==0)
            return 0;
        int n=0;
        for(int i=0; i<num_args_ ; ++i)
            if(bound_[i])
                ++n;
        return n;
    }
    template< class Ch, class Tr, class Alloc>
    int basic_format<Ch,Tr, Alloc>::
    fed_args() const {
        if(bound_.size()==0)
            return cur_arg_;
        int n=0;
        for(int i=0; i<cur_arg_ ; ++i)
            if(!bound_[i])
                ++n;
        return n;
    }
    template< class Ch, class Tr, class Alloc>
    int basic_format<Ch,Tr, Alloc>::
    cur_arg() const {
      return cur_arg_+1; }
    template< class Ch, class Tr, class Alloc>
    int basic_format<Ch,Tr, Alloc>::
    remaining_args() const {
        if(bound_.size()==0)
            return num_args_-cur_arg_;
        int n=0;
        for(int i=cur_arg_; i<num_args_ ; ++i)
            if(!bound_[i])
                ++n;
        return n;
    }
    template< class Ch, class Tr, class Alloc>
    typename basic_format<Ch, Tr, Alloc>::string_type
    basic_format<Ch,Tr, Alloc>::
    str () const {
        if(items_.size()==0)
            return prefix_;
        if( cur_arg_ < num_args_)
            if( exceptions() & io::too_few_args_bit )
                boost::throw_exception(io::too_few_args(cur_arg_, num_args_));
        unsigned long i;
        string_type res;
        res.reserve(size());
        res += prefix_;
        for(i=0; i < items_.size(); ++i) {
            const format_item_t& item = items_[i];
            res += item.res_;
            if( item.argN_ == format_item_t::argN_tabulation) {
                (__builtin_expect(!(item.pad_scheme_ & format_item_t::tabulation), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/format/format_implementation.hpp", 234, "item.pad_scheme_ & format_item_t::tabulation") : (void)0);
                if( static_cast<size_type>(item.fmtstate_.width_) > res.size() )
                    res.append( static_cast<size_type>(item.fmtstate_.width_) - res.size(),
                                        item.fmtstate_.fill_ );
            }
            res += item.appendix_;
        }
        dumped_=true;
        return res;
    }
    template< class Ch, class Tr, class Alloc>
    typename std::basic_string<Ch, Tr, Alloc>::size_type basic_format<Ch,Tr, Alloc>::
    size () const {
        using std::max;
        size_type sz = prefix_.size();
        unsigned long i;
        for(i=0; i < items_.size(); ++i) {
            const format_item_t& item = items_[i];
            sz += item.res_.size();
            if( item.argN_ == format_item_t::argN_tabulation)
                sz = max (sz,
                                        static_cast<size_type>(item.fmtstate_.width_) );
            sz += item.appendix_.size();
        }
        return sz;
    }
namespace io {
namespace detail {
    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    bind_arg_body (basic_format<Ch, Tr, Alloc>& self, int argN, const T& val) {
        if(self.dumped_)
            self.clear();
        if(argN<1 || argN > self.num_args_) {
            if( self.exceptions() & io::out_of_range_bit )
                boost::throw_exception(io::out_of_range(argN, 1, self.num_args_+1 ) );
            else return self;
        }
        if(self.bound_.size()==0)
            self.bound_.assign(self.num_args_,false);
        else
            (__builtin_expect(!(self.num_args_ == static_cast<signed int>(self.bound_.size())), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/format/format_implementation.hpp", 289, "self.num_args_ == static_cast<signed int>(self.bound_.size())") : (void)0);
        int o_cur_arg = self.cur_arg_;
        self.cur_arg_ = argN-1;
        self.bound_[self.cur_arg_]=false;
        self.operator%(val);
        self.cur_arg_ = o_cur_arg;
        self.bound_[argN-1]=true;
        if(self.cur_arg_ == argN-1 ) {
            while(self.cur_arg_ < self.num_args_ && self.bound_[self.cur_arg_])
                ++self.cur_arg_;
        }
        (__builtin_expect(!(self.cur_arg_ >= self.num_args_ || ! self.bound_[self.cur_arg_]), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/format/format_implementation.hpp", 306, "self.cur_arg_ >= self.num_args_ || ! self.bound_[self.cur_arg_]") : (void)0);
        return self;
    }
    template<class Ch, class Tr, class Alloc, class T> basic_format<Ch, Tr, Alloc>&
    modify_item_body (basic_format<Ch, Tr, Alloc>& self, int itemN, T manipulator) {
        if(itemN<1 || itemN > static_cast<signed int>(self.items_.size() )) {
            if( self.exceptions() & io::out_of_range_bit )
                boost::throw_exception(io::out_of_range(itemN, 1, static_cast<int>(self.items_.size()) ));
            else return self;
        }
        self.items_[itemN-1].fmtstate_. template apply_manip<T> ( manipulator );
        return self;
    }
}
}
}
namespace boost {
namespace io {
namespace detail {
struct group0
{
    group0() {}
};
template <class Ch, class Tr>
inline
::std:: basic_ostream<Ch, Tr>&
operator << ( ::std:: basic_ostream<Ch, Tr>& os,
             const group0& )
{
   return os;
}
template <class T1>
struct group1
{
    T1 a1_;
    group1(T1 a1)
      : a1_(a1)
      {}
private:
   group1& operator=(const group1&);
};
template <class Ch, class Tr, class T1>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group1<T1>& x)
{
   os << x.a1_;
   return os;
}
template <class T1,class T2>
struct group2
{
    T1 a1_;
    T2 a2_;
    group2(T1 a1,T2 a2)
      : a1_(a1),a2_(a2)
      {}
private:
   group2& operator=(const group2&);
};
template <class Ch, class Tr, class T1,class T2>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group2<T1,T2>& x)
{
   os << x.a1_<< x.a2_;
   return os;
}
template <class T1,class T2,class T3>
struct group3
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    group3(T1 a1,T2 a2,T3 a3)
      : a1_(a1),a2_(a2),a3_(a3)
      {}
private:
   group3& operator=(const group3&);
};
template <class Ch, class Tr, class T1,class T2,class T3>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group3<T1,T2,T3>& x)
{
   os << x.a1_<< x.a2_<< x.a3_;
   return os;
}
template <class T1,class T2,class T3,class T4>
struct group4
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    group4(T1 a1,T2 a2,T3 a3,T4 a4)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4)
      {}
private:
   group4& operator=(const group4&);
};
template <class Ch, class Tr, class T1,class T2,class T3,class T4>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group4<T1,T2,T3,T4>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_;
   return os;
}
template <class T1,class T2,class T3,class T4,class T5>
struct group5
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    group5(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5)
      {}
};
template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group5<T1,T2,T3,T4,T5>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_;
   return os;
}
template <class T1,class T2,class T3,class T4,class T5,class T6>
struct group6
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    group6(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6)
      {}
};
template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group6<T1,T2,T3,T4,T5,T6>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_;
   return os;
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
struct group7
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    group7(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7)
      {}
};
template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group7<T1,T2,T3,T4,T5,T6,T7>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_;
   return os;
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
struct group8
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    T8 a8_;
    group8(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8)
      {}
};
template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group8<T1,T2,T3,T4,T5,T6,T7,T8>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_;
   return os;
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
struct group9
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    T8 a8_;
    T9 a9_;
    group9(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8),a9_(a9)
      {}
};
template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group9<T1,T2,T3,T4,T5,T6,T7,T8,T9>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_<< x.a9_;
   return os;
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
struct group10
{
    T1 a1_;
    T2 a2_;
    T3 a3_;
    T4 a4_;
    T5 a5_;
    T6 a6_;
    T7 a7_;
    T8 a8_;
    T9 a9_;
    T10 a10_;
    group10(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9,T10 a10)
      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8),a9_(a9),a10_(a10)
      {}
};
template <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
inline
::std:: basic_ostream<Ch, Tr>&
operator << (::std:: basic_ostream<Ch, Tr>& os,
             const group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10>& x)
{
   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_<< x.a9_<< x.a10_;
   return os;
}
template <class T1,class T2>
inline
group1<T1>
group_head( group2<T1,T2> const& x)
{
   return group1<T1> (x.a1_);
}
template <class T1,class T2>
inline
group1<T2>
group_last( group2<T1,T2> const& x)
{
   return group1<T2> (x.a2_);
}
template <class T1,class T2,class T3>
inline
group2<T1,T2>
group_head( group3<T1,T2,T3> const& x)
{
   return group2<T1,T2> (x.a1_,x.a2_);
}
template <class T1,class T2,class T3>
inline
group1<T3>
group_last( group3<T1,T2,T3> const& x)
{
   return group1<T3> (x.a3_);
}
template <class T1,class T2,class T3,class T4>
inline
group3<T1,T2,T3>
group_head( group4<T1,T2,T3,T4> const& x)
{
   return group3<T1,T2,T3> (x.a1_,x.a2_,x.a3_);
}
template <class T1,class T2,class T3,class T4>
inline
group1<T4>
group_last( group4<T1,T2,T3,T4> const& x)
{
   return group1<T4> (x.a4_);
}
template <class T1,class T2,class T3,class T4,class T5>
inline
group4<T1,T2,T3,T4>
group_head( group5<T1,T2,T3,T4,T5> const& x)
{
   return group4<T1,T2,T3,T4> (x.a1_,x.a2_,x.a3_,x.a4_);
}
template <class T1,class T2,class T3,class T4,class T5>
inline
group1<T5>
group_last( group5<T1,T2,T3,T4,T5> const& x)
{
   return group1<T5> (x.a5_);
}
template <class T1,class T2,class T3,class T4,class T5,class T6>
inline
group5<T1,T2,T3,T4,T5>
group_head( group6<T1,T2,T3,T4,T5,T6> const& x)
{
   return group5<T1,T2,T3,T4,T5> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_);
}
template <class T1,class T2,class T3,class T4,class T5,class T6>
inline
group1<T6>
group_last( group6<T1,T2,T3,T4,T5,T6> const& x)
{
   return group1<T6> (x.a6_);
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
inline
group6<T1,T2,T3,T4,T5,T6>
group_head( group7<T1,T2,T3,T4,T5,T6,T7> const& x)
{
   return group6<T1,T2,T3,T4,T5,T6> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_);
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7>
inline
group1<T7>
group_last( group7<T1,T2,T3,T4,T5,T6,T7> const& x)
{
   return group1<T7> (x.a7_);
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
inline
group7<T1,T2,T3,T4,T5,T6,T7>
group_head( group8<T1,T2,T3,T4,T5,T6,T7,T8> const& x)
{
   return group7<T1,T2,T3,T4,T5,T6,T7> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_);
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>
inline
group1<T8>
group_last( group8<T1,T2,T3,T4,T5,T6,T7,T8> const& x)
{
   return group1<T8> (x.a8_);
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
inline
group8<T1,T2,T3,T4,T5,T6,T7,T8>
group_head( group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> const& x)
{
   return group8<T1,T2,T3,T4,T5,T6,T7,T8> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_,x.a8_);
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>
inline
group1<T9>
group_last( group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> const& x)
{
   return group1<T9> (x.a9_);
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
inline
group9<T1,T2,T3,T4,T5,T6,T7,T8,T9>
group_head( group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10> const& x)
{
   return group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_,x.a8_,x.a9_);
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>
inline
group1<T10>
group_last( group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10> const& x)
{
   return group1<T10> (x.a10_);
}
}
inline detail::group1< detail::group0 >
group() { return detail::group1< detail::group0 > ( detail::group0() ); }
template <class T1, class Var>
inline
detail::group1< detail::group2<T1, Var const&> >
  group(T1 a1, Var const& var)
{
   return detail::group1< detail::group2<T1, Var const&> >
                   ( detail::group2<T1, Var const&>
                        (a1, var)
                  );
}
template <class T1,class T2, class Var>
inline
detail::group1< detail::group3<T1,T2, Var const&> >
  group(T1 a1,T2 a2, Var const& var)
{
   return detail::group1< detail::group3<T1,T2, Var const&> >
                   ( detail::group3<T1,T2, Var const&>
                        (a1,a2, var)
                  );
}
template <class T1,class T2,class T3, class Var>
inline
detail::group1< detail::group4<T1,T2,T3, Var const&> >
  group(T1 a1,T2 a2,T3 a3, Var const& var)
{
   return detail::group1< detail::group4<T1,T2,T3, Var const&> >
                   ( detail::group4<T1,T2,T3, Var const&>
                        (a1,a2,a3, var)
                  );
}
template <class T1,class T2,class T3,class T4, class Var>
inline
detail::group1< detail::group5<T1,T2,T3,T4, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4, Var const& var)
{
   return detail::group1< detail::group5<T1,T2,T3,T4, Var const&> >
                   ( detail::group5<T1,T2,T3,T4, Var const&>
                        (a1,a2,a3,a4, var)
                  );
}
template <class T1,class T2,class T3,class T4,class T5, class Var>
inline
detail::group1< detail::group6<T1,T2,T3,T4,T5, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5, Var const& var)
{
   return detail::group1< detail::group6<T1,T2,T3,T4,T5, Var const&> >
                   ( detail::group6<T1,T2,T3,T4,T5, Var const&>
                        (a1,a2,a3,a4,a5, var)
                  );
}
template <class T1,class T2,class T3,class T4,class T5,class T6, class Var>
inline
detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6, Var const& var)
{
   return detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var const&> >
                   ( detail::group7<T1,T2,T3,T4,T5,T6, Var const&>
                        (a1,a2,a3,a4,a5,a6, var)
                  );
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7, class Var>
inline
detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7, Var const& var)
{
   return detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&> >
                   ( detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&>
                        (a1,a2,a3,a4,a5,a6,a7, var)
                  );
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8, class Var>
inline
detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8, Var const& var)
{
   return detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&> >
                   ( detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&>
                        (a1,a2,a3,a4,a5,a6,a7,a8, var)
                  );
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9, class Var>
inline
detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9, Var const& var)
{
   return detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&> >
                   ( detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&>
                        (a1,a2,a3,a4,a5,a6,a7,a8,a9, var)
                  );
}
template <class T1, class Var>
inline
detail::group1< detail::group2<T1, Var&> >
  group(T1 a1, Var& var)
{
   return detail::group1< detail::group2<T1, Var&> >
                   ( detail::group2<T1, Var&>
                        (a1, var)
                  );
}
template <class T1,class T2, class Var>
inline
detail::group1< detail::group3<T1,T2, Var&> >
  group(T1 a1,T2 a2, Var& var)
{
   return detail::group1< detail::group3<T1,T2, Var&> >
                   ( detail::group3<T1,T2, Var&>
                        (a1,a2, var)
                  );
}
template <class T1,class T2,class T3, class Var>
inline
detail::group1< detail::group4<T1,T2,T3, Var&> >
  group(T1 a1,T2 a2,T3 a3, Var& var)
{
   return detail::group1< detail::group4<T1,T2,T3, Var&> >
                   ( detail::group4<T1,T2,T3, Var&>
                        (a1,a2,a3, var)
                  );
}
template <class T1,class T2,class T3,class T4, class Var>
inline
detail::group1< detail::group5<T1,T2,T3,T4, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4, Var& var)
{
   return detail::group1< detail::group5<T1,T2,T3,T4, Var&> >
                   ( detail::group5<T1,T2,T3,T4, Var&>
                        (a1,a2,a3,a4, var)
                  );
}
template <class T1,class T2,class T3,class T4,class T5, class Var>
inline
detail::group1< detail::group6<T1,T2,T3,T4,T5, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5, Var& var)
{
   return detail::group1< detail::group6<T1,T2,T3,T4,T5, Var&> >
                   ( detail::group6<T1,T2,T3,T4,T5, Var&>
                        (a1,a2,a3,a4,a5, var)
                  );
}
template <class T1,class T2,class T3,class T4,class T5,class T6, class Var>
inline
detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6, Var& var)
{
   return detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var&> >
                   ( detail::group7<T1,T2,T3,T4,T5,T6, Var&>
                        (a1,a2,a3,a4,a5,a6, var)
                  );
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7, class Var>
inline
detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7, Var& var)
{
   return detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&> >
                   ( detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&>
                        (a1,a2,a3,a4,a5,a6,a7, var)
                  );
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8, class Var>
inline
detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8, Var& var)
{
   return detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&> >
                   ( detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&>
                        (a1,a2,a3,a4,a5,a6,a7,a8, var)
                  );
}
template <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9, class Var>
inline
detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&> >
  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9, Var& var)
{
   return detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&> >
                   ( detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&>
                        (a1,a2,a3,a4,a5,a6,a7,a8,a9, var)
                  );
}
}
}
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
}
namespace boost {
namespace io {
namespace detail {
    template<class Ch, class Tr, class Alloc>
    void mk_str( std::basic_string<Ch,Tr, Alloc> & res,
                 const Ch * beg,
                 typename std::basic_string<Ch,Tr,Alloc>::size_type size,
                 std::streamsize w,
                 const Ch fill_char,
                 std::ios_base::fmtflags f,
                 const Ch prefix_space,
                 bool center)
    {
        typedef typename std::basic_string<Ch,Tr,Alloc>::size_type size_type;
        res.resize(0);
        if(w<=0 || static_cast<size_type>(w) <=size) {
            res.reserve(size + !!prefix_space);
            if(prefix_space)
              res.append(1, prefix_space);
            if (size)
              res.append(beg, size);
        }
        else {
            std::streamsize n=static_cast<std::streamsize>(w-size-!!prefix_space);
            std::streamsize n_after = 0, n_before = 0;
            res.reserve(static_cast<size_type>(w));
            if(center)
                n_after = n/2, n_before = n - n_after;
            else
                if(f & std::ios_base::left)
                    n_after = n;
                else
                    n_before = n;
            if(n_before) res.append(static_cast<size_type>(n_before), fill_char);
            if(prefix_space)
              res.append(1, prefix_space);
            if (size)
              res.append(beg, size);
            if(n_after) res.append(static_cast<size_type>(n_after), fill_char);
        }
    }
    template< class Ch, class Tr, class T> inline
    void put_head (::std:: basic_ostream<Ch, Tr> &, const T& ) {
    }
    template< class Ch, class Tr, class T> inline
    void put_head( ::std:: basic_ostream<Ch, Tr> & os, const group1<T>& x ) {
        os << group_head(x.a1_);
    }
    template< class Ch, class Tr, class T> inline
    void put_last( ::std:: basic_ostream<Ch, Tr> & os, const T& x ) {
        os << x ;
    }
    template< class Ch, class Tr, class T> inline
    void put_last( ::std:: basic_ostream<Ch, Tr> & os, const group1<T>& x ) {
        os << group_last(x.a1_);
    }
    template< class Ch, class Tr, class T> inline
    void put_head( ::std:: basic_ostream<Ch, Tr> &, T& ) {
    }
    template< class Ch, class Tr, class T> inline
    void put_last( ::std:: basic_ostream<Ch, Tr> & os, T& x) {
        os << x ;
    }
    template< class Ch, class Tr, class Alloc, class T>
    void put( T x,
              const format_item<Ch, Tr, Alloc>& specs,
              typename basic_format<Ch, Tr, Alloc>::string_type& res,
              typename basic_format<Ch, Tr, Alloc>::internal_streambuf_t & buf,
              io::detail::locale_t *loc_p = __null)
    {
        typedef typename basic_format<Ch, Tr, Alloc>::string_type string_type;
        typedef typename basic_format<Ch, Tr, Alloc>::format_item_t format_item_t;
        typedef typename string_type::size_type size_type;
        basic_oaltstringstream<Ch, Tr, Alloc> oss( &buf);
        specs.fmtstate_.apply_on(oss, loc_p);
        put_head( oss, x );
        const std::ios_base::fmtflags fl=oss.flags();
        const bool internal = (fl & std::ios_base::internal) != 0;
        const std::streamsize w = oss.width();
        const bool two_stepped_padding= internal && (w!=0);
        res.resize(0);
        if(! two_stepped_padding) {
            if(w>0)
                oss.width(0);
            put_last( oss, x);
            const Ch * res_beg = buf.pbase();
            Ch prefix_space = 0;
            if(specs.pad_scheme_ & format_item_t::spacepad)
                if(buf.pcount()== 0 ||
                   (res_beg[0] !=oss.widen('+') && res_beg[0] !=oss.widen('-') ))
                    prefix_space = oss.widen(' ');
            size_type res_size = (std::min)(
                static_cast<size_type>(specs.truncate_ - !!prefix_space),
                buf.pcount() );
            mk_str(res, res_beg, res_size, w, oss.fill(), fl,
                   prefix_space, (specs.pad_scheme_ & format_item_t::centered) !=0 );
        }
        else {
            put_last( oss, x);
            const Ch * res_beg = buf.pbase();
            size_type res_size = buf.pcount();
            bool prefix_space=false;
            if(specs.pad_scheme_ & format_item_t::spacepad)
                if(buf.pcount()== 0 ||
                   (res_beg[0] !=oss.widen('+') && res_beg[0] !=oss.widen('-') ))
                    prefix_space = true;
            if(res_size == static_cast<size_type>(w) && w<=specs.truncate_ && !prefix_space) {
                res.assign(res_beg, res_size);
            }
            else {
                res.assign(res_beg, res_size);
                res_beg=__null;
                buf.clear_buffer();
                basic_oaltstringstream<Ch, Tr, Alloc> oss2( &buf);
                specs.fmtstate_.apply_on(oss2, loc_p);
                put_head( oss2, x );
                oss2.width(0);
                if(prefix_space)
                    oss2 << ' ';
                put_last(oss2, x );
                if(buf.pcount()==0 && specs.pad_scheme_ & format_item_t::spacepad) {
                    prefix_space =true;
                    oss2 << ' ';
                }
                const Ch * tmp_beg = buf.pbase();
                size_type tmp_size = (std::min)(static_cast<size_type>(specs.truncate_),
                                                buf.pcount() );
                if(static_cast<size_type>(w) <= tmp_size) {
                        res.assign(tmp_beg, tmp_size);
                }
                else {
                    size_type sz = (std::min)(res_size + (prefix_space ? 1 : 0), tmp_size);
                    size_type i = prefix_space;
                    for(; i<sz && tmp_beg[i] == res[i - (prefix_space ? 1 : 0)]; ++i) {}
                    if(i>=tmp_size) i=prefix_space;
                    res.assign(tmp_beg, i);
                                        std::streamsize d = w - static_cast<std::streamsize>(tmp_size);
                                        (__builtin_expect(!(d>0), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/format/feed_args.hpp", 227, "d>0") : (void)0);
                    res.append(static_cast<size_type>( d ), oss2.fill());
                    res.append(tmp_beg+i, tmp_size-i);
                    (__builtin_expect(!(i+(tmp_size-i)+(std::max)(d,(std::streamsize)0) == static_cast<size_type>(w)), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/format/feed_args.hpp", 231, "i+(tmp_size-i)+(std::max)(d,(std::streamsize)0) == static_cast<size_type>(w)") : (void)0);
                    (__builtin_expect(!(res.size() == static_cast<size_type>(w)), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/format/feed_args.hpp", 232, "res.size() == static_cast<size_type>(w)") : (void)0);
                }
            }
        }
        buf.clear_buffer();
    }
    template< class Ch, class Tr, class Alloc, class T>
    void distribute (basic_format<Ch,Tr, Alloc>& self, T x) {
        if(self.cur_arg_ >= self.num_args_) {
            if( self.exceptions() & too_many_args_bit )
                boost::throw_exception(too_many_args(self.cur_arg_, self.num_args_));
            else return;
        }
        for(unsigned long i=0; i < self.items_.size(); ++i) {
            if(self.items_[i].argN_ == self.cur_arg_) {
                put<Ch, Tr, Alloc, T> (x, self.items_[i], self.items_[i].res_,
                                self.buf_, boost::get_pointer(self.loc_) );
            }
        }
    }
    template<class Ch, class Tr, class Alloc, class T>
    basic_format<Ch, Tr, Alloc>&
    feed (basic_format<Ch,Tr, Alloc>& self, T x) {
        if(self.dumped_) self.clear();
        distribute<Ch, Tr, Alloc, T> (self, x);
        ++self.cur_arg_;
        if(self.bound_.size() != 0) {
                while( self.cur_arg_ < self.num_args_ && self.bound_[self.cur_arg_] )
                    ++self.cur_arg_;
        }
        return self;
    }
}
}
}
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
}
namespace boost {
namespace io {
namespace detail {
    template<class T>
    const T& const_or_not(const T& x) {
        return x;
    }
    template<class Ch, class Facet> inline
    char wrap_narrow(const Facet& fac, Ch c, char deflt) {
        return const_or_not(fac).narrow(c, deflt);
    }
    template<class Ch, class Facet> inline
    bool wrap_isdigit(const Facet& fac, Ch c) {
        return fac.is(std::ctype<Ch>::digit, c);
    }
    template<class Iter, class Facet>
    Iter wrap_scan_notdigit(const Facet & fac, Iter beg, Iter end) {
        using namespace std;
        for( ; beg!=end && wrap_isdigit(fac, *beg); ++beg) ;
        return beg;
    }
    template<class Res, class Iter, class Facet>
    Iter str2int (const Iter & start, const Iter & last, Res & res,
                 const Facet& fac)
    {
        using namespace std;
        Iter it;
        res=0;
        for(it=start; it != last && wrap_isdigit(fac, *it); ++it ) {
            char cur_ch = wrap_narrow(fac, *it, 0);
            res *= 10;
            res += cur_ch - '0';
        }
        return it;
    }
    template<class Iter, class Facet>
    Iter skip_asterisk(Iter start, Iter last, const Facet& fac)
    {
        using namespace std;
        ++ start;
        start = wrap_scan_notdigit(fac, start, last);
        if(start!=last && *start== const_or_not(fac).widen( '$') )
            ++start;
        return start;
    }
    inline void maybe_throw_exception(unsigned char exceptions,
                                      std::size_t pos, std::size_t size)
    {
        if(exceptions & io::bad_format_string_bit)
            boost::throw_exception(io::bad_format_string(pos, size) );
    }
    template<class Ch, class Tr, class Alloc, class Iter, class Facet>
    bool parse_printf_directive(Iter & start, const Iter& last,
                                detail::format_item<Ch, Tr, Alloc> * fpar,
                                const Facet& fac,
                                std::size_t offset, unsigned char exceptions)
    {
        typedef typename basic_format<Ch, Tr, Alloc>::format_item_t format_item_t;
        fpar->argN_ = format_item_t::argN_no_posit;
        bool precision_set = false;
        bool in_brackets=false;
        Iter start0 = start;
        std::size_t fstring_size = last-start0+offset;
        if(start>= last) {
                maybe_throw_exception(exceptions, start-start0 + offset, fstring_size);
                return false;
        }
        if(*start== const_or_not(fac).widen( '|')) {
            in_brackets=true;
            if( ++start >= last ) {
                maybe_throw_exception(exceptions, start-start0 + offset, fstring_size);
                return false;
            }
        }
        if(*start== const_or_not(fac).widen( '0'))
            goto parse_flags;
        if(wrap_isdigit(fac, *start)) {
            int n;
            start = str2int(start, last, n, fac);
            if( start >= last ) {
                maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
                return false;
            }
            if( *start == const_or_not(fac).widen( '%') ) {
                fpar->argN_ = n-1;
                ++start;
                if( in_brackets)
                    maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
                else
                    return true;
            }
            if ( *start== const_or_not(fac).widen( '$') ) {
                fpar->argN_ = n-1;
                ++start;
            }
            else {
                fpar->fmtstate_.width_ = n;
                fpar->argN_ = format_item_t::argN_no_posit;
                goto parse_precision;
            }
        }
      parse_flags:
        while ( start != last) {
            switch ( wrap_narrow(fac, *start, 0)) {
            case '\'' : break;
            case 'l':
            case 'h':
                break;
            case '-':
                fpar->fmtstate_.flags_ |= std::ios_base::left;
                break;
            case '=':
                fpar->pad_scheme_ |= format_item_t::centered;
                break;
            case '_':
                fpar->fmtstate_.flags_ |= std::ios_base::internal;
                break;
            case ' ':
                fpar->pad_scheme_ |= format_item_t::spacepad;
                break;
            case '+':
                fpar->fmtstate_.flags_ |= std::ios_base::showpos;
                break;
            case '0':
                fpar->pad_scheme_ |= format_item_t::zeropad;
                break;
            case '#':
                fpar->fmtstate_.flags_ |= std::ios_base::showpoint | std::ios_base::showbase;
                break;
            default:
                goto parse_width;
            }
            ++start;
        }
        if( start>=last) {
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            return true;
        }
      parse_width:
        if(*start == const_or_not(fac).widen( '*') )
            start = skip_asterisk(start, last, fac);
        if(start!=last && wrap_isdigit(fac, *start))
            start = str2int(start, last, fpar->fmtstate_.width_, fac);
      parse_precision:
        if( start>= last) {
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            return true;
        }
        if (*start== const_or_not(fac).widen( '.')) {
            ++start;
            if(start != last && *start == const_or_not(fac).widen( '*') )
                start = skip_asterisk(start, last, fac);
            if(start != last && wrap_isdigit(fac, *start)) {
                start = str2int(start, last, fpar->fmtstate_.precision_, fac);
                precision_set = true;
            }
            else
                fpar->fmtstate_.precision_ =0;
        }
        while( start != last && ( *start== const_or_not(fac).widen( 'l')
                                  || *start== const_or_not(fac).widen( 'L')
                                  || *start== const_or_not(fac).widen( 'h')) )
            ++start;
        if( start>=last) {
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            return true;
        }
        if( in_brackets && *start== const_or_not(fac).widen( '|') ) {
            ++start;
            return true;
        }
        switch ( wrap_narrow(fac, *start, 0) ) {
        case 'X':
            fpar->fmtstate_.flags_ |= std::ios_base::uppercase;
        case 'p':
        case 'x':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::hex;
            break;
        case 'o':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::oct;
            break;
        case 'E':
            fpar->fmtstate_.flags_ |= std::ios_base::uppercase;
        case 'e':
            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield;
            fpar->fmtstate_.flags_ |= std::ios_base::scientific;
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::dec;
            break;
        case 'f':
            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield;
            fpar->fmtstate_.flags_ |= std::ios_base::fixed;
        case 'u':
        case 'd':
        case 'i':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::dec;
            break;
        case 'T':
            ++start;
            if( start >= last)
                maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
            else
                fpar->fmtstate_.fill_ = *start;
            fpar->pad_scheme_ |= format_item_t::tabulation;
            fpar->argN_ = format_item_t::argN_tabulation;
            break;
        case 't':
            fpar->fmtstate_.fill_ = const_or_not(fac).widen( ' ');
            fpar->pad_scheme_ |= format_item_t::tabulation;
            fpar->argN_ = format_item_t::argN_tabulation;
            break;
        case 'G':
            fpar->fmtstate_.flags_ |= std::ios_base::uppercase;
            break;
        case 'g':
            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;
            fpar->fmtstate_.flags_ |= std::ios_base::dec;
            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield;
            break;
        case 'C':
        case 'c':
            fpar->truncate_ = 1;
            break;
        case 'S':
        case 's':
            if(precision_set)
                fpar->truncate_ = fpar->fmtstate_.precision_;
            fpar->fmtstate_.precision_ = 6;
            break;
        case 'n' :
            fpar->argN_ = format_item_t::argN_ignored;
            break;
        default:
            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
        }
        ++start;
        if( in_brackets ) {
            if( start != last && *start== const_or_not(fac).widen( '|') ) {
                ++start;
                return true;
            }
            else maybe_throw_exception(exceptions, start-start0+offset, fstring_size);
        }
        return true;
    }
    template<class String, class Facet>
    int upper_bound_from_fstring(const String& buf,
                                 const typename String::value_type arg_mark,
                                 const Facet& fac,
                                 unsigned char exceptions)
    {
        using namespace boost::io;
        typename String::size_type i1=0;
        int num_items=0;
        while( (i1=buf.find(arg_mark,i1)) != String::npos ) {
            if( i1+1 >= buf.size() ) {
                if(exceptions & bad_format_string_bit)
                    boost::throw_exception(bad_format_string(i1, buf.size() ));
                else {
                  ++num_items;
                  break;
                }
            }
            if(buf[i1+1] == buf[i1] ) {
                i1+=2; continue;
            }
            ++i1;
            i1 = detail::wrap_scan_notdigit(fac, buf.begin()+i1, buf.end()) - buf.begin();
            if( i1 < buf.size() && buf[i1] == arg_mark )
                ++i1;
            ++num_items;
        }
        return num_items;
    }
    template<class String> inline
    void append_string(String& dst, const String& src,
                       const typename String::size_type beg,
                       const typename String::size_type end) {
        dst.append(src.begin()+beg, src.begin()+end);
    }
}
}
    template<class Ch, class Tr, class Alloc>
    basic_format<Ch, Tr, Alloc>& basic_format<Ch, Tr, Alloc>::
    parse (const string_type& buf) {
        using namespace std;
        const std::ctype<Ch> & fac = std::use_facet< std::ctype<Ch> >(getloc());
        const Ch arg_mark = io::detail::const_or_not(fac).widen( '%');
        bool ordered_args=true;
        int max_argN=-1;
        int num_items = io::detail::upper_bound_from_fstring(buf, arg_mark, fac, exceptions());
        make_or_reuse_data(num_items);
        num_items=0;
        typename string_type::size_type i0=0, i1=0;
        typename string_type::const_iterator it;
        bool special_things=false;
        int cur_item=0;
        while( (i1=buf.find(arg_mark,i1)) != string_type::npos ) {
            string_type & piece = (cur_item==0) ? prefix_ : items_[cur_item-1].appendix_;
            if( buf[i1+1] == buf[i1] ) {
                io::detail::append_string(piece, buf, i0, i1+1);
                i1+=2; i0=i1;
                continue;
            }
            (__builtin_expect(!(static_cast<unsigned int>(cur_item) < items_.size() || cur_item==0), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/format/parsing.hpp", 441, "static_cast<unsigned int>(cur_item) < items_.size() || cur_item==0") : (void)0);
            if(i1!=i0) {
                io::detail::append_string(piece, buf, i0, i1);
                i0=i1;
            }
            ++i1;
            it = buf.begin()+i1;
            bool parse_ok = io::detail::parse_printf_directive(
                it, buf.end(), &items_[cur_item], fac, i1, exceptions());
            i1 = it - buf.begin();
            if( ! parse_ok )
                continue;
            i0=i1;
            items_[cur_item].compute_states();
            int argN=items_[cur_item].argN_;
            if(argN == format_item_t::argN_ignored)
                continue;
            if(argN ==format_item_t::argN_no_posit)
                ordered_args=false;
            else if(argN == format_item_t::argN_tabulation) special_things=true;
            else if(argN > max_argN) max_argN = argN;
            ++num_items;
            ++cur_item;
        }
        (__builtin_expect(!(cur_item == num_items), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/format/parsing.hpp", 467, "cur_item == num_items") : (void)0);
        {
            string_type & piece = (cur_item==0) ? prefix_ : items_[cur_item-1].appendix_;
            io::detail::append_string(piece, buf, i0, buf.size());
        }
        if( !ordered_args) {
            if(max_argN >= 0 ) {
                if(exceptions() & io::bad_format_string_bit)
                    boost::throw_exception(io::bad_format_string(max_argN, 0));
            }
            int non_ordered_items = 0;
            for(int i=0; i< num_items; ++i)
                if(items_[i].argN_ == format_item_t::argN_no_posit) {
                    items_[i].argN_ = non_ordered_items;
                    ++non_ordered_items;
                }
            max_argN = non_ordered_items-1;
        }
        items_.resize(num_items, format_item_t(io::detail::const_or_not(fac).widen( ' ')) );
        if(special_things) style_ |= special_needs;
        num_args_ = max_argN + 1;
        if(ordered_args) style_ |= ordered;
        else style_ &= ~ordered;
        return *this;
    }
}
namespace boost {
    template<class Ch, class Tr, class Alloc> inline
    std::basic_string<Ch, Tr, Alloc> str(const basic_format<Ch, Tr, Alloc>& f) {
        return f.str();
    }
    namespace io {
         using ::boost::str;
    }
        template<class Ch, class Tr, class Alloc>
        std::basic_ostream<Ch, Tr> &
        operator<<( std::basic_ostream<Ch, Tr> & os,
                    const basic_format<Ch, Tr, Alloc>& f)
    {
        typedef boost::basic_format<Ch, Tr, Alloc> format_t;
        if(f.items_.size()==0)
            os << f.prefix_;
        else {
            if(f.cur_arg_ < f.num_args_)
                if( f.exceptions() & io::too_few_args_bit )
                    boost::throw_exception(io::too_few_args(f.cur_arg_, f.num_args_));
            if(f.style_ & format_t::special_needs)
                os << f.str();
            else {
                os << f.prefix_;
                for(unsigned long i=0; i<f.items_.size(); ++i) {
                    const typename format_t::format_item_t& item = f.items_[i];
                    os << item.res_;
                    os << item.appendix_;
                }
            }
        }
        f.dumped_=true;
        return os;
    }
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  struct _Resetiosflags { ios_base::fmtflags _M_mask; };
  inline _Resetiosflags
  resetiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }
  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Resetiosflags __f)
    {
      __is.setf(ios_base::fmtflags(0), __f._M_mask);
      return __is;
    }
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Resetiosflags __f)
    {
      __os.setf(ios_base::fmtflags(0), __f._M_mask);
      return __os;
    }
  struct _Setiosflags { ios_base::fmtflags _M_mask; };
  inline _Setiosflags
  setiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }
  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setiosflags __f)
    {
      __is.setf(__f._M_mask);
      return __is;
    }
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setiosflags __f)
    {
      __os.setf(__f._M_mask);
      return __os;
    }
  struct _Setbase { int _M_base; };
  inline _Setbase
  setbase(int __base)
  { return { __base }; }
  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setbase __f)
    {
      __is.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __is;
    }
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setbase __f)
    {
      __os.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __os;
    }
  template<typename _CharT>
    struct _Setfill { _CharT _M_c; };
  template<typename _CharT>
    inline _Setfill<_CharT>
    setfill(_CharT __c)
    { return { __c }; }
  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setfill<_CharT> __f)
    {
      __is.fill(__f._M_c);
      return __is;
    }
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setfill<_CharT> __f)
    {
      __os.fill(__f._M_c);
      return __os;
    }
  struct _Setprecision { int _M_n; };
  inline _Setprecision
  setprecision(int __n)
  { return { __n }; }
  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setprecision __f)
    {
      __is.precision(__f._M_n);
      return __is;
    }
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setprecision __f)
    {
      __os.precision(__f._M_n);
      return __os;
    }
  struct _Setw { int _M_n; };
  inline _Setw
  setw(int __n)
  { return { __n }; }
  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setw __f)
    {
      __is.width(__f._M_n);
      return __is;
    }
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setw __f)
    {
      __os.width(__f._M_n);
      return __os;
    }
  template<typename _MoneyT>
    struct _Get_money { _MoneyT& _M_mon; bool _M_intl; };
  template<typename _MoneyT>
    inline _Get_money<_MoneyT>
    get_money(_MoneyT& __mon, bool __intl = false)
    { return { __mon, __intl }; }
  template<typename _CharT, typename _Traits, typename _MoneyT>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_money<_MoneyT> __f)
    {
      typedef istreambuf_iterator<_CharT, _Traits> _Iter;
      typedef money_get<_CharT, _Iter> _MoneyGet;
      ios_base::iostate __err = ios_base::goodbit;
      const _MoneyGet& __mg = use_facet<_MoneyGet>(__is.getloc());
      __mg.get(_Iter(__is.rdbuf()), _Iter(), __f._M_intl,
        __is, __err, __f._M_mon);
      if (ios_base::goodbit != __err)
 __is.setstate(__err);
      return __is;
    }
  template<typename _MoneyT>
    struct _Put_money { const _MoneyT& _M_mon; bool _M_intl; };
  template<typename _MoneyT>
    inline _Put_money<_MoneyT>
    put_money(const _MoneyT& __mon, bool __intl = false)
    { return { __mon, __intl }; }
  template<typename _CharT, typename _Traits, typename _MoneyT>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_money<_MoneyT> __f)
    {
      typedef ostreambuf_iterator<_CharT, _Traits> _Iter;
      typedef money_put<_CharT, _Iter> _MoneyPut;
      const _MoneyPut& __mp = use_facet<_MoneyPut>(__os.getloc());
      const _Iter __end = __mp.put(_Iter(__os.rdbuf()), __f._M_intl,
       __os, __os.fill(), __f._M_mon);
      if (__end.failed())
 __os.setstate(ios_base::badbit);
      return __os;
    }
  extern template ostream& operator<<(ostream&, _Setfill<char>);
  extern template ostream& operator<<(ostream&, _Setiosflags);
  extern template ostream& operator<<(ostream&, _Resetiosflags);
  extern template ostream& operator<<(ostream&, _Setbase);
  extern template ostream& operator<<(ostream&, _Setprecision);
  extern template ostream& operator<<(ostream&, _Setw);
  extern template istream& operator>>(istream&, _Setfill<char>);
  extern template istream& operator>>(istream&, _Setiosflags);
  extern template istream& operator>>(istream&, _Resetiosflags);
  extern template istream& operator>>(istream&, _Setbase);
  extern template istream& operator>>(istream&, _Setprecision);
  extern template istream& operator>>(istream&, _Setw);
  extern template wostream& operator<<(wostream&, _Setfill<wchar_t>);
  extern template wostream& operator<<(wostream&, _Setiosflags);
  extern template wostream& operator<<(wostream&, _Resetiosflags);
  extern template wostream& operator<<(wostream&, _Setbase);
  extern template wostream& operator<<(wostream&, _Setprecision);
  extern template wostream& operator<<(wostream&, _Setw);
  extern template wistream& operator>>(wistream&, _Setfill<wchar_t>);
  extern template wistream& operator>>(wistream&, _Setiosflags);
  extern template wistream& operator>>(wistream&, _Resetiosflags);
  extern template wistream& operator>>(wistream&, _Setbase);
  extern template wistream& operator>>(wistream&, _Setprecision);
  extern template wistream& operator>>(wistream&, _Setw);
}
       
       
       
namespace
boost
    {
    namespace
    exception_detail
        {
        class
        error_info_base
            {
            public:
            virtual std::string tag_typeid_name() const = 0;
            virtual std::string value_as_string() const = 0;
            protected:
            ~error_info_base() throw()
                {
                }
            };
        }
    template <class Tag,class T>
    class
    error_info:
        public exception_detail::error_info_base
        {
        public:
        typedef T value_type;
        error_info( value_type const & value );
        ~error_info() throw();
        value_type const &
        value() const
            {
            return value_;
            }
        value_type &
        value()
            {
            return value_;
            }
        private:
        std::string tag_typeid_name() const;
        std::string value_as_string() const;
        value_type value_;
        };
    }
       
       
       
       
#pragma GCC visibility push(default)
namespace __cxxabiv1
{
  extern "C"
  {
  __extension__ typedef int __guard __attribute__((mode (__DI__)));
  typedef void __cxa_vec_ctor_return_type;
  typedef void __cxa_cdtor_return_type;
  }
}
namespace __cxxabiv1
{
  extern "C"
  {
  typedef __cxa_cdtor_return_type (*__cxa_cdtor_type)(void *);
  void*
  __cxa_vec_new(size_t __element_count, size_t __element_size,
  size_t __padding_size, __cxa_cdtor_type constructor,
  __cxa_cdtor_type destructor);
  void*
  __cxa_vec_new2(size_t __element_count, size_t __element_size,
   size_t __padding_size, __cxa_cdtor_type constructor,
   __cxa_cdtor_type destructor, void *(*__alloc) (size_t),
   void (*__dealloc) (void*));
  void*
  __cxa_vec_new3(size_t __element_count, size_t __element_size,
   size_t __padding_size, __cxa_cdtor_type constructor,
   __cxa_cdtor_type destructor, void *(*__alloc) (size_t),
   void (*__dealloc) (void*, size_t));
  __cxa_vec_ctor_return_type
  __cxa_vec_ctor(void* __array_address, size_t __element_count,
   size_t __element_size, __cxa_cdtor_type constructor,
   __cxa_cdtor_type destructor);
  __cxa_vec_ctor_return_type
  __cxa_vec_cctor(void* dest_array, void* src_array, size_t element_count,
    size_t element_size,
    __cxa_cdtor_return_type (*constructor) (void*, void*),
    __cxa_cdtor_type destructor);
  void
  __cxa_vec_dtor(void* __array_address, size_t __element_count,
   size_t __element_size, __cxa_cdtor_type destructor);
  void
  __cxa_vec_cleanup(void* __array_address, size_t __element_count,
      size_t __s, __cxa_cdtor_type destructor) throw();
  void
  __cxa_vec_delete(void* __array_address, size_t __element_size,
     size_t __padding_size, __cxa_cdtor_type destructor);
  void
  __cxa_vec_delete2(void* __array_address, size_t __element_size,
      size_t __padding_size, __cxa_cdtor_type destructor,
      void (*__dealloc) (void*));
  void
  __cxa_vec_delete3(void* __array_address, size_t __element_size,
      size_t __padding_size, __cxa_cdtor_type destructor,
      void (*__dealloc) (void*, size_t));
  int
  __cxa_guard_acquire(__guard*);
  void
  __cxa_guard_release(__guard*) throw();
  void
  __cxa_guard_abort(__guard*) throw();
  void
  __cxa_pure_virtual(void) __attribute__ ((__noreturn__));
  void
  __cxa_bad_cast();
  void
  __cxa_bad_typeid();
  int
  __cxa_atexit(void (*)(void*), void*, void*) throw();
  int
  __cxa_finalize(void*);
  char*
  __cxa_demangle(const char* __mangled_name, char* __output_buffer,
   size_t* __length, int* __status);
  }
}
namespace __cxxabiv1
{
  class __fundamental_type_info : public std::type_info
  {
  public:
    explicit
    __fundamental_type_info(const char* __n) : std::type_info(__n) { }
    virtual
    ~__fundamental_type_info();
  };
  class __array_type_info : public std::type_info
  {
  public:
    explicit
    __array_type_info(const char* __n) : std::type_info(__n) { }
    virtual
    ~__array_type_info();
  };
  class __function_type_info : public std::type_info
  {
  public:
    explicit
    __function_type_info(const char* __n) : std::type_info(__n) { }
    virtual
    ~__function_type_info();
  protected:
    virtual bool
    __is_function_p() const;
  };
  class __enum_type_info : public std::type_info
  {
  public:
    explicit
    __enum_type_info(const char* __n) : std::type_info(__n) { }
    virtual
    ~__enum_type_info();
  };
  class __pbase_type_info : public std::type_info
  {
  public:
    unsigned int __flags;
    const std::type_info* __pointee;
    explicit
    __pbase_type_info(const char* __n, int __quals,
        const std::type_info* __type)
    : std::type_info(__n), __flags(__quals), __pointee(__type)
    { }
    virtual
    ~__pbase_type_info();
    enum __masks
      {
 __const_mask = 0x1,
 __volatile_mask = 0x2,
 __restrict_mask = 0x4,
 __incomplete_mask = 0x8,
 __incomplete_class_mask = 0x10
      };
  protected:
    __pbase_type_info(const __pbase_type_info&);
    __pbase_type_info&
    operator=(const __pbase_type_info&);
    virtual bool
    __do_catch(const std::type_info* __thr_type, void** __thr_obj,
        unsigned int __outer) const;
    inline virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };
  class __pointer_type_info : public __pbase_type_info
  {
  public:
    explicit
    __pointer_type_info(const char* __n, int __quals,
   const std::type_info* __type)
    : __pbase_type_info (__n, __quals, __type) { }
    virtual
    ~__pointer_type_info();
  protected:
    virtual bool
    __is_pointer_p() const;
    virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };
  class __class_type_info;
  class __pointer_to_member_type_info : public __pbase_type_info
  {
  public:
    __class_type_info* __context;
    explicit
    __pointer_to_member_type_info(const char* __n, int __quals,
      const std::type_info* __type,
      __class_type_info* __klass)
    : __pbase_type_info(__n, __quals, __type), __context(__klass) { }
    virtual
    ~__pointer_to_member_type_info();
  protected:
    __pointer_to_member_type_info(const __pointer_to_member_type_info&);
    __pointer_to_member_type_info&
    operator=(const __pointer_to_member_type_info&);
    virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };
  class __base_class_type_info
  {
  public:
    const __class_type_info* __base_type;
    long __offset_flags;
    enum __offset_flags_masks
      {
 __virtual_mask = 0x1,
 __public_mask = 0x2,
 __hwm_bit = 2,
 __offset_shift = 8
      };
    bool
    __is_virtual_p() const
    { return __offset_flags & __virtual_mask; }
    bool
    __is_public_p() const
    { return __offset_flags & __public_mask; }
    ptrdiff_t
    __offset() const
    {
      return static_cast<ptrdiff_t>(__offset_flags) >> __offset_shift;
    }
  };
  class __class_type_info : public std::type_info
  {
  public:
    explicit
    __class_type_info (const char *__n) : type_info(__n) { }
    virtual
    ~__class_type_info ();
    enum __sub_kind
      {
 __unknown = 0,
 __not_contained,
 __contained_ambig,
 __contained_virtual_mask = __base_class_type_info::__virtual_mask,
 __contained_public_mask = __base_class_type_info::__public_mask,
 __contained_mask = 1 << __base_class_type_info::__hwm_bit,
 __contained_private = __contained_mask,
 __contained_public = __contained_mask | __contained_public_mask
      };
    struct __upcast_result;
    struct __dyncast_result;
  protected:
    virtual bool
    __do_upcast(const __class_type_info* __dst_type, void**__obj_ptr) const;
    virtual bool
    __do_catch(const type_info* __thr_type, void** __thr_obj,
        unsigned __outer) const;
  public:
    virtual bool
    __do_upcast(const __class_type_info* __dst, const void* __obj,
  __upcast_result& __result) const;
    inline __sub_kind
    __find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
        const __class_type_info* __src_type,
        const void* __src_ptr) const;
    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;
    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __src_ptr) const;
  };
  class __si_class_type_info : public __class_type_info
  {
  public:
    const __class_type_info* __base_type;
    explicit
    __si_class_type_info(const char *__n, const __class_type_info *__base)
    : __class_type_info(__n), __base_type(__base) { }
    virtual
    ~__si_class_type_info();
  protected:
    __si_class_type_info(const __si_class_type_info&);
    __si_class_type_info&
    operator=(const __si_class_type_info&);
    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;
    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __sub_ptr) const;
    virtual bool
    __do_upcast(const __class_type_info*__dst, const void*__obj,
  __upcast_result& __result) const;
  };
  class __vmi_class_type_info : public __class_type_info
  {
  public:
    unsigned int __flags;
    unsigned int __base_count;
    __base_class_type_info __base_info[1];
    explicit
    __vmi_class_type_info(const char* __n, int ___flags)
    : __class_type_info(__n), __flags(___flags), __base_count(0) { }
    virtual
    ~__vmi_class_type_info();
    enum __flags_masks
      {
 __non_diamond_repeat_mask = 0x1,
 __diamond_shaped_mask = 0x2,
 __flags_unknown_mask = 0x10
      };
  protected:
    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;
    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __src_ptr) const;
    virtual bool
    __do_upcast(const __class_type_info* __dst, const void* __obj,
  __upcast_result& __result) const;
  };
  extern "C" void*
  __dynamic_cast(const void* __src_ptr,
   const __class_type_info* __src_type,
   const __class_type_info* __dst_type,
   ptrdiff_t __src2dst);
  extern "C" std::type_info*
  __cxa_current_exception_type() throw() __attribute__ ((__pure__));
  class __foreign_exception
  {
    virtual ~__foreign_exception() throw();
    virtual void __pure_dummy() = 0;
  };
}
namespace abi = __cxxabiv1;
namespace __gnu_cxx
{
  class recursive_init_error: public std::exception
  {
  public:
    recursive_init_error() throw() { }
    virtual ~recursive_init_error() throw ();
  };
}
#pragma GCC visibility pop
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
}
       
       
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;
    private:
      istream_type* _M_stream;
      _Tp _M_value;
      bool _M_ok;
    public:
      istream_iterator()
      : _M_stream(0), _M_value(), _M_ok(false) {}
      istream_iterator(istream_type& __s)
      : _M_stream(&__s)
      { _M_read(); }
      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }
      const _Tp&
      operator*() const
      {
 ;
 return _M_value;
      }
      const _Tp*
      operator->() const { return &(operator*()); }
      istream_iterator&
      operator++()
      {
 ;
 _M_read();
 return *this;
      }
      istream_iterator
      operator++(int)
      {
 ;
 istream_iterator __tmp = *this;
 _M_read();
 return __tmp;
      }
      bool
      _M_equal(const istream_iterator& __x) const
      { return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream); }
    private:
      void
      _M_read()
      {
 _M_ok = (_M_stream && *_M_stream) ? true : false;
 if (_M_ok)
   {
     *_M_stream >> _M_value;
     _M_ok = *_M_stream ? true : false;
   }
      }
    };
  template<typename _Tp, typename _CharT, typename _Traits, typename _Dist>
    inline bool
    operator==(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return __x._M_equal(__y); }
  template <class _Tp, class _CharT, class _Traits, class _Dist>
    inline bool
    operator!=(const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __x,
        const istream_iterator<_Tp, _CharT, _Traits, _Dist>& __y)
    { return !__x._M_equal(__y); }
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;
    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;
    public:
      ostream_iterator(ostream_type& __s) : _M_stream(&__s), _M_string(0) {}
      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(&__s), _M_string(__c) { }
      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }
      ostream_iterator&
      operator=(const _Tp& __value)
      {
 ;
 *_M_stream << __value;
 if (_M_string) *_M_stream << _M_string;
 return *this;
      }
      ostream_iterator&
      operator*()
      { return *this; }
      ostream_iterator&
      operator++()
      { return *this; }
      ostream_iterator&
      operator++(int)
      { return *this; }
    };
}
namespace boost { namespace detail {
template <class Iterator>
struct iterator_traits
    : std::iterator_traits<Iterator>
{};
using std::distance;
}}
namespace boost {
template <class Iterator>
struct iterator_value
{
    typedef typename boost::detail::iterator_traits<Iterator>::value_type type;
};
template <class Iterator>
struct iterator_reference
{
    typedef typename boost::detail::iterator_traits<Iterator>::reference type;
};
template <class Iterator>
struct iterator_pointer
{
    typedef typename boost::detail::iterator_traits<Iterator>::pointer type;
};
template <class Iterator>
struct iterator_difference
{
    typedef typename boost::detail::iterator_traits<Iterator>::difference_type type;
};
template <class Iterator>
struct iterator_category
{
    typedef typename boost::detail::iterator_traits<Iterator>::iterator_category type;
};
}
       
namespace boost
{
  namespace detail {
   template <class Category, class T, class Distance, class Pointer, class Reference>
   struct iterator_base : std::iterator<Category, T, Distance, Pointer, Reference> {};
  }
  template <class Category, class T, class Distance = std::ptrdiff_t,
            class Pointer = T*, class Reference = T&>
  struct iterator : boost::detail::iterator_base<Category, T, Distance, Pointer, Reference> {};
}
namespace boost { namespace mpl {
namespace aux {
template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct or_impl
    : true_
{
};
template< typename T1, typename T2, typename T3, typename T4 >
struct or_impl< false,T1,T2,T3,T4 >
    : or_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4
        , false_
        >
{
};
template<>
struct or_impl<
          false
        , false_, false_, false_, false_
        >
    : false_
{
};
}
template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = false_, typename T4 = false_, typename T5 = false_
    >
struct or_
    : aux::or_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4, T5
        >
{
   
};
template<> struct or_< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : or_< T1 , T2 > { }; }; template< typename Tag > struct lambda< or_< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef or_< na , na > result_; typedef or_< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< or_< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< or_< na , na > > : int_<-1> { }; }
}}
       
namespace boost {
template< typename T > struct is_array : public ::boost::integral_constant<bool,false> { public: };
template< typename T, std::size_t N > struct is_array< T[N] > : public ::boost::integral_constant<bool,true> { public: };
template< typename T, std::size_t N > struct is_array< T const[N] > : public ::boost::integral_constant<bool,true> { public: };
template< typename T, std::size_t N > struct is_array< T volatile[N] > : public ::boost::integral_constant<bool,true> { public: };
template< typename T, std::size_t N > struct is_array< T const volatile[N] > : public ::boost::integral_constant<bool,true> { public: };
template< typename T > struct is_array< T[] > : public ::boost::integral_constant<bool,true> { public: };
template< typename T > struct is_array< T const[] > : public ::boost::integral_constant<bool,true> { public: };
template< typename T > struct is_array< T volatile[] > : public ::boost::integral_constant<bool,true> { public: };
template< typename T > struct is_array< T const volatile[] > : public ::boost::integral_constant<bool,true> { public: };
}
namespace boost {
namespace detail {
template <typename T>
struct add_reference_rvalue_layer
{
    typedef T& type;
};
template <typename T>
struct add_reference_rvalue_layer<T&&>
{
    typedef T&& type;
};
template <typename T>
struct add_reference_impl
{
    typedef typename add_reference_rvalue_layer<T>::type type;
};
template< typename T > struct add_reference_impl<T&> { public: typedef T& type; };
template<> struct add_reference_impl<void> { public: typedef void type; };
template<> struct add_reference_impl<void const> { public: typedef void const type; };
template<> struct add_reference_impl<void volatile> { public: typedef void volatile type; };
template<> struct add_reference_impl<void const volatile> { public: typedef void const volatile type; };
}
template< typename T > struct add_reference { public: typedef typename boost::detail::add_reference_impl<T>::type type; };
}
namespace boost {
namespace detail{
template <class T>
struct is_abstract_imp
{
   static const bool value = __is_abstract(T);
};
}
template< typename T > struct is_abstract : public ::boost::integral_constant<bool,::boost::detail::is_abstract_imp<T>::value> { public: };
}
namespace boost {
namespace type_traits_detail {
    template <typename T, bool b>
    struct add_rvalue_reference_helper
    { typedef T type; };
    template <typename T>
    struct add_rvalue_reference_helper<T, true>
    {
        typedef T&& type;
    };
    template <typename T>
    struct add_rvalue_reference_imp
    {
       typedef typename boost::type_traits_detail::add_rvalue_reference_helper
                  <T, (!is_void<T>::value && !is_reference<T>::value) >::type type;
    };
}
template< typename T > struct add_rvalue_reference { public: typedef typename boost::type_traits_detail::add_rvalue_reference_imp<T>::type type; };
}
namespace boost {
namespace detail {
struct any_conversion
{
    template <typename T> any_conversion(const volatile T&);
    template <typename T> any_conversion(T&);
};
template <typename T> struct checker
{
    static boost::type_traits::no_type _m_check(any_conversion ...);
    static boost::type_traits::yes_type _m_check(T, int);
};
template <typename From, typename To>
struct is_convertible_basic_impl
{
    static typename add_rvalue_reference<From>::type _m_from;
    static bool const value = sizeof( boost::detail::checker<To>::_m_check(_m_from, 0) )
        == sizeof(::boost::type_traits::yes_type);
};
template <typename From, typename To>
struct is_convertible_impl
{
    typedef typename add_reference<From>::type ref_type;
    static const bool value = (::boost::type_traits::ice_and< ::boost::type_traits::ice_or< ::boost::detail::is_convertible_basic_impl<ref_type,To>::value, ::boost::is_void<To>::value >::value, ::boost::type_traits::ice_not< ::boost::is_array<To>::value >::value >::value);
};
template <bool trivial1, bool trivial2, bool abstract_target>
struct is_convertible_impl_select
{
   template <class From, class To>
   struct rebind
   {
      typedef is_convertible_impl<From, To> type;
   };
};
template <>
struct is_convertible_impl_select<true, true, false>
{
   template <class From, class To>
   struct rebind
   {
      typedef true_type type;
   };
};
template <>
struct is_convertible_impl_select<false, false, true>
{
   template <class From, class To>
   struct rebind
   {
      typedef false_type type;
   };
};
template <>
struct is_convertible_impl_select<true, false, true>
{
   template <class From, class To>
   struct rebind
   {
      typedef false_type type;
   };
};
template <typename From, typename To>
struct is_convertible_impl_dispatch_base
{
   typedef is_convertible_impl_select<
      ::boost::is_arithmetic<From>::value,
      ::boost::is_arithmetic<To>::value,
      ::boost::is_abstract<To>::value
   > selector;
   typedef typename selector::template rebind<From, To> isc_binder;
   typedef typename isc_binder::type type;
};
template <typename From, typename To>
struct is_convertible_impl_dispatch
   : public is_convertible_impl_dispatch_base<From, To>::type
{};
    template<> struct is_convertible_impl< void,void > { public: static const bool value = (true); }; template<> struct is_convertible_impl< void,void const > { public: static const bool value = (true); }; template<> struct is_convertible_impl< void,void volatile > { public: static const bool value = (true); }; template<> struct is_convertible_impl< void,void const volatile > { public: static const bool value = (true); }; template<> struct is_convertible_impl< void const,void > { public: static const bool value = (true); }; template<> struct is_convertible_impl< void const,void const > { public: static const bool value = (true); }; template<> struct is_convertible_impl< void const,void volatile > { public: static const bool value = (true); }; template<> struct is_convertible_impl< void const,void const volatile > { public: static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void > { public: static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void const > { public: static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void volatile > { public: static const bool value = (true); }; template<> struct is_convertible_impl< void volatile,void const volatile > { public: static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void > { public: static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void const > { public: static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void volatile > { public: static const bool value = (true); }; template<> struct is_convertible_impl< void const volatile,void const volatile > { public: static const bool value = (true); };
template< typename To > struct is_convertible_impl< void,To > { public: static const bool value = (false); };
template< typename From > struct is_convertible_impl< From,void > { public: static const bool value = (false); };
template< typename To > struct is_convertible_impl< void const,To > { public: static const bool value = (false); };
template< typename To > struct is_convertible_impl< void volatile,To > { public: static const bool value = (false); };
template< typename To > struct is_convertible_impl< void const volatile,To > { public: static const bool value = (false); };
template< typename From > struct is_convertible_impl< From,void const > { public: static const bool value = (false); };
template< typename From > struct is_convertible_impl< From,void volatile > { public: static const bool value = (false); };
template< typename From > struct is_convertible_impl< From,void const volatile > { public: static const bool value = (false); };
}
template< typename From, typename To > struct is_convertible : public ::boost::integral_constant<bool,(::boost::detail::is_convertible_impl_dispatch<From,To>::value)> { public: };
}
namespace boost
{
  template <typename A, typename B>
  struct is_interoperable
    : mpl::or_<
          is_convertible< A, B >
        , is_convertible< B, A > >
  {
  };
}
namespace boost { namespace mpl {
template<
      typename C = na
    , typename F1 = na
    , typename F2 = na
    >
struct eval_if
{
    typedef typename if_<C,F1,F2>::type f_;
    typedef typename f_::type type;
   
};
template<
      bool C
    , typename F1
    , typename F2
    >
struct eval_if_c
{
    typedef typename if_c<C,F1,F2>::type f_;
    typedef typename f_::type type;
};
template<> struct eval_if< na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 =na , typename T5 =na > struct apply : eval_if< T1 , T2 , T3 > { }; }; template< typename Tag > struct lambda< eval_if< na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef eval_if< na , na , na > result_; typedef eval_if< na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< eval_if< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< eval_if< na , na , na > > : int_<-1> { }; }
}}
namespace boost { namespace mpl {
template<
      typename T = na
    >
struct identity
{
    typedef T type;
   
};
template<
      typename T = na
    >
struct make_identity
{
    typedef identity<T> type;
   
};
template<> struct identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : identity< T1 > { }; }; template< typename Tag > struct lambda< identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef identity< na > result_; typedef identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< identity< T1 > > : int_<1> { }; template<> struct template_arity< identity< na > > : int_<-1> { }; }
template<> struct make_identity< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : make_identity< T1 > { }; }; template< typename Tag > struct lambda< make_identity< na > , Tag , int_<-1> > { typedef false_ is_le; typedef make_identity< na > result_; typedef make_identity< na > type; }; namespace aux { template< typename T1 > struct template_arity< make_identity< T1 > > : int_<1> { }; template<> struct template_arity< make_identity< na > > : int_<-1> { }; }
}}
namespace mpl_ {
template< int N > struct arg;
}
namespace boost { namespace mpl { using ::mpl_::arg; } }
namespace boost { namespace mpl { namespace aux {
typedef char (&no_tag)[1];
typedef char (&yes_tag)[2];
template< bool C_ > struct yes_no_tag
{
    typedef no_tag type;
};
template<> struct yes_no_tag<true>
{
    typedef yes_tag type;
};
template< long n > struct weighted_tag
{
    typedef char (&type)[n];
};
}}}
       
namespace mpl_ {
struct failed {};
template< bool C > struct assert { typedef void* type; };
template<> struct assert<false> { typedef assert type; };
template< bool C >
int assertion_failed( typename assert<C>::type );
template< bool C >
struct assertion
{
    static int failed( assert<false> );
};
template<>
struct assertion<true>
{
    static int failed( void* );
};
struct assert_
{
    template< typename T1, typename T2 = na, typename T3 = na, typename T4 = na > struct types {};
    static assert_ const arg;
    enum relations { equal = 1, not_equal, greater, greater_equal, less, less_equal };
};
boost::mpl::aux::weighted_tag<1>::type operator==( assert_, assert_ );
boost::mpl::aux::weighted_tag<2>::type operator!=( assert_, assert_ );
boost::mpl::aux::weighted_tag<3>::type operator>( assert_, assert_ );
boost::mpl::aux::weighted_tag<4>::type operator>=( assert_, assert_ );
boost::mpl::aux::weighted_tag<5>::type operator<( assert_, assert_ );
boost::mpl::aux::weighted_tag<6>::type operator<=( assert_, assert_ );
template< assert_::relations r, long x, long y > struct assert_relation {};
template< bool > struct assert_arg_pred_impl { typedef int type; };
template<> struct assert_arg_pred_impl<true> { typedef void* type; };
template< typename P > struct assert_arg_pred
{
    typedef typename P::type p_type;
    typedef typename assert_arg_pred_impl< p_type::value >::type type;
};
template< typename P > struct assert_arg_pred_not
{
    typedef typename P::type p_type;
    enum { p = !p_type::value };
    typedef typename assert_arg_pred_impl<p>::type type;
};
template< typename Pred >
failed ************ (Pred::************
      assert_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type )
    );
template< typename Pred >
failed ************ (boost::mpl::not_<Pred>::************
      assert_not_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type )
    );
template< typename Pred >
assert<false>
assert_arg( void (*)(Pred), typename assert_arg_pred_not<Pred>::type );
template< typename Pred >
assert<false>
assert_not_arg( void (*)(Pred), typename assert_arg_pred<Pred>::type );
}
namespace mpl_ {
template<> struct arg< -1 >
{
    static const int value = -1;
   
   
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_27 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};
template<> struct arg<1>
{
    static const int value = 1;
    typedef arg<2> next;
   
   
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U1 type;
        enum { mpl_assertion_in_line_45 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};
template<> struct arg<2>
{
    static const int value = 2;
    typedef arg<3> next;
   
   
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U2 type;
        enum { mpl_assertion_in_line_63 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};
template<> struct arg<3>
{
    static const int value = 3;
    typedef arg<4> next;
   
   
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U3 type;
        enum { mpl_assertion_in_line_81 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};
template<> struct arg<4>
{
    static const int value = 4;
    typedef arg<5> next;
   
   
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U4 type;
        enum { mpl_assertion_in_line_99 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};
template<> struct arg<5>
{
    static const int value = 5;
    typedef arg<6> next;
   
   
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
        typedef U5 type;
        enum { mpl_assertion_in_line_117 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (boost::mpl::is_na<type>))0, 1 ) ) ) };
    };
};

}
namespace mpl_ {
typedef arg< -1 > _;
}
namespace boost { namespace mpl {
using ::mpl_::_;
namespace placeholders {
using mpl_::_;
}
}}
namespace mpl_ {
typedef arg<1> _1;
}
namespace boost { namespace mpl {
using ::mpl_::_1;
namespace placeholders {
using mpl_::_1;
}
}}
namespace mpl_ {
typedef arg<2> _2;
}
namespace boost { namespace mpl {
using ::mpl_::_2;
namespace placeholders {
using mpl_::_2;
}
}}
namespace mpl_ {
typedef arg<3> _3;
}
namespace boost { namespace mpl {
using ::mpl_::_3;
namespace placeholders {
using mpl_::_3;
}
}}
namespace mpl_ {
typedef arg<4> _4;
}
namespace boost { namespace mpl {
using ::mpl_::_4;
namespace placeholders {
using mpl_::_4;
}
}}
namespace mpl_ {
typedef arg<5> _5;
}
namespace boost { namespace mpl {
using ::mpl_::_5;
namespace placeholders {
using mpl_::_5;
}
}}
namespace mpl_ {
typedef arg<6> _6;
}
namespace boost { namespace mpl {
using ::mpl_::_6;
namespace placeholders {
using mpl_::_6;
}
}}
namespace boost {
struct no_traversal_tag {};
struct incrementable_traversal_tag
  : no_traversal_tag
{
};
struct single_pass_traversal_tag
  : incrementable_traversal_tag
{
};
struct forward_traversal_tag
  : single_pass_traversal_tag
{
};
struct bidirectional_traversal_tag
  : forward_traversal_tag
{
};
struct random_access_traversal_tag
  : bidirectional_traversal_tag
{
};
namespace detail
{
  template <class Cat>
  struct old_category_to_traversal
    : mpl::eval_if<
          is_convertible<Cat,std::random_access_iterator_tag>
        , mpl::identity<random_access_traversal_tag>
        , mpl::eval_if<
              is_convertible<Cat,std::bidirectional_iterator_tag>
            , mpl::identity<bidirectional_traversal_tag>
            , mpl::eval_if<
                  is_convertible<Cat,std::forward_iterator_tag>
                , mpl::identity<forward_traversal_tag>
                , mpl::eval_if<
                      is_convertible<Cat,std::input_iterator_tag>
                    , mpl::identity<single_pass_traversal_tag>
                    , mpl::eval_if<
                          is_convertible<Cat,std::output_iterator_tag>
                        , mpl::identity<incrementable_traversal_tag>
                        , void
                      >
                  >
              >
          >
      >
  {};
  template <class Traversal>
  struct pure_traversal_tag
    : mpl::eval_if<
          is_convertible<Traversal,random_access_traversal_tag>
        , mpl::identity<random_access_traversal_tag>
        , mpl::eval_if<
              is_convertible<Traversal,bidirectional_traversal_tag>
            , mpl::identity<bidirectional_traversal_tag>
            , mpl::eval_if<
                  is_convertible<Traversal,forward_traversal_tag>
                , mpl::identity<forward_traversal_tag>
                , mpl::eval_if<
                      is_convertible<Traversal,single_pass_traversal_tag>
                    , mpl::identity<single_pass_traversal_tag>
                    , mpl::eval_if<
                          is_convertible<Traversal,incrementable_traversal_tag>
                        , mpl::identity<incrementable_traversal_tag>
                        , void
                      >
                  >
              >
          >
      >
  {
  };
}
template <class Cat>
struct iterator_category_to_traversal
  : mpl::eval_if<
        is_convertible<Cat,incrementable_traversal_tag>
      , mpl::identity<Cat>
      , boost::detail::old_category_to_traversal<Cat>
    >
{};
template <class Iterator = mpl::_1>
struct iterator_traversal
  : iterator_category_to_traversal<
        typename boost::detail::iterator_traits<Iterator>::iterator_category
    >
{};
}
namespace boost { namespace mpl {
namespace aux {
template< bool C_, typename T1, typename T2, typename T3, typename T4 >
struct and_impl
    : false_
{
};
template< typename T1, typename T2, typename T3, typename T4 >
struct and_impl< true,T1,T2,T3,T4 >
    : and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4
        , true_
        >
{
};
template<>
struct and_impl<
          true
        , true_, true_, true_, true_
        >
    : true_
{
};
}
template<
      typename T1 = na
    , typename T2 = na
    , typename T3 = true_, typename T4 = true_, typename T5 = true_
    >
struct and_
    : aux::and_impl<
          ::boost::mpl::aux::nested_type_wknd<T1>::value
        , T2, T3, T4, T5
        >
{
   
};
template<> struct and_< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : and_< T1 , T2 > { }; }; template< typename Tag > struct lambda< and_< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef and_< na , na > result_; typedef and_< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< and_< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< and_< na , na > > : int_<-1> { }; }
}}
namespace boost {
namespace detail{
template <class T>
struct is_const_rvalue_filter
{
   static const bool value = ::boost::detail::cv_traits_imp<T*>::is_const;
};
template <class T>
struct is_const_rvalue_filter<T&&>
{
   static const bool value = false;
};
}
template< typename T > struct is_const : public ::boost::integral_constant<bool,::boost::detail::is_const_rvalue_filter<T>::value> { public: };
template< typename T > struct is_const< T& > : public ::boost::integral_constant<bool,false> { public: };
}
namespace boost {
namespace type_traits {
struct false_result
{
    template <typename T> struct result_
    {
        static const bool value = false;
    };
};
}}
namespace boost {
namespace type_traits {
template <class R>
struct is_function_ptr_helper
{
    static const bool value = false;
};
template <class R >
struct is_function_ptr_helper<R (*)()> { static const bool value = true; };
template <class R >
struct is_function_ptr_helper<R (*)( ...)> { static const bool value = true; };
template <class R , class T0>
struct is_function_ptr_helper<R (*)( T0)> { static const bool value = true; };
template <class R , class T0>
struct is_function_ptr_helper<R (*)( T0 ...)> { static const bool value = true; };
template <class R , class T0 , class T1>
struct is_function_ptr_helper<R (*)( T0 , T1)> { static const bool value = true; };
template <class R , class T0 , class T1>
struct is_function_ptr_helper<R (*)( T0 , T1 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 ...)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24)> { static const bool value = true; };
template <class R , class T0 , class T1 , class T2 , class T3 , class T4 , class T5 , class T6 , class T7 , class T8 , class T9 , class T10 , class T11 , class T12 , class T13 , class T14 , class T15 , class T16 , class T17 , class T18 , class T19 , class T20 , class T21 , class T22 , class T23 , class T24>
struct is_function_ptr_helper<R (*)( T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 ...)> { static const bool value = true; };
}
}
namespace boost {
namespace detail {
template<bool is_ref = true>
struct is_function_chooser
    : public ::boost::type_traits::false_result
{
};
template <>
struct is_function_chooser<false>
{
    template< typename T > struct result_
        : public ::boost::type_traits::is_function_ptr_helper<T*>
    {
    };
};
template <typename T>
struct is_function_impl
    : public is_function_chooser< ::boost::is_reference<T>::value >
        ::template result_<T>
{
};
}
template< typename T > struct is_function : public ::boost::integral_constant<bool,::boost::detail::is_function_impl<T>::value> { public: };
template< typename T > struct is_function< T&& > : public ::boost::integral_constant<bool,false> { public: };
}
namespace boost {
namespace detail {
template <typename T>
struct is_class_impl
{
    static const bool value = __is_class(T);
};
}
template< typename T > struct is_class : public ::boost::integral_constant<bool,::boost::detail::is_class_impl<T>::value> { public: };
}
namespace boost {
template< typename T > struct remove_pointer { public: typedef T type; };
template< typename T > struct remove_pointer<T*> { public: typedef T type; };
template< typename T > struct remove_pointer<T* const> { public: typedef T type; };
template< typename T > struct remove_pointer<T* volatile> { public: typedef T type; };
template< typename T > struct remove_pointer<T* const volatile> { public: typedef T type; };
}
namespace boost { namespace detail {
namespace indirect_traits {
template <class T>
struct is_reference_to_const : mpl::false_
{
};
template <class T>
struct is_reference_to_const<T const&> : mpl::true_
{
};
template <class T>
struct is_reference_to_function : mpl::false_
{
};
template <class T>
struct is_reference_to_function<T&> : is_function<T>
{
};
template <class T>
struct is_pointer_to_function : mpl::false_
{
};
template <class T>
struct is_pointer_to_function<T*> : is_function<T>
{
};
template <class T>
struct is_reference_to_member_function_pointer_impl : mpl::false_
{
};
template <class T>
struct is_reference_to_member_function_pointer_impl<T&>
    : is_member_function_pointer<typename remove_cv<T>::type>
{
};
template <class T>
struct is_reference_to_member_function_pointer
    : is_reference_to_member_function_pointer_impl<T>
{
   
};
template <class T>
struct is_reference_to_function_pointer_aux
    : mpl::and_<
          is_reference<T>
        , is_pointer_to_function<
              typename remove_cv<
                  typename remove_reference<T>::type
              >::type
          >
      >
{
};
template <class T>
struct is_reference_to_function_pointer
    : mpl::if_<
          is_reference_to_function<T>
        , mpl::false_
        , is_reference_to_function_pointer_aux<T>
     >::type
{
};
template <class T>
struct is_reference_to_non_const
    : mpl::and_<
          is_reference<T>
        , mpl::not_<
             is_reference_to_const<T>
          >
      >
{
};
template <class T>
struct is_reference_to_volatile : mpl::false_
{
};
template <class T>
struct is_reference_to_volatile<T volatile&> : mpl::true_
{
};
template <class T>
struct is_reference_to_pointer : mpl::false_
{
};
template <class T>
struct is_reference_to_pointer<T*&> : mpl::true_
{
};
template <class T>
struct is_reference_to_pointer<T* const&> : mpl::true_
{
};
template <class T>
struct is_reference_to_pointer<T* volatile&> : mpl::true_
{
};
template <class T>
struct is_reference_to_pointer<T* const volatile&> : mpl::true_
{
};
template <class T>
struct is_reference_to_class
    : mpl::and_<
          is_reference<T>
        , is_class<
              typename remove_cv<
                  typename remove_reference<T>::type
              >::type
          >
      >
{
   
};
template <class T>
struct is_pointer_to_class
    : mpl::and_<
          is_pointer<T>
        , is_class<
              typename remove_cv<
                  typename remove_pointer<T>::type
              >::type
          >
      >
{
   
};
}
using namespace indirect_traits;
}}
namespace boost { struct use_default; }
namespace boost { namespace detail {
struct input_output_iterator_tag
  : std::input_iterator_tag
{
    operator std::output_iterator_tag() const
    {
        return std::output_iterator_tag();
    }
};
template <class ValueParam, class Reference>
struct iterator_writability_disabled
  : mpl::or_<
        is_const<Reference>
      , boost::detail::indirect_traits::is_reference_to_const<Reference>
      , is_const<ValueParam>
    >
{};
template <class Traversal, class ValueParam, class Reference>
struct iterator_facade_default_category
  : mpl::eval_if<
        mpl::and_<
            is_reference<Reference>
          , is_convertible<Traversal,forward_traversal_tag>
        >
      , mpl::eval_if<
            is_convertible<Traversal,random_access_traversal_tag>
          , mpl::identity<std::random_access_iterator_tag>
          , mpl::if_<
                is_convertible<Traversal,bidirectional_traversal_tag>
              , std::bidirectional_iterator_tag
              , std::forward_iterator_tag
            >
        >
      , typename mpl::eval_if<
            mpl::and_<
                is_convertible<Traversal, single_pass_traversal_tag>
              , is_convertible<Reference, ValueParam>
            >
          , mpl::identity<std::input_iterator_tag>
          , mpl::identity<Traversal>
        >
    >
{
};
template <class T>
struct is_iterator_category
  : mpl::or_<
        is_convertible<T,std::input_iterator_tag>
      , is_convertible<T,std::output_iterator_tag>
    >
{
};
template <class T>
struct is_iterator_traversal
  : is_convertible<T,incrementable_traversal_tag>
{};
template <class Category, class Traversal>
struct iterator_category_with_traversal
  : Category, Traversal
{
    enum { mpl_assertion_in_line_149 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) ( is_convertible< typename iterator_category_to_traversal<Category>::type , Traversal >))0, 1 ) ) ) };
    enum { mpl_assertion_in_line_151 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_iterator_category<Category>))0, 1 ) ) ) };
    enum { mpl_assertion_in_line_152 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_category<Traversal>))0, 1 ) ) ) };
    enum { mpl_assertion_in_line_153 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_traversal<Category>))0, 1 ) ) ) };
    enum { mpl_assertion_in_line_155 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_iterator_traversal<Traversal>))0, 1 ) ) ) };
};
template <class Traversal, class ValueParam, class Reference>
struct facade_iterator_category_impl
{
    enum { mpl_assertion_in_line_166 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (is_iterator_category<Traversal>))0, 1 ) ) ) };
    typedef typename iterator_facade_default_category<
        Traversal,ValueParam,Reference
    >::type category;
    typedef typename mpl::if_<
        is_same<
            Traversal
          , typename iterator_category_to_traversal<category>::type
        >
      , category
      , iterator_category_with_traversal<category,Traversal>
    >::type type;
};
template <class CategoryOrTraversal, class ValueParam, class Reference>
struct facade_iterator_category
  : mpl::eval_if<
        is_iterator_category<CategoryOrTraversal>
      , mpl::identity<CategoryOrTraversal>
      , facade_iterator_category_impl<CategoryOrTraversal,ValueParam,Reference>
    >
{
};
}}
namespace boost
{
  namespace iterators
  {
    template<bool>
    struct enabled
    {
      template<typename T>
      struct base
      {
        typedef T type;
      };
    };
    template<>
    struct enabled<false>
    {
      template<typename T>
      struct base
      {
      };
    };
    template <class Cond,
              class Return>
    struct enable_if
      : enabled<(Cond::value)>::template base<Return>
    {
    };
  }
}
namespace boost {
template <typename T>
inline T implicit_cast (typename mpl::identity<T>::type x) {
    return x;
}
}
namespace boost {
template< typename T > struct add_const { public: typedef T const type; };
template< typename T > struct add_const<T&> { public: typedef T& type; };
}
namespace boost {
namespace detail {
template <typename T>
struct add_pointer_impl
{
    typedef typename remove_reference<T>::type no_ref_type;
    typedef no_ref_type* type;
};
}
template< typename T > struct add_pointer { public: typedef typename boost::detail::add_pointer_impl<T>::type type; };
}
       
namespace boost {
namespace detail {
template <typename T, bool is_vol>
struct remove_const_helper
{
    typedef T type;
};
template <typename T>
struct remove_const_helper<T, true>
{
    typedef T volatile type;
};
template <typename T>
struct remove_const_impl
{
    typedef typename remove_const_helper<
          typename cv_traits_imp<T*>::unqualified_type
        , ::boost::is_volatile<T>::value
        >::type type;
};
template <typename T>
struct remove_const_impl<T&&>
{
    typedef T&& type;
};
}
template< typename T > struct remove_const { public: typedef typename boost::detail::remove_const_impl<T>::type type; };
template< typename T > struct remove_const<T&> { public: typedef T& type; };
template< typename T, std::size_t N > struct remove_const<T const[N]> { public: typedef T type[N]; };
template< typename T, std::size_t N > struct remove_const<T const volatile[N]> { public: typedef T volatile type[N]; };
}
namespace boost { namespace mpl {
template< typename Value > struct always
{
    template<
          typename T
        , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na
        >
    struct apply
    {
        typedef Value type;
    };
};

}}
namespace boost { namespace mpl {
template<
      typename F, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na
    >
struct apply;
template<
      typename F
    >
struct apply0;
template<
      typename F, typename T1
    >
struct apply1;
template<
      typename F, typename T1, typename T2
    >
struct apply2;
template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply3;
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply4;
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply5;
}}
namespace boost { namespace mpl { namespace aux {
template< typename T > struct type_wrapper
{
    typedef T type;
};
template< typename T > struct wrapped_type;
template< typename T > struct wrapped_type< type_wrapper<T> >
{
    typedef T type;
};
}}}
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_apply { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::apply>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
namespace boost { namespace mpl {
template<
      typename F
    , typename has_apply_ = typename aux::has_apply<F>::type
    >
struct apply_wrap0
    : F::template apply< >
{
};
template< typename F >
struct apply_wrap0< F,true_ >
    : F::apply
{
};
template<
      typename F, typename T1
    >
struct apply_wrap1
    : F::template apply<T1>
{
};
template<
      typename F, typename T1, typename T2
    >
struct apply_wrap2
    : F::template apply< T1,T2 >
{
};
template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply_wrap3
    : F::template apply< T1,T2,T3 >
{
};
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply_wrap4
    : F::template apply< T1,T2,T3,T4 >
{
};
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply_wrap5
    : F::template apply< T1,T2,T3,T4,T5 >
{
};
}}
namespace boost { namespace mpl {
template<
      typename F, typename T1 = na, typename T2 = na, typename T3 = na
    , typename T4 = na, typename T5 = na
    >
struct bind;
template<
      typename F
    >
struct bind0;
template<
      typename F, typename T1
    >
struct bind1;
template<
      typename F, typename T1, typename T2
    >
struct bind2;
template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind3;
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind4;
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind5;
}}
namespace boost { namespace mpl {


template<
      typename T = na
    >
struct next
{
    typedef typename T::next type;
   
};
template<
      typename T = na
    >
struct prior
{
    typedef typename T::prior type;
   
};
template<> struct next< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : next< T1 > { }; }; template< typename Tag > struct lambda< next< na > , Tag , int_<-1> > { typedef false_ is_le; typedef next< na > result_; typedef next< na > type; }; namespace aux { template< typename T1 > struct template_arity< next< T1 > > : int_<1> { }; template<> struct template_arity< next< na > > : int_<-1> { }; }
template<> struct prior< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : prior< T1 > { }; }; template< typename Tag > struct lambda< prior< na > , Tag , int_<-1> > { typedef false_ is_le; typedef prior< na > result_; typedef prior< na > type; }; namespace aux { template< typename T1 > struct template_arity< prior< T1 > > : int_<1> { }; template<> struct template_arity< prior< na > > : int_<-1> { }; }
}}
namespace boost { namespace mpl {
template<
      typename T = na
    , int not_le_ = 0
    >
struct protect : T
{
    typedef protect type;
};
template<> struct protect< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : protect< T1 > { }; };
namespace aux { template< typename T1 > struct template_arity< protect< T1 > > : int_<1> { }; template<> struct template_arity< protect< na > > : int_<-1> { }; }
}}
namespace boost { namespace mpl {
namespace aux {
template<
      typename T, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg
{
    typedef T type;
};
template<
      typename T
    , typename Arg
    >
struct replace_unnamed_arg
{
    typedef Arg next;
    typedef T type;
};
template<
      typename Arg
    >
struct replace_unnamed_arg< arg< -1 >, Arg >
{
    typedef typename Arg::next next;
    typedef Arg type;
};
template<
      int N, typename U1, typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg< arg<N>, U1, U2, U3, U4, U5 >
{
    typedef typename apply_wrap5<mpl::arg<N>, U1, U2, U3, U4, U5>::type type;
};
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg< bind< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5 >
{
    typedef bind< F,T1,T2,T3,T4,T5 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};
}
template<
      typename F
    >
struct bind0
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;
     public:
        typedef typename apply_wrap0<
              f_
            >::type type;
    };
};
namespace aux {
template<
      typename F, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg<
      bind0<F>, U1, U2, U3, U4, U5
    >
{
    typedef bind0<F> f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};
}

namespace aux { template< typename T1 > struct template_arity< bind0< T1> > : int_<1> { }; }
template<
      typename F
    >
struct bind< F,na,na,na,na,na >
    : bind0<F>
{
};
template<
      typename F, typename T1
    >
struct bind1
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;
     public:
        typedef typename apply_wrap1<
              f_
            , typename t1::type
            >::type type;
    };
};
namespace aux {
template<
      typename F, typename T1, typename U1, typename U2, typename U3
    , typename U4, typename U5
    >
struct resolve_bind_arg<
      bind1< F,T1 >, U1, U2, U3, U4, U5
    >
{
    typedef bind1< F,T1 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};
}

namespace aux { template< typename T1 , typename T2 > struct template_arity< bind1< T1 , T2> > : int_<2> { }; }
template<
      typename F, typename T1
    >
struct bind< F,T1,na,na,na,na >
    : bind1< F,T1 >
{
};
template<
      typename F, typename T1, typename T2
    >
struct bind2
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;
        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;
     public:
        typedef typename apply_wrap2<
              f_
            , typename t1::type, typename t2::type
            >::type type;
    };
};
namespace aux {
template<
      typename F, typename T1, typename T2, typename U1, typename U2
    , typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind2< F,T1,T2 >, U1, U2, U3, U4, U5
    >
{
    typedef bind2< F,T1,T2 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};
}

namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< bind2< T1 , T2 , T3> > : int_<3> { }; }
template<
      typename F, typename T1, typename T2
    >
struct bind< F,T1,T2,na,na,na >
    : bind2< F,T1,T2 >
{
};
template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind3
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;
        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;
        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;
     public:
        typedef typename apply_wrap3<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            >::type type;
    };
};
namespace aux {
template<
      typename F, typename T1, typename T2, typename T3, typename U1
    , typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind3< F,T1,T2,T3 >, U1, U2, U3, U4, U5
    >
{
    typedef bind3< F,T1,T2,T3 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};
}

namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 > struct template_arity< bind3< T1 , T2 , T3 , T4> > : int_<4> { }; }
template<
      typename F, typename T1, typename T2, typename T3
    >
struct bind< F,T1,T2,T3,na,na >
    : bind3< F,T1,T2,T3 >
{
};
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind4
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;
        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;
        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;
        typedef aux::replace_unnamed_arg< T4,n4 > r4;
        typedef typename r4::type a4;
        typedef typename r4::next n5;
        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;
     public:
        typedef typename apply_wrap4<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            , typename t4::type
            >::type type;
    };
};
namespace aux {
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename U1, typename U2, typename U3, typename U4, typename U5
    >
struct resolve_bind_arg<
      bind4< F,T1,T2,T3,T4 >, U1, U2, U3, U4, U5
    >
{
    typedef bind4< F,T1,T2,T3,T4 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};
}

namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< bind4< T1 , T2 , T3 , T4 , T5> > : int_<5> { }; }
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct bind< F,T1,T2,T3,T4,na >
    : bind4< F,T1,T2,T3,T4 >
{
};
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind5
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef aux::replace_unnamed_arg< F, mpl::arg<1> > r0;
        typedef typename r0::type a0;
        typedef typename r0::next n1;
        typedef typename aux::resolve_bind_arg< a0,U1,U2,U3,U4,U5 >::type f_;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;
        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;
        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;
        typedef aux::replace_unnamed_arg< T4,n4 > r4;
        typedef typename r4::type a4;
        typedef typename r4::next n5;
        typedef aux::resolve_bind_arg< a4,U1,U2,U3,U4,U5 > t4;
        typedef aux::replace_unnamed_arg< T5,n5 > r5;
        typedef typename r5::type a5;
        typedef typename r5::next n6;
        typedef aux::resolve_bind_arg< a5,U1,U2,U3,U4,U5 > t5;
     public:
        typedef typename apply_wrap5<
              f_
            , typename t1::type, typename t2::type, typename t3::type
            , typename t4::type, typename t5::type
            >::type type;
    };
};
namespace aux {
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename U1, typename U2, typename U3, typename U4
    , typename U5
    >
struct resolve_bind_arg<
      bind5< F,T1,T2,T3,T4,T5 >, U1, U2, U3, U4, U5
    >
{
    typedef bind5< F,T1,T2,T3,T4,T5 > f_;
    typedef typename apply_wrap5< f_,U1,U2,U3,U4,U5 >::type type;
};
}

namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 > struct template_arity< bind5< T1 , T2 , T3 , T4 , T5 , T6> > : int_<6> { }; }
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct bind
    : bind5< F,T1,T2,T3,T4,T5 >
{
};
template< template< typename T1, typename T2, typename T3 > class F, typename Tag >
struct quote3;
template< typename T1, typename T2, typename T3 > struct if_;
template<
      typename Tag, typename T1, typename T2, typename T3
    >
struct bind3<
      quote3< if_,Tag >
    , T1, T2, T3
    >
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef mpl::arg<1> n1;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;
        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;
        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;
        typedef typename if_<
              typename t1::type
            , t2, t3
            >::type f_;
     public:
        typedef typename f_::type type;
    };
};
template<
      template< typename T1, typename T2, typename T3 > class F, typename Tag
    >
struct quote3;
template< typename T1, typename T2, typename T3 > struct eval_if;
template<
      typename Tag, typename T1, typename T2, typename T3
    >
struct bind3<
      quote3< eval_if,Tag >
    , T1, T2, T3
    >
{
    template<
          typename U1 = na, typename U2 = na, typename U3 = na
        , typename U4 = na, typename U5 = na
        >
    struct apply
    {
     private:
        typedef mpl::arg<1> n1;
        typedef aux::replace_unnamed_arg< T1,n1 > r1;
        typedef typename r1::type a1;
        typedef typename r1::next n2;
        typedef aux::resolve_bind_arg< a1,U1,U2,U3,U4,U5 > t1;
        typedef aux::replace_unnamed_arg< T2,n2 > r2;
        typedef typename r2::type a2;
        typedef typename r2::next n3;
        typedef aux::resolve_bind_arg< a2,U1,U2,U3,U4,U5 > t2;
        typedef aux::replace_unnamed_arg< T3,n3 > r3;
        typedef typename r3::type a3;
        typedef typename r3::next n4;
        typedef aux::resolve_bind_arg< a3,U1,U2,U3,U4,U5 > t3;
        typedef typename eval_if<
              typename t1::type
            , t2, t3
            >::type f_;
     public:
        typedef typename f_::type type;
    };
};
}}
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<true> > struct has_type { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::type>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
namespace boost { namespace mpl {
template< typename T, bool has_type_ >
struct quote_impl
{
    typedef typename T::type type;
};
template< typename T >
struct quote_impl< T,false >
{
    typedef T type;
};
template<
      template< typename P1 > class F
    , typename Tag = void_
    >
struct quote1
{
    template< typename U1 > struct apply
        : quote_impl<
              F<U1>
            , aux::has_type< F<U1> >::value
            >
    {
    };
};
template<
      template< typename P1, typename P2 > class F
    , typename Tag = void_
    >
struct quote2
{
    template< typename U1, typename U2 > struct apply
        : quote_impl<
              F< U1,U2 >
            , aux::has_type< F< U1,U2 > >::value
            >
    {
    };
};
template<
      template< typename P1, typename P2, typename P3 > class F
    , typename Tag = void_
    >
struct quote3
{
    template< typename U1, typename U2, typename U3 > struct apply
        : quote_impl<
              F< U1,U2,U3 >
            , aux::has_type< F< U1,U2,U3 > >::value
            >
    {
    };
};
template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename Tag = void_
    >
struct quote4
{
    template<
          typename U1, typename U2, typename U3, typename U4
        >
    struct apply
        : quote_impl<
              F< U1,U2,U3,U4 >
            , aux::has_type< F< U1,U2,U3,U4 > >::value
            >
    {
    };
};
template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename Tag = void_
    >
struct quote5
{
    template<
          typename U1, typename U2, typename U3, typename U4
        , typename U5
        >
    struct apply
        : quote_impl<
              F< U1,U2,U3,U4,U5 >
            , aux::has_type< F< U1,U2,U3,U4,U5 > >::value
            >
    {
    };
};
}}
namespace boost { namespace mpl { namespace aux {
template< int N > struct arity_tag
{
    typedef char (&type)[N + 1];
};
template<
      int C1, int C2, int C3, int C4, int C5, int C6
    >
struct max_arity
{
    static const int value = ( C6 > 0 ? C6 : ( C5 > 0 ? C5 : ( C4 > 0 ? C4 : ( C3 > 0 ? C3 : ( C2 > 0 ? C2 : ( C1 > 0 ? C1 : -1 ) ) ) ) ) );
};
arity_tag<0>::type arity_helper(...);
template<
      template< typename P1 > class F
    , typename T1
    >
typename arity_tag<1>::type
arity_helper(type_wrapper< F<T1> >, arity_tag<1>);
template<
      template< typename P1, typename P2 > class F
    , typename T1, typename T2
    >
typename arity_tag<2>::type
arity_helper(type_wrapper< F< T1,T2 > >, arity_tag<2>);
template<
      template< typename P1, typename P2, typename P3 > class F
    , typename T1, typename T2, typename T3
    >
typename arity_tag<3>::type
arity_helper(type_wrapper< F< T1,T2,T3 > >, arity_tag<3>);
template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename T1, typename T2, typename T3, typename T4
    >
typename arity_tag<4>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4 > >, arity_tag<4>);
template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    >
typename arity_tag<5>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4,T5 > >, arity_tag<5>);
template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5, typename P6
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    , typename T6
    >
typename arity_tag<6>::type
arity_helper(type_wrapper< F< T1,T2,T3,T4,T5,T6 > >, arity_tag<6>);
template< typename F, int N >
struct template_arity_impl
{
    static const int value = sizeof(::boost::mpl::aux::arity_helper(type_wrapper<F>(), arity_tag<N>())) - 1;
};
template< typename F >
struct template_arity
{
    static const int value = ( max_arity< template_arity_impl< F,1 >::value, template_arity_impl< F,2 >::value, template_arity_impl< F,3 >::value, template_arity_impl< F,4 >::value, template_arity_impl< F,5 >::value, template_arity_impl< F,6 >::value >::value );
    typedef mpl::int_<value> type;
};
}}}
namespace boost { namespace mpl {
namespace aux {
template<
      bool C1 = false, bool C2 = false, bool C3 = false, bool C4 = false
    , bool C5 = false
    >
struct lambda_or
    : true_
{
};
template<>
struct lambda_or< false,false,false,false,false >
    : false_
{
};
}
template<
      typename T
    , typename Tag
    , typename Arity
    >
struct lambda
{
    typedef false_ is_le;
    typedef T result_;
    typedef T type;
};
template<
      typename T
    >
struct is_lambda_expression
    : lambda<T>::is_le
{
};
template< int N, typename Tag >
struct lambda< arg<N>,Tag, int_< -1 > >
{
    typedef true_ is_le;
    typedef mpl::arg<N> result_;
    typedef mpl::protect<result_> type;
};
template<
      typename F
    , typename Tag
    >
struct lambda<
          bind0<F>
        , Tag
        , int_<1>
        >
{
    typedef false_ is_le;
    typedef bind0<
          F
        > result_;
    typedef result_ type;
};
namespace aux {
template<
      typename IsLE, typename Tag
    , template< typename P1 > class F
    , typename L1
    >
struct le_result1
{
    typedef F<
          typename L1::type
        > result_;
    typedef result_ type;
};
template<
      typename Tag
    , template< typename P1 > class F
    , typename L1
    >
struct le_result1< true_,Tag,F,L1 >
{
    typedef bind1<
          quote1< F,Tag >
        , typename L1::result_
        > result_;
    typedef mpl::protect<result_> type;
};
}
template<
      template< typename P1 > class F
    , typename T1
    , typename Tag
    >
struct lambda<
          F<T1>
        , Tag
        , int_<1>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef typename l1::is_le is_le1;
    typedef typename aux::lambda_or<
          is_le1::value
        >::type is_le;
    typedef aux::le_result1<
          is_le, Tag, F, l1
        > le_result_;
    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};
template<
      typename F, typename T1
    , typename Tag
    >
struct lambda<
          bind1< F,T1 >
        , Tag
        , int_<2>
        >
{
    typedef false_ is_le;
    typedef bind1<
          F
        , T1
        > result_;
    typedef result_ type;
};
namespace aux {
template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2 > class F
    , typename L1, typename L2
    >
struct le_result2
{
    typedef F<
          typename L1::type, typename L2::type
        > result_;
    typedef result_ type;
};
template<
      typename Tag
    , template< typename P1, typename P2 > class F
    , typename L1, typename L2
    >
struct le_result2< true_,Tag,F,L1,L2 >
{
    typedef bind2<
          quote2< F,Tag >
        , typename L1::result_, typename L2::result_
        > result_;
    typedef mpl::protect<result_> type;
};
}
template<
      template< typename P1, typename P2 > class F
    , typename T1, typename T2
    , typename Tag
    >
struct lambda<
          F< T1,T2 >
        , Tag
        , int_<2>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value
        >::type is_le;
    typedef aux::le_result2<
          is_le, Tag, F, l1, l2
        > le_result_;
    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};
template<
      typename F, typename T1, typename T2
    , typename Tag
    >
struct lambda<
          bind2< F,T1,T2 >
        , Tag
        , int_<3>
        >
{
    typedef false_ is_le;
    typedef bind2<
          F
        , T1, T2
        > result_;
    typedef result_ type;
};
namespace aux {
template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3 > class F
    , typename L1, typename L2, typename L3
    >
struct le_result3
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        > result_;
    typedef result_ type;
};
template<
      typename Tag
    , template< typename P1, typename P2, typename P3 > class F
    , typename L1, typename L2, typename L3
    >
struct le_result3< true_,Tag,F,L1,L2,L3 >
{
    typedef bind3<
          quote3< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        > result_;
    typedef mpl::protect<result_> type;
};
}
template<
      template< typename P1, typename P2, typename P3 > class F
    , typename T1, typename T2, typename T3
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3 >
        , Tag
        , int_<3>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;
    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;
    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value
        >::type is_le;
    typedef aux::le_result3<
          is_le, Tag, F, l1, l2, l3
        > le_result_;
    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};
template<
      typename F, typename T1, typename T2, typename T3
    , typename Tag
    >
struct lambda<
          bind3< F,T1,T2,T3 >
        , Tag
        , int_<4>
        >
{
    typedef false_ is_le;
    typedef bind3<
          F
        , T1, T2, T3
        > result_;
    typedef result_ type;
};
namespace aux {
template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename L1, typename L2, typename L3, typename L4
    >
struct le_result4
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        , typename L4::type
        > result_;
    typedef result_ type;
};
template<
      typename Tag
    , template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename L1, typename L2, typename L3, typename L4
    >
struct le_result4< true_,Tag,F,L1,L2,L3,L4 >
{
    typedef bind4<
          quote4< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        , typename L4::result_
        > result_;
    typedef mpl::protect<result_> type;
};
}
template<
      template< typename P1, typename P2, typename P3, typename P4 > class F
    , typename T1, typename T2, typename T3, typename T4
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3,T4 >
        , Tag
        , int_<4>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;
    typedef lambda< T4,Tag > l4;
    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;
    typedef typename l4::is_le is_le4;
    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value, is_le4::value
        >::type is_le;
    typedef aux::le_result4<
          is_le, Tag, F, l1, l2, l3, l4
        > le_result_;
    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename Tag
    >
struct lambda<
          bind4< F,T1,T2,T3,T4 >
        , Tag
        , int_<5>
        >
{
    typedef false_ is_le;
    typedef bind4<
          F
        , T1, T2, T3, T4
        > result_;
    typedef result_ type;
};
namespace aux {
template<
      typename IsLE, typename Tag
    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
    , typename L1, typename L2, typename L3, typename L4, typename L5
    >
struct le_result5
{
    typedef F<
          typename L1::type, typename L2::type, typename L3::type
        , typename L4::type, typename L5::type
        > result_;
    typedef result_ type;
};
template<
      typename Tag
    , template< typename P1, typename P2, typename P3, typename P4, typename P5 > class F
    , typename L1, typename L2, typename L3, typename L4, typename L5
    >
struct le_result5< true_,Tag,F,L1,L2,L3,L4,L5 >
{
    typedef bind5<
          quote5< F,Tag >
        , typename L1::result_, typename L2::result_, typename L3::result_
        , typename L4::result_, typename L5::result_
        > result_;
    typedef mpl::protect<result_> type;
};
}
template<
      template<
          typename P1, typename P2, typename P3, typename P4
        , typename P5
        >
      class F
    , typename T1, typename T2, typename T3, typename T4, typename T5
    , typename Tag
    >
struct lambda<
          F< T1,T2,T3,T4,T5 >
        , Tag
        , int_<5>
        >
{
    typedef lambda< T1,Tag > l1;
    typedef lambda< T2,Tag > l2;
    typedef lambda< T3,Tag > l3;
    typedef lambda< T4,Tag > l4;
    typedef lambda< T5,Tag > l5;
    typedef typename l1::is_le is_le1;
    typedef typename l2::is_le is_le2;
    typedef typename l3::is_le is_le3;
    typedef typename l4::is_le is_le4;
    typedef typename l5::is_le is_le5;
    typedef typename aux::lambda_or<
          is_le1::value, is_le2::value, is_le3::value, is_le4::value
        , is_le5::value
        >::type is_le;
    typedef aux::le_result5<
          is_le, Tag, F, l1, l2, l3, l4, l5
        > le_result_;
    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    , typename Tag
    >
struct lambda<
          bind5< F,T1,T2,T3,T4,T5 >
        , Tag
        , int_<6>
        >
{
    typedef false_ is_le;
    typedef bind5<
          F
        , T1, T2, T3, T4, T5
        > result_;
    typedef result_ type;
};
template< typename T, typename Tag >
struct lambda< mpl::protect<T>,Tag, int_<1> >
{
    typedef false_ is_le;
    typedef mpl::protect<T> result_;
    typedef result_ type;
};
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    , typename Tag
    >
struct lambda<
          bind< F,T1,T2,T3,T4,T5 >
        , Tag
        , int_<6>
        >
{
    typedef false_ is_le;
    typedef bind< F,T1,T2,T3,T4,T5 > result_;
    typedef result_ type;
};
template<
      typename F
    , typename Tag1
    , typename Tag2
    , typename Arity
    >
struct lambda<
          lambda< F,Tag1,Arity >
        , Tag2
        , int_<3>
        >
{
    typedef lambda< F,Tag2 > l1;
    typedef lambda< Tag1,Tag2 > l2;
    typedef typename l1::is_le is_le;
    typedef bind1< quote1<aux::template_arity>, typename l1::result_ > arity_;
    typedef lambda< typename if_< is_le,arity_,Arity >::type, Tag2 > l3;
    typedef aux::le_result3<is_le, Tag2, mpl::lambda, l1, l2, l3> le_result_;
    typedef typename le_result_::result_ result_;
    typedef typename le_result_::type type;
};
template<> struct lambda< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : lambda< T1 , T2 > { }; }; template< typename Tag > struct lambda< lambda< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef lambda< na , na > result_; typedef lambda< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 > struct template_arity< lambda< T1 , T2 , T3 > > : int_<3> { }; template<> struct template_arity< lambda< na , na > > : int_<-1> { }; }
}}
namespace boost { namespace mpl {
template<
      typename F
    >
struct apply0
    : apply_wrap0<
          typename lambda<F>::type
        >
{
   
};
template<
      typename F
    >
struct apply< F,na,na,na,na,na >
    : apply0<F>
{
};
template<
      typename F, typename T1
    >
struct apply1
    : apply_wrap1<
          typename lambda<F>::type
        , T1
        >
{
   
};
template<
      typename F, typename T1
    >
struct apply< F,T1,na,na,na,na >
    : apply1< F,T1 >
{
};
template<
      typename F, typename T1, typename T2
    >
struct apply2
    : apply_wrap2<
          typename lambda<F>::type
        , T1, T2
        >
{
   
};
template<
      typename F, typename T1, typename T2
    >
struct apply< F,T1,T2,na,na,na >
    : apply2< F,T1,T2 >
{
};
template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply3
    : apply_wrap3<
          typename lambda<F>::type
        , T1, T2, T3
        >
{
   
};
template<
      typename F, typename T1, typename T2, typename T3
    >
struct apply< F,T1,T2,T3,na,na >
    : apply3< F,T1,T2,T3 >
{
};
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply4
    : apply_wrap4<
          typename lambda<F>::type
        , T1, T2, T3, T4
        >
{
   
};
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    >
struct apply< F,T1,T2,T3,T4,na >
    : apply4< F,T1,T2,T3,T4 >
{
};
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply5
    : apply_wrap5<
          typename lambda<F>::type
        , T1, T2, T3, T4, T5
        >
{
   
};
template<
      typename F, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct apply
    : apply5< F,T1,T2,T3,T4,T5 >
{
};
}}
namespace boost
{
  template <class I, class V, class TC, class R, class D> class iterator_facade;
  namespace detail
  {
    struct always_bool2
    {
        template <class T, class U>
        struct apply
        {
            typedef bool type;
        };
    };
    template <
        class Facade1
      , class Facade2
      , class Return
    >
    struct enable_if_interoperable
      : ::boost::iterators::enable_if<
           mpl::or_<
               is_convertible<Facade1, Facade2>
             , is_convertible<Facade2, Facade1>
           >
         , Return
        >
    {};
    template <
        class ValueParam
      , class CategoryOrTraversal
      , class Reference
      , class Difference
    >
    struct iterator_facade_types
    {
        typedef typename facade_iterator_category<
            CategoryOrTraversal, ValueParam, Reference
        >::type iterator_category;
        typedef typename remove_const<ValueParam>::type value_type;
        typedef typename mpl::eval_if<
            boost::detail::iterator_writability_disabled<ValueParam,Reference>
          , add_pointer<const value_type>
          , add_pointer<value_type>
        >::type pointer;
    };
    template <class Iterator>
    class postfix_increment_proxy
    {
        typedef typename iterator_value<Iterator>::type value_type;
     public:
        explicit postfix_increment_proxy(Iterator const& x)
          : stored_value(*x)
        {}
        value_type&
        operator*() const
        {
            return this->stored_value;
        }
     private:
        mutable value_type stored_value;
    };
    template <class Iterator>
    class writable_postfix_increment_proxy
    {
        typedef typename iterator_value<Iterator>::type value_type;
     public:
        explicit writable_postfix_increment_proxy(Iterator const& x)
          : stored_value(*x)
          , stored_iterator(x)
        {}
        writable_postfix_increment_proxy const&
        operator*() const
        {
            return *this;
        }
        operator value_type&() const
        {
            return stored_value;
        }
        template <class T>
        T const& operator=(T const& x) const
        {
            *this->stored_iterator = x;
            return x;
        }
        template <class T>
        T& operator=(T& x) const
        {
            *this->stored_iterator = x;
            return x;
        }
        operator Iterator const&() const
        {
            return stored_iterator;
        }
     private:
        mutable value_type stored_value;
        Iterator stored_iterator;
    };
    template <class Reference, class Value>
    struct is_non_proxy_reference
      : is_convertible<
            typename remove_reference<Reference>::type
            const volatile*
          , Value const volatile*
        >
    {};
    template <class Iterator, class Value, class Reference, class CategoryOrTraversal>
    struct postfix_increment_result
      : mpl::eval_if<
            mpl::and_<
                is_convertible<Reference,Value const&>
              , mpl::not_<
                    is_convertible<
                        typename iterator_category_to_traversal<CategoryOrTraversal>::type
                      , forward_traversal_tag
                    >
                >
            >
          , mpl::if_<
                is_non_proxy_reference<Reference,Value>
              , postfix_increment_proxy<Iterator>
              , writable_postfix_increment_proxy<Iterator>
            >
          , mpl::identity<Iterator>
        >
    {};
    template <class T>
    struct operator_arrow_proxy
    {
        operator_arrow_proxy(T const* px) : m_value(*px) {}
        T* operator->() const { return &m_value; }
        operator T*() const { return &m_value; }
        mutable T m_value;
    };
    template <class ValueType, class Reference, class Pointer>
    struct operator_arrow_result
    {
        typedef typename mpl::if_<
            is_reference<Reference>
          , Pointer
          , operator_arrow_proxy<ValueType>
        >::type type;
        static type make(Reference x)
        {
            return boost::implicit_cast<type>(&x);
        }
    };
    template <class Iterator>
    class operator_brackets_proxy
    {
        typedef typename Iterator::reference reference;
        typedef typename Iterator::value_type value_type;
     public:
        operator_brackets_proxy(Iterator const& iter)
          : m_iter(iter)
        {}
        operator reference() const
        {
            return *m_iter;
        }
        operator_brackets_proxy& operator=(value_type const& val)
        {
            *m_iter = val;
            return *this;
        }
     private:
        Iterator m_iter;
    };
    template <class ValueType, class Reference>
    struct use_operator_brackets_proxy
      : mpl::not_<
            mpl::and_<
                boost::is_POD<ValueType>
              , iterator_writability_disabled<ValueType,Reference>
            >
        >
    {};
    template <class Iterator, class Value, class Reference>
    struct operator_brackets_result
    {
        typedef typename mpl::if_<
            use_operator_brackets_proxy<Value,Reference>
          , operator_brackets_proxy<Iterator>
          , Value
        >::type type;
    };
    template <class Iterator>
    operator_brackets_proxy<Iterator> make_operator_brackets_result(Iterator const& iter, mpl::true_)
    {
        return operator_brackets_proxy<Iterator>(iter);
    }
    template <class Iterator>
    typename Iterator::value_type make_operator_brackets_result(Iterator const& iter, mpl::false_)
    {
      return *iter;
    }
    struct choose_difference_type
    {
        template <class I1, class I2>
        struct apply
          :
          mpl::eval_if<
              is_convertible<I2,I1>
            , iterator_difference<I1>
            , iterator_difference<I2>
          >
        {};
    };
  }
  class iterator_core_access
  {
      template <class I, class V, class TC, class R, class D> friend class iterator_facade;
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator ==( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator !=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator <( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator >( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator <=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator >=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs);
      template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > friend typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::choose_difference_type,Derived1,Derived2>::type >::type operator -( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs)
      ;
      template <class Derived, class V, class TC, class R, class D> friend inline Derived operator+ (iterator_facade<Derived, V, TC, R, D> const& , typename Derived::difference_type)
      ;
      template <class Derived, class V, class TC, class R, class D> friend inline Derived operator+ (typename Derived::difference_type , iterator_facade<Derived, V, TC, R, D> const&)
      ;
      template <class Facade>
      static typename Facade::reference dereference(Facade const& f)
      {
          return f.dereference();
      }
      template <class Facade>
      static void increment(Facade& f)
      {
          f.increment();
      }
      template <class Facade>
      static void decrement(Facade& f)
      {
          f.decrement();
      }
      template <class Facade1, class Facade2>
      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::true_)
      {
          return f1.equal(f2);
      }
      template <class Facade1, class Facade2>
      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::false_)
      {
          return f2.equal(f1);
      }
      template <class Facade>
      static void advance(Facade& f, typename Facade::difference_type n)
      {
          f.advance(n);
      }
      template <class Facade1, class Facade2>
      static typename Facade1::difference_type distance_from(
          Facade1 const& f1, Facade2 const& f2, mpl::true_)
      {
          return -f1.distance_to(f2);
      }
      template <class Facade1, class Facade2>
      static typename Facade2::difference_type distance_from(
          Facade1 const& f1, Facade2 const& f2, mpl::false_)
      {
          return f2.distance_to(f1);
      }
      template <class I, class V, class TC, class R, class D>
      static I& derived(iterator_facade<I,V,TC,R,D>& facade)
      {
          return *static_cast<I*>(&facade);
      }
      template <class I, class V, class TC, class R, class D>
      static I const& derived(iterator_facade<I,V,TC,R,D> const& facade)
      {
          return *static_cast<I const*>(&facade);
      }
   private:
      iterator_core_access();
  };
  template <
      class Derived
    , class Value
    , class CategoryOrTraversal
    , class Reference = Value&
    , class Difference = std::ptrdiff_t
  >
  class iterator_facade
  {
   private:
      Derived& derived()
      {
          return *static_cast<Derived*>(this);
      }
      Derived const& derived() const
      {
          return *static_cast<Derived const*>(this);
      }
      typedef boost::detail::iterator_facade_types<
         Value, CategoryOrTraversal, Reference, Difference
      > associated_types;
      typedef boost::detail::operator_arrow_result<
        typename associated_types::value_type
        , Reference
        , typename associated_types::pointer
      > pointer_;
   protected:
      typedef iterator_facade<Derived,Value,CategoryOrTraversal,Reference,Difference> iterator_facade_;
   public:
      typedef typename associated_types::value_type value_type;
      typedef Reference reference;
      typedef Difference difference_type;
      typedef typename pointer_::type pointer;
      typedef typename associated_types::iterator_category iterator_category;
      reference operator*() const
      {
          return iterator_core_access::dereference(this->derived());
      }
      pointer operator->() const
      {
          return pointer_::make(*this->derived());
      }
      typename boost::detail::operator_brackets_result<Derived,Value,reference>::type
      operator[](difference_type n) const
      {
          typedef boost::detail::use_operator_brackets_proxy<Value,Reference> use_proxy;
          return boost::detail::make_operator_brackets_result<Derived>(
              this->derived() + n
            , use_proxy()
          );
      }
      Derived& operator++()
      {
          iterator_core_access::increment(this->derived());
          return this->derived();
      }
      Derived& operator--()
      {
          iterator_core_access::decrement(this->derived());
          return this->derived();
      }
      Derived operator--(int)
      {
          Derived tmp(this->derived());
          --*this;
          return tmp;
      }
      Derived& operator+=(difference_type n)
      {
          iterator_core_access::advance(this->derived(), n);
          return this->derived();
      }
      Derived& operator-=(difference_type n)
      {
          iterator_core_access::advance(this->derived(), -n);
          return this->derived();
      }
      Derived operator-(difference_type x) const
      {
          Derived result(this->derived());
          return result -= x;
      }
  };
  template <class I, class V, class TC, class R, class D>
  inline typename boost::detail::postfix_increment_result<I,V,R,TC>::type
  operator++(
      iterator_facade<I,V,TC,R,D>& i
    , int
  )
  {
      typename boost::detail::postfix_increment_result<I,V,R,TC>::type
          tmp(*static_cast<I*>(&i));
      ++i;
      return tmp;
  }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator ==( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return iterator_core_access::equal( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator !=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return ! iterator_core_access::equal( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator <( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return 0 > iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator >( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return 0 < iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator <=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return 0 >= iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::always_bool2,Derived1,Derived2>::type >::type operator >=( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return 0 <= iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
  template < class Derived1, class V1, class TC1, class Reference1, class Difference1 , class Derived2, class V2, class TC2, class Reference2, class Difference2 > inline typename boost::detail::enable_if_interoperable< Derived1, Derived2 , typename mpl::apply2<boost::detail::choose_difference_type,Derived1,Derived2>::type >::type operator -( iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs) { static_assert(( is_interoperable< Derived1, Derived2 >::value ), "( is_interoperable< Derived1, Derived2 >::value )"); return iterator_core_access::distance_from( *static_cast<Derived1 const*>(&lhs) , *static_cast<Derived2 const*>(&rhs) , is_convertible<Derived2,Derived1>() ); }
template <class Derived, class V, class TC, class R, class D> inline Derived operator+ ( iterator_facade<Derived, V, TC, R, D> const& i , typename Derived::difference_type n ) { Derived tmp(static_cast<Derived const&>(i)); return tmp += n; }
template <class Derived, class V, class TC, class R, class D> inline Derived operator+ ( typename Derived::difference_type n , iterator_facade<Derived, V, TC, R, D> const& i ) { Derived tmp(static_cast<Derived const&>(i)); return tmp += n; }
}
namespace boost {
    namespace range_detail {
        template< typename T > struct exists { typedef void type; };
    }
}
       
namespace boost
{
    namespace range_detail {
        template< typename C, typename Enable=void > struct extract_iterator {}; template< typename C > struct extract_iterator< C , typename boost::range_detail::exists< typename C::iterator >::type > { typedef typename C::iterator type; };
    }
    template< typename C >
    struct range_mutable_iterator : range_detail::extract_iterator<C>
    {};
    template< typename Iterator >
    struct range_mutable_iterator< std::pair<Iterator,Iterator> >
    {
        typedef Iterator type;
    };
    template< typename T, std::size_t sz >
    struct range_mutable_iterator< T[sz] >
    {
        typedef T* type;
    };
}
       
namespace boost
{
    namespace range_detail {
        template< typename C, typename Enable=void > struct extract_const_iterator {}; template< typename C > struct extract_const_iterator< C , typename boost::range_detail::exists< typename C::const_iterator >::type > { typedef typename C::const_iterator type; };
    }
    template< typename C >
    struct range_const_iterator : range_detail::extract_const_iterator<C>
    {};
    template< typename Iterator >
    struct range_const_iterator< std::pair<Iterator,Iterator> >
    {
        typedef Iterator type;
    };
    template< typename T, std::size_t sz >
    struct range_const_iterator< T[sz] >
    {
        typedef const T* type;
    };
}
namespace boost
{
    template< typename C >
    struct range_iterator
    {
        typedef typename
            mpl::eval_if_c< is_const<C>::value,
                            range_const_iterator< typename remove_const<C>::type >,
                            range_mutable_iterator<C> >::type type;
    };
}
namespace boost
{
namespace range_detail
{
    template< typename C >
    inline typename range_iterator<C>::type
    range_begin( C& c )
    {
        return c.begin();
    }
    template< typename Iterator >
    inline Iterator range_begin( const std::pair<Iterator,Iterator>& p )
    {
        return p.first;
    }
    template< typename Iterator >
    inline Iterator range_begin( std::pair<Iterator,Iterator>& p )
    {
        return p.first;
    }
    template< typename T, std::size_t sz >
    inline const T* range_begin( const T (&a)[sz] )
    {
        return a;
    }
    template< typename T, std::size_t sz >
    inline T* range_begin( T (&a)[sz] )
    {
        return a;
    }
}
namespace range_adl_barrier
{
template< class T >
inline typename range_iterator<T>::type begin( T& r )
{
    using namespace range_detail;
    return range_begin( r );
}
template< class T >
inline typename range_iterator<const T>::type begin( const T& r )
{
    using namespace range_detail;
    return range_begin( r );
}
    }
}
namespace boost
{
    namespace range_adl_barrier
    {
        template< class T >
        inline typename range_iterator<const T>::type
        const_begin( const T& r )
        {
            return boost::range_adl_barrier::begin( r );
        }
    }
    using namespace range_adl_barrier;
}
namespace boost
{
    namespace range_detail
    {
        using type_traits::yes_type;
        using type_traits::no_type;
        yes_type is_string_impl( const char* const );
        yes_type is_string_impl( const wchar_t* const );
        no_type is_string_impl( ... );
        template< std::size_t sz >
        yes_type is_char_array_impl( char (&boost_range_array)[sz] );
        template< std::size_t sz >
        yes_type is_char_array_impl( const char (&boost_range_array)[sz] );
        no_type is_char_array_impl( ... );
        template< std::size_t sz >
        yes_type is_wchar_t_array_impl( wchar_t (&boost_range_array)[sz] );
        template< std::size_t sz >
        yes_type is_wchar_t_array_impl( const wchar_t (&boost_range_array)[sz] );
        no_type is_wchar_t_array_impl( ... );
        yes_type is_char_ptr_impl( char* const );
        no_type is_char_ptr_impl( ... );
        yes_type is_const_char_ptr_impl( const char* const );
        no_type is_const_char_ptr_impl( ... );
        yes_type is_wchar_t_ptr_impl( wchar_t* const );
        no_type is_wchar_t_ptr_impl( ... );
        yes_type is_const_wchar_t_ptr_impl( const wchar_t* const );
        no_type is_const_wchar_t_ptr_impl( ... );
        template< typename Iterator >
        yes_type is_pair_impl( const std::pair<Iterator,Iterator>* );
        no_type is_pair_impl( ... );
        struct char_or_wchar_t_array_tag {};
    }
}
       
namespace boost
{
    namespace range_detail
    {
        typedef mpl::int_<1>::type std_container_;
        typedef mpl::int_<2>::type std_pair_;
        typedef mpl::int_<3>::type const_std_pair_;
        typedef mpl::int_<4>::type array_;
        typedef mpl::int_<5>::type const_array_;
        typedef mpl::int_<6>::type char_array_;
        typedef mpl::int_<7>::type wchar_t_array_;
        typedef mpl::int_<8>::type char_ptr_;
        typedef mpl::int_<9>::type const_char_ptr_;
        typedef mpl::int_<10>::type wchar_t_ptr_;
        typedef mpl::int_<11>::type const_wchar_t_ptr_;
        typedef mpl::int_<12>::type string_;
        template< typename C >
        struct range_helper
        {
            static C* c;
            static C ptr;
            static const bool is_pair_ = sizeof( boost::range_detail::is_pair_impl( c ) ) == sizeof( yes_type );
            static const bool is_char_ptr_ = sizeof( boost::range_detail::is_char_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_const_char_ptr_ = sizeof( boost::range_detail::is_const_char_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_wchar_t_ptr_ = sizeof( boost::range_detail::is_wchar_t_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_const_wchar_t_ptr_ = sizeof( boost::range_detail::is_const_wchar_t_ptr_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_char_array_ = sizeof( boost::range_detail::is_char_array_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_wchar_t_array_ = sizeof( boost::range_detail::is_wchar_t_array_impl( ptr ) ) == sizeof( yes_type );
            static const bool is_string_ = (boost::type_traits::ice_or<is_const_char_ptr_, is_const_wchar_t_ptr_>::value );
            static const bool is_array_ = boost::is_array<C>::value;
        };
        template< typename C >
        class range
        {
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_pair_,
                                                                  boost::range_detail::std_pair_,
                                                                  void >::type pair_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_array_,
                                                                    boost::range_detail::array_,
                                                                    pair_t >::type array_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_string_,
                                                                    boost::range_detail::string_,
                                                                    array_t >::type string_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_const_char_ptr_,
                                                                    boost::range_detail::const_char_ptr_,
                                                                    string_t >::type const_char_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_char_ptr_,
                                                                    boost::range_detail::char_ptr_,
                                                                    const_char_ptr_t >::type char_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_const_wchar_t_ptr_,
                                                                    boost::range_detail::const_wchar_t_ptr_,
                                                                    char_ptr_t >::type const_wchar_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_wchar_t_ptr_,
                                                                    boost::range_detail::wchar_t_ptr_,
                                                                    const_wchar_ptr_t >::type wchar_ptr_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_wchar_t_array_,
                                                                    boost::range_detail::wchar_t_array_,
                                                                    wchar_ptr_t >::type wchar_array_t;
            typedef typename boost::mpl::if_c< ::boost::range_detail::range_helper<C>::is_char_array_,
                                                                    boost::range_detail::char_array_,
                                                                    wchar_array_t >::type char_array_t;
        public:
            typedef typename boost::mpl::if_c< ::boost::is_void<char_array_t>::value,
                                                                    boost::range_detail::std_container_,
                                                                    char_array_t >::type type;
        };
    }
}
       
extern "C" {
void *memchr(const void *, int, size_t);
int memcmp(const void *, const void *, size_t);
void *memcpy(void *, const void *, size_t);
void *memmove(void *, const void *, size_t);
void *memset(void *, int, size_t);
char *strcat(char *, const char *);
char *strchr(const char *, int);
int strcmp(const char *, const char *);
int strcoll(const char *, const char *);
char *strcpy(char *, const char *);
size_t strcspn(const char *, const char *);
char *strerror(int) __asm("_" "strerror" );
size_t strlen(const char *);
char *strncat(char *, const char *, size_t);
int strncmp(const char *, const char *, size_t);
char *strncpy(char *, const char *, size_t);
char *strpbrk(const char *, const char *);
char *strrchr(const char *, int);
size_t strspn(const char *, const char *);
char *strstr(const char *, const char *);
char *strtok(char *, const char *);
size_t strxfrm(char *, const char *, size_t);
}
extern "C" {
char *strtok_r(char *, const char *, char **);
}
extern "C" {
int strerror_r(int, char *, size_t);
char *strdup(const char *);
void *memccpy(void *, const void *, int, size_t);
}
extern "C" {
char *stpcpy(char *, const char *);
char *stpncpy(char *, const char *, size_t) __attribute__((visibility("default")));
char *strndup(const char *, size_t) __attribute__((visibility("default")));
size_t strnlen(const char *, size_t) __attribute__((visibility("default")));
char *strsignal(int sig);
}
extern "C" {
void *memmem(const void *, size_t, const void *, size_t) __attribute__((visibility("default")));
void memset_pattern4(void *, const void *, size_t) __attribute__((visibility("default")));
void memset_pattern8(void *, const void *, size_t) __attribute__((visibility("default")));
void memset_pattern16(void *, const void *, size_t) __attribute__((visibility("default")));
char *strcasestr(const char *, const char *);
char *strnstr(const char *, const char *, size_t);
size_t strlcat(char *, const char *, size_t);
size_t strlcpy(char *, const char *, size_t);
void strmode(int, char *);
char *strsep(char **, const char *);
void swab(const void * , void * , ssize_t);
}
extern "C" {
int bcmp(const void *, const void *, size_t) ;
void bcopy(const void *, void *, size_t) ;
void bzero(void *, size_t) ;
char *index(const char *, int) ;
char *rindex(const char *, int) ;
int ffs(int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);
}
extern "C" {
int ffsl(long) __attribute__((visibility("default")));
int fls(int) __attribute__((visibility("default")));
int flsl(long) __attribute__((visibility("default")));
}
namespace boost
{
    namespace range_detail
    {
        template <typename T>
        inline void boost_range_silence_warning( const T& ) { }
        inline const char* str_end( const char* s, const char* )
        {
            return s + strlen( s );
        }
        inline const wchar_t* str_end( const wchar_t* s, const wchar_t* )
        {
            return s + wcslen( s );
        }
        template< class Char >
        inline Char* str_end( Char* s )
        {
            return const_cast<Char*>( str_end( s, s ) );
        }
        template< class T, std::size_t sz >
        inline T* array_end( T (&boost_range_array)[sz] )
        {
            return boost_range_array + sz;
        }
        template< class T, std::size_t sz >
        inline const T* array_end( const T (&boost_range_array)[sz] )
        {
            return boost_range_array + sz;
        }
        template< class Char >
        inline std::size_t str_size( const Char* const& s )
        {
            return str_end( s ) - s;
        }
        template< class T, std::size_t sz >
        inline std::size_t array_size( T (&boost_range_array)[sz] )
        {
            boost_range_silence_warning( boost_range_array );
            return sz;
        }
        template< class T, std::size_t sz >
        inline std::size_t array_size( const T (&boost_range_array)[sz] )
        {
            boost_range_silence_warning( boost_range_array );
            return sz;
        }
    }
}
namespace boost
{
namespace range_detail
{
        template< typename C >
        inline typename range_iterator<C>::type
        range_end( C& c )
        {
            return c.end();
        }
        template< typename Iterator >
        inline Iterator range_end( const std::pair<Iterator,Iterator>& p )
        {
            return p.second;
        }
        template< typename Iterator >
        inline Iterator range_end( std::pair<Iterator,Iterator>& p )
        {
            return p.second;
        }
        template< typename T, std::size_t sz >
        inline const T* range_end( const T (&a)[sz] )
        {
            return range_detail::array_end<T,sz>( a );
        }
        template< typename T, std::size_t sz >
        inline T* range_end( T (&a)[sz] )
        {
            return range_detail::array_end<T,sz>( a );
        }
}
namespace range_adl_barrier
{
template< class T >
inline typename range_iterator<T>::type end( T& r )
{
    using namespace range_detail;
    return range_end( r );
}
template< class T >
inline typename range_iterator<const T>::type end( const T& r )
{
    using namespace range_detail;
    return range_end( r );
}
    }
}
namespace boost
{
    namespace range_adl_barrier
    {
        template< class T >
        inline typename range_iterator<const T>::type
        const_end( const T& r )
        {
            return boost::range_adl_barrier::end( r );
        }
    }
    using namespace range_adl_barrier;
}
namespace boost
{
    template< class T >
    struct range_difference : iterator_difference< typename range_iterator<T>::type >
    { };
}
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
}
namespace boost
{
    namespace range_detail
    {
        template<class SinglePassRange>
        inline typename range_difference<SinglePassRange>::type
        range_calculate_size(const SinglePassRange& rng)
        {
            (__builtin_expect(!((boost::end(rng) - boost::begin(rng)) >= 0 && "reachability invariant broken!"), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/range/size.hpp", 33, "(boost::end(rng) - boost::begin(rng)) >= 0 && \"reachability invariant broken!\"") : (void)0);
            return boost::end(rng) - boost::begin(rng);
        }
    }
    template<class SinglePassRange>
    inline typename range_difference<SinglePassRange>::type
    size(const SinglePassRange& rng)
    {
        using namespace range_detail;
        return range_calculate_size(rng);
    }
}
namespace boost
{
    template< class T >
    inline typename range_difference<T>::type
    distance( const T& r )
    {
        return std::distance( boost::begin( r ), boost::end( r ) );
    }
}
namespace boost
{
    template< class T >
    inline bool empty( const T& r )
    {
        return boost::begin( r ) == boost::end( r );
    }
}
namespace boost
{
  template <bool B, class T = void>
  struct enable_if_c {
    typedef T type;
  };
  template <class T>
  struct enable_if_c<false, T> {};
  template <class Cond, class T = void>
  struct enable_if : public enable_if_c<Cond::value, T> {};
  template <bool B, class T>
  struct lazy_enable_if_c {
    typedef typename T::type type;
  };
  template <class T>
  struct lazy_enable_if_c<false, T> {};
  template <class Cond, class T>
  struct lazy_enable_if : public lazy_enable_if_c<Cond::value, T> {};
  template <bool B, class T = void>
  struct disable_if_c {
    typedef T type;
  };
  template <class T>
  struct disable_if_c<true, T> {};
  template <class Cond, class T = void>
  struct disable_if : public disable_if_c<Cond::value, T> {};
  template <bool B, class T>
  struct lazy_disable_if_c {
    typedef typename T::type type;
  };
  template <class T>
  struct lazy_disable_if_c<true, T> {};
  template <class Cond, class T>
  struct lazy_disable_if : public lazy_disable_if_c<Cond::value, T> {};
}
namespace boost {
template <class T>
inline T next(T x) { return ++x; }
template <class T, class Distance>
inline T next(T x, Distance n)
{
    std::advance(x, n);
    return x;
}
template <class T>
inline T prior(T x) { return --x; }
template <class T, class Distance>
inline T prior(T x, Distance n)
{
    std::advance(x, -n);
    return x;
}
}
namespace boost {
namespace noncopyable_
{
  class noncopyable
  {
   protected:
      noncopyable() {}
      ~noncopyable() {}
   private:
      noncopyable( const noncopyable& );
      const noncopyable& operator=( const noncopyable& );
  };
}
typedef noncopyable_::noncopyable noncopyable;
}
namespace boost
{
  struct use_default;
  template<class To>
  struct is_convertible<use_default,To>
    : mpl::false_ {};
  namespace detail
  {
    struct enable_type;
  }
  template<typename From, typename To>
  struct enable_if_convertible
    : iterators::enable_if<
          is_convertible<From, To>
        , boost::detail::enable_type
      >
  {};
  namespace detail
  {
    template <class T, class DefaultNullaryFn>
    struct ia_dflt_help
      : mpl::eval_if<
            is_same<T, use_default>
          , DefaultNullaryFn
          , mpl::identity<T>
        >
    {
    };
    template <
        class Derived
      , class Base
      , class Value
      , class Traversal
      , class Reference
      , class Difference
    >
    struct iterator_adaptor_base
    {
        typedef iterator_facade<
            Derived
          , typename boost::detail::ia_dflt_help<
                Value
              , mpl::eval_if<
                    is_same<Reference,use_default>
                  , iterator_value<Base>
                  , remove_reference<Reference>
                >
            >::type
          , typename boost::detail::ia_dflt_help<
                Traversal
              , iterator_traversal<Base>
            >::type
          , typename boost::detail::ia_dflt_help<
                Reference
              , mpl::eval_if<
                    is_same<Value,use_default>
                  , iterator_reference<Base>
                  , add_reference<Value>
                >
            >::type
          , typename boost::detail::ia_dflt_help<
                Difference, iterator_difference<Base>
            >::type
        >
        type;
    };
    template <class Tr1, class Tr2>
    inline void iterator_adaptor_assert_traversal ()
    {
      static_assert((is_convertible<Tr1, Tr2>::value), "(is_convertible<Tr1, Tr2>::value)");
    }
  }
  template <
      class Derived
    , class Base
    , class Value = use_default
    , class Traversal = use_default
    , class Reference = use_default
    , class Difference = use_default
  >
  class iterator_adaptor
    : public boost::detail::iterator_adaptor_base<
        Derived, Base, Value, Traversal, Reference, Difference
      >::type
  {
      friend class iterator_core_access;
   protected:
      typedef typename boost::detail::iterator_adaptor_base<
          Derived, Base, Value, Traversal, Reference, Difference
      >::type super_t;
   public:
      iterator_adaptor() {}
      explicit iterator_adaptor(Base const &iter)
          : m_iterator(iter)
      {
      }
      typedef Base base_type;
      Base const& base() const
        { return m_iterator; }
   protected:
      typedef iterator_adaptor<Derived,Base,Value,Traversal,Reference,Difference> iterator_adaptor_;
      Base const& base_reference() const
        { return m_iterator; }
      Base& base_reference()
        { return m_iterator; }
   private:
      typename super_t::reference dereference() const
        { return *m_iterator; }
      template <
      class OtherDerived, class OtherIterator, class V, class C, class R, class D
      >
      bool equal(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& x) const
      {
          return m_iterator == x.base();
      }
      typedef typename iterator_category_to_traversal<
          typename super_t::iterator_category
      >::type my_traversal;
      void advance(typename super_t::difference_type n)
      {
          boost::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();
          m_iterator += n;
      }
      void increment() { ++m_iterator; }
      void decrement()
      {
          boost::detail::iterator_adaptor_assert_traversal<my_traversal, bidirectional_traversal_tag>();
           --m_iterator;
      }
      template <
          class OtherDerived, class OtherIterator, class V, class C, class R, class D
      >
      typename super_t::difference_type distance_to(
          iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& y) const
      {
          boost::detail::iterator_adaptor_assert_traversal<my_traversal, random_access_traversal_tag>();
          return y.base() - m_iterator;
      }
   private:
      Base m_iterator;
  };
}
namespace boost
{
  template <class Iterator>
  class reverse_iterator
      : public iterator_adaptor< reverse_iterator<Iterator>, Iterator >
  {
      typedef iterator_adaptor< reverse_iterator<Iterator>, Iterator > super_t;
      friend class iterator_core_access;
   public:
      reverse_iterator() {}
      explicit reverse_iterator(Iterator x)
          : super_t(x) {}
      template<class OtherIterator>
      reverse_iterator(
          reverse_iterator<OtherIterator> const& r
          , typename enable_if_convertible<OtherIterator, Iterator>::type* = 0
          )
          : super_t(r.base())
      {}
   private:
      typename super_t::reference dereference() const { return *boost::prior(this->base()); }
      void increment() { --this->base_reference(); }
      void decrement() { ++this->base_reference(); }
      void advance(typename super_t::difference_type n)
      {
          this->base_reference() += -n;
      }
      template <class OtherIterator>
      typename super_t::difference_type
      distance_to(reverse_iterator<OtherIterator> const& y) const
      {
          return this->base_reference() - y.base();
      }
  };
  template <class BidirectionalIterator>
  reverse_iterator<BidirectionalIterator> make_reverse_iterator(BidirectionalIterator x)
  {
      return reverse_iterator<BidirectionalIterator>(x);
  }
}
namespace boost
{
    template< typename C >
    struct range_reverse_iterator
    {
        typedef reverse_iterator<
            typename range_iterator<C>::type > type;
    };
}
namespace boost
{
template< class C >
inline typename range_reverse_iterator<C>::type
rbegin( C& c )
{
    typedef typename range_reverse_iterator<C>::type
        iter_type;
    return iter_type( boost::end( c ) );
}
template< class C >
inline typename range_reverse_iterator<const C>::type
rbegin( const C& c )
{
    typedef typename range_reverse_iterator<const C>::type
        iter_type;
    return iter_type( boost::end( c ) );
}
template< class T >
inline typename range_reverse_iterator<const T>::type
const_rbegin( const T& r )
{
    return boost::rbegin( r );
}
}
namespace boost
{
template< class C >
inline typename range_reverse_iterator<C>::type
rend( C& c )
{
    typedef typename range_reverse_iterator<C>::type
               iter_type;
    return iter_type( boost::begin( c ) );
}
template< class C >
inline typename range_reverse_iterator<const C>::type
rend( const C& c )
{
    typedef typename range_reverse_iterator<const C>::type
        iter_type;
    return iter_type( boost::begin( c ) );
}
template< class T >
inline typename range_reverse_iterator<const T>::type
const_rend( const T& r )
{
    return boost::rend( r );
}
}
namespace boost
{
  namespace concepts {}
}
namespace boost { namespace concepts {
namespace detail
{
  typedef char yes;
  typedef char (&no)[2];
  template <class Model, void (Model::*)()>
  struct wrap_constraints {};
  template <class Model>
  inline yes has_constraints_(Model*, wrap_constraints<Model,&Model::constraints>* = 0);
  inline no has_constraints_(...);
}
template <class Model>
struct not_satisfied
{
    static const bool value = sizeof( detail::has_constraints_((Model*)0) ) == sizeof(detail::yes);
    typedef mpl::bool_<value> type;
};
}}
namespace boost { namespace concepts {
template <class ModelFn>
struct requirement_;
namespace detail
{
  template <void(*)()> struct instantiate {};
}
template <class Model>
struct requirement
{
    static void failed() { ((Model*)0)->~Model(); }
};
struct failed {};
template <class Model>
struct requirement<failed ************ Model::************>
{
    static void failed() { ((Model*)0)->~Model(); }
};
template <class Model>
struct constraint
{
    static void failed() { ((Model*)0)->constraints(); }
};
template <class Model>
struct requirement_<void(*)(Model)>
  : mpl::if_<
        concepts::not_satisfied<Model>
      , constraint<Model>
      , requirement<failed ************ Model::************>
    >::type
{};
}}
namespace boost { namespace concepts {
template <class Model>
struct usage_requirements
{
    ~usage_requirements() { ((Model*)0)->~Model(); }
};
}}
namespace boost
{
  template <class Model>
  inline void function_requires(Model* = 0)
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Model)>::failed> boost_concept_check45;
  }
  template <class T> inline void ignore_unused_variable_warning(T const&) {}
  template < typename T > struct Integer; template < typename T > struct IntegerConcept : Integer< T > { }; template < typename T > struct Integer
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Integer>)>::failed> boost_concept_check67; ~Integer()
        {
            x.error_type_must_be_an_integer_type();
        }
   private:
      T x;
  };
  template <> struct Integer<char> {};
  template <> struct Integer<signed char> {};
  template <> struct Integer<unsigned char> {};
  template <> struct Integer<short> {};
  template <> struct Integer<unsigned short> {};
  template <> struct Integer<int> {};
  template <> struct Integer<unsigned int> {};
  template <> struct Integer<long> {};
  template <> struct Integer<unsigned long> {};
  template <> struct Integer< ::boost::long_long_type> {};
  template <> struct Integer< ::boost::ulong_long_type> {};
  template < typename T > struct SignedInteger; template < typename T > struct SignedIntegerConcept : SignedInteger< T > { }; template < typename T > struct SignedInteger {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SignedInteger>)>::failed> boost_concept_check93; ~SignedInteger() {
      x.error_type_must_be_a_signed_integer_type();
    }
   private:
    T x;
  };
  template <> struct SignedInteger<signed char> { };
  template <> struct SignedInteger<short> {};
  template <> struct SignedInteger<int> {};
  template <> struct SignedInteger<long> {};
  template <> struct SignedInteger< ::boost::long_long_type> {};
  template < typename T > struct UnsignedInteger; template < typename T > struct UnsignedIntegerConcept : UnsignedInteger< T > { }; template < typename T > struct UnsignedInteger {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnsignedInteger>)>::failed> boost_concept_check110; ~UnsignedInteger() {
      x.error_type_must_be_an_unsigned_integer_type();
    }
   private:
    T x;
  };
  template <> struct UnsignedInteger<unsigned char> {};
  template <> struct UnsignedInteger<unsigned short> {};
  template <> struct UnsignedInteger<unsigned int> {};
  template <> struct UnsignedInteger<unsigned long> {};
  template <> struct UnsignedInteger< ::boost::ulong_long_type> {};
  template < typename TT > struct DefaultConstructible; template < typename TT > struct DefaultConstructibleConcept : DefaultConstructible< TT > { }; template < typename TT > struct DefaultConstructible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<DefaultConstructible>)>::failed> boost_concept_check132; ~DefaultConstructible() {
      TT a;
      ignore_unused_variable_warning(a);
    }
  };
  template < typename TT > struct Assignable; template < typename TT > struct AssignableConcept : Assignable< TT > { }; template < typename TT > struct Assignable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Assignable>)>::failed> boost_concept_check140; ~Assignable() {
      a = b;
      const_constraints(b);
    }
   private:
    void const_constraints(const TT& x) {
      a = x;
    }
   private:
    TT a;
    TT b;
  };
  template < typename TT > struct CopyConstructible; template < typename TT > struct CopyConstructibleConcept : CopyConstructible< TT > { }; template < typename TT > struct CopyConstructible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<CopyConstructible>)>::failed> boost_concept_check162; ~CopyConstructible() {
      TT a(b);
      TT* ptr = &a;
      const_constraints(a);
      ignore_unused_variable_warning(ptr);
    }
   private:
    void const_constraints(const TT& a) {
      TT c(a);
      const TT* ptr = &a;
      ignore_unused_variable_warning(c);
      ignore_unused_variable_warning(ptr);
    }
    TT b;
  };
  template < typename TT > struct SGIAssignable; template < typename TT > struct SGIAssignableConcept : SGIAssignable< TT > { }; template < typename TT > struct SGIAssignable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SGIAssignable>)>::failed> boost_concept_check186; ~SGIAssignable() {
      TT c(a);
      a = b;
      const_constraints(b);
      ignore_unused_variable_warning(c);
    }
   private:
    void const_constraints(const TT& x) {
      TT c(x);
      a = x;
      ignore_unused_variable_warning(c);
    }
    TT a;
    TT b;
  };
  template < typename X , typename Y > struct Convertible; template < typename X , typename Y > struct ConvertibleConcept : Convertible< X, Y > { }; template < typename X , typename Y > struct Convertible
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Convertible>)>::failed> boost_concept_check211; ~Convertible() {
      Y y = x;
      ignore_unused_variable_warning(y);
    }
   private:
    X x;
  };
  template <class TT>
  void require_boolean_expr(const TT& t) {
    bool x = t;
    ignore_unused_variable_warning(x);
  }
  template < typename TT > struct EqualityComparable; template < typename TT > struct EqualityComparableConcept : EqualityComparable< TT > { }; template < typename TT > struct EqualityComparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<EqualityComparable>)>::failed> boost_concept_check236; ~EqualityComparable() {
      require_boolean_expr(a == b);
      require_boolean_expr(a != b);
    }
   private:
    TT a, b;
  };
  template < typename TT > struct LessThanComparable; template < typename TT > struct LessThanComparableConcept : LessThanComparable< TT > { }; template < typename TT > struct LessThanComparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessThanComparable>)>::failed> boost_concept_check246; ~LessThanComparable() {
      require_boolean_expr(a < b);
    }
   private:
    TT a, b;
  };
  template < typename TT > struct Comparable; template < typename TT > struct ComparableConcept : Comparable< TT > { }; template < typename TT > struct Comparable
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Comparable>)>::failed> boost_concept_check256; ~Comparable() {
      require_boolean_expr(a < b);
      require_boolean_expr(a > b);
      require_boolean_expr(a <= b);
      require_boolean_expr(a >= b);
    }
   private:
    TT a, b;
  };
  template < typename First , typename Second > struct EqualOp; template < typename First , typename Second > struct EqualOpConcept : EqualOp< First, Second > { }; template < typename First , typename Second > struct EqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<EqualOp>)>::failed> boost_concept_check286; ~EqualOp() { (void)constraints_(); } private: bool constraints_() { return a == b; } First a; Second b; };
  template < typename First , typename Second > struct NotEqualOp; template < typename First , typename Second > struct NotEqualOpConcept : NotEqualOp< First, Second > { }; template < typename First , typename Second > struct NotEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<NotEqualOp>)>::failed> boost_concept_check287; ~NotEqualOp() { (void)constraints_(); } private: bool constraints_() { return a != b; } First a; Second b; };
  template < typename First , typename Second > struct LessThanOp; template < typename First , typename Second > struct LessThanOpConcept : LessThanOp< First, Second > { }; template < typename First , typename Second > struct LessThanOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessThanOp>)>::failed> boost_concept_check288; ~LessThanOp() { (void)constraints_(); } private: bool constraints_() { return a < b; } First a; Second b; };
  template < typename First , typename Second > struct LessEqualOp; template < typename First , typename Second > struct LessEqualOpConcept : LessEqualOp< First, Second > { }; template < typename First , typename Second > struct LessEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LessEqualOp>)>::failed> boost_concept_check289; ~LessEqualOp() { (void)constraints_(); } private: bool constraints_() { return a <= b; } First a; Second b; };
  template < typename First , typename Second > struct GreaterThanOp; template < typename First , typename Second > struct GreaterThanOpConcept : GreaterThanOp< First, Second > { }; template < typename First , typename Second > struct GreaterThanOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<GreaterThanOp>)>::failed> boost_concept_check290; ~GreaterThanOp() { (void)constraints_(); } private: bool constraints_() { return a > b; } First a; Second b; };
  template < typename First , typename Second > struct GreaterEqualOp; template < typename First , typename Second > struct GreaterEqualOpConcept : GreaterEqualOp< First, Second > { }; template < typename First , typename Second > struct GreaterEqualOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<GreaterEqualOp>)>::failed> boost_concept_check291; ~GreaterEqualOp() { (void)constraints_(); } private: bool constraints_() { return a >= b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct PlusOp; template < typename Ret , typename First , typename Second > struct PlusOpConcept : PlusOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct PlusOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<PlusOp>)>::failed> boost_concept_check293; ~PlusOp() { (void)constraints_(); } private: Ret constraints_() { return a + b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct TimesOp; template < typename Ret , typename First , typename Second > struct TimesOpConcept : TimesOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct TimesOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<TimesOp>)>::failed> boost_concept_check294; ~TimesOp() { (void)constraints_(); } private: Ret constraints_() { return a * b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct DivideOp; template < typename Ret , typename First , typename Second > struct DivideOpConcept : DivideOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct DivideOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<DivideOp>)>::failed> boost_concept_check295; ~DivideOp() { (void)constraints_(); } private: Ret constraints_() { return a / b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct SubtractOp; template < typename Ret , typename First , typename Second > struct SubtractOpConcept : SubtractOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct SubtractOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SubtractOp>)>::failed> boost_concept_check296; ~SubtractOp() { (void)constraints_(); } private: Ret constraints_() { return a - b; } First a; Second b; };
  template < typename Ret , typename First , typename Second > struct ModOp; template < typename Ret , typename First , typename Second > struct ModOpConcept : ModOp< Ret, First, Second > { }; template < typename Ret , typename First , typename Second > struct ModOp { typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ModOp>)>::failed> boost_concept_check297; ~ModOp() { (void)constraints_(); } private: Ret constraints_() { return a % b; } First a; Second b; };
  template < typename Func , typename Return > struct Generator; template < typename Func , typename Return > struct GeneratorConcept : Generator< Func, Return > { }; template < typename Func , typename Return > struct Generator
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Generator>)>::failed> boost_concept_check304; ~Generator() { test(is_void<Return>()); }
   private:
      void test(boost::mpl::false_)
      {
          const Return& r = f();
          ignore_unused_variable_warning(r);
      }
      void test(boost::mpl::true_)
      {
          f();
      }
      Func f;
  };
  template < typename Func , typename Return , typename Arg > struct UnaryFunction; template < typename Func , typename Return , typename Arg > struct UnaryFunctionConcept : UnaryFunction< Func, Return, Arg > { }; template < typename Func , typename Return , typename Arg > struct UnaryFunction
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnaryFunction>)>::failed> boost_concept_check324; ~UnaryFunction() { test(is_void<Return>()); }
   private:
      void test(boost::mpl::false_)
      {
          f(arg);
          Return r = f(arg);
          ignore_unused_variable_warning(r);
      }
      void test(boost::mpl::true_)
      {
          f(arg);
      }
      UnaryFunction();
      Func f;
      Arg arg;
  };
  template < typename Func , typename Return , typename First , typename Second > struct BinaryFunction; template < typename Func , typename Return , typename First , typename Second > struct BinaryFunctionConcept : BinaryFunction< Func, Return, First, Second > { }; template < typename Func , typename Return , typename First , typename Second > struct BinaryFunction
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BinaryFunction>)>::failed> boost_concept_check354; ~BinaryFunction() { test(is_void<Return>()); }
   private:
      void test(boost::mpl::false_)
      {
          f(first,second);
          Return r = f(first, second);
          (void)r;
      }
      void test(boost::mpl::true_)
      {
          f(first,second);
      }
      BinaryFunction();
      Func f;
      First first;
      Second second;
  };
  template < typename Func , typename Arg > struct UnaryPredicate; template < typename Func , typename Arg > struct UnaryPredicateConcept : UnaryPredicate< Func, Arg > { }; template < typename Func , typename Arg > struct UnaryPredicate
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UnaryPredicate>)>::failed> boost_concept_check384; ~UnaryPredicate() {
      require_boolean_expr(f(arg));
    }
   private:
      UnaryPredicate();
    Func f;
    Arg arg;
  };
  template < typename Func , typename First , typename Second > struct BinaryPredicate; template < typename Func , typename First , typename Second > struct BinaryPredicateConcept : BinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct BinaryPredicate
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BinaryPredicate>)>::failed> boost_concept_check403; ~BinaryPredicate() {
      require_boolean_expr(f(a, b));
    }
   private:
      BinaryPredicate();
    Func f;
    First a;
    Second b;
  };
  template < typename Func , typename First , typename Second > struct Const_BinaryPredicate; template < typename Func , typename First , typename Second > struct Const_BinaryPredicateConcept : Const_BinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct Const_BinaryPredicate
    : BinaryPredicate<Func, First, Second>
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Const_BinaryPredicate>)>::failed> boost_concept_check424; ~Const_BinaryPredicate() {
      const_constraints(f);
    }
   private:
    void const_constraints(const Func& fun) {
      require_boolean_expr(fun(a, b));
    }
      Const_BinaryPredicate();
    Func f;
    First a;
    Second b;
  };
  template < typename Func , typename Return > struct AdaptableGenerator; template < typename Func , typename Return > struct AdaptableGeneratorConcept : AdaptableGenerator< Func, Return > { }; template < typename Func , typename Return > struct AdaptableGenerator
    : Generator<Func, typename Func::result_type>
  {
      typedef typename Func::result_type result_type;
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<AdaptableGenerator>)>::failed> boost_concept_check451; ~AdaptableGenerator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check453;
      }
  };
  template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunction; template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunctionConcept : AdaptableUnaryFunction< Func, Return, Arg > { }; template < typename Func , typename Return , typename Arg > struct AdaptableUnaryFunction
    : UnaryFunction<Func, typename Func::result_type, typename Func::argument_type>
  {
      typedef typename Func::argument_type argument_type;
      typedef typename Func::result_type result_type;
      ~AdaptableUnaryFunction()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check465;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<Arg, argument_type>)>::failed> boost_concept_check466;
      }
  };
  template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunction; template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunctionConcept : AdaptableBinaryFunction< Func, Return, First, Second > { }; template < typename Func , typename Return , typename First , typename Second > struct AdaptableBinaryFunction
    : BinaryFunction<
          Func
        , typename Func::result_type
        , typename Func::first_argument_type
        , typename Func::second_argument_type
      >
  {
      typedef typename Func::first_argument_type first_argument_type;
      typedef typename Func::second_argument_type second_argument_type;
      typedef typename Func::result_type result_type;
      ~AdaptableBinaryFunction()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<result_type, Return>)>::failed> boost_concept_check484;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<First, first_argument_type>)>::failed> boost_concept_check485;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<Second, second_argument_type>)>::failed> boost_concept_check486;
      }
  };
  template < typename Func , typename Arg > struct AdaptablePredicate; template < typename Func , typename Arg > struct AdaptablePredicateConcept : AdaptablePredicate< Func, Arg > { }; template < typename Func , typename Arg > struct AdaptablePredicate
    : UnaryPredicate<Func, Arg>
    , AdaptableUnaryFunction<Func, bool, Arg>
  {
  };
  template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicate; template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicateConcept : AdaptableBinaryPredicate< Func, First, Second > { }; template < typename Func , typename First , typename Second > struct AdaptableBinaryPredicate
    : BinaryPredicate<Func, First, Second>
    , AdaptableBinaryFunction<Func, bool, First, Second>
  {
  };
  template < typename TT > struct InputIterator; template < typename TT > struct InputIteratorConcept : InputIterator< TT > { }; template < typename TT > struct InputIterator
    : Assignable<TT>
    , EqualityComparable<TT>
  {
      typedef typename boost::detail::iterator_traits<TT>::value_type value_type;
      typedef typename boost::detail::iterator_traits<TT>::difference_type difference_type;
      typedef typename boost::detail::iterator_traits<TT>::reference reference;
      typedef typename boost::detail::iterator_traits<TT>::pointer pointer;
      typedef typename boost::detail::iterator_traits<TT>::iterator_category iterator_category;
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<InputIterator>)>::failed> boost_concept_check515; ~InputIterator()
      {
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(SignedInteger<difference_type>)>::failed> boost_concept_check517;
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible<iterator_category, std::input_iterator_tag>)>::failed> boost_concept_check518;
        TT j(i);
        (void)*i;
        ++j;
        i++;
      }
   private:
    TT i;
  };
  template < typename TT , typename ValueT > struct OutputIterator; template < typename TT , typename ValueT > struct OutputIteratorConcept : OutputIterator< TT, ValueT > { }; template < typename TT , typename ValueT > struct OutputIterator
    : Assignable<TT>
  {
    typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<OutputIterator>)>::failed> boost_concept_check532; ~OutputIterator() {
      ++i;
      i++;
      *i++ = t;
    }
   private:
    TT i, j;
    ValueT t;
  };
  template < typename TT > struct ForwardIterator; template < typename TT > struct ForwardIteratorConcept : ForwardIterator< TT > { }; template < typename TT > struct ForwardIterator
    : InputIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ForwardIterator>)>::failed> boost_concept_check546; ~ForwardIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< typename ForwardIterator::iterator_category , std::forward_iterator_tag >)>::failed> boost_concept_check551;
          typename InputIterator<TT>::reference r = *i;
          ignore_unused_variable_warning(r);
      }
   private:
      TT i;
  };
  template < typename TT > struct Mutable_ForwardIterator; template < typename TT > struct Mutable_ForwardIteratorConcept : Mutable_ForwardIterator< TT > { }; template < typename TT > struct Mutable_ForwardIterator
    : ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ForwardIterator>)>::failed> boost_concept_check564; ~Mutable_ForwardIterator() {
        *i++ = *i;
      }
   private:
      TT i;
  };
  template < typename TT > struct BidirectionalIterator; template < typename TT > struct BidirectionalIteratorConcept : BidirectionalIterator< TT > { }; template < typename TT > struct BidirectionalIterator
    : ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BidirectionalIterator>)>::failed> boost_concept_check574; ~BidirectionalIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< typename BidirectionalIterator::iterator_category , std::bidirectional_iterator_tag >)>::failed> boost_concept_check579;
          --i;
          i--;
      }
   private:
      TT i;
  };
  template < typename TT > struct Mutable_BidirectionalIterator; template < typename TT > struct Mutable_BidirectionalIteratorConcept : Mutable_BidirectionalIterator< TT > { }; template < typename TT > struct Mutable_BidirectionalIterator
    : BidirectionalIterator<TT>
    , Mutable_ForwardIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_BidirectionalIterator>)>::failed> boost_concept_check592; ~Mutable_BidirectionalIterator()
      {
          *i-- = *i;
      }
   private:
      TT i;
  };
  template < typename TT > struct RandomAccessIterator; template < typename TT > struct RandomAccessIteratorConcept : RandomAccessIterator< TT > { }; template < typename TT > struct RandomAccessIterator
    : BidirectionalIterator<TT>
    , Comparable<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessIterator>)>::failed> boost_concept_check604; ~RandomAccessIterator()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Convertible< typename BidirectionalIterator<TT>::iterator_category , std::random_access_iterator_tag >)>::failed> boost_concept_check609;
          i += n;
          i = i + n; i = n + i;
          i -= n;
          i = i - n;
          n = i - j;
          (void)i[n];
      }
   private:
    TT a, b;
    TT i, j;
      typename boost::detail::iterator_traits<TT>::difference_type n;
  };
  template < typename TT > struct Mutable_RandomAccessIterator; template < typename TT > struct Mutable_RandomAccessIteratorConcept : Mutable_RandomAccessIterator< TT > { }; template < typename TT > struct Mutable_RandomAccessIterator
    : RandomAccessIterator<TT>
    , Mutable_BidirectionalIterator<TT>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_RandomAccessIterator>)>::failed> boost_concept_check629; ~Mutable_RandomAccessIterator()
      {
          i[n] = *i;
      }
   private:
    TT i;
    typename boost::detail::iterator_traits<TT>::difference_type n;
  };
  template < typename C > struct Container; template < typename C > struct ContainerConcept : Container< C > { }; template < typename C > struct Container
    : Assignable<C>
  {
    typedef typename C::value_type value_type;
    typedef typename C::difference_type difference_type;
    typedef typename C::size_type size_type;
    typedef typename C::const_reference const_reference;
    typedef typename C::const_pointer const_pointer;
    typedef typename C::const_iterator const_iterator;
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Container>)>::failed> boost_concept_check651; ~Container()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(InputIterator<const_iterator>)>::failed> boost_concept_check653;
          const_constraints(c);
      }
   private:
      void const_constraints(const C& cc) {
          i = cc.begin();
          i = cc.end();
          n = cc.size();
          n = cc.max_size();
          b = cc.empty();
      }
      C c;
      bool b;
      const_iterator i;
      size_type n;
  };
  template < typename C > struct Mutable_Container; template < typename C > struct Mutable_ContainerConcept : Mutable_Container< C > { }; template < typename C > struct Mutable_Container
    : Container<C>
  {
      typedef typename C::reference reference;
      typedef typename C::iterator iterator;
      typedef typename C::pointer pointer;
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_Container>)>::failed> boost_concept_check678; ~Mutable_Container()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Assignable<typename Mutable_Container::value_type>)>::failed> boost_concept_check681;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(InputIterator<iterator>)>::failed> boost_concept_check683;
          i = c.begin();
          i = c.end();
          c.swap(c2);
      }
   private:
      iterator i;
      C c, c2;
  };
  template < typename C > struct ForwardContainer; template < typename C > struct ForwardContainerConcept : ForwardContainer< C > { }; template < typename C > struct ForwardContainer
    : Container<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ForwardContainer>)>::failed> boost_concept_check698; ~ForwardContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( ForwardIterator< typename ForwardContainer::const_iterator >)>::failed> boost_concept_check703;
      }
  };
  template < typename C > struct Mutable_ForwardContainer; template < typename C > struct Mutable_ForwardContainerConcept : Mutable_ForwardContainer< C > { }; template < typename C > struct Mutable_ForwardContainer
    : ForwardContainer<C>
    , Mutable_Container<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ForwardContainer>)>::failed> boost_concept_check711; ~Mutable_ForwardContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Mutable_ForwardIterator< typename Mutable_ForwardContainer::iterator >)>::failed> boost_concept_check716;
      }
  };
  template < typename C > struct ReversibleContainer; template < typename C > struct ReversibleContainerConcept : ReversibleContainer< C > { }; template < typename C > struct ReversibleContainer
    : ForwardContainer<C>
  {
      typedef typename
        C::const_reverse_iterator
      const_reverse_iterator;
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ReversibleContainer>)>::failed> boost_concept_check727; ~ReversibleContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( BidirectionalIterator< typename ReversibleContainer::const_iterator>)>::failed> boost_concept_check731;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BidirectionalIterator<const_reverse_iterator>)>::failed> boost_concept_check733;
          const_constraints(c);
      }
   private:
      void const_constraints(const C& cc)
      {
          const_reverse_iterator i = cc.rbegin();
          i = cc.rend();
      }
      C c;
  };
  template < typename C > struct Mutable_ReversibleContainer; template < typename C > struct Mutable_ReversibleContainerConcept : Mutable_ReversibleContainer< C > { }; template < typename C > struct Mutable_ReversibleContainer
    : Mutable_ForwardContainer<C>
    , ReversibleContainer<C>
  {
      typedef typename C::reverse_iterator reverse_iterator;
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_ReversibleContainer>)>::failed> boost_concept_check752; ~Mutable_ReversibleContainer()
      {
          typedef typename Mutable_ForwardContainer<C>::iterator iterator;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_BidirectionalIterator<iterator>)>::failed> boost_concept_check755;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_BidirectionalIterator<reverse_iterator>)>::failed> boost_concept_check756;
          reverse_iterator i = c.rbegin();
          i = c.rend();
      }
   private:
      C c;
  };
  template < typename C > struct RandomAccessContainer; template < typename C > struct RandomAccessContainerConcept : RandomAccessContainer< C > { }; template < typename C > struct RandomAccessContainer
    : ReversibleContainer<C>
  {
      typedef typename C::size_type size_type;
      typedef typename C::const_reference const_reference;
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessContainer>)>::failed> boost_concept_check771; ~RandomAccessContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( RandomAccessIterator< typename RandomAccessContainer::const_iterator >)>::failed> boost_concept_check776;
          const_constraints(c);
      }
   private:
      void const_constraints(const C& cc)
      {
          const_reference r = cc[n];
          ignore_unused_variable_warning(r);
      }
      C c;
      size_type n;
  };
  template < typename C > struct Mutable_RandomAccessContainer; template < typename C > struct Mutable_RandomAccessContainerConcept : Mutable_RandomAccessContainer< C > { }; template < typename C > struct Mutable_RandomAccessContainer
    : Mutable_ReversibleContainer<C>
    , RandomAccessContainer<C>
  {
   private:
      typedef Mutable_RandomAccessContainer self;
   public:
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Mutable_RandomAccessContainer>)>::failed> boost_concept_check798; ~Mutable_RandomAccessContainer()
      {
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_RandomAccessIterator<typename self::iterator>)>::failed> boost_concept_check800;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(Mutable_RandomAccessIterator<typename self::reverse_iterator>)>::failed> boost_concept_check801;
          typename self::reference r = c[i];
          ignore_unused_variable_warning(r);
      }
   private:
      typename Mutable_ReversibleContainer<C>::size_type i;
      C c;
  };
  template < typename S > struct Sequence; template < typename S > struct SequenceConcept : Sequence< S > { }; template < typename S > struct Sequence
    : Mutable_ForwardContainer<S>
    , DefaultConstructible<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Sequence>)>::failed> boost_concept_check820; ~Sequence()
      {
          S
              c(n),
              c2(n, t),
              c3(first, last);
          c.insert(p, t);
          c.insert(p, n, t);
          c.insert(p, first, last);
          c.erase(p);
          c.erase(p, q);
          typename Sequence::reference r = c.front();
          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(c2);
          ignore_unused_variable_warning(c3);
          ignore_unused_variable_warning(r);
          const_constraints(c);
      }
   private:
      void const_constraints(const S& c) {
          typename Sequence::const_reference r = c.front();
          ignore_unused_variable_warning(r);
      }
      typename S::value_type t;
      typename S::size_type n;
      typename S::value_type* first, *last;
      typename S::iterator p, q;
  };
  template < typename S > struct FrontInsertionSequence; template < typename S > struct FrontInsertionSequenceConcept : FrontInsertionSequence< S > { }; template < typename S > struct FrontInsertionSequence
    : Sequence<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<FrontInsertionSequence>)>::failed> boost_concept_check857; ~FrontInsertionSequence()
      {
          c.push_front(t);
          c.pop_front();
      }
   private:
      S c;
      typename S::value_type t;
  };
  template < typename S > struct BackInsertionSequence; template < typename S > struct BackInsertionSequenceConcept : BackInsertionSequence< S > { }; template < typename S > struct BackInsertionSequence
    : Sequence<S>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BackInsertionSequence>)>::failed> boost_concept_check870; ~BackInsertionSequence()
      {
          c.push_back(t);
          c.pop_back();
          typename BackInsertionSequence::reference r = c.back();
          ignore_unused_variable_warning(r);
          const_constraints(c);
      }
   private:
      void const_constraints(const S& cc) {
          typename BackInsertionSequence::const_reference
              r = cc.back();
          ignore_unused_variable_warning(r);
      };
      S c;
      typename S::value_type t;
  };
  template < typename C > struct AssociativeContainer; template < typename C > struct AssociativeContainerConcept : AssociativeContainer< C > { }; template < typename C > struct AssociativeContainer
    : ForwardContainer<C>
    , DefaultConstructible<C>
  {
      typedef typename C::key_type key_type;
      typedef typename C::key_compare key_compare;
      typedef typename C::value_compare value_compare;
      typedef typename C::iterator iterator;
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<AssociativeContainer>)>::failed> boost_concept_check897; ~AssociativeContainer()
      {
          i = c.find(k);
          r = c.equal_range(k);
          c.erase(k);
          c.erase(i);
          c.erase(r.first, r.second);
          const_constraints(c);
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BinaryPredicate<key_compare,key_type,key_type>)>::failed> boost_concept_check905;
          typedef typename AssociativeContainer::value_type value_type_;
          typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BinaryPredicate<value_compare,value_type_,value_type_>)>::failed> boost_concept_check908;
      }
      typedef typename C::const_iterator const_iterator;
   private:
      void const_constraints(const C& cc)
      {
          ci = cc.find(k);
          n = cc.count(k);
          cr = cc.equal_range(k);
      }
      C c;
      iterator i;
      std::pair<iterator,iterator> r;
      const_iterator ci;
      std::pair<const_iterator,const_iterator> cr;
      typename C::key_type k;
      typename C::size_type n;
  };
  template < typename C > struct UniqueAssociativeContainer; template < typename C > struct UniqueAssociativeContainerConcept : UniqueAssociativeContainer< C > { }; template < typename C > struct UniqueAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<UniqueAssociativeContainer>)>::failed> boost_concept_check933; ~UniqueAssociativeContainer()
      {
          C c(first, last);
          pos_flag = c.insert(t);
          c.insert(first, last);
          ignore_unused_variable_warning(c);
      }
   private:
      std::pair<typename C::iterator, bool> pos_flag;
      typename C::value_type t;
      typename C::value_type* first, *last;
  };
  template < typename C > struct MultipleAssociativeContainer; template < typename C > struct MultipleAssociativeContainerConcept : MultipleAssociativeContainer< C > { }; template < typename C > struct MultipleAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<MultipleAssociativeContainer>)>::failed> boost_concept_check951; ~MultipleAssociativeContainer()
      {
          C c(first, last);
          pos = c.insert(t);
          c.insert(first, last);
          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(pos);
      }
   private:
      typename C::iterator pos;
      typename C::value_type t;
      typename C::value_type* first, *last;
  };
  template < typename C > struct SimpleAssociativeContainer; template < typename C > struct SimpleAssociativeContainerConcept : SimpleAssociativeContainer< C > { }; template < typename C > struct SimpleAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SimpleAssociativeContainer>)>::failed> boost_concept_check970; ~SimpleAssociativeContainer()
      {
          typedef typename C::key_type key_type;
          typedef typename C::value_type value_type;
          enum { mpl_assertion_in_line_974 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (boost::is_same<key_type,value_type>))0, 1 ) ) ) };
      }
  };
  template < typename C > struct PairAssociativeContainer; template < typename C > struct PairAssociativeContainerConcept : PairAssociativeContainer< C > { }; template < typename C > struct PairAssociativeContainer
    : AssociativeContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<PairAssociativeContainer>)>::failed> boost_concept_check981; ~PairAssociativeContainer()
      {
          typedef typename C::key_type key_type;
          typedef typename C::value_type value_type;
          typedef typename C::mapped_type mapped_type;
          typedef std::pair<const key_type, mapped_type> required_value_type;
          enum { mpl_assertion_in_line_987 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (boost::is_same<value_type,required_value_type>))0, 1 ) ) ) };
      }
  };
  template < typename C > struct SortedAssociativeContainer; template < typename C > struct SortedAssociativeContainerConcept : SortedAssociativeContainer< C > { }; template < typename C > struct SortedAssociativeContainer
    : AssociativeContainer<C>
    , ReversibleContainer<C>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SortedAssociativeContainer>)>::failed> boost_concept_check995; ~SortedAssociativeContainer()
      {
          C
              c(kc),
              c2(first, last),
              c3(first, last, kc);
          p = c.upper_bound(k);
          p = c.lower_bound(k);
          r = c.equal_range(k);
          c.insert(p, t);
          ignore_unused_variable_warning(c);
          ignore_unused_variable_warning(c2);
          ignore_unused_variable_warning(c3);
          const_constraints(c);
      }
      void const_constraints(const C& c)
      {
          kc = c.key_comp();
          vc = c.value_comp();
          cp = c.upper_bound(k);
          cp = c.lower_bound(k);
          cr = c.equal_range(k);
      }
   private:
      typename C::key_compare kc;
      typename C::value_compare vc;
      typename C::value_type t;
      typename C::key_type k;
      typedef typename C::iterator iterator;
      typedef typename C::const_iterator const_iterator;
      typedef SortedAssociativeContainer self;
      iterator p;
      const_iterator cp;
      std::pair<typename self::iterator,typename self::iterator> r;
      std::pair<typename self::const_iterator,typename self::const_iterator> cr;
      typename C::value_type* first, *last;
  };
  template < typename C > struct Collection; template < typename C > struct CollectionConcept : Collection< C > { }; template < typename C > struct Collection
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<Collection>)>::failed> boost_concept_check1044; ~Collection()
      {
        boost::function_requires<boost::InputIteratorConcept<iterator> >();
        boost::function_requires<boost::InputIteratorConcept<const_iterator> >();
        boost::function_requires<boost::CopyConstructibleConcept<value_type> >();
        const_constraints(c);
        i = c.begin();
        i = c.end();
        c.swap(c);
      }
      void const_constraints(const C& c) {
        ci = c.begin();
        ci = c.end();
        n = c.size();
        b = c.empty();
      }
    private:
      typedef typename C::value_type value_type;
      typedef typename C::iterator iterator;
      typedef typename C::const_iterator const_iterator;
      typedef typename C::reference reference;
      typedef typename C::const_reference const_reference;
      typedef typename C::difference_type difference_type;
      typedef typename C::size_type size_type;
      C c;
      bool b;
      iterator i;
      const_iterator ci;
      size_type n;
  };
}
namespace boost_concepts
{
  template < typename Iterator > struct ReadableIterator; template < typename Iterator > struct ReadableIteratorConcept : ReadableIterator< Iterator > { }; template < typename Iterator > struct ReadableIterator
    : boost::Assignable<Iterator>
    , boost::CopyConstructible<Iterator>
  {
      typedef typename boost::detail::iterator_traits<Iterator>::value_type value_type;
      typedef typename boost::detail::iterator_traits<Iterator>::reference reference;
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ReadableIterator>)>::failed> boost_concept_check50; ~ReadableIterator()
      {
          value_type v = *i;
          boost::ignore_unused_variable_warning(v);
      }
  private:
      Iterator i;
  };
  template <
      typename Iterator
    , typename ValueType = typename boost::detail::iterator_traits<Iterator>::value_type
  >
  struct WritableIterator
    : boost::CopyConstructible<Iterator>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<WritableIterator>)>::failed> boost_concept_check67; ~WritableIterator()
      {
          *i = v;
      }
  private:
      ValueType v;
      Iterator i;
  };
  template <
      typename Iterator
    , typename ValueType = typename boost::detail::iterator_traits<Iterator>::value_type
  >
  struct WritableIteratorConcept : WritableIterator<Iterator,ValueType> {};
  template < typename Iterator > struct SwappableIterator; template < typename Iterator > struct SwappableIteratorConcept : SwappableIterator< Iterator > { }; template < typename Iterator > struct SwappableIterator
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SwappableIterator>)>::failed> boost_concept_check84; ~SwappableIterator()
      {
          std::iter_swap(i1, i2);
      }
  private:
      Iterator i1;
      Iterator i2;
  };
  template < typename Iterator > struct LvalueIterator; template < typename Iterator > struct LvalueIteratorConcept : LvalueIterator< Iterator > { }; template < typename Iterator > struct LvalueIterator
  {
      typedef typename boost::detail::iterator_traits<Iterator>::value_type value_type;
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<LvalueIterator>)>::failed> boost_concept_check97; ~LvalueIterator()
      {
        value_type& r = const_cast<value_type&>(*i);
        boost::ignore_unused_variable_warning(r);
      }
  private:
      Iterator i;
  };
  template < typename Iterator > struct IncrementableIterator; template < typename Iterator > struct IncrementableIteratorConcept : IncrementableIterator< Iterator > { }; template < typename Iterator > struct IncrementableIterator
    : boost::Assignable<Iterator>
    , boost::CopyConstructible<Iterator>
  {
      typedef typename boost::iterator_traversal<Iterator>::type traversal_category;
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< traversal_category , boost::incrementable_traversal_tag >)>::failed> boost_concept_check120;
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<IncrementableIterator>)>::failed> boost_concept_check122; ~IncrementableIterator()
      {
          ++i;
          (void)i++;
      }
  private:
      Iterator i;
  };
  template < typename Iterator > struct SinglePassIterator; template < typename Iterator > struct SinglePassIteratorConcept : SinglePassIterator< Iterator > { }; template < typename Iterator > struct SinglePassIterator
    : IncrementableIterator<Iterator>
    , boost::EqualityComparable<Iterator>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< typename SinglePassIterator::traversal_category , boost::single_pass_traversal_tag > )>::failed> boost_concept_check140;
  };
  template < typename Iterator > struct ForwardTraversal; template < typename Iterator > struct ForwardTraversalConcept : ForwardTraversal< Iterator > { }; template < typename Iterator > struct ForwardTraversal
    : SinglePassIterator<Iterator>
    , boost::DefaultConstructible<Iterator>
  {
      typedef typename boost::detail::iterator_traits<Iterator>::difference_type difference_type;
      enum { mpl_assertion_in_line_149 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (boost::is_integral<difference_type>))0, 1 ) ) ) };
      enum { mpl_assert_rel_value150 = (std::numeric_limits<difference_type>::is_signed == true) }; enum { mpl_assertion_in_line_150 = sizeof( boost::mpl::assertion_failed<mpl_assert_rel_value150>( (boost::mpl::failed ************ ( boost::mpl::assert_relation< boost::mpl::assert_::relations( sizeof( boost::mpl::assert_::arg == boost::mpl::assert_::arg ) ) , std::numeric_limits<difference_type>::is_signed , true >::************)) 0 ) ) };
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< typename ForwardTraversal::traversal_category , boost::forward_traversal_tag > )>::failed> boost_concept_check156;
  };
  template < typename Iterator > struct BidirectionalTraversal; template < typename Iterator > struct BidirectionalTraversalConcept : BidirectionalTraversal< Iterator > { }; template < typename Iterator > struct BidirectionalTraversal
    : ForwardTraversal<Iterator>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< typename BidirectionalTraversal::traversal_category , boost::bidirectional_traversal_tag > )>::failed> boost_concept_check166;
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BidirectionalTraversal>)>::failed> boost_concept_check168; ~BidirectionalTraversal()
      {
          --i;
          (void)i--;
      }
   private:
      Iterator i;
  };
  template < typename Iterator > struct RandomAccessTraversal; template < typename Iterator > struct RandomAccessTraversalConcept : RandomAccessTraversal< Iterator > { }; template < typename Iterator > struct RandomAccessTraversal
    : BidirectionalTraversal<Iterator>
  {
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( boost::Convertible< typename RandomAccessTraversal::traversal_category , boost::random_access_traversal_tag > )>::failed> boost_concept_check184;
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessTraversal>)>::failed> boost_concept_check186; ~RandomAccessTraversal()
      {
          i += n;
          i = i + n;
          i = n + i;
          i -= n;
          i = i - n;
          n = i - j;
      }
   private:
      typename BidirectionalTraversal<Iterator>::difference_type n;
      Iterator i, j;
  };
  namespace detail
  {
    template <typename Iterator1, typename Iterator2>
    void interop_single_pass_constraints(Iterator1 const& i1, Iterator2 const& i2)
    {
        bool b;
        b = i1 == i2;
        b = i1 != i2;
        b = i2 == i1;
        b = i2 != i1;
        boost::ignore_unused_variable_warning(b);
    }
    template <typename Iterator1, typename Iterator2>
    void interop_rand_access_constraints(
        Iterator1 const& i1, Iterator2 const& i2,
        boost::random_access_traversal_tag, boost::random_access_traversal_tag)
    {
        bool b;
        typename boost::detail::iterator_traits<Iterator2>::difference_type n;
        b = i1 < i2;
        b = i1 <= i2;
        b = i1 > i2;
        b = i1 >= i2;
        n = i1 - i2;
        b = i2 < i1;
        b = i2 <= i1;
        b = i2 > i1;
        b = i2 >= i1;
        n = i2 - i1;
        boost::ignore_unused_variable_warning(b);
        boost::ignore_unused_variable_warning(n);
    }
    template <typename Iterator1, typename Iterator2>
    void interop_rand_access_constraints(
        Iterator1 const&, Iterator2 const&,
        boost::single_pass_traversal_tag, boost::single_pass_traversal_tag)
    { }
  }
  template < typename Iterator , typename ConstIterator > struct InteroperableIterator; template < typename Iterator , typename ConstIterator > struct InteroperableIteratorConcept : InteroperableIterator< Iterator, ConstIterator > { }; template < typename Iterator , typename ConstIterator > struct InteroperableIterator
  {
   private:
      typedef typename boost::detail::pure_traversal_tag<
          typename boost::iterator_traversal<
              Iterator
          >::type
      >::type traversal_category;
      typedef typename boost::detail::pure_traversal_tag<
          typename boost::iterator_traversal<
              ConstIterator
          >::type
      >::type const_traversal_category;
  public:
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(SinglePassIterator<Iterator>)>::failed> boost_concept_check264;
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(SinglePassIterator<ConstIterator>)>::failed> boost_concept_check265;
      typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<InteroperableIterator>)>::failed> boost_concept_check267; ~InteroperableIterator()
      {
          detail::interop_single_pass_constraints(i, ci);
          detail::interop_rand_access_constraints(i, ci, traversal_category(), const_traversal_category());
          ci = i;
      }
   private:
      Iterator i;
      ConstIterator ci;
  };
}
namespace boost
{
    template< class T >
    struct range_value : iterator_value< typename range_iterator<T>::type >
    { };
}
namespace boost
{
    namespace range_detail
    {
        template<typename T1, typename T2>
        class SameTypeConcept
        {
        public:
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SameTypeConcept>)>::failed> boost_concept_check21; ~SameTypeConcept()
            {
                same_type(a,b);
            }
        private:
            template<typename T> void same_type(T,T) {}
            T1 a;
            T2 b;
        };
    }
}
namespace boost {
    namespace range_detail {
        template<class Iterator>
        struct IncrementableIteratorConcept : CopyConstructible<Iterator>
        {
            typedef typename iterator_traversal<Iterator>::type traversal_category;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< traversal_category, incrementable_traversal_tag >)>::failed> boost_concept_check122;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<IncrementableIteratorConcept>)>::failed> boost_concept_check124; ~IncrementableIteratorConcept()
            {
                ++i;
                (void)i++;
            }
        private:
            Iterator i;
        };
        template<class Iterator>
        struct SinglePassIteratorConcept
            : IncrementableIteratorConcept<Iterator>
            , EqualityComparable<Iterator>
        {
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< typename SinglePassIteratorConcept::traversal_category, single_pass_traversal_tag >)>::failed> boost_concept_check144;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SinglePassIteratorConcept>)>::failed> boost_concept_check146; ~SinglePassIteratorConcept()
            {
                Iterator i2(++i);
                boost::ignore_unused_variable_warning(i2);
                (void)(i++);
                typename boost::detail::iterator_traits<Iterator>::reference r1(*i);
                boost::ignore_unused_variable_warning(r1);
                typename boost::detail::iterator_traits<Iterator>::reference r2(*(++i));
                boost::ignore_unused_variable_warning(r2);
            }
        private:
            Iterator i;
        };
        template<class Iterator>
        struct ForwardIteratorConcept
            : SinglePassIteratorConcept<Iterator>
            , DefaultConstructible<Iterator>
        {
            typedef typename boost::detail::iterator_traits<Iterator>::difference_type difference_type;
            enum { mpl_assertion_in_line_176 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_arg( (void (*) (is_integral<difference_type>))0, 1 ) ) ) };
            enum { mpl_assert_rel_value177 = (std::numeric_limits<difference_type>::is_signed == true) }; enum { mpl_assertion_in_line_177 = sizeof( boost::mpl::assertion_failed<mpl_assert_rel_value177>( (boost::mpl::failed ************ ( boost::mpl::assert_relation< boost::mpl::assert_::relations( sizeof( boost::mpl::assert_::arg == boost::mpl::assert_::arg ) ) , std::numeric_limits<difference_type>::is_signed , true >::************)) 0 ) ) };
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< typename ForwardIteratorConcept::traversal_category, forward_traversal_tag >)>::failed> boost_concept_check183;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<ForwardIteratorConcept>)>::failed> boost_concept_check185; ~ForwardIteratorConcept()
            {
                Iterator i2(i++);
                boost::ignore_unused_variable_warning(i2);
                typename boost::detail::iterator_traits<Iterator>::reference r(*(i++));
                boost::ignore_unused_variable_warning(r);
            }
        private:
            Iterator i;
         };
         template<class Iterator>
         struct BidirectionalIteratorConcept
             : ForwardIteratorConcept<Iterator>
         {
             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< typename BidirectionalIteratorConcept::traversal_category, bidirectional_traversal_tag >)>::failed> boost_concept_check210;
             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<BidirectionalIteratorConcept>)>::failed> boost_concept_check212; ~BidirectionalIteratorConcept()
             {
                 --i;
                 (void)i--;
             }
         private:
             Iterator i;
         };
         template<class Iterator>
         struct RandomAccessIteratorConcept
             : BidirectionalIteratorConcept<Iterator>
         {
             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( Convertible< typename RandomAccessIteratorConcept::traversal_category, random_access_traversal_tag >)>::failed> boost_concept_check231;
             typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<RandomAccessIteratorConcept>)>::failed> boost_concept_check233; ~RandomAccessIteratorConcept()
             {
                 i += n;
                 i = i + n;
                 i = n + i;
                 i -= n;
                 i = i - n;
                 n = i - j;
             }
         private:
             typename RandomAccessIteratorConcept::difference_type n;
             Iterator i;
             Iterator j;
         };
    }
    template<class T>
    struct SinglePassRangeConcept
    {
         typedef typename range_iterator<T const>::type const_iterator;
         typedef typename range_iterator<T>::type iterator;
         typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::SinglePassIteratorConcept<iterator>)>::failed> boost_concept_check259;
         typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::SinglePassIteratorConcept<const_iterator>)>::failed> boost_concept_check260;
         typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<SinglePassRangeConcept>)>::failed> boost_concept_check262; ~SinglePassRangeConcept()
         {
            iterator i1 = boost::begin(*m_range);
            iterator i2 = boost::end(*m_range);
            ignore_unused_variable_warning(i1);
            ignore_unused_variable_warning(i2);
            const_constraints(*m_range);
        }
    private:
        void const_constraints(const T& const_range)
        {
            const_iterator ci1 = boost::begin(const_range);
            const_iterator ci2 = boost::end(const_range);
            ignore_unused_variable_warning(ci1);
            ignore_unused_variable_warning(ci2);
        }
       T* m_range;
    };
    template<class T>
    struct ForwardRangeConcept : SinglePassRangeConcept<T>
    {
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::ForwardIteratorConcept<typename ForwardRangeConcept::iterator>)>::failed> boost_concept_check299;
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(range_detail::ForwardIteratorConcept<typename ForwardRangeConcept::const_iterator>)>::failed> boost_concept_check300;
    };
    template<class Range>
    struct WriteableRangeConcept
    {
        typedef typename range_iterator<Range>::type iterator;
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(boost::concepts::usage_requirements<WriteableRangeConcept>)>::failed> boost_concept_check310; ~WriteableRangeConcept()
        {
            *i = v;
        }
    private:
        iterator i;
        typename range_value<Range>::type v;
    };
    template<class T>
    struct WriteableForwardRangeConcept
        : ForwardRangeConcept<T>
        , WriteableRangeConcept<T>
    {
    };
    template<class T>
    struct BidirectionalRangeConcept : ForwardRangeConcept<T>
    {
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BidirectionalIteratorConcept<typename BidirectionalRangeConcept::iterator>)>::failed> boost_concept_check333;
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(BidirectionalIteratorConcept<typename BidirectionalRangeConcept::const_iterator>)>::failed> boost_concept_check334;
    };
    template<class T>
    struct WriteableBidirectionalRangeConcept
        : BidirectionalRangeConcept<T>
        , WriteableRangeConcept<T>
    {
    };
    template<class T>
    struct RandomAccessRangeConcept : BidirectionalRangeConcept<T>
    {
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(RandomAccessIteratorConcept<typename RandomAccessRangeConcept::iterator>)>::failed> boost_concept_check351;
        typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)(RandomAccessIteratorConcept<typename RandomAccessRangeConcept::const_iterator>)>::failed> boost_concept_check352;
    };
    template<class T>
    struct WriteableRandomAccessRangeConcept
        : RandomAccessRangeConcept<T>
        , WriteableRangeConcept<T>
    {
    };
}
namespace boost
{
    namespace range_detail
    {
        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2,
                  class IteratorCategoryTag1,
                  class IteratorCategoryTag2 >
        inline bool equal_impl( SinglePassTraversalReadableIterator1 first1,
                                SinglePassTraversalReadableIterator1 last1,
                                SinglePassTraversalReadableIterator2 first2,
                                SinglePassTraversalReadableIterator2 last2,
                                IteratorCategoryTag1,
                                IteratorCategoryTag2 )
        {
            do
            {
                if (first1 == last1)
                    return first2 == last2;
                if (first2 == last2)
                    return false;
            } while(*first1++ == *first2++);
            return false;
        }
        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2,
                  class IteratorCategoryTag1,
                  class IteratorCategoryTag2,
                  class BinaryPredicate >
        inline bool equal_impl( SinglePassTraversalReadableIterator1 first1,
                                SinglePassTraversalReadableIterator1 last1,
                                SinglePassTraversalReadableIterator2 first2,
                                SinglePassTraversalReadableIterator2 last2,
                                BinaryPredicate pred,
                                IteratorCategoryTag1,
                                IteratorCategoryTag2 )
        {
            do
            {
                if (first1 == last1)
                    return first2 == last2;
                if (first2 == last2)
                    return false;
            } while(pred(*first1++, *first2++));
            return false;
        }
        template< class RandomAccessTraversalReadableIterator1,
                  class RandomAccessTraversalReadableIterator2 >
        inline bool equal_impl( RandomAccessTraversalReadableIterator1 first1,
                                RandomAccessTraversalReadableIterator1 last1,
                                RandomAccessTraversalReadableIterator2 first2,
                                RandomAccessTraversalReadableIterator2 last2,
                                std::random_access_iterator_tag,
                                std::random_access_iterator_tag )
        {
            return ((last1 - first1) == (last2 - first2))
                && std::equal(first1, last1, first2);
        }
        template< class RandomAccessTraversalReadableIterator1,
                  class RandomAccessTraversalReadableIterator2,
                  class BinaryPredicate >
        inline bool equal_impl( RandomAccessTraversalReadableIterator1 first1,
                                RandomAccessTraversalReadableIterator1 last1,
                                RandomAccessTraversalReadableIterator2 first2,
                                RandomAccessTraversalReadableIterator2 last2,
                                BinaryPredicate pred )
        {
            return ((last1 - first1) == (last2 - first2))
                && std::equal(first1, last1, first2, pred);
        }
        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2 >
        inline bool equal( SinglePassTraversalReadableIterator1 first1,
                           SinglePassTraversalReadableIterator1 last1,
                           SinglePassTraversalReadableIterator2 first2,
                           SinglePassTraversalReadableIterator2 last2 )
        {
            typename std::iterator_traits< SinglePassTraversalReadableIterator1 >::iterator_category tag1;
            typename std::iterator_traits< SinglePassTraversalReadableIterator2 >::iterator_category tag2;
            return equal_impl(first1, last1, first2, last2, tag1, tag2);
        }
        template< class SinglePassTraversalReadableIterator1,
                  class SinglePassTraversalReadableIterator2,
                  class BinaryPredicate >
        inline bool equal( SinglePassTraversalReadableIterator1 first1,
                           SinglePassTraversalReadableIterator1 last1,
                           SinglePassTraversalReadableIterator2 first2,
                           SinglePassTraversalReadableIterator2 last2,
                           BinaryPredicate pred )
        {
            typename std::iterator_traits< SinglePassTraversalReadableIterator1 >::iterator_category tag1;
            typename std::iterator_traits< SinglePassTraversalReadableIterator2 >::iterator_category tag2;
            return equal_impl(first1, last1, first2, last2, pred, tag1, tag2);
        }
    }
    namespace range
    {
        template< class SinglePassRange1, class SinglePassRange2 >
        inline bool equal( const SinglePassRange1& rng1, const SinglePassRange2& rng2 )
        {
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange1> )>::failed> boost_concept_check162;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange2> )>::failed> boost_concept_check163;
            return ::boost::range_detail::equal(
                ::boost::begin(rng1), ::boost::end(rng1),
                ::boost::begin(rng2), ::boost::end(rng2) );
        }
        template< class SinglePassRange1, class SinglePassRange2, class BinaryPredicate >
        inline bool equal( const SinglePassRange1& rng1, const SinglePassRange2& rng2,
                           BinaryPredicate pred )
        {
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange1> )>::failed> boost_concept_check175;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( SinglePassRangeConcept<const SinglePassRange2> )>::failed> boost_concept_check176;
            return ::boost::range_detail::equal(
                ::boost::begin(rng1), ::boost::end(rng1),
                ::boost::begin(rng2), ::boost::end(rng2),
                pred);
        }
    }
    using range::equal;
}
namespace boost
{
    namespace range_detail
    {
template<class DataMemberPtr>
class safe_bool
{
public:
    typedef safe_bool this_type;
    typedef DataMemberPtr unspecified_bool_type;
    static unspecified_bool_type to_unspecified_bool(const bool x, DataMemberPtr p)
    {
        return x ? p : 0;
    }
private:
    safe_bool();
    safe_bool(const safe_bool&);
    void operator=(const safe_bool&);
    ~safe_bool();
};
    }
}
       
namespace boost
{
    namespace iterator_range_detail
    {
        template<class IteratorT>
        struct iterator_range_impl {
            template< class ForwardRange >
            static IteratorT adl_begin( ForwardRange& r )
            {
                return static_cast<IteratorT>( boost::begin( r ) );
            }
            template< class ForwardRange >
            static IteratorT adl_end( ForwardRange& r )
            {
                return static_cast<IteratorT>( boost::end( r ) );
            }
        };
        template< class Left, class Right >
        inline bool less_than( const Left& l, const Right& r )
        {
            return std::lexicographical_compare( boost::begin(l),
                                                 boost::end(l),
                                                 boost::begin(r),
                                                 boost::end(r) );
        }
        template< class Left, class Right >
        inline bool greater_than( const Left& l, const Right& r )
        {
            return less_than(r,l);
        }
        template< class Left, class Right >
        inline bool less_or_equal_than( const Left& l, const Right& r )
        {
            return !iterator_range_detail::less_than(r,l);
        }
        template< class Left, class Right >
        inline bool greater_or_equal_than( const Left& l, const Right& r )
        {
            return !iterator_range_detail::less_than(l,r);
        }
        template< class Left, class Right >
        inline bool equal(const Left& l, const Right& r)
        {
            return boost::equal(l, r);
        }
        struct range_tag { };
        struct const_range_tag { };
    }
        template<class IteratorT>
        class iterator_range
        {
            typedef range_detail::safe_bool< IteratorT iterator_range<IteratorT>::* > safe_bool_t;
        protected:
            typedef iterator_range_detail::iterator_range_impl<IteratorT> impl;
        public:
            typedef iterator_range<IteratorT> type;
            typedef typename safe_bool_t::unspecified_bool_type unspecified_bool_type;
            typedef typename
                iterator_value<IteratorT>::type value_type;
            typedef typename
                iterator_difference<IteratorT>::type difference_type;
            typedef std::size_t size_type;
            typedef iterator_range<IteratorT> this_type;
            typedef typename
                iterator_reference<IteratorT>::type reference;
            typedef IteratorT const_iterator;
            typedef IteratorT iterator;
        private:
            typedef typename
                boost::mpl::if_< boost::is_abstract<value_type>,
                                 reference, value_type >::type abstract_value_type;
        public:
            iterator_range() : m_Begin( iterator() ), m_End( iterator() )
            { }
            template< class Iterator >
            iterator_range( Iterator Begin, Iterator End ) :
                m_Begin(Begin), m_End(End)
            {}
            template< class Range >
            iterator_range( const Range& r ) :
                m_Begin( impl::adl_begin( r ) ), m_End( impl::adl_end( r ) )
            {}
            template< class Range >
            iterator_range( Range& r ) :
                m_Begin( impl::adl_begin( r ) ), m_End( impl::adl_end( r ) )
            {}
            template< class Range >
            iterator_range( const Range& r, iterator_range_detail::const_range_tag ) :
                m_Begin( impl::adl_begin( r ) ), m_End( impl::adl_end( r ) )
            {}
            template< class Range >
            iterator_range( Range& r, iterator_range_detail::range_tag ) :
                m_Begin( impl::adl_begin( r ) ), m_End( impl::adl_end( r ) )
            {}
            this_type& operator=( const this_type& r )
            {
                m_Begin = r.begin();
                m_End = r.end();
                return *this;
            }
            template< class Iterator >
            iterator_range& operator=( const iterator_range<Iterator>& r )
            {
                m_Begin = r.begin();
                m_End = r.end();
                return *this;
            }
            template< class ForwardRange >
            iterator_range& operator=( ForwardRange& r )
            {
                m_Begin = impl::adl_begin( r );
                m_End = impl::adl_end( r );
                return *this;
            }
            template< class ForwardRange >
            iterator_range& operator=( const ForwardRange& r )
            {
                m_Begin = impl::adl_begin( r );
                m_End = impl::adl_end( r );
                return *this;
            }
            IteratorT begin() const
            {
                return m_Begin;
            }
            IteratorT end() const
            {
                return m_End;
            }
            difference_type size() const
            {
                return m_End - m_Begin;
            }
            bool empty() const
            {
                return m_Begin == m_End;
            }
            operator unspecified_bool_type() const
            {
                return safe_bool_t::to_unspecified_bool(m_Begin != m_End, &iterator_range::m_Begin);
            }
            bool operator!() const
            {
                return empty();
            }
            bool equal( const iterator_range& r ) const
            {
                return m_Begin == r.m_Begin && m_End == r.m_End;
            }
        public:
           reference front() const
           {
               (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/range/iterator_range_core.hpp", 313, "!empty()") : (void)0);
               return *m_Begin;
           }
           reference back() const
           {
               (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/range/iterator_range_core.hpp", 319, "!empty()") : (void)0);
               IteratorT last( m_End );
               return *--last;
           }
           void pop_front()
           {
               (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/range/iterator_range_core.hpp", 327, "!empty()") : (void)0);
               ++m_Begin;
           }
           void pop_back()
           {
               (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/range/iterator_range_core.hpp", 334, "!empty()") : (void)0);
               --m_End;
           }
           reference operator[]( difference_type at ) const
           {
               (__builtin_expect(!(at >= 0 && at < size()), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/range/iterator_range_core.hpp", 340, "at >= 0 && at < size()") : (void)0);
               return m_Begin[at];
           }
           abstract_value_type operator()( difference_type at ) const
           {
               (__builtin_expect(!(at >= 0 && at < size()), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/range/iterator_range_core.hpp", 351, "at >= 0 && at < size()") : (void)0);
               return m_Begin[at];
           }
           iterator_range& advance_begin( difference_type n )
           {
               std::advance( m_Begin, n );
               return *this;
           }
           iterator_range& advance_end( difference_type n )
           {
               std::advance( m_End, n );
               return *this;
           }
        private:
            IteratorT m_Begin;
            IteratorT m_End;
        protected:
            typedef iterator_range iterator_range_;
        };
        template< class IteratorT, class ForwardRange >
        inline bool operator==( const ForwardRange& l,
                                const iterator_range<IteratorT>& r )
        {
            return boost::equal( l, r );
        }
        template< class IteratorT, class ForwardRange >
        inline bool operator!=( const ForwardRange& l,
                                const iterator_range<IteratorT>& r )
        {
            return !boost::equal( l, r );
        }
        template< class IteratorT, class ForwardRange >
        inline bool operator<( const ForwardRange& l,
                               const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::less_than( l, r );
        }
        template< class IteratorT, class ForwardRange >
        inline bool operator<=( const ForwardRange& l,
                                const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::less_or_equal_than( l, r );
        }
        template< class IteratorT, class ForwardRange >
        inline bool operator>( const ForwardRange& l,
                               const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::greater_than( l, r );
        }
        template< class IteratorT, class ForwardRange >
        inline bool operator>=( const ForwardRange& l,
                                const iterator_range<IteratorT>& r )
        {
            return iterator_range_detail::greater_or_equal_than( l, r );
        }
        template< class Iterator1T, class Iterator2T >
        inline bool operator==( const iterator_range<Iterator1T>& l,
                                const iterator_range<Iterator2T>& r )
        {
            return boost::equal( l, r );
        }
        template< class IteratorT, class ForwardRange >
        inline bool operator==( const iterator_range<IteratorT>& l,
                                const ForwardRange& r )
        {
            return boost::equal( l, r );
        }
        template< class Iterator1T, class Iterator2T >
        inline bool operator!=( const iterator_range<Iterator1T>& l,
                                const iterator_range<Iterator2T>& r )
        {
            return !boost::equal( l, r );
        }
        template< class IteratorT, class ForwardRange >
        inline bool operator!=( const iterator_range<IteratorT>& l,
                                const ForwardRange& r )
        {
            return !boost::equal( l, r );
        }
        template< class Iterator1T, class Iterator2T >
        inline bool operator<( const iterator_range<Iterator1T>& l,
                               const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::less_than( l, r );
        }
        template< class IteratorT, class ForwardRange >
        inline bool operator<( const iterator_range<IteratorT>& l,
                               const ForwardRange& r )
        {
            return iterator_range_detail::less_than( l, r );
        }
        template< class Iterator1T, class Iterator2T >
        inline bool operator<=( const iterator_range<Iterator1T>& l,
                                const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::less_or_equal_than( l, r );
        }
        template< class IteratorT, class ForwardRange >
        inline bool operator<=( const iterator_range<IteratorT>& l,
                                const ForwardRange& r )
        {
            return iterator_range_detail::less_or_equal_than( l, r );
        }
        template< class Iterator1T, class Iterator2T >
        inline bool operator>( const iterator_range<Iterator1T>& l,
                               const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::greater_than( l, r );
        }
        template< class IteratorT, class ForwardRange >
        inline bool operator>( const iterator_range<IteratorT>& l,
                               const ForwardRange& r )
        {
            return iterator_range_detail::greater_than( l, r );
        }
        template< class Iterator1T, class Iterator2T >
        inline bool operator>=( const iterator_range<Iterator1T>& l,
                                const iterator_range<Iterator2T>& r )
        {
            return iterator_range_detail::greater_or_equal_than( l, r );
        }
        template< class IteratorT, class ForwardRange >
        inline bool operator>=( const iterator_range<IteratorT>& l,
                                const ForwardRange& r )
        {
            return iterator_range_detail::greater_or_equal_than( l, r );
        }
        template< typename IteratorT >
        inline iterator_range< IteratorT >
        make_iterator_range( IteratorT Begin, IteratorT End )
        {
            return iterator_range<IteratorT>( Begin, End );
        }
        template< class ForwardRange >
        inline iterator_range< typename range_iterator<ForwardRange>::type >
        make_iterator_range( ForwardRange& r )
        {
           return iterator_range< typename range_iterator<ForwardRange>::type >
                ( r, iterator_range_detail::range_tag() );
        }
        template< class ForwardRange >
        inline iterator_range< typename range_iterator<const ForwardRange>::type >
        make_iterator_range( const ForwardRange& r )
        {
           return iterator_range< typename range_iterator<const ForwardRange>::type >
                ( r, iterator_range_detail::const_range_tag() );
        }
        namespace iterator_range_detail
        {
            template< class Range >
            inline iterator_range< typename range_iterator<Range>::type >
            make_range_impl( Range& r,
                             typename range_difference<Range>::type advance_begin,
                             typename range_difference<Range>::type advance_end )
            {
                typename range_iterator<Range>::type
                    new_begin = boost::begin( r ),
                    new_end = boost::end( r );
                std::advance( new_begin, advance_begin );
                std::advance( new_end, advance_end );
                return make_iterator_range( new_begin, new_end );
            }
        }
        template< class Range >
        inline iterator_range< typename range_iterator<Range>::type >
        make_iterator_range( Range& r,
                    typename range_difference<Range>::type advance_begin,
                    typename range_difference<Range>::type advance_end )
        {
            return iterator_range_detail::make_range_impl( r, advance_begin, advance_end );
        }
        template< class Range >
        inline iterator_range< typename range_iterator<const Range>::type >
        make_iterator_range( const Range& r,
                    typename range_difference<Range>::type advance_begin,
                    typename range_difference<Range>::type advance_end )
        {
            return iterator_range_detail::make_range_impl( r, advance_begin, advance_end );
        }
        template< typename SeqT, typename Range >
        inline SeqT copy_range( const Range& r )
        {
            return SeqT( boost::begin( r ), boost::end( r ) );
        }
}
       
namespace boost
{
        template< typename IteratorT, typename Elem, typename Traits >
        inline std::basic_ostream<Elem,Traits>& operator<<(
                    std::basic_ostream<Elem, Traits>& Os,
                    const iterator_range<IteratorT>& r )
        {
            std::copy( r.begin(), r.end(),
                       std::ostream_iterator< typename
                                              iterator_value<IteratorT>::type,
                                              Elem, Traits>(Os) );
            return Os;
        }
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  inline size_t
  __deque_buf_size(size_t __size)
  { return (__size < 512
     ? size_t(512 / __size) : size_t(1)); }
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;
      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }
      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp** _Map_pointer;
      typedef _Deque_iterator _Self;
      _Tp* _M_cur;
      _Tp* _M_first;
      _Tp* _M_last;
      _Map_pointer _M_node;
      _Deque_iterator(_Tp* __x, _Map_pointer __y)
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }
      _Deque_iterator()
      : _M_cur(0), _M_first(0), _M_last(0), _M_node(0) { }
      _Deque_iterator(const iterator& __x)
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) { }
      reference
      operator*() const
      { return *_M_cur; }
      pointer
      operator->() const
      { return _M_cur; }
      _Self&
      operator++()
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }
      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }
      _Self&
      operator--()
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }
      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }
      _Self&
      operator+=(difference_type __n)
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
                    : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }
      _Self
      operator+(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp += __n;
      }
      _Self&
      operator-=(difference_type __n)
      { return *this += -__n; }
      _Self
      operator-(difference_type __n) const
      {
 _Self __tmp = *this;
 return __tmp -= __n;
      }
      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
      void
      _M_set_node(_Map_pointer __new_node)
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }
    };
  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __x._M_cur == __y._M_cur; }
  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __x._M_cur == __y._M_cur; }
  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x == __y); }
  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x == __y); }
  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                          : (__x._M_node < __y._M_node); }
  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                   : (__x._M_node < __y._M_node); }
  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return __y < __x; }
  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return __y < __x; }
  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__y < __x); }
  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__y < __x); }
  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    { return !(__x < __y); }
  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    { return !(__x < __y); }
  template<typename _Tp, typename _Ref, typename _Ptr>
    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)
    {
      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
 (_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }
  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y)
    {
      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
 (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }
  template<typename _Tp, typename _Ref, typename _Ptr>
    inline _Deque_iterator<_Tp, _Ref, _Ptr>
    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
    { return __x + __n; }
  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>&,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>&, const _Tp&);
  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, _Tp&, _Tp*>);
  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
         _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
         __result); }
  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, _Tp&, _Tp*>);
  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy_backward(_Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__first),
    _Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__last),
    __result); }
  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, _Tp&, _Tp*>);
  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
         _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
         __result); }
  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, _Tp&, _Tp*>);
  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::move_backward(_Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__first),
    _Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__last),
    __result); }
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    public:
      typedef _Alloc allocator_type;
      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }
      typedef _Deque_iterator<_Tp, _Tp&, _Tp*> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;
      _Deque_base()
      : _M_impl()
      { _M_initialize_map(0); }
      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }
      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }
      _Deque_base(_Deque_base&& __x)
      : _M_impl(__x._M_get_Tp_allocator())
      {
 _M_initialize_map(0);
 if (__x._M_impl._M_map)
   {
     std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
     std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
     std::swap(this->_M_impl._M_map, __x._M_impl._M_map);
     std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);
   }
      }
      ~_Deque_base();
    protected:
      typedef typename _Alloc::template rebind<_Tp*>::other _Map_alloc_type;
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;
      struct _Deque_impl
      : public _Tp_alloc_type
      {
 _Tp** _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;
 _Deque_impl()
 : _Tp_alloc_type(), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }
 _Deque_impl(const _Tp_alloc_type& __a)
 : _Tp_alloc_type(__a), _M_map(0), _M_map_size(0),
   _M_start(), _M_finish()
 { }
      };
      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
      _Map_alloc_type
      _M_get_map_allocator() const
      { return _Map_alloc_type(_M_get_Tp_allocator()); }
      _Tp*
      _M_allocate_node()
      {
 return _M_impl._Tp_alloc_type::allocate(__deque_buf_size(sizeof(_Tp)));
      }
      void
      _M_deallocate_node(_Tp* __p)
      {
 _M_impl._Tp_alloc_type::deallocate(__p, __deque_buf_size(sizeof(_Tp)));
      }
      _Tp**
      _M_allocate_map(size_t __n)
      { return _M_get_map_allocator().allocate(__n); }
      void
      _M_deallocate_map(_Tp** __p, size_t __n)
      { _M_get_map_allocator().deallocate(__p, __n); }
    protected:
      void _M_initialize_map(size_t);
      void _M_create_nodes(_Tp** __nstart, _Tp** __nfinish);
      void _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish);
      enum { _S_initial_map_size = 8 };
      _Deque_impl _M_impl;
    };
  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base()
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
      + 1);
      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);
      _Tp** __nstart = (this->_M_impl._M_map
   + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Tp** __nfinish = __nstart + __num_nodes;
      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = 0;
   this->_M_impl._M_map_size = 0;
   throw;
 }
      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      _Tp** __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)
    {
      for (_Tp** __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {
      typedef typename _Alloc::value_type _Alloc_value_type;
     
     
      typedef _Deque_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
    protected:
      typedef pointer* _Map_pointer;
      static size_t _S_buffer_size()
      { return __deque_buf_size(sizeof(_Tp)); }
      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;
      using _Base::_M_impl;
    public:
      deque()
      : _Base() { }
      explicit
      deque(const allocator_type& __a)
      : _Base(__a, 0) { }
      explicit
      deque(size_type __n, const value_type& __value = value_type(),
     const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
      deque(const deque& __x)
      : _Base(__x._M_get_Tp_allocator(), __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }
      deque(deque&& __x)
      : _Base(std::forward<_Base>(__x)) { }
      deque(initializer_list<value_type> __l,
     const allocator_type& __a = allocator_type())
 : _Base(__a)
        {
   _M_range_initialize(__l.begin(), __l.end(),
         random_access_iterator_tag());
 }
      template<typename _InputIterator>
        deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }
      ~deque()
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
      deque&
      operator=(const deque& __x);
      deque&
      operator=(deque&& __x)
      {
 this->clear();
 this->swap(__x);
 return *this;
      }
      deque&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }
      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }
      iterator
      begin()
      { return this->_M_impl._M_start; }
      const_iterator
      begin() const
      { return this->_M_impl._M_start; }
      iterator
      end()
      { return this->_M_impl._M_finish; }
      const_iterator
      end() const
      { return this->_M_impl._M_finish; }
      reverse_iterator
      rbegin()
      { return reverse_iterator(this->_M_impl._M_finish); }
      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->_M_impl._M_finish); }
      reverse_iterator
      rend()
      { return reverse_iterator(this->_M_impl._M_start); }
      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->_M_impl._M_start); }
      const_iterator
      cbegin() const
      { return this->_M_impl._M_start; }
      const_iterator
      cend() const
      { return this->_M_impl._M_finish; }
      const_reverse_iterator
      crbegin() const
      { return const_reverse_iterator(this->_M_impl._M_finish); }
      const_reverse_iterator
      crend() const
      { return const_reverse_iterator(this->_M_impl._M_start); }
      size_type
      size() const
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }
      size_type
      max_size() const
      { return _M_get_Tp_allocator().max_size(); }
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 const size_type __len = size();
 if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start + difference_type(__new_size));
 else
   insert(this->_M_impl._M_finish, __new_size - __len, __x);
      }
      void
      shrink_to_fit()
      { std::__shrink_to_fit<deque>::_S_do_it(*this); }
      bool
      empty() const
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
      reference
      operator[](size_type __n)
      { return this->_M_impl._M_start[difference_type(__n)]; }
      const_reference
      operator[](size_type __n) const
      { return this->_M_impl._M_start[difference_type(__n)]; }
    protected:
      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("deque::_M_range_check"));
      }
    public:
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
      reference
      front()
      { return *begin(); }
      const_reference
      front() const
      { return *begin(); }
      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1, __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }
      void
      push_front(value_type&& __x)
      { emplace_front(std::move(__x)); }
      template<typename... _Args>
        void
        emplace_front(_Args&&... __args);
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     this->_M_impl.construct(this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }
      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }
      template<typename... _Args>
        void
        emplace_back(_Args&&... __args);
      void
      pop_front()
      {
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
      void
      pop_back()
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
      template<typename... _Args>
        iterator
        emplace(iterator __position, _Args&&... __args);
      iterator
      insert(iterator __position, const value_type& __x);
      iterator
      insert(iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
      void
      insert(iterator __p, initializer_list<value_type> __l)
      { this->insert(__p, __l.begin(), __l.end()); }
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
      iterator
      erase(iterator __position);
      iterator
      erase(iterator __first, iterator __last);
      void
      swap(deque& __x)
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_map, __x._M_impl._M_map);
 std::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);
 std::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),
          __x._M_get_Tp_allocator());
      }
      void
      clear()
      { _M_erase_at_end(begin()); }
    protected:
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_initialize_map(static_cast<size_type>(__n));
   _M_fill_initialize(__x);
 }
      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag);
      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag);
      void
      _M_fill_initialize(const value_type& __value);
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }
      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }
      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);
      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
        {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
   else
     _M_erase_at_end(std::copy(__first, __last, begin()));
 }
      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     insert(end(), __n - size(), __val);
   }
 else
   {
     _M_erase_at_end(begin() + difference_type(__n));
     std::fill(begin(), end(), __val);
   }
      }
      template<typename... _Args>
        void _M_push_back_aux(_Args&&... __args);
      template<typename... _Args>
        void _M_push_front_aux(_Args&&... __args);
      void _M_pop_back_aux();
      void _M_pop_front_aux();
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos,
      _Integer __n, _Integer __x, __true_type)
        { _M_fill_insert(__pos, __n, __x); }
      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
 }
      template<typename _InputIterator>
        void
        _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, std::input_iterator_tag);
      template<typename _ForwardIterator>
        void
        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag);
      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
      template<typename... _Args>
        iterator
        _M_insert_aux(iterator __pos, _Args&&... __args);
      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);
      template<typename _ForwardIterator>
        void
        _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);
      void
      _M_destroy_data_aux(iterator __first, iterator __last);
      template<typename _Alloc1>
        void
        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
        { _M_destroy_data_aux(__first, __last); }
      void
      _M_destroy_data(iterator __first, iterator __last,
        const std::allocator<_Tp>&)
      {
 if (!__has_trivial_destructor(value_type))
   _M_destroy_data_aux(__first, __last);
      }
      void
      _M_erase_at_begin(iterator __pos)
      {
 _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
 _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
 this->_M_impl._M_start = __pos;
      }
      void
      _M_erase_at_end(iterator __pos)
      {
 _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
 _M_destroy_nodes(__pos._M_node + 1,
    this->_M_impl._M_finish._M_node + 1);
 this->_M_impl._M_finish = __pos;
      }
      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
                               - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }
      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }
      void
      _M_new_elements_at_front(size_type __new_elements);
      void
      _M_new_elements_at_back(size_type __new_elements);
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }
      void
      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }
      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);
    };
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
             && std::equal(__x.begin(), __x.end(), __y.begin()); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }
  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    { __x.swap(__y); }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      const size_type __len = size();
      if (&__x != this)
 {
   if (__len >= __x.size())
     _M_erase_at_end(std::copy(__x.begin(), __x.end(),
          this->_M_impl._M_start));
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       insert(this->_M_impl._M_finish, __mid, __x.end());
     }
 }
      return *this;
    }
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      emplace_front(_Args&&... __args)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     this->_M_impl.construct(this->_M_impl._M_start._M_cur - 1,
        std::forward<_Args>(__args)...);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(std::forward<_Args>(__args)...);
      }
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     this->_M_impl.construct(this->_M_impl._M_finish._M_cur,
        std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(std::forward<_Args>(__args)...);
      }
  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      if (__position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
        return _M_insert_aux(__position, __x);
    }
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      emplace(iterator __position, _Args&&... __args)
      {
 if (__position._M_cur == this->_M_impl._M_start._M_cur)
   {
     push_front(std::forward<_Args>(__args)...);
     return this->_M_impl._M_start;
   }
 else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
   {
     push_back(std::forward<_Args>(__args)...);
     iterator __tmp = this->_M_impl._M_finish;
     --__tmp;
     return __tmp;
   }
 else
   return _M_insert_aux(__position, std::forward<_Args>(__args)...);
      }
  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const difference_type __index = __position - begin();
      if (static_cast<size_type>(__index) < (size() >> 1))
 {
   if (__position != begin())
     std::move_backward(begin(), __position, __next);
   pop_front();
 }
      else
 {
   if (__next != end())
     std::move(__next, end(), __position);
   pop_back();
 }
      return begin() + __index;
    }
  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
 {
   clear();
   return end();
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = __first - begin();
   if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
     {
       if (__first != begin())
  std::move_backward(begin(), __first, __last);
       _M_erase_at_begin(begin() + __n);
     }
   else
     {
       if (__last != end())
  std::move(__last, end(), __first);
       _M_erase_at_end(end() - __n);
     }
   return begin() + __elems_before;
 }
    }
  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
        iterator __cur = begin();
        for (; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          _M_erase_at_end(__cur);
        else
          insert(end(), __first, __last);
      }
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x, _M_get_Tp_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
        _M_insert_aux(__pos, __n, __x);
    }
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, _M_get_Tp_allocator());
          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }
  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      {
        this->_M_initialize_map(0);
        try
          {
            for (; __first != __last; ++__first)
              push_back(*__first);
          }
        catch(...)
          {
            clear();
            throw;
          }
      }
  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);
        _Map_pointer __cur_node;
        try
          {
            for (__cur_node = this->_M_impl._M_start._M_node;
                 __cur_node < this->_M_impl._M_finish._M_node;
                 ++__cur_node)
       {
  _ForwardIterator __mid = __first;
  std::advance(__mid, _S_buffer_size());
  std::__uninitialized_copy_a(__first, __mid, *__cur_node,
         _M_get_Tp_allocator());
  __first = __mid;
       }
            std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     _M_get_Tp_allocator());
          }
        catch(...)
          {
            std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     _M_get_Tp_allocator());
            throw;
          }
      }
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_back_aux(_Args&&... __args)
      {
 _M_reserve_map_at_back();
 *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
 try
   {
     this->_M_impl.construct(this->_M_impl._M_finish._M_cur,
        std::forward<_Args>(__args)...);
     this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
      + 1);
     this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
   }
 catch(...)
   {
     _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
     throw;
   }
      }
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_front_aux(_Args&&... __args)
      {
 _M_reserve_map_at_front();
 *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
 try
   {
     this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
            - 1);
     this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;
     this->_M_impl.construct(this->_M_impl._M_start._M_cur,
        std::forward<_Args>(__args)...);
   }
 catch(...)
   {
     ++this->_M_impl._M_start;
     _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
     throw;
   }
      }
  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      this->_M_impl.destroy(this->_M_impl._M_finish._M_cur);
    }
  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      this->_M_impl.destroy(this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }
  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }
  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         _M_get_Tp_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos, _Args&&... __args)
      {
 value_type __x_copy(std::forward<_Args>(__args)...);
 difference_type __index = __pos - this->_M_impl._M_start;
 if (static_cast<size_type>(__index) < size() / 2)
   {
     push_front(std::move(front()));
     iterator __front1 = this->_M_impl._M_start;
     ++__front1;
     iterator __front2 = __front1;
     ++__front2;
     __pos = this->_M_impl._M_start + __index;
     iterator __pos1 = __pos;
     ++__pos1;
     std::move(__front2, __pos1, __front1);
   }
 else
   {
     push_back(std::move(back()));
     iterator __back1 = this->_M_impl._M_finish;
     --__back1;
     iterator __back2 = __back1;
     --__back2;
     __pos = this->_M_impl._M_start + __index;
     std::move_backward(__pos, __back2, __back1);
   }
 *__pos = std::move(__x_copy);
 return __pos;
      }
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_move_a(this->_M_impl._M_start,
           __start_n, __new_start,
           _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::move(__start_n, __pos, __old_start);
    std::fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_move_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::move_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_move(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }
  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __start_n, __new_start,
      _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::move(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_move_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = this->_M_impl._M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = this->_M_impl._M_finish - __elemsafter;
          try
            {
              if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::move_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
              else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_move(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
            }
          catch(...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
              throw;
            }
        }
      }
   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
     __node < __last._M_node; ++__node)
  std::_Destroy(*__node, *__node + _S_buffer_size(),
         _M_get_Tp_allocator());
       if (__first._M_node != __last._M_node)
  {
    std::_Destroy(__first._M_cur, __first._M_last,
    _M_get_Tp_allocator());
    std::_Destroy(__last._M_first, __last._M_cur,
    _M_get_Tp_allocator());
  }
       else
  std::_Destroy(__first._M_cur, __last._M_cur,
         _M_get_Tp_allocator());
     }
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_front"));
      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
          throw;
        }
    }
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_back"));
      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
          throw;
        }
    }
  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;
      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
        this->_M_impl._M_finish._M_node + 1,
        __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
                              + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;
   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }
      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }
  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
           __node < __last._M_node; ++__node)
 std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);
      if (__first._M_node != __last._M_node)
 {
   std::fill(__first._M_cur, __first._M_last, __value);
   std::fill(__last._M_first, __last._M_cur, __value);
 }
      else
 std::fill(__first._M_cur, __last._M_cur, __value);
    }
  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;
      difference_type __len = __last - __first;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, std::min(__first._M_last - __first._M_cur,
           __result._M_last - __result._M_cur));
   std::copy(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
   __first += __clen;
   __result += __clen;
   __len -= __clen;
 }
      return __result;
    }
  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;
      difference_type __len = __last - __first;
      while (__len > 0)
 {
   difference_type __llen = __last._M_cur - __last._M_first;
   _Tp* __lend = __last._M_cur;
   difference_type __rlen = __result._M_cur - __result._M_first;
   _Tp* __rend = __result._M_cur;
   if (!__llen)
     {
       __llen = _Self::_S_buffer_size();
       __lend = *(__last._M_node - 1) + __llen;
     }
   if (!__rlen)
     {
       __rlen = _Self::_S_buffer_size();
       __rend = *(__result._M_node - 1) + __rlen;
     }
   const difference_type __clen = std::min(__len,
        std::min(__llen, __rlen));
   std::copy_backward(__lend - __clen, __lend, __rend);
   __last -= __clen;
   __result -= __clen;
   __len -= __clen;
 }
      return __result;
    }
  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;
      difference_type __len = __last - __first;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, std::min(__first._M_last - __first._M_cur,
           __result._M_last - __result._M_cur));
   std::move(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
   __first += __clen;
   __result += __clen;
   __len -= __clen;
 }
      return __result;
    }
  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;
      difference_type __len = __last - __first;
      while (__len > 0)
 {
   difference_type __llen = __last._M_cur - __last._M_first;
   _Tp* __lend = __last._M_cur;
   difference_type __rlen = __result._M_cur - __result._M_first;
   _Tp* __rend = __result._M_cur;
   if (!__llen)
     {
       __llen = _Self::_S_buffer_size();
       __lend = *(__last._M_node - 1) + __llen;
     }
   if (!__rlen)
     {
       __rlen = _Self::_S_buffer_size();
       __rend = *(__result._M_node - 1) + __rlen;
     }
   const difference_type __clen = std::min(__len,
        std::min(__llen, __rlen));
   std::move_backward(__lend - __clen, __lend, __rend);
   __last -= __clen;
   __result -= __clen;
   __len -= __clen;
 }
      return __result;
    }
}
       
namespace boost
{
    namespace detail
    {
        template< typename C >
        struct range_size
        {
            typedef typename C::size_type type;
        };
        template< typename Iterator >
        struct range_size< std::pair<Iterator,Iterator> >
        {
            typedef std::size_t type;
        };
        template< typename T, std::size_t sz >
        struct range_size< T[sz] >
        {
            typedef std::size_t type;
        };
    }
    template< class T >
    struct range_size :
        detail::range_size<T>
    { };
    template< class T >
    struct range_size<const T >
        : detail::range_size<T>
    { };
}
namespace boost
{
    template< class T >
    struct range_mutable_iterator<T*>
    {
        typedef T* type;
    };
    template< class T >
    struct range_const_iterator<T*>
    {
        typedef const T* type;
    };
    template< class T >
    struct range_size<T*>
    {
       typedef std::size_t type;
    };
}
       
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
  inline void*
  memchr(void* __s, int __c, size_t __n)
  { return __builtin_memchr(__s, __c, __n); }
  inline char*
  strchr(char* __s, int __n)
  { return __builtin_strchr(__s, __n); }
  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(__s1, __s2); }
  inline char*
  strrchr(char* __s, int __n)
  { return __builtin_strrchr(__s, __n); }
  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(__s1, __s2); }
}
       
       
namespace boost
{
    namespace range_detail
    {
        inline std::size_t length( const char* s )
        {
            return strlen( s );
        }
        inline std::size_t length( const wchar_t* s )
        {
            return wcslen( s );
        }
        inline bool is_char_ptr( char* )
        {
            return true;
        }
        inline bool is_char_ptr( const char* )
        {
            return true;
        }
        inline bool is_char_ptr( wchar_t* )
        {
            return true;
        }
        inline bool is_char_ptr( const wchar_t* )
        {
            return true;
        }
        template< class T >
        inline long is_char_ptr( T )
        {
            return 0L;
        }
        template< class T >
        inline iterator_range<T*>
        make_range( T* const r, bool )
        {
            return iterator_range<T*>( r, r + length(r) );
        }
        template< class T >
        inline iterator_range<typename range_iterator<T>::type>
        make_range( T& r, long )
        {
            return boost::make_iterator_range( r );
        }
    }
    template< class Range >
    inline iterator_range<typename range_iterator<Range>::type>
    as_literal( Range& r )
    {
        return range_detail::make_range( r, range_detail::is_char_ptr(r) );
    }
    template< class Range >
    inline iterator_range<typename range_iterator<const Range>::type>
    as_literal( const Range& r )
    {
        return range_detail::make_range( r, range_detail::is_char_ptr(r) );
    }
    template< class Char, std::size_t sz >
    inline iterator_range<Char*> as_literal( Char (&arr)[sz] )
    {
        return range_detail::make_range( arr, range_detail::is_char_ptr(arr) );
    }
    template< class Char, std::size_t sz >
    inline iterator_range<const Char*> as_literal( const Char (&arr)[sz] )
    {
        return range_detail::make_range( arr, range_detail::is_char_ptr(arr) );
    }
}
namespace boost {
    namespace algorithm {
        template<typename FinderT, typename IteratorT>
        struct FinderConcept
        {
        private:
            typedef iterator_range<IteratorT> range;
        public:
            void constraints()
            {
                r=(*pF)(i,i);
            }
        private:
            range r;
            IteratorT i;
            FinderT* pF;
        };
        template<typename FormatterT, typename FinderT, typename IteratorT>
        struct FormatterConcept
        {
        public:
            void constraints()
            {
                ::boost::begin((*pFo)( (*pF)(i,i) ));
                ::boost::end((*pFo)( (*pF)(i,i) ));
            }
        private:
            IteratorT i;
            FinderT* pF;
            FormatterT *pFo;
        };
    }
}
namespace boost {
    namespace algorithm {
        namespace detail {
            template<
                typename ForwardIteratorT,
                typename FormatterT,
                typename FormatResultT >
            class find_format_store :
                public iterator_range<ForwardIteratorT>
            {
            public:
                typedef iterator_range<ForwardIteratorT> base_type;
                typedef FormatterT formatter_type;
                typedef FormatResultT format_result_type;
            public:
                find_format_store(
                        const base_type& FindResult,
                        const format_result_type& FormatResult,
                        const formatter_type& Formatter ) :
                    base_type(FindResult),
                    m_FormatResult(FormatResult),
                    m_Formatter(Formatter) {}
                template< typename FindResultT >
                find_format_store& operator=( FindResultT FindResult )
                {
                    iterator_range<ForwardIteratorT>::operator=(FindResult);
                    if( !this->empty() ) {
                        m_FormatResult=m_Formatter(FindResult);
                    }
                    return *this;
                }
                const format_result_type& format_result()
                {
                    return m_FormatResult;
                }
            private:
                format_result_type m_FormatResult;
                const formatter_type& m_Formatter;
            };
            template<typename InputT, typename FindResultT>
            bool check_find_result(InputT&, FindResultT& FindResult)
            {
                typedef typename
                    range_const_iterator<InputT>::type input_iterator_type;
                iterator_range<input_iterator_type> ResultRange(FindResult);
                return !ResultRange.empty();
            }
        }
    }
}
namespace boost {
    namespace algorithm {
        template<int I> struct size_descriptor
        {
            typedef char (& type)[I];
        };
        typedef size_descriptor<1>::type yes_type;
        typedef size_descriptor<2>::type no_type;
    }
}
namespace boost {
    namespace algorithm {
        template< typename T >
        class has_native_replace
        {
        public:
            static const bool value=false;
            typedef mpl::bool_<has_native_replace<T>::value> type;
        };
        template< typename T >
        class has_stable_iterators
        {
        public:
            static const bool value=false;
            typedef mpl::bool_<has_stable_iterators<T>::value> type;
        };
        template< typename T >
        class has_const_time_insert
        {
        public:
            static const bool value=false;
            typedef mpl::bool_<has_const_time_insert<T>::value> type;
        };
        template< typename T >
        class has_const_time_erase
        {
        public:
            static const bool value=false;
            typedef mpl::bool_<has_const_time_erase<T>::value> type;
        };
    }
}
namespace boost {
    namespace algorithm {
        namespace detail {
            template< typename InputT, typename ForwardIteratorT >
            inline void insert(
                InputT& Input,
                typename InputT::iterator At,
                ForwardIteratorT Begin,
                ForwardIteratorT End )
            {
                Input.insert( At, Begin, End );
            }
            template< typename InputT, typename InsertT >
            inline void insert(
                InputT& Input,
                typename InputT::iterator At,
                const InsertT& Insert )
            {
                ::boost::algorithm::detail::insert( Input, At, ::boost::begin(Insert), ::boost::end(Insert) );
            }
            template< typename InputT >
            inline typename InputT::iterator erase(
                InputT& Input,
                typename InputT::iterator From,
                typename InputT::iterator To )
            {
                return Input.erase( From, To );
            }
            template< bool HasConstTimeOperations >
            struct replace_const_time_helper
            {
                template< typename InputT, typename ForwardIteratorT >
                void operator()(
                    InputT& Input,
                    typename InputT::iterator From,
                    typename InputT::iterator To,
                    ForwardIteratorT Begin,
                    ForwardIteratorT End )
                {
                    ForwardIteratorT InsertIt=Begin;
                    typename InputT::iterator InputIt=From;
                    for(; InsertIt!=End && InputIt!=To; InsertIt++, InputIt++ )
                    {
                        *InputIt=*InsertIt;
                    }
                    if ( InsertIt!=End )
                    {
                        Input.insert( InputIt, InsertIt, End );
                    }
                    else
                    {
                        if ( InputIt!=To )
                        {
                            Input.erase( InputIt, To );
                        }
                    }
                }
            };
            template<>
            struct replace_const_time_helper< true >
            {
                template< typename InputT, typename ForwardIteratorT >
                void operator()(
                    InputT& Input,
                    typename InputT::iterator From,
                    typename InputT::iterator To,
                    ForwardIteratorT Begin,
                    ForwardIteratorT End )
                {
                    typename InputT::iterator At=Input.erase( From, To );
                    if ( Begin!=End )
                    {
                        if(!Input.empty())
                        {
                            Input.insert( At, Begin, End );
                        }
                        else
                        {
                            Input.insert( Input.begin(), Begin, End );
                        }
                    }
                }
            };
            template< bool HasNative >
            struct replace_native_helper
            {
                template< typename InputT, typename ForwardIteratorT >
                void operator()(
                    InputT& Input,
                    typename InputT::iterator From,
                    typename InputT::iterator To,
                    ForwardIteratorT Begin,
                    ForwardIteratorT End )
                {
                    replace_const_time_helper<
                        boost::mpl::and_<
                            has_const_time_insert<InputT>,
                            has_const_time_erase<InputT> >::value >()(
                        Input, From, To, Begin, End );
                }
            };
            template<>
            struct replace_native_helper< true >
            {
                template< typename InputT, typename ForwardIteratorT >
                void operator()(
                    InputT& Input,
                    typename InputT::iterator From,
                    typename InputT::iterator To,
                    ForwardIteratorT Begin,
                    ForwardIteratorT End )
                {
                    Input.replace( From, To, Begin, End );
                }
            };
            template< typename InputT, typename ForwardIteratorT >
            inline void replace(
                InputT& Input,
                typename InputT::iterator From,
                typename InputT::iterator To,
                ForwardIteratorT Begin,
                ForwardIteratorT End )
            {
                replace_native_helper< has_native_replace<InputT>::value >()(
                    Input, From, To, Begin, End );
            }
            template< typename InputT, typename InsertT >
            inline void replace(
                InputT& Input,
                typename InputT::iterator From,
                typename InputT::iterator To,
                const InsertT& Insert )
            {
                if(From!=To)
                {
                    ::boost::algorithm::detail::replace( Input, From, To, ::boost::begin(Insert), ::boost::end(Insert) );
                }
                else
                {
                    ::boost::algorithm::detail::insert( Input, From, ::boost::begin(Insert), ::boost::end(Insert) );
                }
            }
        }
    }
}
namespace boost {
    namespace algorithm {
        namespace detail {
            template< typename StorageT, typename OutputIteratorT >
            inline OutputIteratorT move_from_storage(
                StorageT& Storage,
                OutputIteratorT DestBegin,
                OutputIteratorT DestEnd )
            {
                OutputIteratorT OutputIt=DestBegin;
                while( !Storage.empty() && OutputIt!=DestEnd )
                {
                    *OutputIt=Storage.front();
                    Storage.pop_front();
                    ++OutputIt;
                }
                return OutputIt;
            }
            template< typename StorageT, typename WhatT >
            inline void copy_to_storage(
                StorageT& Storage,
                const WhatT& What )
            {
                Storage.insert( Storage.end(), ::boost::begin(What), ::boost::end(What) );
            }
            template< bool HasStableIterators >
            struct process_segment_helper
            {
                template<
                    typename StorageT,
                    typename InputT,
                    typename ForwardIteratorT >
                ForwardIteratorT operator()(
                    StorageT& Storage,
                    InputT& ,
                    ForwardIteratorT InsertIt,
                    ForwardIteratorT SegmentBegin,
                    ForwardIteratorT SegmentEnd )
                {
                    ForwardIteratorT It=::boost::algorithm::detail::move_from_storage( Storage, InsertIt, SegmentBegin );
                    if( Storage.empty() )
                    {
                        if( It==SegmentBegin )
                        {
                            return SegmentEnd;
                        }
                        else
                        {
                            return std::copy( SegmentBegin, SegmentEnd, It );
                        }
                    }
                    else
                    {
                        while( It!=SegmentEnd )
                        {
                            Storage.push_back( *It );
                            *It=Storage.front();
                            Storage.pop_front();
                            ++It;
                        }
                        return It;
                    }
                }
            };
            template<>
            struct process_segment_helper< true >
            {
                template<
                    typename StorageT,
                    typename InputT,
                    typename ForwardIteratorT >
                ForwardIteratorT operator()(
                    StorageT& Storage,
                    InputT& Input,
                    ForwardIteratorT InsertIt,
                    ForwardIteratorT SegmentBegin,
                    ForwardIteratorT SegmentEnd )
                {
                    ::boost::algorithm::detail::replace( Input, InsertIt, SegmentBegin, Storage );
                    Storage.clear();
                    return SegmentEnd;
                }
            };
            template<
                typename StorageT,
                typename InputT,
                typename ForwardIteratorT >
            inline ForwardIteratorT process_segment(
                StorageT& Storage,
                InputT& Input,
                ForwardIteratorT InsertIt,
                ForwardIteratorT SegmentBegin,
                ForwardIteratorT SegmentEnd )
            {
                return
                    process_segment_helper<
                        has_stable_iterators<InputT>::value>()(
                                Storage, Input, InsertIt, SegmentBegin, SegmentEnd );
            }
        }
    }
}
namespace boost {
    namespace algorithm {
        namespace detail {
           template<
                typename OutputIteratorT,
                typename InputT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline OutputIteratorT find_format_copy_impl2(
                OutputIteratorT Output,
                const InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult,
                const FormatResultT& FormatResult )
            {
                typedef find_format_store<
                    typename
                        range_const_iterator<InputT>::type,
                        FormatterT,
                        FormatResultT > store_type;
                store_type M( FindResult, FormatResult, Formatter );
                if ( !M )
                {
                    Output = std::copy( ::boost::begin(Input), ::boost::end(Input), Output );
                    return Output;
                }
                Output = std::copy( ::boost::begin(Input), ::boost::begin(M), Output );
                Output = std::copy( ::boost::begin(M.format_result()), ::boost::end(M.format_result()), Output );
                Output = std::copy( M.end(), ::boost::end(Input), Output );
                return Output;
            }
            template<
                typename OutputIteratorT,
                typename InputT,
                typename FormatterT,
                typename FindResultT >
            inline OutputIteratorT find_format_copy_impl(
                OutputIteratorT Output,
                const InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult )
            {
                if( ::boost::algorithm::detail::check_find_result(Input, FindResult) ) {
                    return ::boost::algorithm::detail::find_format_copy_impl2(
                        Output,
                        Input,
                        Formatter,
                        FindResult,
                        Formatter(FindResult) );
                } else {
                    return std::copy( ::boost::begin(Input), ::boost::end(Input), Output );
                }
            }
           template<
                typename InputT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline InputT find_format_copy_impl2(
                const InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult,
                const FormatResultT& FormatResult)
            {
                typedef find_format_store<
                    typename
                        range_const_iterator<InputT>::type,
                        FormatterT,
                        FormatResultT > store_type;
                store_type M( FindResult, FormatResult, Formatter );
                if ( !M )
                {
                    return InputT( Input );
                }
                InputT Output;
                insert( Output, ::boost::end(Output), ::boost::begin(Input), M.begin() );
                insert( Output, ::boost::end(Output), M.format_result() );
                insert( Output, ::boost::end(Output), M.end(), ::boost::end(Input) );
                return Output;
            }
            template<
                typename InputT,
                typename FormatterT,
                typename FindResultT >
            inline InputT find_format_copy_impl(
                const InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult)
            {
                if( ::boost::algorithm::detail::check_find_result(Input, FindResult) ) {
                    return ::boost::algorithm::detail::find_format_copy_impl2(
                        Input,
                        Formatter,
                        FindResult,
                        Formatter(FindResult) );
                } else {
                    return Input;
                }
            }
            template<
                typename InputT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline void find_format_impl2(
                InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult,
                const FormatResultT& FormatResult)
            {
                typedef find_format_store<
                    typename
                        range_iterator<InputT>::type,
                        FormatterT,
                        FormatResultT > store_type;
                store_type M( FindResult, FormatResult, Formatter );
                if ( !M )
                {
                    return;
                }
                ::boost::algorithm::detail::replace( Input, M.begin(), M.end(), M.format_result() );
            }
            template<
                typename InputT,
                typename FormatterT,
                typename FindResultT >
            inline void find_format_impl(
                InputT& Input,
                FormatterT Formatter,
                const FindResultT& FindResult)
            {
                if( ::boost::algorithm::detail::check_find_result(Input, FindResult) ) {
                    ::boost::algorithm::detail::find_format_impl2(
                        Input,
                        Formatter,
                        FindResult,
                        Formatter(FindResult) );
                }
            }
        }
    }
}
namespace boost {
    namespace algorithm {
        namespace detail {
           template<
                typename OutputIteratorT,
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline OutputIteratorT find_format_all_copy_impl2(
                OutputIteratorT Output,
                const InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                const FindResultT& FindResult,
                const FormatResultT& FormatResult )
            {
                typedef typename
                    range_const_iterator<InputT>::type input_iterator_type;
                typedef find_format_store<
                        input_iterator_type,
                        FormatterT,
                        FormatResultT > store_type;
                store_type M( FindResult, FormatResult, Formatter );
                input_iterator_type LastMatch=::boost::begin(Input);
                while( M )
                {
                    Output = std::copy( LastMatch, M.begin(), Output );
                    Output = std::copy( ::boost::begin(M.format_result()), ::boost::end(M.format_result()), Output );
                    LastMatch=M.end();
                    M=Finder( LastMatch, ::boost::end(Input) );
                }
                Output = std::copy( LastMatch, ::boost::end(Input), Output );
                return Output;
            }
            template<
                typename OutputIteratorT,
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT >
            inline OutputIteratorT find_format_all_copy_impl(
                OutputIteratorT Output,
                const InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                const FindResultT& FindResult )
            {
                if( ::boost::algorithm::detail::check_find_result(Input, FindResult) ) {
                    return ::boost::algorithm::detail::find_format_all_copy_impl2(
                        Output,
                        Input,
                        Finder,
                        Formatter,
                        FindResult,
                        Formatter(FindResult) );
                } else {
                    return std::copy( ::boost::begin(Input), ::boost::end(Input), Output );
                }
            }
           template<
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline InputT find_format_all_copy_impl2(
                const InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                const FindResultT& FindResult,
                const FormatResultT& FormatResult)
            {
                typedef typename
                    range_const_iterator<InputT>::type input_iterator_type;
                typedef find_format_store<
                        input_iterator_type,
                        FormatterT,
                        FormatResultT > store_type;
                store_type M( FindResult, FormatResult, Formatter );
                input_iterator_type LastMatch=::boost::begin(Input);
                InputT Output;
                while( M )
                {
                    insert( Output, ::boost::end(Output), LastMatch, M.begin() );
                    insert( Output, ::boost::end(Output), M.format_result() );
                    LastMatch=M.end();
                    M=Finder( LastMatch, ::boost::end(Input) );
                }
                ::boost::algorithm::detail::insert( Output, ::boost::end(Output), LastMatch, ::boost::end(Input) );
                return Output;
            }
            template<
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT >
            inline InputT find_format_all_copy_impl(
                const InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                const FindResultT& FindResult)
            {
                if( ::boost::algorithm::detail::check_find_result(Input, FindResult) ) {
                    return ::boost::algorithm::detail::find_format_all_copy_impl2(
                        Input,
                        Finder,
                        Formatter,
                        FindResult,
                        Formatter(FindResult) );
                } else {
                    return Input;
                }
            }
            template<
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT,
                typename FormatResultT >
            inline void find_format_all_impl2(
                InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                FindResultT FindResult,
                FormatResultT FormatResult)
            {
                typedef typename
                    range_iterator<InputT>::type input_iterator_type;
                typedef find_format_store<
                        input_iterator_type,
                        FormatterT,
                        FormatResultT > store_type;
                store_type M( FindResult, FormatResult, Formatter );
                std::deque<
                    typename range_value<InputT>::type> Storage;
                input_iterator_type InsertIt=::boost::begin(Input);
                input_iterator_type SearchIt=::boost::begin(Input);
                while( M )
                {
                    InsertIt=process_segment(
                        Storage,
                        Input,
                        InsertIt,
                        SearchIt,
                        M.begin() );
                    SearchIt=M.end();
                    ::boost::algorithm::detail::copy_to_storage( Storage, M.format_result() );
                    M=Finder( SearchIt, ::boost::end(Input) );
                }
                InsertIt=::boost::algorithm::detail::process_segment(
                    Storage,
                    Input,
                    InsertIt,
                    SearchIt,
                    ::boost::end(Input) );
                if ( Storage.empty() )
                {
                    ::boost::algorithm::detail::erase( Input, InsertIt, ::boost::end(Input) );
                }
                else
                {
                    ::boost::algorithm::detail::insert( Input, ::boost::end(Input), Storage.begin(), Storage.end() );
                }
            }
            template<
                typename InputT,
                typename FinderT,
                typename FormatterT,
                typename FindResultT >
            inline void find_format_all_impl(
                InputT& Input,
                FinderT Finder,
                FormatterT Formatter,
                FindResultT FindResult)
            {
                if( ::boost::algorithm::detail::check_find_result(Input, FindResult) ) {
                    ::boost::algorithm::detail::find_format_all_impl2(
                        Input,
                        Finder,
                        Formatter,
                        FindResult,
                        Formatter(FindResult) );
                }
            }
        }
    }
}
namespace boost {
    namespace algorithm {
        template<
            typename OutputIteratorT,
            typename RangeT,
            typename FinderT,
            typename FormatterT>
        inline OutputIteratorT find_format_copy(
            OutputIteratorT Output,
            const RangeT& Input,
            FinderT Finder,
            FormatterT Formatter )
        {
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FinderConcept< FinderT, typename range_const_iterator<RangeT>::type> )>::failed> boost_concept_check69;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FormatterConcept< FormatterT, FinderT,typename range_const_iterator<RangeT>::type> )>::failed> boost_concept_check74;
            iterator_range<typename range_const_iterator<RangeT>::type> lit_input(::boost::as_literal(Input));
            return detail::find_format_copy_impl(
                Output,
                lit_input,
                Formatter,
                Finder( ::boost::begin(lit_input), ::boost::end(lit_input) ) );
        }
        template<
            typename SequenceT,
            typename FinderT,
            typename FormatterT>
        inline SequenceT find_format_copy(
            const SequenceT& Input,
            FinderT Finder,
            FormatterT Formatter )
        {
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FinderConcept< FinderT, typename range_const_iterator<SequenceT>::type> )>::failed> boost_concept_check103;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FormatterConcept< FormatterT, FinderT,typename range_const_iterator<SequenceT>::type> )>::failed> boost_concept_check108;
            return detail::find_format_copy_impl(
                Input,
                Formatter,
                Finder(::boost::begin(Input), ::boost::end(Input)));
        }
        template<
            typename SequenceT,
            typename FinderT,
            typename FormatterT>
        inline void find_format(
            SequenceT& Input,
            FinderT Finder,
            FormatterT Formatter)
        {
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FinderConcept< FinderT, typename range_const_iterator<SequenceT>::type> )>::failed> boost_concept_check139;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FormatterConcept< FormatterT, FinderT,typename range_const_iterator<SequenceT>::type> )>::failed> boost_concept_check144;
            detail::find_format_impl(
                Input,
                Formatter,
                Finder(::boost::begin(Input), ::boost::end(Input)));
        }
        template<
            typename OutputIteratorT,
            typename RangeT,
            typename FinderT,
            typename FormatterT>
        inline OutputIteratorT find_format_all_copy(
            OutputIteratorT Output,
            const RangeT& Input,
            FinderT Finder,
            FormatterT Formatter)
        {
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FinderConcept< FinderT, typename range_const_iterator<RangeT>::type> )>::failed> boost_concept_check188;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FormatterConcept< FormatterT, FinderT,typename range_const_iterator<RangeT>::type> )>::failed> boost_concept_check193;
            iterator_range<typename range_const_iterator<RangeT>::type> lit_input(::boost::as_literal(Input));
            return detail::find_format_all_copy_impl(
                Output,
                lit_input,
                Finder,
                Formatter,
                Finder(::boost::begin(lit_input), ::boost::end(lit_input)));
        }
        template<
            typename SequenceT,
            typename FinderT,
            typename FormatterT >
        inline SequenceT find_format_all_copy(
            const SequenceT& Input,
            FinderT Finder,
            FormatterT Formatter )
        {
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FinderConcept< FinderT, typename range_const_iterator<SequenceT>::type> )>::failed> boost_concept_check223;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FormatterConcept< FormatterT, FinderT,typename range_const_iterator<SequenceT>::type> )>::failed> boost_concept_check228;
            return detail::find_format_all_copy_impl(
                Input,
                Finder,
                Formatter,
                Finder( ::boost::begin(Input), ::boost::end(Input) ) );
        }
        template<
            typename SequenceT,
            typename FinderT,
            typename FormatterT >
        inline void find_format_all(
            SequenceT& Input,
            FinderT Finder,
            FormatterT Formatter )
        {
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FinderConcept< FinderT, typename range_const_iterator<SequenceT>::type> )>::failed> boost_concept_check261;
            typedef ::boost::concepts::detail::instantiate< &::boost::concepts::requirement_<void(*)( FormatterConcept< FormatterT, FinderT,typename range_const_iterator<SequenceT>::type> )>::failed> boost_concept_check266;
            detail::find_format_all_impl(
                Input,
                Finder,
                Formatter,
                Finder(::boost::begin(Input), ::boost::end(Input)));
        }
    }
    using algorithm::find_format_copy;
    using algorithm::find_format;
    using algorithm::find_format_all_copy;
    using algorithm::find_format_all;
}
namespace boost {
    namespace algorithm {
    enum token_compress_mode_type
    {
        token_compress_on,
        token_compress_off
    };
    }
    using algorithm::token_compress_on;
    using algorithm::token_compress_off;
}
namespace boost {
    namespace algorithm {
        namespace detail {
            template<typename SearchIteratorT,typename PredicateT>
            struct first_finderF
            {
                typedef SearchIteratorT search_iterator_type;
                template< typename SearchT >
                first_finderF( const SearchT& Search, PredicateT Comp ) :
                    m_Search(::boost::begin(Search), ::boost::end(Search)), m_Comp(Comp) {}
                first_finderF(
                        search_iterator_type SearchBegin,
                        search_iterator_type SearchEnd,
                        PredicateT Comp ) :
                    m_Search(SearchBegin, SearchEnd), m_Comp(Comp) {}
                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    typedef iterator_range<ForwardIteratorT> result_type;
                    typedef ForwardIteratorT input_iterator_type;
                    for(input_iterator_type OuterIt=Begin;
                        OuterIt!=End;
                        ++OuterIt)
                    {
                        if( boost::empty(m_Search) )
                            return result_type( End, End );
                        input_iterator_type InnerIt=OuterIt;
                        search_iterator_type SubstrIt=m_Search.begin();
                        for(;
                            InnerIt!=End && SubstrIt!=m_Search.end();
                            ++InnerIt,++SubstrIt)
                        {
                            if( !( m_Comp(*InnerIt,*SubstrIt) ) )
                                break;
                        }
                        if ( SubstrIt==m_Search.end() )
                            return result_type( OuterIt, InnerIt );
                    }
                    return result_type( End, End );
                }
            private:
                iterator_range<search_iterator_type> m_Search;
                PredicateT m_Comp;
            };
            template<typename SearchIteratorT, typename PredicateT>
            struct last_finderF
            {
                typedef SearchIteratorT search_iterator_type;
                typedef first_finderF<
                    search_iterator_type,
                    PredicateT> first_finder_type;
                template< typename SearchT >
                last_finderF( const SearchT& Search, PredicateT Comp ) :
                    m_Search(::boost::begin(Search), ::boost::end(Search)), m_Comp(Comp) {}
                last_finderF(
                        search_iterator_type SearchBegin,
                        search_iterator_type SearchEnd,
                        PredicateT Comp ) :
                    m_Search(SearchBegin, SearchEnd), m_Comp(Comp) {}
                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    typedef iterator_range<ForwardIteratorT> result_type;
                    if( boost::empty(m_Search) )
                        return result_type( End, End );
                    typedef typename boost::detail::
                        iterator_traits<ForwardIteratorT>::iterator_category category;
                    return findit( Begin, End, category() );
                }
            private:
                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                findit(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End,
                    std::forward_iterator_tag ) const
                {
                    typedef ForwardIteratorT input_iterator_type;
                    typedef iterator_range<ForwardIteratorT> result_type;
                    first_finder_type first_finder(
                        m_Search.begin(), m_Search.end(), m_Comp );
                    result_type M=first_finder( Begin, End );
                    result_type Last=M;
                    while( M )
                    {
                        Last=M;
                        M=first_finder( ::boost::end(M), End );
                    }
                    return Last;
                }
                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                findit(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End,
                    std::bidirectional_iterator_tag ) const
                {
                    typedef iterator_range<ForwardIteratorT> result_type;
                    typedef ForwardIteratorT input_iterator_type;
                    for(input_iterator_type OuterIt=End;
                        OuterIt!=Begin; )
                    {
                        input_iterator_type OuterIt2=--OuterIt;
                        input_iterator_type InnerIt=OuterIt2;
                        search_iterator_type SubstrIt=m_Search.begin();
                        for(;
                            InnerIt!=End && SubstrIt!=m_Search.end();
                            ++InnerIt,++SubstrIt)
                        {
                            if( !( m_Comp(*InnerIt,*SubstrIt) ) )
                                break;
                        }
                        if( SubstrIt==m_Search.end() )
                            return result_type( OuterIt2, InnerIt );
                    }
                    return result_type( End, End );
                }
            private:
                iterator_range<search_iterator_type> m_Search;
                PredicateT m_Comp;
            };
            template<typename SearchIteratorT, typename PredicateT>
            struct nth_finderF
            {
                typedef SearchIteratorT search_iterator_type;
                typedef first_finderF<
                    search_iterator_type,
                    PredicateT> first_finder_type;
                typedef last_finderF<
                    search_iterator_type,
                    PredicateT> last_finder_type;
                template< typename SearchT >
                nth_finderF(
                        const SearchT& Search,
                        int Nth,
                        PredicateT Comp) :
                    m_Search(::boost::begin(Search), ::boost::end(Search)),
                    m_Nth(Nth),
                    m_Comp(Comp) {}
                nth_finderF(
                        search_iterator_type SearchBegin,
                        search_iterator_type SearchEnd,
                        int Nth,
                        PredicateT Comp) :
                    m_Search(SearchBegin, SearchEnd),
                    m_Nth(Nth),
                    m_Comp(Comp) {}
                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    if(m_Nth>=0)
                    {
                        return find_forward(Begin, End, m_Nth);
                    }
                    else
                    {
                        return find_backward(Begin, End, -m_Nth);
                    }
                }
            private:
                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                find_forward(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End,
                    unsigned int N) const
                {
                    typedef ForwardIteratorT input_iterator_type;
                    typedef iterator_range<ForwardIteratorT> result_type;
                    if( boost::empty(m_Search) )
                        return result_type( End, End );
                    first_finder_type first_finder(
                        m_Search.begin(), m_Search.end(), m_Comp );
                    result_type M( Begin, Begin );
                    for( unsigned int n=0; n<=N; ++n )
                    {
                        M=first_finder( ::boost::end(M), End );
                        if ( !M )
                        {
                            return M;
                        }
                    }
                    return M;
                }
                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                find_backward(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End,
                    unsigned int N) const
                {
                    typedef ForwardIteratorT input_iterator_type;
                    typedef iterator_range<ForwardIteratorT> result_type;
                    if( boost::empty(m_Search) )
                        return result_type( End, End );
                    last_finder_type last_finder(
                        m_Search.begin(), m_Search.end(), m_Comp );
                    result_type M( End, End );
                    for( unsigned int n=1; n<=N; ++n )
                    {
                        M=last_finder( Begin, ::boost::begin(M) );
                        if ( !M )
                        {
                            return M;
                        }
                    }
                    return M;
                }
            private:
                iterator_range<search_iterator_type> m_Search;
                int m_Nth;
                PredicateT m_Comp;
            };
            template<typename ForwardIteratorT>
                iterator_range<ForwardIteratorT>
            find_head_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N,
                std::forward_iterator_tag )
            {
                typedef ForwardIteratorT input_iterator_type;
                typedef iterator_range<ForwardIteratorT> result_type;
                input_iterator_type It=Begin;
                for(
                    unsigned int Index=0;
                    Index<N && It!=End; ++Index,++It ) {};
                return result_type( Begin, It );
            }
            template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
            find_head_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N,
                std::random_access_iterator_tag )
            {
                typedef ForwardIteratorT input_iterator_type;
                typedef iterator_range<ForwardIteratorT> result_type;
                if ( (End<=Begin) || ( static_cast<unsigned int>(End-Begin) < N ) )
                    return result_type( Begin, End );
                return result_type(Begin,Begin+N);
            }
            template<typename ForwardIteratorT>
                iterator_range<ForwardIteratorT>
            find_head_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N )
            {
                typedef typename boost::detail::
                    iterator_traits<ForwardIteratorT>::iterator_category category;
                return ::boost::algorithm::detail::find_head_impl( Begin, End, N, category() );
            }
            template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
            find_tail_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N,
                std::forward_iterator_tag )
            {
                typedef ForwardIteratorT input_iterator_type;
                typedef iterator_range<ForwardIteratorT> result_type;
                unsigned int Index=0;
                input_iterator_type It=Begin;
                input_iterator_type It2=Begin;
                for( Index=0; Index<N && It2!=End; ++Index,++It2 ) {};
                for(; It2!=End; ++It,++It2 ) {};
                return result_type( It, It2 );
            }
            template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
            find_tail_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N,
                std::bidirectional_iterator_tag )
            {
                typedef ForwardIteratorT input_iterator_type;
                typedef iterator_range<ForwardIteratorT> result_type;
                input_iterator_type It=End;
                for(
                    unsigned int Index=0;
                    Index<N && It!=Begin; ++Index,--It ) {};
                return result_type( It, End );
            }
            template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
            find_tail_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N,
                std::random_access_iterator_tag )
            {
                typedef ForwardIteratorT input_iterator_type;
                typedef iterator_range<ForwardIteratorT> result_type;
                if ( (End<=Begin) || ( static_cast<unsigned int>(End-Begin) < N ) )
                    return result_type( Begin, End );
                return result_type( End-N, End );
            }
            template< typename ForwardIteratorT >
            iterator_range<ForwardIteratorT>
            find_tail_impl(
                ForwardIteratorT Begin,
                ForwardIteratorT End,
                unsigned int N )
            {
                typedef typename boost::detail::
                    iterator_traits<ForwardIteratorT>::iterator_category category;
                return ::boost::algorithm::detail::find_tail_impl( Begin, End, N, category() );
            }
            struct head_finderF
            {
                head_finderF( int N ) : m_N(N) {}
                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    if(m_N>=0)
                    {
                        return ::boost::algorithm::detail::find_head_impl( Begin, End, m_N );
                    }
                    else
                    {
                        iterator_range<ForwardIteratorT> Res=
                            ::boost::algorithm::detail::find_tail_impl( Begin, End, -m_N );
                        return ::boost::make_iterator_range(Begin, Res.begin());
                    }
                }
            private:
                int m_N;
            };
            struct tail_finderF
            {
                tail_finderF( int N ) : m_N(N) {}
                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    if(m_N>=0)
                    {
                        return ::boost::algorithm::detail::find_tail_impl( Begin, End, m_N );
                    }
                    else
                    {
                        iterator_range<ForwardIteratorT> Res=
                            ::boost::algorithm::detail::find_head_impl( Begin, End, -m_N );
                        return ::boost::make_iterator_range(Res.end(), End);
                    }
                }
            private:
                int m_N;
            };
            template< typename PredicateT >
            struct token_finderF
            {
                token_finderF(
                    PredicateT Pred,
                    token_compress_mode_type eCompress=token_compress_off ) :
                        m_Pred(Pred), m_eCompress(eCompress) {}
                template< typename ForwardIteratorT >
                iterator_range<ForwardIteratorT>
                operator()(
                    ForwardIteratorT Begin,
                    ForwardIteratorT End ) const
                {
                    typedef iterator_range<ForwardIteratorT> result_type;
                    ForwardIteratorT It=std::find_if( Begin, End, m_Pred );
                    if( It==End )
                    {
                        return result_type( End, End );
                    }
                    else
                    {
                        ForwardIteratorT It2=It;
                        if( m_eCompress==token_compress_on )
                        {
                            while( It2!=End && m_Pred(*It2) ) ++It2;
                        }
                        else
                        {
                            ++It2;
                        }
                        return result_type( It, It2 );
                    }
                }
            private:
                PredicateT m_Pred;
                token_compress_mode_type m_eCompress;
            };
            template<typename ForwardIterator1T>
            struct range_finderF
            {
                typedef ForwardIterator1T input_iterator_type;
                typedef iterator_range<input_iterator_type> result_type;
                range_finderF(
                    input_iterator_type Begin,
                    input_iterator_type End ) : m_Range(Begin, End) {}
                range_finderF(const iterator_range<input_iterator_type>& Range) :
                    m_Range(Range) {}
                template< typename ForwardIterator2T >
                iterator_range<ForwardIterator2T>
                operator()(
                    ForwardIterator2T,
                    ForwardIterator2T ) const
                {
                    return m_Range;
                }
            private:
                iterator_range<input_iterator_type> m_Range;
            };
        }
    }
}
namespace boost {
    namespace algorithm {
        struct is_equal
        {
            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {
                return Arg1==Arg2;
            }
        };
        struct is_iequal
        {
            is_iequal( const std::locale& Loc=std::locale() ) :
                m_Loc( Loc ) {}
            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {
                    return std::toupper<T1>(Arg1,m_Loc)==std::toupper<T2>(Arg2,m_Loc);
            }
        private:
            std::locale m_Loc;
        };
        struct is_less
        {
            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {
                return Arg1<Arg2;
            }
        };
        struct is_iless
        {
            is_iless( const std::locale& Loc=std::locale() ) :
                m_Loc( Loc ) {}
            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {
                    return std::toupper<T1>(Arg1,m_Loc)<std::toupper<T2>(Arg2,m_Loc);
            }
        private:
            std::locale m_Loc;
        };
        struct is_not_greater
        {
            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {
                return Arg1<=Arg2;
            }
        };
        struct is_not_igreater
        {
            is_not_igreater( const std::locale& Loc=std::locale() ) :
                m_Loc( Loc ) {}
            template< typename T1, typename T2 >
                bool operator()( const T1& Arg1, const T2& Arg2 ) const
            {
                    return std::toupper<T1>(Arg1,m_Loc)<=std::toupper<T2>(Arg2,m_Loc);
            }
        private:
            std::locale m_Loc;
        };
    }
    using algorithm::is_equal;
    using algorithm::is_iequal;
    using algorithm::is_less;
    using algorithm::is_iless;
    using algorithm::is_not_greater;
    using algorithm::is_not_igreater;
}
namespace boost {
    namespace algorithm {
        template<typename RangeT>
        inline detail::first_finderF<
            typename range_const_iterator<RangeT>::type,
            is_equal>
        first_finder( const RangeT& Search )
        {
            return
                detail::first_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                        is_equal>( ::boost::as_literal(Search), is_equal() ) ;
        }
        template<typename RangeT,typename PredicateT>
        inline detail::first_finderF<
            typename range_const_iterator<RangeT>::type,
            PredicateT>
        first_finder(
            const RangeT& Search, PredicateT Comp )
        {
            return
                detail::first_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                    PredicateT>( ::boost::as_literal(Search), Comp );
        }
        template<typename RangeT>
        inline detail::last_finderF<
            typename range_const_iterator<RangeT>::type,
            is_equal>
        last_finder( const RangeT& Search )
        {
            return
                detail::last_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                    is_equal>( ::boost::as_literal(Search), is_equal() );
        }
        template<typename RangeT, typename PredicateT>
        inline detail::last_finderF<
            typename range_const_iterator<RangeT>::type,
            PredicateT>
        last_finder( const RangeT& Search, PredicateT Comp )
        {
            return
                detail::last_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                    PredicateT>( ::boost::as_literal(Search), Comp ) ;
        }
        template<typename RangeT>
        inline detail::nth_finderF<
            typename range_const_iterator<RangeT>::type,
            is_equal>
        nth_finder(
            const RangeT& Search,
            int Nth)
        {
            return
                detail::nth_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                    is_equal>( ::boost::as_literal(Search), Nth, is_equal() ) ;
        }
        template<typename RangeT, typename PredicateT>
        inline detail::nth_finderF<
            typename range_const_iterator<RangeT>::type,
            PredicateT>
        nth_finder(
            const RangeT& Search,
            int Nth,
            PredicateT Comp )
        {
            return
                detail::nth_finderF<
                    typename
                        range_const_iterator<RangeT>::type,
                    PredicateT>( ::boost::as_literal(Search), Nth, Comp );
        }
        inline detail::head_finderF
        head_finder( int N )
        {
            return detail::head_finderF(N);
        }
        inline detail::tail_finderF
        tail_finder( int N )
        {
            return detail::tail_finderF(N);
        }
        template< typename PredicateT >
        inline detail::token_finderF<PredicateT>
        token_finder(
            PredicateT Pred,
            token_compress_mode_type eCompress=token_compress_off )
        {
            return detail::token_finderF<PredicateT>( Pred, eCompress );
        }
        template< typename ForwardIteratorT >
        inline detail::range_finderF<ForwardIteratorT>
        range_finder(
            ForwardIteratorT Begin,
            ForwardIteratorT End )
        {
            return detail::range_finderF<ForwardIteratorT>( Begin, End );
        }
        template< typename ForwardIteratorT >
        inline detail::range_finderF<ForwardIteratorT>
        range_finder( iterator_range<ForwardIteratorT> Range )
        {
            return detail::range_finderF<ForwardIteratorT>( Range );
        }
    }
    using algorithm::first_finder;
    using algorithm::last_finder;
    using algorithm::nth_finder;
    using algorithm::head_finder;
    using algorithm::tail_finder;
    using algorithm::token_finder;
    using algorithm::range_finder;
}
namespace boost {
    namespace algorithm {
        namespace detail {
            template< typename CharT >
            struct empty_container
            {
                typedef empty_container<CharT> type;
                typedef CharT value_type;
                typedef std::size_t size_type;
                typedef std::ptrdiff_t difference_type;
                typedef const value_type& reference;
                typedef const value_type& const_reference;
                typedef const value_type* iterator;
                typedef const value_type* const_iterator;
                const_iterator begin() const
                {
                    return reinterpret_cast<const_iterator>(0);
                }
                const_iterator end() const
                {
                    return reinterpret_cast<const_iterator>(0);
                }
                bool empty() const
                {
                    return false;
                }
                size_type size() const
                {
                    return 0;
                }
            };
            template<typename InputIteratorT, typename OutputIteratorT>
            inline OutputIteratorT bounded_copy(
                InputIteratorT First,
                InputIteratorT Last,
                OutputIteratorT DestFirst,
                OutputIteratorT DestLast )
            {
                InputIteratorT InputIt=First;
                OutputIteratorT OutputIt=DestFirst;
                for(; InputIt!=Last && OutputIt!=DestLast; InputIt++, OutputIt++ )
                {
                    *OutputIt=*InputIt;
                }
                return OutputIt;
            }
            template<
                typename SeqT,
                typename IteratorT=typename SeqT::const_iterator >
            struct copy_iterator_rangeF :
                public std::unary_function< iterator_range<IteratorT>, SeqT >
            {
                SeqT operator()( const iterator_range<IteratorT>& Range ) const
                {
                    return copy_range<SeqT>(Range);
                }
            };
        }
    }
}
namespace boost {
    namespace algorithm {
        namespace detail {
            template<typename RangeT>
            struct const_formatF
            {
            private:
                typedef typename
                    range_const_iterator<RangeT>::type format_iterator;
                typedef iterator_range<format_iterator> result_type;
            public:
                const_formatF(const RangeT& Format) :
                    m_Format(::boost::begin(Format), ::boost::end(Format)) {}
                template<typename Range2T>
                const result_type& operator()(const Range2T&) const
                {
                    return m_Format;
                }
            private:
                result_type m_Format;
            };
            template<typename RangeT>
            struct identity_formatF
            {
                template< typename Range2T >
                const RangeT& operator()(const Range2T& Replace) const
                {
                    return RangeT(::boost::begin(Replace), ::boost::end(Replace));
                }
            };
            template< typename CharT >
            struct empty_formatF
            {
                template< typename ReplaceT >
                empty_container<CharT> operator()(const ReplaceT&) const
                {
                    return empty_container<CharT>();
                }
            };
            template<typename FinderT>
            struct dissect_formatF
            {
            public:
                dissect_formatF(FinderT Finder) :
                  m_Finder(Finder) {}
                  template<typename RangeT>
                  inline iterator_range<
                      typename range_const_iterator<RangeT>::type>
                  operator()(const RangeT& Replace) const
                  {
                      return m_Finder(::boost::begin(Replace), ::boost::end(Replace));
                  }
            private:
                FinderT m_Finder;
            };
        }
    }
}
namespace boost {
    namespace algorithm {
        template<typename RangeT>
        inline detail::const_formatF<
            iterator_range<
                typename range_const_iterator<RangeT>::type> >
        const_formatter(const RangeT& Format)
        {
            return detail::const_formatF<
                iterator_range<
                    typename range_const_iterator<RangeT>::type> >(::boost::as_literal(Format));
        }
        template<typename RangeT>
        inline detail::identity_formatF<
            iterator_range<
                typename range_const_iterator<RangeT>::type> >
        identity_formatter()
        {
            return detail::identity_formatF<
                iterator_range<
                    typename range_const_iterator<RangeT>::type> >();
        }
        template<typename RangeT>
        inline detail::empty_formatF<
            typename range_value<RangeT>::type>
        empty_formatter(const RangeT&)
        {
            return detail::empty_formatF<
                typename range_value<RangeT>::type>();
        }
        template<typename FinderT>
        inline detail::dissect_formatF< FinderT >
        dissect_formatter(const FinderT& Finder)
        {
            return detail::dissect_formatF<FinderT>(Finder);
        }
    }
    using algorithm::const_formatter;
    using algorithm::identity_formatter;
    using algorithm::empty_formatter;
    using algorithm::dissect_formatter;
}
namespace boost {
    namespace algorithm {
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T>
        inline OutputIteratorT replace_range_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const iterator_range<
                typename
                    range_const_iterator<Range1T>::type>& SearchRange,
            const Range2T& Format)
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::range_finder(SearchRange),
                ::boost::algorithm::const_formatter(Format));
        }
        template<typename SequenceT, typename RangeT>
        inline SequenceT replace_range_copy(
            const SequenceT& Input,
            const iterator_range<
                typename
                    range_const_iterator<SequenceT>::type>& SearchRange,
            const RangeT& Format)
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::range_finder(SearchRange),
                ::boost::algorithm::const_formatter(Format));
        }
        template<typename SequenceT, typename RangeT>
        inline void replace_range(
            SequenceT& Input,
            const iterator_range<
                typename
                    range_iterator<SequenceT>::type>& SearchRange,
            const RangeT& Format)
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::range_finder(SearchRange),
                ::boost::algorithm::const_formatter(Format));
        }
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT replace_first_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format)
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::first_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT replace_first_copy(
            const SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::first_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void replace_first(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::first_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT ireplace_first_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format,
            const std::locale& Loc=std::locale() )
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename Range2T, typename Range1T>
        inline SequenceT ireplace_first_copy(
            const SequenceT& Input,
            const Range2T& Search,
            const Range1T& Format,
            const std::locale& Loc=std::locale() )
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void ireplace_first(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT replace_last_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::last_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT replace_last_copy(
            const SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::last_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void replace_last(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::last_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT ireplace_last_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format,
            const std::locale& Loc=std::locale() )
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::last_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT ireplace_last_copy(
            const SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::last_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void ireplace_last(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::last_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT replace_nth_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            int Nth,
            const Range3T& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::nth_finder(Search, Nth),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT replace_nth_copy(
            const SequenceT& Input,
            const Range1T& Search,
            int Nth,
            const Range2T& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::nth_finder(Search, Nth),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void replace_nth(
            SequenceT& Input,
            const Range1T& Search,
            int Nth,
            const Range2T& Format )
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::nth_finder(Search, Nth),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT ireplace_nth_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            int Nth,
            const Range3T& Format,
            const std::locale& Loc=std::locale() )
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::nth_finder(Search, Nth, is_iequal(Loc) ),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT ireplace_nth_copy(
            const SequenceT& Input,
            const Range1T& Search,
            int Nth,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::nth_finder(Search, Nth, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void ireplace_nth(
            SequenceT& Input,
            const Range1T& Search,
            int Nth,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::nth_finder(Search, Nth, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT replace_all_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format )
        {
            return ::boost::algorithm::find_format_all_copy(
                Output,
                Input,
                ::boost::algorithm::first_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT replace_all_copy(
            const SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            return ::boost::algorithm::find_format_all_copy(
                Input,
                ::boost::algorithm::first_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void replace_all(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format )
        {
            ::boost::algorithm::find_format_all(
                Input,
                ::boost::algorithm::first_finder(Search),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T,
            typename Range3T>
        inline OutputIteratorT ireplace_all_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            const Range2T& Search,
            const Range3T& Format,
            const std::locale& Loc=std::locale() )
        {
            return ::boost::algorithm::find_format_all_copy(
                Output,
                Input,
                ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline SequenceT ireplace_all_copy(
            const SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            return ::boost::algorithm::find_format_all_copy(
                Input,
                ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename Range1T, typename Range2T>
        inline void ireplace_all(
            SequenceT& Input,
            const Range1T& Search,
            const Range2T& Format,
            const std::locale& Loc=std::locale() )
        {
            ::boost::algorithm::find_format_all(
                Input,
                ::boost::algorithm::first_finder(Search, is_iequal(Loc)),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T>
        inline OutputIteratorT replace_head_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            int N,
            const Range2T& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::head_finder(N),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename RangeT>
        inline SequenceT replace_head_copy(
            const SequenceT& Input,
            int N,
            const RangeT& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::head_finder(N),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename RangeT>
        inline void replace_head(
            SequenceT& Input,
            int N,
            const RangeT& Format )
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::head_finder(N),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<
            typename OutputIteratorT,
            typename Range1T,
            typename Range2T>
        inline OutputIteratorT replace_tail_copy(
            OutputIteratorT Output,
            const Range1T& Input,
            int N,
            const Range2T& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Output,
                Input,
                ::boost::algorithm::tail_finder(N),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename RangeT>
        inline SequenceT replace_tail_copy(
            const SequenceT& Input,
            int N,
            const RangeT& Format )
        {
            return ::boost::algorithm::find_format_copy(
                Input,
                ::boost::algorithm::tail_finder(N),
                ::boost::algorithm::const_formatter(Format) );
        }
        template<typename SequenceT, typename RangeT>
        inline void replace_tail(
            SequenceT& Input,
            int N,
            const RangeT& Format )
        {
            ::boost::algorithm::find_format(
                Input,
                ::boost::algorithm::tail_finder(N),
                ::boost::algorithm::const_formatter(Format) );
        }
    }
    using algorithm::replace_range_copy;
    using algorithm::replace_range;
    using algorithm::replace_first_copy;
    using algorithm::replace_first;
    using algorithm::ireplace_first_copy;
    using algorithm::ireplace_first;
    using algorithm::replace_last_copy;
    using algorithm::replace_last;
    using algorithm::ireplace_last_copy;
    using algorithm::ireplace_last;
    using algorithm::replace_nth_copy;
    using algorithm::replace_nth;
    using algorithm::ireplace_nth_copy;
    using algorithm::ireplace_nth;
    using algorithm::replace_all_copy;
    using algorithm::replace_all;
    using algorithm::ireplace_all_copy;
    using algorithm::ireplace_all;
    using algorithm::replace_head_copy;
    using algorithm::replace_head;
    using algorithm::replace_tail_copy;
    using algorithm::replace_tail;
}
namespace boost {
namespace units {
namespace detail {
inline
std::string
demangle(const char* name)
{
    char* realname;
    std::size_t len;
    int stat;
    realname = abi::__cxa_demangle(name,__null,&len,&stat);
    if (realname != __null)
    {
        std::string out(realname);
        std::free(realname);
        boost::replace_all(out,"boost::units::","");
        return out;
    }
    return std::string("demangle :: error - unable to demangle specified symbol");
}
}
template<class L>
std::string simplify_typename(const L& )
{
    const std::string demangled = detail::demangle(typeid(L).name());
    return demangled;
}
}
}
namespace
boost
    {
    template <class T>
    inline
    std::string
    tag_type_name()
        {
        return units::detail::demangle(typeid(T*).name());
        }
    template <class T>
    inline
    std::string
    type_name()
        {
        return units::detail::demangle(typeid(T).name());
        }
    namespace
    exception_detail
        {
        struct
        type_info_
            {
            detail::sp_typeinfo const * type_;
            explicit
            type_info_( detail::sp_typeinfo const & type ):
                type_(&type)
                {
                }
            friend
            bool
            operator<( type_info_ const & a, type_info_ const & b )
                {
                return 0!=(a.type_->before(*b.type_));
                }
            };
        }
    }
namespace
boost
    {
    namespace
    exception_detail
        {
        template <class ErrorInfo>
        struct
        get_info
            {
            static
            typename ErrorInfo::value_type *
            get( exception const & x )
                {
                if( exception_detail::error_info_container * c=x.data_.get() )
                    if( shared_ptr<exception_detail::error_info_base> eib = c->get(::boost::exception_detail::type_info_(typeid(ErrorInfo))) )
                        {
                        (__builtin_expect(!(0!=dynamic_cast<ErrorInfo *>(eib.get())), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/exception/get_error_info.hpp", 38, "0!=dynamic_cast<ErrorInfo *>(eib.get())") : (void)0);
                        ErrorInfo * w = static_cast<ErrorInfo *>(eib.get());
                        return &w->value();
                        }
                return 0;
                }
            };
        template <>
        struct
        get_info<throw_function>
            {
            static
            char const * *
            get( exception const & x )
                {
                return x.throw_function_ ? &x.throw_function_ : 0;
                }
            };
        template <>
        struct
        get_info<throw_file>
            {
            static
            char const * *
            get( exception const & x )
                {
                return x.throw_file_ ? &x.throw_file_ : 0;
                }
            };
        template <>
        struct
        get_info<throw_line>
            {
            static
            int *
            get( exception const & x )
                {
                return x.throw_line_!=-1 ? &x.throw_line_ : 0;
                }
            };
        template <class T,class R>
        struct
        get_error_info_return_type
            {
            typedef R * type;
            };
        template <class T,class R>
        struct
        get_error_info_return_type<T const,R>
            {
            typedef R const * type;
            };
        }
    template <class ErrorInfo,class E>
    inline
    typename exception_detail::get_error_info_return_type<E,typename ErrorInfo::value_type>::type
    get_error_info( E & some_exception )
        {
        if( exception const * x = dynamic_cast<exception const *>(&some_exception) )
            return exception_detail::get_info<ErrorInfo>::get(*x);
        else
            return 0;
        }
    }
       
       
       
       
namespace
boost
    {
    namespace
    to_string_detail
        {
        struct
        partial_ordering_helper1
            {
            template <class CharT,class Traits>
            partial_ordering_helper1( std::basic_ostream<CharT,Traits> & );
            };
        struct
        partial_ordering_helper2
            {
            template <class T>
            partial_ordering_helper2( T const & );
            };
        char operator<<( partial_ordering_helper1, partial_ordering_helper2 );
        template <class T,class CharT,class Traits>
        struct
        is_output_streamable_impl
            {
            static std::basic_ostream<CharT,Traits> & f();
            static T const & g();
            enum e { value=1!=(sizeof(f()<<g())) };
            };
        }
    template <class T, class CharT=char, class Traits=std::char_traits<CharT> >
    struct
    is_output_streamable
        {
        enum e { value=to_string_detail::is_output_streamable_impl<T,CharT,Traits>::value };
        };
    }
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
    protected:
      ios_base::openmode _M_mode;
      __string_type _M_string;
    public:
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {
     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
      void
      str(const __string_type& __s)
      {
 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }
    protected:
      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }
      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }
      virtual int_type
      underflow();
      virtual int_type
      pbackfail(int_type __c = traits_type::eof());
      virtual int_type
      overflow(int_type __c = traits_type::eof());
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {
     _M_string.clear();
     _M_sync(__s, __n, 0);
   }
 return this;
      }
      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);
      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);
      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);
      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }
    };
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;
    private:
      __stringbuf_type _M_stringbuf;
    public:
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }
      ~basic_istringstream()
      { }
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }
      __string_type
      str() const
      { return _M_stringbuf.str(); }
      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;
    private:
      __stringbuf_type _M_stringbuf;
    public:
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }
      ~basic_ostringstream()
      { }
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }
      __string_type
      str() const
      { return _M_stringbuf.str(); }
      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;
    private:
      __stringbuf_type _M_stringbuf;
    public:
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }
      ~basic_stringstream()
      { }
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }
      __string_type
      str() const
      { return _M_stringbuf.str(); }
      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {
   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }
  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();
      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);
      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();
      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }
  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {
   _M_update_egptr();
   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }
  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);
      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();
   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;
   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->gbump((__beg + __newoffi) - this->gptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       this->pbump((__beg + __newoffo) - this->pptr());
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }
  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();
   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->gbump((__beg + __pos) - this->gptr());
       if (__testout)
                this->pbump((__beg + __pos) - this->pptr());
       __ret = __sp;
     }
 }
      return __ret;
    }
  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();
      if (__base != _M_string.data())
 {
   __endg += __i;
   __i = 0;
   __endp = __endg;
 }
      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   this->setp(__base, __endp);
   this->pbump(__o);
   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }
  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;
  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;
}
namespace
boost
    {
    namespace
    to_string_detail
        {
        template <class T>
        typename disable_if<is_output_streamable<T>,char>::type to_string( T const & );
        template <class,bool IsOutputStreamable>
        struct has_to_string_impl;
        template <class T>
        struct
        has_to_string_impl<T,true>
            {
            enum e { value=1 };
            };
        template <class T>
        struct
        has_to_string_impl<T,false>
            {
            static T const & f();
            enum e { value=1!=sizeof(to_string(f())) };
            };
        }
    template <class T>
    inline
    typename enable_if<is_output_streamable<T>,std::string>::type
    to_string( T const & x )
        {
        std::ostringstream out;
        out << x;
        return out.str();
        }
    template <class T>
    struct
    has_to_string
        {
        enum e { value=to_string_detail::has_to_string_impl<T,is_output_streamable<T>::value>::value };
        };
    template <class T,class U>
    inline
    std::string
    to_string( std::pair<T,U> const & x )
        {
        return std::string("(") + to_string(x.first) + ',' + to_string(x.second) + ')';
        }
    inline
    std::string
    to_string( std::exception const & x )
        {
        return x.what();
        }
    }
       
       
       
namespace
boost
    {
    namespace
    exception_detail
        {
        template <class T>
        inline
        std::string
        object_hex_dump( T const & x, std::size_t max_size=16 )
            {
            std::ostringstream s;
            s << "type: " << type_name<T>() << ", size: " << sizeof(T) << ", dump: ";
            std::size_t n=sizeof(T)>max_size?max_size:sizeof(T);
            s.fill('0');
            s.width(2);
            unsigned char const * b=reinterpret_cast<unsigned char const *>(&x);
            s << std::setw(2) << std::hex << (unsigned int)*b;
            for( unsigned char const * e=b+n; ++b!=e; )
                s << " " << std::setw(2) << std::hex << (unsigned int)*b;
            return s.str();
            }
        }
    }
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
}
namespace
boost
    {
    namespace
    exception_detail
        {
        template <bool ToStringAvailable>
        struct
        to_string_dispatcher
            {
            template <class T,class Stub>
            static
            std::string
            convert( T const & x, Stub )
                {
                return to_string(x);
                }
            };
        template <>
        struct
        to_string_dispatcher<false>
            {
            template <class T,class Stub>
            static
            std::string
            convert( T const & x, Stub s )
                {
                return s(x);
                }
            template <class T>
            static
            std::string
            convert( T const & x, std::string s )
                {
                return s;
                }
            template <class T>
            static
            std::string
            convert( T const & x, char const * s )
                {
                (__builtin_expect(!(s!=0), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/exception/to_string_stub.hpp", 63, "s!=0") : (void)0);
                return s;
                }
            };
        namespace
        to_string_dispatch
            {
            template <class T,class Stub>
            inline
            std::string
            dispatch( T const & x, Stub s )
                {
                return to_string_dispatcher<has_to_string<T>::value>::convert(x,s);
                }
            }
        template <class T>
        inline
        std::string
        string_stub_dump( T const & x )
            {
            return "[ " + exception_detail::object_hex_dump(x) + " ]";
            }
        }
    template <class T>
    inline
    std::string
    to_string_stub( T const & x )
        {
        return exception_detail::to_string_dispatch::dispatch(x,&exception_detail::string_stub_dump<T>);
        }
    template <class T,class Stub>
    inline
    std::string
    to_string_stub( T const & x, Stub s )
        {
        return exception_detail::to_string_dispatch::dispatch(x,s);
        }
    }
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  enum _Rb_tree_color { _S_red = false, _S_black = true };
  struct _Rb_tree_node_base
  {
    typedef _Rb_tree_node_base* _Base_ptr;
    typedef const _Rb_tree_node_base* _Const_Base_ptr;
    _Rb_tree_color _M_color;
    _Base_ptr _M_parent;
    _Base_ptr _M_left;
    _Base_ptr _M_right;
    static _Base_ptr
    _S_minimum(_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }
    static _Const_Base_ptr
    _S_minimum(_Const_Base_ptr __x)
    {
      while (__x->_M_left != 0) __x = __x->_M_left;
      return __x;
    }
    static _Base_ptr
    _S_maximum(_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
    static _Const_Base_ptr
    _S_maximum(_Const_Base_ptr __x)
    {
      while (__x->_M_right != 0) __x = __x->_M_right;
      return __x;
    }
  };
  template<typename _Val>
    struct _Rb_tree_node : public _Rb_tree_node_base
    {
      typedef _Rb_tree_node<_Val>* _Link_type;
      _Val _M_value_field;
      template<typename... _Args>
        _Rb_tree_node(_Args&&... __args)
 : _Rb_tree_node_base(),
   _M_value_field(std::forward<_Args>(__args)...) { }
    };
  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();
  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();
  __attribute__ ((__pure__)) _Rb_tree_node_base*
  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();
  __attribute__ ((__pure__)) const _Rb_tree_node_base*
  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();
  template<typename _Tp>
    struct _Rb_tree_iterator
    {
      typedef _Tp value_type;
      typedef _Tp& reference;
      typedef _Tp* pointer;
      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;
      typedef _Rb_tree_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;
      typedef _Rb_tree_node<_Tp>* _Link_type;
      _Rb_tree_iterator()
      : _M_node() { }
      explicit
      _Rb_tree_iterator(_Link_type __x)
      : _M_node(__x) { }
      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }
      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }
      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }
      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }
      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }
      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }
      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }
      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }
      _Base_ptr _M_node;
  };
  template<typename _Tp>
    struct _Rb_tree_const_iterator
    {
      typedef _Tp value_type;
      typedef const _Tp& reference;
      typedef const _Tp* pointer;
      typedef _Rb_tree_iterator<_Tp> iterator;
      typedef bidirectional_iterator_tag iterator_category;
      typedef ptrdiff_t difference_type;
      typedef _Rb_tree_const_iterator<_Tp> _Self;
      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;
      typedef const _Rb_tree_node<_Tp>* _Link_type;
      _Rb_tree_const_iterator()
      : _M_node() { }
      explicit
      _Rb_tree_const_iterator(_Link_type __x)
      : _M_node(__x) { }
      _Rb_tree_const_iterator(const iterator& __it)
      : _M_node(__it._M_node) { }
      reference
      operator*() const
      { return static_cast<_Link_type>(_M_node)->_M_value_field; }
      pointer
      operator->() const
      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }
      _Self&
      operator++()
      {
 _M_node = _Rb_tree_increment(_M_node);
 return *this;
      }
      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_increment(_M_node);
 return __tmp;
      }
      _Self&
      operator--()
      {
 _M_node = _Rb_tree_decrement(_M_node);
 return *this;
      }
      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _Rb_tree_decrement(_M_node);
 return __tmp;
      }
      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }
      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }
      _Base_ptr _M_node;
    };
  template<typename _Val>
    inline bool
    operator==(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }
  template<typename _Val>
    inline bool
    operator!=(const _Rb_tree_iterator<_Val>& __x,
               const _Rb_tree_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }
  void
  _Rb_tree_insert_and_rebalance(const bool __insert_left,
                                _Rb_tree_node_base* __x,
                                _Rb_tree_node_base* __p,
                                _Rb_tree_node_base& __header) throw ();
  _Rb_tree_node_base*
  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,
          _Rb_tree_node_base& __header) throw ();
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc = allocator<_Val> >
    class _Rb_tree
    {
      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other
              _Node_allocator;
    protected:
      typedef _Rb_tree_node_base* _Base_ptr;
      typedef const _Rb_tree_node_base* _Const_Base_ptr;
    public:
      typedef _Key key_type;
      typedef _Val value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef _Rb_tree_node<_Val>* _Link_type;
      typedef const _Rb_tree_node<_Val>* _Const_Link_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
      _Node_allocator&
      _M_get_Node_allocator()
      { return *static_cast<_Node_allocator*>(&this->_M_impl); }
      const _Node_allocator&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }
      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }
    protected:
      _Link_type
      _M_get_node()
      { return _M_impl._Node_allocator::allocate(1); }
      void
      _M_put_node(_Link_type __p)
      { _M_impl._Node_allocator::deallocate(__p, 1); }
      template<typename... _Args>
        _Link_type
        _M_create_node(_Args&&... __args)
 {
   _Link_type __tmp = _M_get_node();
   try
     {
       _M_get_Node_allocator().construct(__tmp,
          std::forward<_Args>(__args)...);
     }
   catch(...)
     {
       _M_put_node(__tmp);
       throw;
     }
   return __tmp;
 }
      void
      _M_destroy_node(_Link_type __p)
      {
 _M_get_Node_allocator().destroy(__p);
 _M_put_node(__p);
      }
      _Link_type
      _M_clone_node(_Const_Link_type __x)
      {
 _Link_type __tmp = _M_create_node(__x->_M_value_field);
 __tmp->_M_color = __x->_M_color;
 __tmp->_M_left = 0;
 __tmp->_M_right = 0;
 return __tmp;
      }
    protected:
      template<typename _Key_compare,
        bool _Is_pod_comparator = __is_pod(_Key_compare)>
        struct _Rb_tree_impl : public _Node_allocator
        {
   _Key_compare _M_key_compare;
   _Rb_tree_node_base _M_header;
   size_type _M_node_count;
   _Rb_tree_impl()
   : _Node_allocator(), _M_key_compare(), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }
   _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)
   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),
     _M_node_count(0)
   { _M_initialize(); }
 private:
   void
   _M_initialize()
   {
     this->_M_header._M_color = _S_red;
     this->_M_header._M_parent = 0;
     this->_M_header._M_left = &this->_M_header;
     this->_M_header._M_right = &this->_M_header;
   }
 };
      _Rb_tree_impl<_Compare> _M_impl;
    protected:
      _Base_ptr&
      _M_root()
      { return this->_M_impl._M_header._M_parent; }
      _Const_Base_ptr
      _M_root() const
      { return this->_M_impl._M_header._M_parent; }
      _Base_ptr&
      _M_leftmost()
      { return this->_M_impl._M_header._M_left; }
      _Const_Base_ptr
      _M_leftmost() const
      { return this->_M_impl._M_header._M_left; }
      _Base_ptr&
      _M_rightmost()
      { return this->_M_impl._M_header._M_right; }
      _Const_Base_ptr
      _M_rightmost() const
      { return this->_M_impl._M_header._M_right; }
      _Link_type
      _M_begin()
      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }
      _Const_Link_type
      _M_begin() const
      {
 return static_cast<_Const_Link_type>
   (this->_M_impl._M_header._M_parent);
      }
      _Link_type
      _M_end()
      { return static_cast<_Link_type>(&this->_M_impl._M_header); }
      _Const_Link_type
      _M_end() const
      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }
      static const_reference
      _S_value(_Const_Link_type __x)
      { return __x->_M_value_field; }
      static const _Key&
      _S_key(_Const_Link_type __x)
      { return _KeyOfValue()(_S_value(__x)); }
      static _Link_type
      _S_left(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_left); }
      static _Const_Link_type
      _S_left(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_left); }
      static _Link_type
      _S_right(_Base_ptr __x)
      { return static_cast<_Link_type>(__x->_M_right); }
      static _Const_Link_type
      _S_right(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x->_M_right); }
      static const_reference
      _S_value(_Const_Base_ptr __x)
      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }
      static const _Key&
      _S_key(_Const_Base_ptr __x)
      { return _KeyOfValue()(_S_value(__x)); }
      static _Base_ptr
      _S_minimum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }
      static _Const_Base_ptr
      _S_minimum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_minimum(__x); }
      static _Base_ptr
      _S_maximum(_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }
      static _Const_Base_ptr
      _S_maximum(_Const_Base_ptr __x)
      { return _Rb_tree_node_base::_S_maximum(__x); }
    public:
      typedef _Rb_tree_iterator<value_type> iterator;
      typedef _Rb_tree_const_iterator<value_type> const_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    private:
      iterator
      _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y,
   const value_type& __v);
      iterator
      _M_insert_lower(_Base_ptr __x, _Base_ptr __y, const value_type& __v);
      iterator
      _M_insert_equal_lower(const value_type& __x);
      _Link_type
      _M_copy(_Const_Link_type __x, _Link_type __p);
      void
      _M_erase(_Link_type __x);
      iterator
      _M_lower_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);
      const_iterator
      _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;
      iterator
      _M_upper_bound(_Link_type __x, _Link_type __y,
       const _Key& __k);
      const_iterator
      _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
       const _Key& __k) const;
    public:
      _Rb_tree() { }
      _Rb_tree(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_impl(__comp, __a) { }
      _Rb_tree(const _Rb_tree& __x)
      : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
      {
 if (__x._M_root() != 0)
   {
     _M_root() = _M_copy(__x._M_begin(), _M_end());
     _M_leftmost() = _S_minimum(_M_root());
     _M_rightmost() = _S_maximum(_M_root());
     _M_impl._M_node_count = __x._M_impl._M_node_count;
   }
      }
      _Rb_tree(_Rb_tree&& __x);
      ~_Rb_tree()
      { _M_erase(_M_begin()); }
      _Rb_tree&
      operator=(const _Rb_tree& __x);
      _Compare
      key_comp() const
      { return _M_impl._M_key_compare; }
      iterator
      begin()
      {
 return iterator(static_cast<_Link_type>
   (this->_M_impl._M_header._M_left));
      }
      const_iterator
      begin() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (this->_M_impl._M_header._M_left));
      }
      iterator
      end()
      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }
      const_iterator
      end() const
      {
 return const_iterator(static_cast<_Const_Link_type>
         (&this->_M_impl._M_header));
      }
      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }
      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }
      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }
      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
      bool
      empty() const
      { return _M_impl._M_node_count == 0; }
      size_type
      size() const
      { return _M_impl._M_node_count; }
      size_type
      max_size() const
      { return _M_get_Node_allocator().max_size(); }
      void
      swap(_Rb_tree& __t);
      pair<iterator, bool>
      _M_insert_unique(const value_type& __x);
      iterator
      _M_insert_equal(const value_type& __x);
      iterator
      _M_insert_unique_(const_iterator __position, const value_type& __x);
      iterator
      _M_insert_equal_(const_iterator __position, const value_type& __x);
      template<typename _InputIterator>
        void
        _M_insert_unique(_InputIterator __first, _InputIterator __last);
      template<typename _InputIterator>
        void
        _M_insert_equal(_InputIterator __first, _InputIterator __last);
      iterator
      erase(iterator __position);
      const_iterator
      erase(const_iterator __position);
      size_type
      erase(const key_type& __x);
      iterator
      erase(iterator __first, iterator __last);
      const_iterator
      erase(const_iterator __first, const_iterator __last);
      void
      erase(const key_type* __first, const key_type* __last);
      void
      clear()
      {
        _M_erase(_M_begin());
        _M_leftmost() = _M_end();
        _M_root() = 0;
        _M_rightmost() = _M_end();
        _M_impl._M_node_count = 0;
      }
      iterator
      find(const key_type& __k);
      const_iterator
      find(const key_type& __k) const;
      size_type
      count(const key_type& __k) const;
      iterator
      lower_bound(const key_type& __k)
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
      const_iterator
      lower_bound(const key_type& __k) const
      { return _M_lower_bound(_M_begin(), _M_end(), __k); }
      iterator
      upper_bound(const key_type& __k)
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }
      const_iterator
      upper_bound(const key_type& __k) const
      { return _M_upper_bound(_M_begin(), _M_end(), __k); }
      pair<iterator, iterator>
      equal_range(const key_type& __k);
      pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;
      bool
      __rb_verify() const;
    };
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return __x.size() == __y.size()
      && std::equal(__x.begin(), __x.end(), __y.begin());
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    {
      return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end());
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x == __y); }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return __y < __x; }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__y < __x); }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline bool
    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
        const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { return !(__x < __y); }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline void
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,
  _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _Rb_tree(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&& __x)
    : _M_impl(__x._M_impl._M_key_compare, __x._M_get_Node_allocator())
    {
      if (__x._M_root() != 0)
 {
   _M_root() = __x._M_root();
   _M_leftmost() = __x._M_leftmost();
   _M_rightmost() = __x._M_rightmost();
   _M_root()->_M_parent = _M_end();
   __x._M_root() = 0;
   __x._M_leftmost() = __x._M_end();
   __x._M_rightmost() = __x._M_end();
   this->_M_impl._M_node_count = __x._M_impl._M_node_count;
   __x._M_impl._M_node_count = 0;
 }
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)
    {
      if (this != &__x)
 {
   clear();
   _M_impl._M_key_compare = __x._M_impl._M_key_compare;
   if (__x._M_root() != 0)
     {
       _M_root() = _M_copy(__x._M_begin(), _M_end());
       _M_leftmost() = _S_minimum(_M_root());
       _M_rightmost() = _S_maximum(_M_root());
       _M_impl._M_node_count = __x._M_impl._M_node_count;
     }
 }
      return *this;
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || _M_impl._M_key_compare(_KeyOfValue()(__v),
            _S_key(__p)));
      _Link_type __z = _M_create_node(__v);
      _Rb_tree_insert_and_rebalance(__insert_left, __z,
        const_cast<_Base_ptr>(__p),
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_lower(_Base_ptr __x, _Base_ptr __p, const _Val& __v)
    {
      bool __insert_left = (__x != 0 || __p == _M_end()
       || !_M_impl._M_key_compare(_S_key(__p),
             _KeyOfValue()(__v)));
      _Link_type __z = _M_create_node(__v);
      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
        this->_M_impl._M_header);
      ++_M_impl._M_node_count;
      return iterator(__z);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_lower(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = !_M_impl._M_key_compare(_S_key(__x), _KeyOfValue()(__v)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_lower(__x, __y, __v);
    }
  template<typename _Key, typename _Val, typename _KoV,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type
    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::
    _M_copy(_Const_Link_type __x, _Link_type __p)
    {
      _Link_type __top = _M_clone_node(__x);
      __top->_M_parent = __p;
      try
 {
   if (__x->_M_right)
     __top->_M_right = _M_copy(_S_right(__x), __top);
   __p = __top;
   __x = _S_left(__x);
   while (__x != 0)
     {
       _Link_type __y = _M_clone_node(__x);
       __p->_M_left = __y;
       __y->_M_parent = __p;
       if (__x->_M_right)
  __y->_M_right = _M_copy(_S_right(__x), __y);
       __p = __y;
       __x = _S_left(__x);
     }
 }
      catch(...)
 {
   _M_erase(__top);
   throw;
 }
      return __top;
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_erase(_Link_type __x)
    {
      while (__x != 0)
 {
   _M_erase(_S_right(__x));
   _Link_type __y = _S_left(__x);
   _M_destroy_node(__x);
   __x = __y;
 }
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_lower_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (!_M_impl._M_key_compare(_S_key(__x), __k))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Link_type __x, _Link_type __y,
     const _Key& __k)
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return iterator(__y);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_upper_bound(_Const_Link_type __x, _Const_Link_type __y,
     const _Key& __k) const
    {
      while (__x != 0)
 if (_M_impl._M_key_compare(__k, _S_key(__x)))
   __y = __x, __x = _S_left(__x);
 else
   __x = _S_right(__x);
      return const_iterator(__y);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<iterator,
            iterator>(_M_lower_bound(__x, __y, __k),
        _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<iterator, iterator>(iterator(__y),
          iterator(__y));
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator,
  typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::const_iterator>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    equal_range(const _Key& __k) const
    {
      _Const_Link_type __x = _M_begin();
      _Const_Link_type __y = _M_end();
      while (__x != 0)
 {
   if (_M_impl._M_key_compare(_S_key(__x), __k))
     __x = _S_right(__x);
   else if (_M_impl._M_key_compare(__k, _S_key(__x)))
     __y = __x, __x = _S_left(__x);
   else
     {
       _Const_Link_type __xu(__x), __yu(__y);
       __y = __x, __x = _S_left(__x);
       __xu = _S_right(__xu);
       return pair<const_iterator,
            const_iterator>(_M_lower_bound(__x, __y, __k),
       _M_upper_bound(__xu, __yu, __k));
     }
 }
      return pair<const_iterator, const_iterator>(const_iterator(__y),
        const_iterator(__y));
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)
    {
      if (_M_root() == 0)
 {
   if (__t._M_root() != 0)
     {
       _M_root() = __t._M_root();
       _M_leftmost() = __t._M_leftmost();
       _M_rightmost() = __t._M_rightmost();
       _M_root()->_M_parent = _M_end();
       __t._M_root() = 0;
       __t._M_leftmost() = __t._M_end();
       __t._M_rightmost() = __t._M_end();
     }
 }
      else if (__t._M_root() == 0)
 {
   __t._M_root() = _M_root();
   __t._M_leftmost() = _M_leftmost();
   __t._M_rightmost() = _M_rightmost();
   __t._M_root()->_M_parent = __t._M_end();
   _M_root() = 0;
   _M_leftmost() = _M_end();
   _M_rightmost() = _M_end();
 }
      else
 {
   std::swap(_M_root(),__t._M_root());
   std::swap(_M_leftmost(),__t._M_leftmost());
   std::swap(_M_rightmost(),__t._M_rightmost());
   _M_root()->_M_parent = _M_end();
   __t._M_root()->_M_parent = __t._M_end();
 }
      std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);
      std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);
      std::__alloc_swap<_Node_allocator>::
 _S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
      _Compare, _Alloc>::iterator, bool>
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      bool __comp = true;
      while (__x != 0)
 {
   __y = __x;
   __comp = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x));
   __x = __comp ? _S_left(__x) : _S_right(__x);
 }
      iterator __j = iterator(__y);
      if (__comp)
 {
   if (__j == begin())
     return pair<iterator, bool>(_M_insert_(__x, __y, __v), true);
   else
     --__j;
 }
      if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))
 return pair<iterator, bool>(_M_insert_(__x, __y, __v), true);
      return pair<iterator, bool>(__j, false);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal(const _Val& __v)
    {
      _Link_type __x = _M_begin();
      _Link_type __y = _M_end();
      while (__x != 0)
 {
   __y = __x;
   __x = _M_impl._M_key_compare(_KeyOfValue()(__v), _S_key(__x)) ?
         _S_left(__x) : _S_right(__x);
 }
      return _M_insert_(__x, __y, __v);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_unique_(const_iterator __position, const _Val& __v)
    {
      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && _M_impl._M_key_compare(_S_key(_M_rightmost()),
     _KeyOfValue()(__v)))
     return _M_insert_(0, _M_rightmost(), __v);
   else
     return _M_insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
          _S_key(__position._M_node)))
 {
   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
   else if (_M_impl._M_key_compare(_S_key((--__before)._M_node),
       _KeyOfValue()(__v)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert_(0, __before._M_node, __v);
       else
  return _M_insert_(__position._M_node,
      __position._M_node, __v);
     }
   else
     return _M_insert_unique(__v).first;
 }
      else if (_M_impl._M_key_compare(_S_key(__position._M_node),
          _KeyOfValue()(__v)))
 {
   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert_(0, _M_rightmost(), __v);
   else if (_M_impl._M_key_compare(_KeyOfValue()(__v),
       _S_key((++__after)._M_node)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert_(0, __position._M_node, __v);
       else
  return _M_insert_(__after._M_node, __after._M_node, __v);
     }
   else
     return _M_insert_unique(__v).first;
 }
      else
 return iterator(static_cast<_Link_type>
   (const_cast<_Base_ptr>(__position._M_node)));
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    _M_insert_equal_(const_iterator __position, const _Val& __v)
    {
      if (__position._M_node == _M_end())
 {
   if (size() > 0
       && !_M_impl._M_key_compare(_KeyOfValue()(__v),
      _S_key(_M_rightmost())))
     return _M_insert_(0, _M_rightmost(), __v);
   else
     return _M_insert_equal(__v);
 }
      else if (!_M_impl._M_key_compare(_S_key(__position._M_node),
           _KeyOfValue()(__v)))
 {
   const_iterator __before = __position;
   if (__position._M_node == _M_leftmost())
     return _M_insert_(_M_leftmost(), _M_leftmost(), __v);
   else if (!_M_impl._M_key_compare(_KeyOfValue()(__v),
        _S_key((--__before)._M_node)))
     {
       if (_S_right(__before._M_node) == 0)
  return _M_insert_(0, __before._M_node, __v);
       else
  return _M_insert_(__position._M_node,
      __position._M_node, __v);
     }
   else
     return _M_insert_equal(__v);
 }
      else
 {
   const_iterator __after = __position;
   if (__position._M_node == _M_rightmost())
     return _M_insert_(0, _M_rightmost(), __v);
   else if (!_M_impl._M_key_compare(_S_key((++__after)._M_node),
        _KeyOfValue()(__v)))
     {
       if (_S_right(__position._M_node) == 0)
  return _M_insert_(0, __position._M_node, __v);
       else
  return _M_insert_(__after._M_node, __after._M_node, __v);
     }
   else
     return _M_insert_equal_lower(__v);
 }
    }
  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_unique(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_unique_(end(), *__first);
      }
  template<typename _Key, typename _Val, typename _KoV,
           typename _Cmp, typename _Alloc>
    template<class _II>
      void
      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::
      _M_insert_equal(_II __first, _II __last)
      {
 for (; __first != __last; ++__first)
   _M_insert_equal_(end(), *__first);
      }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __position)
    {
      iterator __result = __position;
      ++__result;
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (__position._M_node,
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
      return __result;
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    inline typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __position)
    {
      const_iterator __result = __position;
      ++__result;
      _Link_type __y =
 static_cast<_Link_type>(_Rb_tree_rebalance_for_erase
    (const_cast<_Base_ptr>(__position._M_node),
     this->_M_impl._M_header));
      _M_destroy_node(__y);
      --_M_impl._M_node_count;
      return __result;
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key& __x)
    {
      pair<iterator, iterator> __p = equal_range(__x);
      const size_type __old_size = size();
      erase(__p.first, __p.second);
      return __old_size - size();
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first == begin() && __last == end())
        {
   clear();
   return end();
        }
      else
        {
   while (__first != __last)
     erase(__first++);
   return __last;
        }
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const_iterator __first, const_iterator __last)
    {
      if (__first == begin() && __last == end())
        {
   clear();
   return end();
        }
      else
        {
   while (__first != __last)
     erase(__first++);
   return __last;
        }
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    void
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    erase(const _Key* __first, const _Key* __last)
    {
      while (__first != __last)
 erase(*__first++);
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k)
    {
      iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue,
        _Compare, _Alloc>::const_iterator
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    find(const _Key& __k) const
    {
      const_iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
      return (__j == end()
       || _M_impl._M_key_compare(__k,
     _S_key(__j._M_node))) ? end() : __j;
    }
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type
    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
    count(const _Key& __k) const
    {
      pair<const_iterator, const_iterator> __p = equal_range(__k);
      const size_type __n = std::distance(__p.first, __p.second);
      return __n;
    }
  __attribute__ ((__pure__)) unsigned int
  _Rb_tree_black_count(const _Rb_tree_node_base* __node,
                       const _Rb_tree_node_base* __root) throw ();
  template<typename _Key, typename _Val, typename _KeyOfValue,
           typename _Compare, typename _Alloc>
    bool
    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::__rb_verify() const
    {
      if (_M_impl._M_node_count == 0 || begin() == end())
 return _M_impl._M_node_count == 0 && begin() == end()
        && this->_M_impl._M_header._M_left == _M_end()
        && this->_M_impl._M_header._M_right == _M_end();
      unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());
      for (const_iterator __it = begin(); __it != end(); ++__it)
 {
   _Const_Link_type __x = static_cast<_Const_Link_type>(__it._M_node);
   _Const_Link_type __L = _S_left(__x);
   _Const_Link_type __R = _S_right(__x);
   if (__x->_M_color == _S_red)
     if ((__L && __L->_M_color == _S_red)
  || (__R && __R->_M_color == _S_red))
       return false;
   if (__L && _M_impl._M_key_compare(_S_key(__x), _S_key(__L)))
     return false;
   if (__R && _M_impl._M_key_compare(_S_key(__R), _S_key(__x)))
     return false;
   if (!__L && !__R && _Rb_tree_black_count(__x, _M_root()) != __len)
     return false;
 }
      if (_M_leftmost() != _Rb_tree_node_base::_S_minimum(_M_root()))
 return false;
      if (_M_rightmost() != _Rb_tree_node_base::_S_maximum(_M_root()))
 return false;
      return true;
    }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template <typename _Key, typename _Tp, typename _Compare = std::less<_Key>,
            typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class map
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;
    private:
      typedef typename _Alloc::value_type _Alloc_value_type;
     
     
     
    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class map<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;
 value_compare(_Compare __c)
 : comp(__c) { }
      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };
    private:
      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;
      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;
      _Rep_type _M_t;
    public:
      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      map()
      : _M_t() { }
      explicit
      map(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
      map(const map& __x)
      : _M_t(__x._M_t) { }
      map(map&& __x)
      : _M_t(std::forward<_Rep_type>(__x._M_t)) { }
      map(initializer_list<value_type> __l,
   const _Compare& __c = _Compare(),
   const allocator_type& __a = allocator_type())
      : _M_t(__c, __a)
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
      template<typename _InputIterator>
        map(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_unique(__first, __last); }
      map&
      operator=(const map& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
      map&
      operator=(map&& __x)
      {
 this->clear();
 this->swap(__x);
 return *this;
      }
      map&
      operator=(initializer_list<value_type> __l)
      {
 this->clear();
 this->insert(__l.begin(), __l.end());
 return *this;
      }
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }
      iterator
      begin()
      { return _M_t.begin(); }
      const_iterator
      begin() const
      { return _M_t.begin(); }
      iterator
      end()
      { return _M_t.end(); }
      const_iterator
      end() const
      { return _M_t.end(); }
      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }
      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }
      reverse_iterator
      rend()
      { return _M_t.rend(); }
      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
      const_iterator
      cbegin() const
      { return _M_t.begin(); }
      const_iterator
      cend() const
      { return _M_t.end(); }
      const_reverse_iterator
      crbegin() const
      { return _M_t.rbegin(); }
      const_reverse_iterator
      crend() const
      { return _M_t.rend(); }
      bool
      empty() const
      { return _M_t.empty(); }
      size_type
      size() const
      { return _M_t.size(); }
      size_type
      max_size() const
      { return _M_t.max_size(); }
      mapped_type&
      operator[](const key_type& __k)
      {

 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
          __i = insert(__i, value_type(__k, mapped_type()));
 return (*__i).second;
      }
      mapped_type&
      at(const key_type& __k)
      {
 iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
      const mapped_type&
      at(const key_type& __k) const
      {
 const_iterator __i = lower_bound(__k);
 if (__i == end() || key_comp()(__k, (*__i).first))
   __throw_out_of_range(("map::at"));
 return (*__i).second;
      }
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_t._M_insert_unique(__x); }
      void
      insert(std::initializer_list<value_type> __list)
      { insert (__list.begin(), __list.end()); }
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
      iterator
      erase(iterator __first, iterator __last)
      { return _M_t.erase(__first, __last); }
      void
      swap(map& __x)
      { _M_t.swap(__x._M_t); }
      void
      clear()
      { _M_t.clear(); }
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }
      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }
      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const map<_K1, _T1, _C1, _A1>&,
     const map<_K1, _T1, _C1, _A1>&);
      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const map<_K1, _T1, _C1, _A1>&,
    const map<_K1, _T1, _C1, _A1>&);
    };
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const map<_Key, _Tp, _Compare, _Alloc>& __x,
              const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const map<_Key, _Tp, _Compare, _Alloc>& __x,
               const map<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(map<_Key, _Tp, _Compare, _Alloc>& __x,
  map<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template <typename _Key, typename _Tp,
     typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class multimap
    {
    public:
      typedef _Key key_type;
      typedef _Tp mapped_type;
      typedef std::pair<const _Key, _Tp> value_type;
      typedef _Compare key_compare;
      typedef _Alloc allocator_type;
    private:
      typedef typename _Alloc::value_type _Alloc_value_type;
     
     
     
    public:
      class value_compare
      : public std::binary_function<value_type, value_type, bool>
      {
 friend class multimap<_Key, _Tp, _Compare, _Alloc>;
      protected:
 _Compare comp;
 value_compare(_Compare __c)
 : comp(__c) { }
      public:
 bool operator()(const value_type& __x, const value_type& __y) const
 { return comp(__x.first, __y.first); }
      };
    private:
      typedef typename _Alloc::template rebind<value_type>::other
        _Pair_alloc_type;
      typedef _Rb_tree<key_type, value_type, _Select1st<value_type>,
         key_compare, _Pair_alloc_type> _Rep_type;
      _Rep_type _M_t;
    public:
      typedef typename _Pair_alloc_type::pointer pointer;
      typedef typename _Pair_alloc_type::const_pointer const_pointer;
      typedef typename _Pair_alloc_type::reference reference;
      typedef typename _Pair_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      typedef typename _Rep_type::reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      multimap()
      : _M_t() { }
      explicit
      multimap(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
      multimap(const multimap& __x)
      : _M_t(__x._M_t) { }
      multimap(multimap&& __x)
      : _M_t(std::forward<_Rep_type>(__x._M_t)) { }
      multimap(initializer_list<value_type> __l,
        const _Compare& __comp = _Compare(),
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a)
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
      template<typename _InputIterator>
        multimap(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
        : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
      multimap&
      operator=(const multimap& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
      multimap&
      operator=(multimap&& __x)
      {
 this->clear();
 this->swap(__x);
 return *this;
      }
      multimap&
      operator=(initializer_list<value_type> __l)
      {
 this->clear();
 this->insert(__l.begin(), __l.end());
 return *this;
      }
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }
      iterator
      begin()
      { return _M_t.begin(); }
      const_iterator
      begin() const
      { return _M_t.begin(); }
      iterator
      end()
      { return _M_t.end(); }
      const_iterator
      end() const
      { return _M_t.end(); }
      reverse_iterator
      rbegin()
      { return _M_t.rbegin(); }
      const_reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }
      reverse_iterator
      rend()
      { return _M_t.rend(); }
      const_reverse_iterator
      rend() const
      { return _M_t.rend(); }
      const_iterator
      cbegin() const
      { return _M_t.begin(); }
      const_iterator
      cend() const
      { return _M_t.end(); }
      const_reverse_iterator
      crbegin() const
      { return _M_t.rbegin(); }
      const_reverse_iterator
      crend() const
      { return _M_t.rend(); }
      bool
      empty() const
      { return _M_t.empty(); }
      size_type
      size() const
      { return _M_t.size(); }
      size_type
      max_size() const
      { return _M_t.max_size(); }
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
      iterator
      erase(iterator __first, iterator __last)
      { return _M_t.erase(__first, __last); }
      void
      swap(multimap& __x)
      { _M_t.swap(__x._M_t); }
      void
      clear()
      { _M_t.clear(); }
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }
      value_compare
      value_comp() const
      { return value_compare(_M_t.key_comp()); }
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }
      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator==(const multimap<_K1, _T1, _C1, _A1>&,
     const multimap<_K1, _T1, _C1, _A1>&);
      template<typename _K1, typename _T1, typename _C1, typename _A1>
        friend bool
        operator<(const multimap<_K1, _T1, _C1, _A1>&,
    const multimap<_K1, _T1, _C1, _A1>&);
  };
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x == __y); }
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
              const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return __y < __x; }
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__y < __x); }
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multimap<_Key, _Tp, _Compare, _Alloc>& __x,
               const multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { return !(__x < __y); }
  template<typename _Key, typename _Tp, typename _Compare, typename _Alloc>
    inline void
    swap(multimap<_Key, _Tp, _Compare, _Alloc>& __x,
         multimap<_Key, _Tp, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
}
namespace
boost
    {
    template <class Tag,class T>
    inline
    typename enable_if<has_to_string<T>,std::string>::type
    to_string( error_info<Tag,T> const & x )
        {
        return to_string(x.value());
        }
    template <class Tag,class T>
    inline
    error_info<Tag,T>::
    error_info( value_type const & value ):
        value_(value)
        {
        }
    template <class Tag,class T>
    inline
    error_info<Tag,T>::
    ~error_info() throw()
        {
        }
    template <class Tag,class T>
    inline
    std::string
    error_info<Tag,T>::
    tag_typeid_name() const
        {
        return tag_type_name<Tag>();
        }
    template <class Tag,class T>
    inline
    std::string
    error_info<Tag,T>::
    value_as_string() const
        {
        return to_string_stub(*this);
        }
    namespace
    exception_detail
        {
        class
        error_info_container_impl:
            public error_info_container
            {
            public:
            error_info_container_impl():
                count_(0)
                {
                }
            ~error_info_container_impl() throw()
                {
                }
            void
            set( shared_ptr<error_info_base> const & x, type_info_ const & typeid_ )
                {
                (__builtin_expect(!(x), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/exception/info.hpp", 87, "x") : (void)0);
                info_[typeid_] = x;
                diagnostic_info_str_.clear();
                }
            shared_ptr<error_info_base>
            get( type_info_ const & ti ) const
                {
                error_info_map::const_iterator i=info_.find(ti);
                if( info_.end()!=i )
                    {
                    shared_ptr<error_info_base> const & p = i->second;
                    (__builtin_expect(!(::boost::exception_detail::type_info_(typeid(*p)).type_==ti.type_), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/exception/info.hpp", 100, "::boost::exception_detail::type_info_(typeid(*p)).type_==ti.type_") : (void)0);
                    return p;
                    }
                return shared_ptr<error_info_base>();
                }
            char const *
            diagnostic_information( char const * header ) const
                {
                if( header )
                    {
                    std::ostringstream tmp;
                    tmp << header;
                    for( error_info_map::const_iterator i=info_.begin(),end=info_.end(); i!=end; ++i )
                        {
                        error_info_base const & x = *i->second;
                        tmp << '[' << x.tag_typeid_name() << "] = " << x.value_as_string() << '\n';
                        }
                    tmp.str().swap(diagnostic_info_str_);
                    }
                return diagnostic_info_str_.c_str();
                }
            private:
            friend class boost::exception;
            typedef std::map< type_info_, shared_ptr<error_info_base> > error_info_map;
            error_info_map info_;
            mutable std::string diagnostic_info_str_;
            mutable int count_;
            error_info_container_impl( error_info_container_impl const & );
            error_info_container_impl & operator=( error_info_container const & );
            void
            add_ref() const
                {
                ++count_;
                }
            bool
            release() const
                {
                if( --count_ )
                    return false;
                else
                    {
                    delete this;
                    return true;
                    }
                }
            refcount_ptr<error_info_container>
            clone() const
                {
                refcount_ptr<error_info_container> p;
                error_info_container_impl * c=new error_info_container_impl;
                p.adopt(c);
                c->info_ = info_;
                return p;
                }
            };
        template <class E,class Tag,class T>
        inline
        E const &
        set_info( E const & x, error_info<Tag,T> const & v )
            {
            typedef error_info<Tag,T> error_info_tag_t;
            shared_ptr<error_info_tag_t> p( new error_info_tag_t(v) );
            exception_detail::error_info_container * c=x.data_.get();
            if( !c )
                x.data_.adopt(c=new exception_detail::error_info_container_impl);
            c->set(p,::boost::exception_detail::type_info_(typeid(error_info_tag_t)));
            return x;
            }
        template <class T>
        struct
        derives_boost_exception
            {
            enum e { value = (sizeof(dispatch_boost_exception((T*)0))==sizeof(large_size)) };
            };
        }
    template <class E,class Tag,class T>
    inline
    typename enable_if<exception_detail::derives_boost_exception<E>,E const &>::type
    operator<<( E const & x, error_info<Tag,T> const & v )
        {
        return exception_detail::set_info(x,v);
        }
    }
       
namespace
boost
    {
    template <class E>
    inline
    E *
    current_exception_cast()
        {
        try
            {
            throw;
            }
        catch(
        E & e )
            {
            return &e;
            }
        catch(
        ...)
            {
            return 0;
            }
        }
    }
namespace
boost
    {
    namespace
    exception_detail
        {
        std::string diagnostic_information_impl( boost::exception const *, std::exception const *, bool );
        }
    inline
    std::string
    current_exception_diagnostic_information()
        {
        boost::exception const * be=current_exception_cast<boost::exception const>();
        std::exception const * se=current_exception_cast<std::exception const>();
        if( be || se )
            return exception_detail::diagnostic_information_impl(be,se,true);
        else
            return "No diagnostic information available.";
        }
    }
namespace
boost
    {
    namespace
    exception_detail
        {
        inline
        exception const *
        get_boost_exception( exception const * e )
            {
            return e;
            }
        inline
        exception const *
        get_boost_exception( ... )
            {
            return 0;
            }
        inline
        std::exception const *
        get_std_exception( std::exception const * e )
            {
            return e;
            }
        inline
        std::exception const *
        get_std_exception( ... )
            {
            return 0;
            }
        inline
        char const *
        get_diagnostic_information( exception const & x, char const * header )
            {
            try
                {
                error_info_container * c=x.data_.get();
                if( !c )
                    x.data_.adopt(c=new exception_detail::error_info_container_impl);
                char const * di=c->diagnostic_information(header);
                (__builtin_expect(!(di!=0), 0) ? __assert_rtn(__func__, "/usr/local/include/boost/exception/diagnostic_information.hpp", 97, "di!=0") : (void)0);
                return di;
                }
            catch(...)
                {
                return 0;
                }
            }
        inline
        std::string
        diagnostic_information_impl( boost::exception const * be, std::exception const * se, bool with_what )
            {
            if( !be && !se )
                return "Unknown exception.";
            if( !be )
                be=dynamic_cast<boost::exception const *>(se);
            if( !se )
                se=dynamic_cast<std::exception const *>(be);
            char const * wh=0;
            if( with_what && se )
                {
                wh=se->what();
                if( be && exception_detail::get_diagnostic_information(*be,0)==wh )
                    return wh;
                }
            std::ostringstream tmp;
            if( be )
                {
                char const * const * f=get_error_info<throw_file>(*be);
                int const * l=get_error_info<throw_line>(*be);
                char const * const * fn=get_error_info<throw_function>(*be);
                if( !f && !l && !fn )
                    tmp << "Throw location unknown (consider using BOOST_THROW_EXCEPTION)\n";
                else
                    {
                    if( f )
                        {
                        tmp << *f;
                        if( int const * l=get_error_info<throw_line>(*be) )
                            tmp << '(' << *l << "): ";
                        }
                    tmp << "Throw in function ";
                    if( char const * const * fn=get_error_info<throw_function>(*be) )
                        tmp << *fn;
                    else
                        tmp << "(unknown)";
                    tmp << '\n';
                    }
                }
            tmp << std::string("Dynamic exception type: ") <<
                units::detail::demangle((be?(::boost::exception_detail::type_info_(typeid(*be))):(::boost::exception_detail::type_info_(typeid(*se)))).type_->name()) << '\n';
            if( with_what && se )
                tmp << "std::exception::what: " << wh << '\n';
            if( be )
                if( char const * s=exception_detail::get_diagnostic_information(*be,tmp.str().c_str()) )
                    if( *s )
                        return s;
            return tmp.str();
            }
        }
    template <class T>
    std::string
    diagnostic_information( T const & e )
        {
        return exception_detail::diagnostic_information_impl(exception_detail::get_boost_exception(&e),exception_detail::get_std_exception(&e),true);
        }
    inline
    char const *
    diagnostic_information_what( exception const & e ) throw()
        {
        char const * w=0;
        try
            {
            (void) exception_detail::diagnostic_information_impl(&e,0,false);
            if( char const * di=exception_detail::get_diagnostic_information(e,0) )
                return di;
            else
                return "Failed to produce boost::diagnostic_information_what()";
            }
        catch(
        ... )
            {
            }
        return w;
        }
    }
namespace boost
{
    class thread_interrupted
    {};
    class thread_exception:
        public std::exception
    {
    protected:
        thread_exception():
            m_sys_err(0)
        {}
        thread_exception(int sys_err_code):
            m_sys_err(sys_err_code)
        {}
    public:
        ~thread_exception() throw()
        {}
        int native_error() const
        {
            return m_sys_err;
        }
    private:
        int m_sys_err;
    };
    class condition_error:
        public std::exception
    {
    public:
        const char* what() const throw()
        {
            return "Condition error";
        }
    };
    class lock_error:
        public thread_exception
    {
    public:
        lock_error()
        {}
        lock_error(int sys_err_code):
            thread_exception(sys_err_code)
        {}
        ~lock_error() throw()
        {}
        virtual const char* what() const throw()
        {
            return "boost::lock_error";
        }
    };
    class thread_resource_error:
        public thread_exception
    {
    public:
        thread_resource_error()
        {}
        thread_resource_error(int sys_err_code):
            thread_exception(sys_err_code)
        {}
        ~thread_resource_error() throw()
        {}
        virtual const char* what() const throw()
        {
            return "boost::thread_resource_error";
        }
    };
    class unsupported_thread_option:
        public thread_exception
    {
    public:
        unsupported_thread_option()
        {}
        unsupported_thread_option(int sys_err_code):
            thread_exception(sys_err_code)
        {}
        ~unsupported_thread_option() throw()
        {}
        virtual const char* what() const throw()
        {
            return "boost::unsupported_thread_option";
        }
    };
    class invalid_thread_argument:
        public thread_exception
    {
    public:
        invalid_thread_argument()
        {}
        invalid_thread_argument(int sys_err_code):
            thread_exception(sys_err_code)
        {}
        ~invalid_thread_argument() throw()
        {}
        virtual const char* what() const throw()
        {
            return "boost::invalid_thread_argument";
        }
    };
    class thread_permission_error:
        public thread_exception
    {
    public:
        thread_permission_error()
        {}
        thread_permission_error(int sys_err_code):
            thread_exception(sys_err_code)
        {}
        ~thread_permission_error() throw()
        {}
        virtual const char* what() const throw()
        {
            return "boost::thread_permission_error";
        }
    };
}
namespace boost
{
    namespace detail
    {
        template<typename T>
        struct thread_move_t
        {
            T& t;
            explicit thread_move_t(T& t_):
                t(t_)
            {}
            T& operator*() const
            {
                return t;
            }
            T* operator->() const
            {
                return &t;
            }
        private:
            void operator=(thread_move_t&);
        };
    }
    template<typename T>
    typename enable_if<boost::is_convertible<T&,detail::thread_move_t<T> >, detail::thread_move_t<T> >::type move(T& t)
    {
        return detail::thread_move_t<T>(t);
    }
    template<typename T>
    detail::thread_move_t<T> move(detail::thread_move_t<T> t)
    {
        return t;
    }
}
       
       
       
       
namespace boost
{
  using ::int8_t;
  using ::int_least8_t;
  using ::int_fast8_t;
  using ::uint8_t;
  using ::uint_least8_t;
  using ::uint_fast8_t;
  using ::int16_t;
  using ::int_least16_t;
  using ::int_fast16_t;
  using ::uint16_t;
  using ::uint_least16_t;
  using ::uint_fast16_t;
  using ::int32_t;
  using ::int_least32_t;
  using ::int_fast32_t;
  using ::uint32_t;
  using ::uint_least32_t;
  using ::uint_fast32_t;
  using ::int64_t;
  using ::int_least64_t;
  using ::int_fast64_t;
  using ::uint64_t;
  using ::uint_least64_t;
  using ::uint_fast64_t;
  using ::intmax_t;
  using ::uintmax_t;
}
struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;
};
struct timezone {
 int tz_minuteswest;
 int tz_dsttime;
};
struct clockinfo {
 int hz;
 int tick;
 int tickadj;
 int stathz;
 int profhz;
};
extern "C" {
int adjtime(const struct timeval *, struct timeval *);
int futimes(int, const struct timeval *);
int lutimes(const char *, const struct timeval *) __attribute__((visibility("default")));
int settimeofday(const struct timeval *, const struct timezone *);
int getitimer(int, struct itimerval *);
int gettimeofday(struct timeval * , void * );
int setitimer(int, const struct itimerval * ,
  struct itimerval * );
int utimes(const char *, const struct timeval *);
}
namespace boost {
namespace date_time {
  struct c_time {
    public:
      inline
      static std::tm* localtime(const std::time_t* t, std::tm* result)
      {
        result = localtime_r(t, result);
        if (!result)
          boost::throw_exception(std::runtime_error("could not convert calendar time to local time"));
        return result;
      }
      inline
      static std::tm* gmtime(const std::time_t* t, std::tm* result)
      {
        result = gmtime_r(t, result);
        if (!result)
          boost::throw_exception(std::runtime_error("could not convert calendar time to UTC time"));
        return result;
      }
  };
}}
namespace boost {
namespace date_time {
  template<class time_type>
  class second_clock
  {
  public:
    typedef typename time_type::date_type date_type;
    typedef typename time_type::time_duration_type time_duration_type;
    static time_type local_time()
    {
      ::std::time_t t;
      ::std::time(&t);
      ::std::tm curr, *curr_ptr;
      curr_ptr = c_time::localtime(&t, &curr);
      return create_time(curr_ptr);
    }
    static time_type universal_time()
    {
      ::std::time_t t;
      ::std::time(&t);
      ::std::tm curr, *curr_ptr;
      curr_ptr = c_time::gmtime(&t, &curr);
      return create_time(curr_ptr);
    }
    template<class time_zone_type>
    static time_type local_time(boost::shared_ptr<time_zone_type> tz_ptr)
    {
      typedef typename time_type::utc_time_type utc_time_type;
      utc_time_type utc_time = second_clock<utc_time_type>::universal_time();
      return time_type(utc_time, tz_ptr);
    }
  private:
    static time_type create_time(::std::tm* current)
    {
      date_type d(static_cast<unsigned short>(current->tm_year + 1900),
                  static_cast<unsigned short>(current->tm_mon + 1),
                  static_cast<unsigned short>(current->tm_mday));
      time_duration_type td(current->tm_hour,
                            current->tm_min,
                            current->tm_sec);
      return time_type(d,td);
    }
  };
} }
namespace boost {
namespace date_time {
  template<class time_type>
  class microsec_clock
  {
  private:
    typedef std::tm* (*time_converter)(const std::time_t*, std::tm*);
  public:
    typedef typename time_type::date_type date_type;
    typedef typename time_type::time_duration_type time_duration_type;
    typedef typename time_duration_type::rep_type resolution_traits_type;
    template<class time_zone_type>
    static time_type local_time(shared_ptr<time_zone_type> tz_ptr)
    {
      typedef typename time_type::utc_time_type utc_time_type;
      typedef second_clock<utc_time_type> second_clock;
      utc_time_type utc_time = second_clock::universal_time();
      time_duration_type utc_offset = second_clock::local_time() - utc_time;
      utc_time = microsec_clock<utc_time_type>::local_time() - utc_offset;
      return time_type(utc_time, tz_ptr);
    }
    static time_type local_time()
    {
      return create_time(&c_time::localtime);
    }
    static time_type universal_time()
    {
      return create_time(&c_time::gmtime);
    }
  private:
    static time_type create_time(time_converter converter)
    {
      timeval tv;
      gettimeofday(&tv, 0);
      std::time_t t = tv.tv_sec;
      boost::uint32_t sub_sec = tv.tv_usec;
      std::tm curr;
      std::tm* curr_ptr = converter(&t, &curr);
      date_type d(static_cast< typename date_type::year_type::value_type >(curr_ptr->tm_year + 1900),
                  static_cast< typename date_type::month_type::value_type >(curr_ptr->tm_mon + 1),
                  static_cast< typename date_type::day_type::value_type >(curr_ptr->tm_mday));
      int adjust = static_cast< int >(resolution_traits_type::res_adjust() / 1000000);
      time_duration_type td(static_cast< typename time_duration_type::hour_type >(curr_ptr->tm_hour),
                            static_cast< typename time_duration_type::min_type >(curr_ptr->tm_min),
                            static_cast< typename time_duration_type::sec_type >(curr_ptr->tm_sec),
                            sub_sec * adjust);
      return time_type(d,td);
    }
  };
} }
       
       
       
namespace boost {
namespace detail {
template <typename T> class empty_base {
};
}
}
namespace boost
{
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct less_than_comparable2 : B
{
     friend bool operator<=(const T& x, const U& y) { return !static_cast<bool>(x > y); }
     friend bool operator>=(const T& x, const U& y) { return !static_cast<bool>(x < y); }
     friend bool operator>(const U& x, const T& y) { return y < x; }
     friend bool operator<(const U& x, const T& y) { return y > x; }
     friend bool operator<=(const U& x, const T& y) { return !static_cast<bool>(y < x); }
     friend bool operator>=(const U& x, const T& y) { return !static_cast<bool>(y > x); }
};
template <class T, class B = ::boost::detail::empty_base<T> >
struct less_than_comparable1 : B
{
     friend bool operator>(const T& x, const T& y) { return y < x; }
     friend bool operator<=(const T& x, const T& y) { return !static_cast<bool>(y < x); }
     friend bool operator>=(const T& x, const T& y) { return !static_cast<bool>(x < y); }
};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct equality_comparable2 : B
{
     friend bool operator==(const U& y, const T& x) { return x == y; }
     friend bool operator!=(const U& y, const T& x) { return !static_cast<bool>(x == y); }
     friend bool operator!=(const T& y, const U& x) { return !static_cast<bool>(y == x); }
};
template <class T, class B = ::boost::detail::empty_base<T> >
struct equality_comparable1 : B
{
     friend bool operator!=(const T& x, const T& y) { return !static_cast<bool>(x == y); }
};
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct multipliable2 : B { friend T operator *( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv *= rhs; return nrv; } friend T operator *( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv *= lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct multipliable1 : B { friend T operator *( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv *= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct addable2 : B { friend T operator +( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv += rhs; return nrv; } friend T operator +( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv += lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct addable1 : B { friend T operator +( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv += rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct subtractable2 : B { friend T operator -( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } }; template <class T, class U, class B = ::boost::detail::empty_base<T> > struct subtractable2_left : B { friend T operator -( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct subtractable1 : B { friend T operator -( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv -= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct dividable2 : B { friend T operator /( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } }; template <class T, class U, class B = ::boost::detail::empty_base<T> > struct dividable2_left : B { friend T operator /( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct dividable1 : B { friend T operator /( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv /= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct modable2 : B { friend T operator %( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } }; template <class T, class U, class B = ::boost::detail::empty_base<T> > struct modable2_left : B { friend T operator %( const U& lhs, const T& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct modable1 : B { friend T operator %( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv %= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct xorable2 : B { friend T operator ^( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv ^= rhs; return nrv; } friend T operator ^( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv ^= lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct xorable1 : B { friend T operator ^( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv ^= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct andable2 : B { friend T operator &( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv &= rhs; return nrv; } friend T operator &( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv &= lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct andable1 : B { friend T operator &( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv &= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct orable2 : B { friend T operator |( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv |= rhs; return nrv; } friend T operator |( const U& lhs, const T& rhs ) { T nrv( rhs ); nrv |= lhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct orable1 : B { friend T operator |( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv |= rhs; return nrv; } };
template <class T, class B = ::boost::detail::empty_base<T> >
struct incrementable : B
{
  friend T operator++(T& x, int)
  {
    incrementable_type nrv(x);
    ++x;
    return nrv;
  }
private:
  typedef T incrementable_type;
};
template <class T, class B = ::boost::detail::empty_base<T> >
struct decrementable : B
{
  friend T operator--(T& x, int)
  {
    decrementable_type nrv(x);
    --x;
    return nrv;
  }
private:
  typedef T decrementable_type;
};
template <class T, class P, class B = ::boost::detail::empty_base<T> >
struct dereferenceable : B
{
  P operator->() const
  {
    return &*static_cast<const T&>(*this);
  }
};
template <class T, class I, class R, class B = ::boost::detail::empty_base<T> >
struct indexable : B
{
  R operator[](I n) const
  {
    return *(static_cast<const T&>(*this) + n);
  }
};
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct left_shiftable2 : B { friend T operator <<( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv <<= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct left_shiftable1 : B { friend T operator <<( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv <<= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> > struct right_shiftable2 : B { friend T operator >>( const T& lhs, const U& rhs ) { T nrv( lhs ); nrv >>= rhs; return nrv; } }; template <class T, class B = ::boost::detail::empty_base<T> > struct right_shiftable1 : B { friend T operator >>( const T& lhs, const T& rhs ) { T nrv( lhs ); nrv >>= rhs; return nrv; } };
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct equivalent2 : B
{
  friend bool operator==(const T& x, const U& y)
  {
    return !static_cast<bool>(x < y) && !static_cast<bool>(x > y);
  }
};
template <class T, class B = ::boost::detail::empty_base<T> >
struct equivalent1 : B
{
  friend bool operator==(const T&x, const T&y)
  {
    return !static_cast<bool>(x < y) && !static_cast<bool>(y < x);
  }
};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct partially_ordered2 : B
{
  friend bool operator<=(const T& x, const U& y)
    { return static_cast<bool>(x < y) || static_cast<bool>(x == y); }
  friend bool operator>=(const T& x, const U& y)
    { return static_cast<bool>(x > y) || static_cast<bool>(x == y); }
  friend bool operator>(const U& x, const T& y)
    { return y < x; }
  friend bool operator<(const U& x, const T& y)
    { return y > x; }
  friend bool operator<=(const U& x, const T& y)
    { return static_cast<bool>(y > x) || static_cast<bool>(y == x); }
  friend bool operator>=(const U& x, const T& y)
    { return static_cast<bool>(y < x) || static_cast<bool>(y == x); }
};
template <class T, class B = ::boost::detail::empty_base<T> >
struct partially_ordered1 : B
{
  friend bool operator>(const T& x, const T& y)
    { return y < x; }
  friend bool operator<=(const T& x, const T& y)
    { return static_cast<bool>(x < y) || static_cast<bool>(x == y); }
  friend bool operator>=(const T& x, const T& y)
    { return static_cast<bool>(y < x) || static_cast<bool>(x == y); }
};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct totally_ordered2
    : less_than_comparable2<T, U
    , equality_comparable2<T, U, B
      > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct totally_ordered1
    : less_than_comparable1<T
    , equality_comparable1<T, B
      > > {};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct additive2
    : addable2<T, U
    , subtractable2<T, U, B
      > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct additive1
    : addable1<T
    , subtractable1<T, B
      > > {};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct multiplicative2
    : multipliable2<T, U
    , dividable2<T, U, B
      > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct multiplicative1
    : multipliable1<T
    , dividable1<T, B
      > > {};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct integer_multiplicative2
    : multiplicative2<T, U
    , modable2<T, U, B
      > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct integer_multiplicative1
    : multiplicative1<T
    , modable1<T, B
      > > {};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct arithmetic2
    : additive2<T, U
    , multiplicative2<T, U, B
      > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct arithmetic1
    : additive1<T
    , multiplicative1<T, B
      > > {};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct integer_arithmetic2
    : additive2<T, U
    , integer_multiplicative2<T, U, B
      > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct integer_arithmetic1
    : additive1<T
    , integer_multiplicative1<T, B
      > > {};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct bitwise2
    : xorable2<T, U
    , andable2<T, U
    , orable2<T, U, B
      > > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct bitwise1
    : xorable1<T
    , andable1<T
    , orable1<T, B
      > > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct unit_steppable
    : incrementable<T
    , decrementable<T, B
      > > {};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct shiftable2
    : left_shiftable2<T, U
    , right_shiftable2<T, U, B
      > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct shiftable1
    : left_shiftable1<T
    , right_shiftable1<T, B
      > > {};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ring_operators2
    : additive2<T, U
    , subtractable2_left<T, U
    , multipliable2<T, U, B
      > > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct ring_operators1
    : additive1<T
    , multipliable1<T, B
      > > {};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ordered_ring_operators2
    : ring_operators2<T, U
    , totally_ordered2<T, U, B
      > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct ordered_ring_operators1
    : ring_operators1<T
    , totally_ordered1<T, B
      > > {};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct field_operators2
    : ring_operators2<T, U
    , dividable2<T, U
    , dividable2_left<T, U, B
      > > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct field_operators1
    : ring_operators1<T
    , dividable1<T, B
      > > {};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ordered_field_operators2
    : field_operators2<T, U
    , totally_ordered2<T, U, B
      > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct ordered_field_operators1
    : field_operators1<T
    , totally_ordered1<T, B
      > > {};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct euclidian_ring_operators2
    : ring_operators2<T, U
    , dividable2<T, U
    , dividable2_left<T, U
    , modable2<T, U
    , modable2_left<T, U, B
      > > > > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct euclidian_ring_operators1
    : ring_operators1<T
    , dividable1<T
    , modable1<T, B
      > > > {};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ordered_euclidian_ring_operators2
    : totally_ordered2<T, U
    , euclidian_ring_operators2<T, U, B
      > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct ordered_euclidian_ring_operators1
    : totally_ordered1<T
    , euclidian_ring_operators1<T, B
      > > {};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct euclidean_ring_operators2
    : ring_operators2<T, U
    , dividable2<T, U
    , dividable2_left<T, U
    , modable2<T, U
    , modable2_left<T, U, B
      > > > > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct euclidean_ring_operators1
    : ring_operators1<T
    , dividable1<T
    , modable1<T, B
      > > > {};
template <class T, class U, class B = ::boost::detail::empty_base<T> >
struct ordered_euclidean_ring_operators2
    : totally_ordered2<T, U
    , euclidean_ring_operators2<T, U, B
      > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct ordered_euclidean_ring_operators1
    : totally_ordered1<T
    , euclidean_ring_operators1<T, B
      > > {};
template <class T, class P, class B = ::boost::detail::empty_base<T> >
struct input_iteratable
    : equality_comparable1<T
    , incrementable<T
    , dereferenceable<T, P, B
      > > > {};
template <class T, class B = ::boost::detail::empty_base<T> >
struct output_iteratable
    : incrementable<T, B
      > {};
template <class T, class P, class B = ::boost::detail::empty_base<T> >
struct forward_iteratable
    : input_iteratable<T, P, B
      > {};
template <class T, class P, class B = ::boost::detail::empty_base<T> >
struct bidirectional_iteratable
    : forward_iteratable<T, P
    , decrementable<T, B
      > > {};
template <class T, class P, class D, class R, class B = ::boost::detail::empty_base<T> >
struct random_access_iteratable
    : bidirectional_iteratable<T, P
    , less_than_comparable1<T
    , additive2<T, D
    , indexable<T, D, R, B
      > > > > {};
}
namespace boost {
namespace detail {
  struct true_t {};
  struct false_t {};
}
template<class T> struct is_chained_base {
  typedef ::boost::detail::false_t value;
};
}
namespace boost {
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct less_than_comparable : less_than_comparable2<T, U, B> {}; template<class T, class U, class B> struct less_than_comparable<T, U, B, ::boost::detail::true_t> : less_than_comparable1<T, U> {}; template <class T, class B> struct less_than_comparable<T, T, B, ::boost::detail::false_t> : less_than_comparable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::less_than_comparable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::less_than_comparable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::less_than_comparable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct equality_comparable : equality_comparable2<T, U, B> {}; template<class T, class U, class B> struct equality_comparable<T, U, B, ::boost::detail::true_t> : equality_comparable1<T, U> {}; template <class T, class B> struct equality_comparable<T, T, B, ::boost::detail::false_t> : equality_comparable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::equality_comparable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::equality_comparable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::equality_comparable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct multipliable : multipliable2<T, U, B> {}; template<class T, class U, class B> struct multipliable<T, U, B, ::boost::detail::true_t> : multipliable1<T, U> {}; template <class T, class B> struct multipliable<T, T, B, ::boost::detail::false_t> : multipliable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::multipliable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::multipliable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::multipliable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct addable : addable2<T, U, B> {}; template<class T, class U, class B> struct addable<T, U, B, ::boost::detail::true_t> : addable1<T, U> {}; template <class T, class B> struct addable<T, T, B, ::boost::detail::false_t> : addable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::addable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::addable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::addable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct subtractable : subtractable2<T, U, B> {}; template<class T, class U, class B> struct subtractable<T, U, B, ::boost::detail::true_t> : subtractable1<T, U> {}; template <class T, class B> struct subtractable<T, T, B, ::boost::detail::false_t> : subtractable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::subtractable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::subtractable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::subtractable1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::subtractable2_left<T, U, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct dividable : dividable2<T, U, B> {}; template<class T, class U, class B> struct dividable<T, U, B, ::boost::detail::true_t> : dividable1<T, U> {}; template <class T, class B> struct dividable<T, T, B, ::boost::detail::false_t> : dividable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::dividable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::dividable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::dividable1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::dividable2_left<T, U, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct modable : modable2<T, U, B> {}; template<class T, class U, class B> struct modable<T, U, B, ::boost::detail::true_t> : modable1<T, U> {}; template <class T, class B> struct modable<T, T, B, ::boost::detail::false_t> : modable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::modable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::modable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::modable1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::modable2_left<T, U, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct xorable : xorable2<T, U, B> {}; template<class T, class U, class B> struct xorable<T, U, B, ::boost::detail::true_t> : xorable1<T, U> {}; template <class T, class B> struct xorable<T, T, B, ::boost::detail::false_t> : xorable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::xorable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::xorable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::xorable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct andable : andable2<T, U, B> {}; template<class T, class U, class B> struct andable<T, U, B, ::boost::detail::true_t> : andable1<T, U> {}; template <class T, class B> struct andable<T, T, B, ::boost::detail::false_t> : andable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::andable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::andable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::andable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct orable : orable2<T, U, B> {}; template<class T, class U, class B> struct orable<T, U, B, ::boost::detail::true_t> : orable1<T, U> {}; template <class T, class B> struct orable<T, T, B, ::boost::detail::false_t> : orable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::orable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::orable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::orable1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class B> struct is_chained_base< ::boost::incrementable<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class B> struct is_chained_base< ::boost::decrementable<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::dereferenceable<T, U, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class V, class B> struct is_chained_base< ::boost::indexable<T, U, V, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct left_shiftable : left_shiftable2<T, U, B> {}; template<class T, class U, class B> struct left_shiftable<T, U, B, ::boost::detail::true_t> : left_shiftable1<T, U> {}; template <class T, class B> struct left_shiftable<T, T, B, ::boost::detail::false_t> : left_shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::left_shiftable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::left_shiftable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::left_shiftable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct right_shiftable : right_shiftable2<T, U, B> {}; template<class T, class U, class B> struct right_shiftable<T, U, B, ::boost::detail::true_t> : right_shiftable1<T, U> {}; template <class T, class B> struct right_shiftable<T, T, B, ::boost::detail::false_t> : right_shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::right_shiftable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::right_shiftable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::right_shiftable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct equivalent : equivalent2<T, U, B> {}; template<class T, class U, class B> struct equivalent<T, U, B, ::boost::detail::true_t> : equivalent1<T, U> {}; template <class T, class B> struct equivalent<T, T, B, ::boost::detail::false_t> : equivalent1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::equivalent<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::equivalent2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::equivalent1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct partially_ordered : partially_ordered2<T, U, B> {}; template<class T, class U, class B> struct partially_ordered<T, U, B, ::boost::detail::true_t> : partially_ordered1<T, U> {}; template <class T, class B> struct partially_ordered<T, T, B, ::boost::detail::false_t> : partially_ordered1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::partially_ordered<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::partially_ordered2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::partially_ordered1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct totally_ordered : totally_ordered2<T, U, B> {}; template<class T, class U, class B> struct totally_ordered<T, U, B, ::boost::detail::true_t> : totally_ordered1<T, U> {}; template <class T, class B> struct totally_ordered<T, T, B, ::boost::detail::false_t> : totally_ordered1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::totally_ordered<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::totally_ordered2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::totally_ordered1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct additive : additive2<T, U, B> {}; template<class T, class U, class B> struct additive<T, U, B, ::boost::detail::true_t> : additive1<T, U> {}; template <class T, class B> struct additive<T, T, B, ::boost::detail::false_t> : additive1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::additive<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::additive2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::additive1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct multiplicative : multiplicative2<T, U, B> {}; template<class T, class U, class B> struct multiplicative<T, U, B, ::boost::detail::true_t> : multiplicative1<T, U> {}; template <class T, class B> struct multiplicative<T, T, B, ::boost::detail::false_t> : multiplicative1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::multiplicative<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::multiplicative2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::multiplicative1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct integer_multiplicative : integer_multiplicative2<T, U, B> {}; template<class T, class U, class B> struct integer_multiplicative<T, U, B, ::boost::detail::true_t> : integer_multiplicative1<T, U> {}; template <class T, class B> struct integer_multiplicative<T, T, B, ::boost::detail::false_t> : integer_multiplicative1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::integer_multiplicative<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::integer_multiplicative2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::integer_multiplicative1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct arithmetic : arithmetic2<T, U, B> {}; template<class T, class U, class B> struct arithmetic<T, U, B, ::boost::detail::true_t> : arithmetic1<T, U> {}; template <class T, class B> struct arithmetic<T, T, B, ::boost::detail::false_t> : arithmetic1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::arithmetic<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::arithmetic2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::arithmetic1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct integer_arithmetic : integer_arithmetic2<T, U, B> {}; template<class T, class U, class B> struct integer_arithmetic<T, U, B, ::boost::detail::true_t> : integer_arithmetic1<T, U> {}; template <class T, class B> struct integer_arithmetic<T, T, B, ::boost::detail::false_t> : integer_arithmetic1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::integer_arithmetic<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::integer_arithmetic2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::integer_arithmetic1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct bitwise : bitwise2<T, U, B> {}; template<class T, class U, class B> struct bitwise<T, U, B, ::boost::detail::true_t> : bitwise1<T, U> {}; template <class T, class B> struct bitwise<T, T, B, ::boost::detail::false_t> : bitwise1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::bitwise<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::bitwise2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::bitwise1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class B> struct is_chained_base< ::boost::unit_steppable<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct shiftable : shiftable2<T, U, B> {}; template<class T, class U, class B> struct shiftable<T, U, B, ::boost::detail::true_t> : shiftable1<T, U> {}; template <class T, class B> struct shiftable<T, T, B, ::boost::detail::false_t> : shiftable1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::shiftable<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::shiftable2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::shiftable1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ring_operators : ring_operators2<T, U, B> {}; template<class T, class U, class B> struct ring_operators<T, U, B, ::boost::detail::true_t> : ring_operators1<T, U> {}; template <class T, class B> struct ring_operators<T, T, B, ::boost::detail::false_t> : ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_ring_operators : ordered_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct ordered_ring_operators<T, U, B, ::boost::detail::true_t> : ordered_ring_operators1<T, U> {}; template <class T, class B> struct ordered_ring_operators<T, T, B, ::boost::detail::false_t> : ordered_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ordered_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ordered_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ordered_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct field_operators : field_operators2<T, U, B> {}; template<class T, class U, class B> struct field_operators<T, U, B, ::boost::detail::true_t> : field_operators1<T, U> {}; template <class T, class B> struct field_operators<T, T, B, ::boost::detail::false_t> : field_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::field_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::field_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::field_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_field_operators : ordered_field_operators2<T, U, B> {}; template<class T, class U, class B> struct ordered_field_operators<T, U, B, ::boost::detail::true_t> : ordered_field_operators1<T, U> {}; template <class T, class B> struct ordered_field_operators<T, T, B, ::boost::detail::false_t> : ordered_field_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ordered_field_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ordered_field_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ordered_field_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct euclidian_ring_operators : euclidian_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct euclidian_ring_operators<T, U, B, ::boost::detail::true_t> : euclidian_ring_operators1<T, U> {}; template <class T, class B> struct euclidian_ring_operators<T, T, B, ::boost::detail::false_t> : euclidian_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::euclidian_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::euclidian_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::euclidian_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_euclidian_ring_operators : ordered_euclidian_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct ordered_euclidian_ring_operators<T, U, B, ::boost::detail::true_t> : ordered_euclidian_ring_operators1<T, U> {}; template <class T, class B> struct ordered_euclidian_ring_operators<T, T, B, ::boost::detail::false_t> : ordered_euclidian_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ordered_euclidian_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ordered_euclidian_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ordered_euclidian_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct euclidean_ring_operators : euclidean_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct euclidean_ring_operators<T, U, B, ::boost::detail::true_t> : euclidean_ring_operators1<T, U> {}; template <class T, class B> struct euclidean_ring_operators<T, T, B, ::boost::detail::false_t> : euclidean_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::euclidean_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::euclidean_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::euclidean_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
template <class T ,class U = T ,class B = ::boost::detail::empty_base<T> ,class O = typename is_chained_base<U>::value > struct ordered_euclidean_ring_operators : ordered_euclidean_ring_operators2<T, U, B> {}; template<class T, class U, class B> struct ordered_euclidean_ring_operators<T, U, B, ::boost::detail::true_t> : ordered_euclidean_ring_operators1<T, U> {}; template <class T, class B> struct ordered_euclidean_ring_operators<T, T, B, ::boost::detail::false_t> : ordered_euclidean_ring_operators1<T, B> {}; template<class T, class U, class B, class O> struct is_chained_base< ::boost::ordered_euclidean_ring_operators<T, U, B, O> > { typedef ::boost::detail::true_t value; }; template<class T, class U, class B> struct is_chained_base< ::boost::ordered_euclidean_ring_operators2<T, U, B> > { typedef ::boost::detail::true_t value; }; template<class T, class B> struct is_chained_base< ::boost::ordered_euclidean_ring_operators1<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::input_iteratable<T, U, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class B> struct is_chained_base< ::boost::output_iteratable<T, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::forward_iteratable<T, U, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class B> struct is_chained_base< ::boost::bidirectional_iteratable<T, U, B> > { typedef ::boost::detail::true_t value; };
 template<class T, class U, class V, class W, class B> struct is_chained_base< ::boost::random_access_iteratable<T, U, V, W, B> > { typedef ::boost::detail::true_t value; };
template <class T, class U>
struct operators2
    : totally_ordered2<T,U
    , integer_arithmetic2<T,U
    , bitwise2<T,U
      > > > {};
template <class T, class U = T>
struct operators : operators2<T, U> {};
template <class T> struct operators<T, T>
    : totally_ordered<T
    , integer_arithmetic<T
    , bitwise<T
    , unit_steppable<T
      > > > > {};
template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V const *,
          class R = V const &>
struct input_iterator_helper
  : input_iteratable<T, P
  , boost::iterator<std::input_iterator_tag, V, D, P, R
    > > {};
template<class T>
struct output_iterator_helper
  : output_iteratable<T
  , boost::iterator<std::output_iterator_tag, void, void, void, void
  > >
{
  T& operator*() { return static_cast<T&>(*this); }
  T& operator++() { return static_cast<T&>(*this); }
};
template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct forward_iterator_helper
  : forward_iteratable<T, P
  , boost::iterator<std::forward_iterator_tag, V, D, P, R
    > > {};
template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct bidirectional_iterator_helper
  : bidirectional_iteratable<T, P
  , boost::iterator<std::bidirectional_iterator_tag, V, D, P, R
    > > {};
template <class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&>
struct random_access_iterator_helper
  : random_access_iteratable<T, P, D, R
  , boost::iterator<std::random_access_iterator_tag, V, D, P, R
    > >
{
  friend D requires_difference_operator(const T& x, const T& y) {
    return x - y;
  }
};
}
namespace boost {
namespace date_time {
  enum time_resolutions {
    sec,
    tenth,
    hundreth,
    hundredth = hundreth,
    milli,
    ten_thousandth,
    micro,
    nano,
    NumResolutions
  };
  enum dst_flags {not_dst, is_dst, calculate};
} }
namespace boost {
namespace date_time {
    enum special_values {not_a_date_time,
                         neg_infin, pos_infin,
                         min_date_time, max_date_time,
                         not_special, NumSpecialValues};
} }
namespace boost {
namespace date_time {
  template<class T, typename rep_type>
  class time_duration : private
      boost::less_than_comparable<T
    , boost::equality_comparable<T
    > >
  {
  public:
    typedef T duration_type;
    typedef rep_type traits_type;
    typedef typename rep_type::day_type day_type;
    typedef typename rep_type::hour_type hour_type;
    typedef typename rep_type::min_type min_type;
    typedef typename rep_type::sec_type sec_type;
    typedef typename rep_type::fractional_seconds_type fractional_seconds_type;
    typedef typename rep_type::tick_type tick_type;
    typedef typename rep_type::impl_type impl_type;
    time_duration() : ticks_(0) {}
    time_duration(hour_type hours_in,
                  min_type minutes_in,
                  sec_type seconds_in=0,
                  fractional_seconds_type frac_sec_in = 0) :
      ticks_(rep_type::to_tick_count(hours_in,minutes_in,seconds_in,frac_sec_in))
    {}
    time_duration(const time_duration<T, rep_type>& other)
      : ticks_(other.ticks_)
    {}
    time_duration(special_values sv) : ticks_(impl_type::from_special(sv))
    {}
    static duration_type unit()
    {
      return duration_type(0,0,0,1);
    }
    static tick_type ticks_per_second()
    {
      return rep_type::res_adjust();
    }
    static time_resolutions resolution()
    {
      return rep_type::resolution();
    }
    hour_type hours() const
    {
      return static_cast<hour_type>(ticks() / (3600*ticks_per_second()));
    }
    min_type minutes() const
    {
      return static_cast<min_type>((ticks() / (60*ticks_per_second())) % 60);
    }
    sec_type seconds() const
    {
      return static_cast<sec_type>((ticks()/ticks_per_second()) % 60);
    }
    sec_type total_seconds() const
    {
      return static_cast<sec_type>(ticks() / ticks_per_second());
    }
    tick_type total_milliseconds() const
    {
      if (ticks_per_second() < 1000) {
        return ticks() * (static_cast<tick_type>(1000) / ticks_per_second());
      }
      return ticks() / (ticks_per_second() / static_cast<tick_type>(1000)) ;
    }
    tick_type total_nanoseconds() const
    {
      if (ticks_per_second() < 1000000000) {
        return ticks() * (static_cast<tick_type>(1000000000) / ticks_per_second());
      }
      return ticks() / (ticks_per_second() / static_cast<tick_type>(1000000000)) ;
    }
    tick_type total_microseconds() const
    {
      if (ticks_per_second() < 1000000) {
        return ticks() * (static_cast<tick_type>(1000000) / ticks_per_second());
      }
      return ticks() / (ticks_per_second() / static_cast<tick_type>(1000000)) ;
    }
    fractional_seconds_type fractional_seconds() const
    {
      return (ticks() % ticks_per_second());
    }
    static unsigned short num_fractional_digits()
    {
      return rep_type::num_fractional_digits();
    }
    duration_type invert_sign() const
    {
      return duration_type(ticks_ * (-1));
    }
    bool is_negative() const
    {
      return ticks_ < 0;
    }
    bool operator<(const time_duration& rhs) const
    {
      return ticks_ < rhs.ticks_;
    }
    bool operator==(const time_duration& rhs) const
    {
      return ticks_ == rhs.ticks_;
    }
    duration_type operator-()const
    {
      return duration_type(ticks_ * (-1));
    }
    duration_type operator-(const duration_type& d) const
    {
      return duration_type(ticks_ - d.ticks_);
    }
    duration_type operator+(const duration_type& d) const
    {
      return duration_type(ticks_ + d.ticks_);
    }
    duration_type operator/(int divisor) const
    {
      return duration_type(ticks_ / divisor);
    }
    duration_type operator-=(const duration_type& d)
    {
      ticks_ = ticks_ - d.ticks_;
      return duration_type(ticks_);
    }
    duration_type operator+=(const duration_type& d)
    {
      ticks_ = ticks_ + d.ticks_;
      return duration_type(ticks_);
    }
    duration_type operator/=(int divisor)
    {
      ticks_ = ticks_ / divisor;
      return duration_type(ticks_);
    }
    duration_type operator*(int rhs) const
    {
      return duration_type(ticks_ * rhs);
    }
    duration_type operator*=(int divisor)
    {
      ticks_ = ticks_ * divisor;
      return duration_type(ticks_);
    }
    tick_type ticks() const
    {
      return traits_type::as_number(ticks_);
    }
    bool is_special()const
    {
      if(traits_type::is_adapted())
      {
        return ticks_.is_special();
      }
      else{
        return false;
      }
    }
    bool is_pos_infinity()const
    {
      if(traits_type::is_adapted())
      {
        return ticks_.is_pos_infinity();
      }
      else{
        return false;
      }
    }
    bool is_neg_infinity()const
    {
      if(traits_type::is_adapted())
      {
        return ticks_.is_neg_infinity();
      }
      else{
        return false;
      }
    }
    bool is_not_a_date_time()const
    {
      if(traits_type::is_adapted())
      {
        return ticks_.is_nan();
      }
      else{
        return false;
      }
    }
    impl_type get_rep()const
    {
      return ticks_;
    }
  protected:
    explicit time_duration(impl_type in) : ticks_(in) {};
    impl_type ticks_;
  };
  template<class base_duration, boost::int64_t frac_of_second>
  class subsecond_duration : public base_duration
  {
  public:
    typedef typename base_duration::traits_type traits_type;
    explicit subsecond_duration(boost::int64_t ss) :
      base_duration(0,0,0,ss*traits_type::res_adjust()/frac_of_second)
    {}
  };
} }
namespace boost {
namespace date_time {
template<typename int_type_>
class int_adapter {
public:
  typedef int_type_ int_type;
  int_adapter(int_type v) :
    value_(v)
  {}
  static bool has_infinity()
  {
    return true;
  }
  static const int_adapter pos_infinity()
  {
    return (::std::numeric_limits<int_type>::max)();
  }
  static const int_adapter neg_infinity()
  {
    return (::std::numeric_limits<int_type>::min)();
  }
  static const int_adapter not_a_number()
  {
    return (::std::numeric_limits<int_type>::max)()-1;
  }
  static int_adapter max ()
  {
    return (::std::numeric_limits<int_type>::max)()-2;
  }
  static int_adapter min ()
  {
    return (::std::numeric_limits<int_type>::min)()+1;
  }
  static int_adapter from_special(special_values sv)
  {
    switch (sv) {
    case not_a_date_time: return not_a_number();
    case neg_infin: return neg_infinity();
    case pos_infin: return pos_infinity();
    case max_date_time: return (max)();
    case min_date_time: return (min)();
    default: return not_a_number();
    }
  }
  static bool is_inf(int_type v)
  {
    return (v == neg_infinity().as_number() ||
            v == pos_infinity().as_number());
  }
  static bool is_neg_inf(int_type v)
  {
    return (v == neg_infinity().as_number());
  }
  static bool is_pos_inf(int_type v)
  {
    return (v == pos_infinity().as_number());
  }
  static bool is_not_a_number(int_type v)
  {
    return (v == not_a_number().as_number());
  }
  static special_values to_special(int_type v)
  {
    if (is_not_a_number(v)) return not_a_date_time;
    if (is_neg_inf(v)) return neg_infin;
    if (is_pos_inf(v)) return pos_infin;
    return not_special;
  }
  static int_type maxcount()
  {
    return (::std::numeric_limits<int_type>::max)()-3;
  }
  bool is_infinity() const
  {
    return (value_ == neg_infinity().as_number() ||
            value_ == pos_infinity().as_number());
  }
  bool is_pos_infinity()const
  {
    return(value_ == pos_infinity().as_number());
  }
  bool is_neg_infinity()const
  {
    return(value_ == neg_infinity().as_number());
  }
  bool is_nan() const
  {
    return (value_ == not_a_number().as_number());
  }
  bool is_special() const
  {
    return(is_infinity() || is_nan());
  }
  bool operator==(const int_adapter& rhs) const
  {
    return (compare(rhs) == 0);
  }
  bool operator==(const int& rhs) const
  {
    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(!is_signed)
    {
      if(is_neg_inf(value_) && rhs == 0)
      {
        return false;
      }
    }
    return (compare(rhs) == 0);
  }
  bool operator!=(const int_adapter& rhs) const
  {
    return (compare(rhs) != 0);
  }
  bool operator!=(const int& rhs) const
  {
    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(!is_signed)
    {
      if(is_neg_inf(value_) && rhs == 0)
      {
        return true;
      }
    }
    return (compare(rhs) != 0);
  }
  bool operator<(const int_adapter& rhs) const
  {
    return (compare(rhs) == -1);
  }
  bool operator<(const int& rhs) const
  {
    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(!is_signed)
    {
      if(is_neg_inf(value_) && rhs == 0)
      {
        return true;
      }
    }
    return (compare(rhs) == -1);
  }
  bool operator>(const int_adapter& rhs) const
  {
    return (compare(rhs) == 1);
  }
  int_type as_number() const
  {
    return value_;
  }
  special_values as_special() const
  {
    return int_adapter::to_special(value_);
  }
  template<class rhs_type>
  inline
  int_adapter operator+(const int_adapter<rhs_type>& rhs) const
  {
    if(is_special() || rhs.is_special())
    {
      if (is_nan() || rhs.is_nan())
      {
        return int_adapter::not_a_number();
      }
      if((is_pos_inf(value_) && rhs.is_neg_inf(rhs.as_number())) ||
      (is_neg_inf(value_) && rhs.is_pos_inf(rhs.as_number())) )
      {
        return int_adapter::not_a_number();
      }
      if (is_infinity())
      {
        return *this;
      }
      if (rhs.is_pos_inf(rhs.as_number()))
      {
        return int_adapter::pos_infinity();
      }
      if (rhs.is_neg_inf(rhs.as_number()))
      {
        return int_adapter::neg_infinity();
      }
    }
    return int_adapter<int_type>(value_ + rhs.as_number());
  }
  int_adapter operator+(const int_type rhs) const
  {
    if(is_special())
    {
      if (is_nan())
      {
        return int_adapter<int_type>(not_a_number());
      }
      if (is_infinity())
      {
        return *this;
      }
    }
    return int_adapter<int_type>(value_ + rhs);
  }
  template<class rhs_type>
  inline
  int_adapter operator-(const int_adapter<rhs_type>& rhs)const
  {
    if(is_special() || rhs.is_special())
    {
      if (is_nan() || rhs.is_nan())
      {
        return int_adapter::not_a_number();
      }
      if((is_pos_inf(value_) && rhs.is_pos_inf(rhs.as_number())) ||
         (is_neg_inf(value_) && rhs.is_neg_inf(rhs.as_number())) )
      {
        return int_adapter::not_a_number();
      }
      if (is_infinity())
      {
        return *this;
      }
      if (rhs.is_pos_inf(rhs.as_number()))
      {
        return int_adapter::neg_infinity();
      }
      if (rhs.is_neg_inf(rhs.as_number()))
      {
        return int_adapter::pos_infinity();
      }
    }
    return int_adapter<int_type>(value_ - rhs.as_number());
  }
  int_adapter operator-(const int_type rhs) const
  {
    if(is_special())
    {
      if (is_nan())
      {
        return int_adapter<int_type>(not_a_number());
      }
      if (is_infinity())
      {
        return *this;
      }
    }
    return int_adapter<int_type>(value_ - rhs);
  }
  int_adapter operator*(const int_adapter& rhs)const
  {
    if(this->is_special() || rhs.is_special())
    {
      return mult_div_specials(rhs);
    }
    return int_adapter<int_type>(value_ * rhs.value_);
  }
  int_adapter operator*(const int rhs) const
  {
    if(is_special())
    {
      return mult_div_specials(rhs);
    }
    return int_adapter<int_type>(value_ * rhs);
  }
  int_adapter operator/(const int_adapter& rhs)const
  {
    if(this->is_special() || rhs.is_special())
    {
      if(is_infinity() && rhs.is_infinity())
      {
        return int_adapter<int_type>(not_a_number());
      }
      if(rhs != 0)
      {
        return mult_div_specials(rhs);
      }
      else {
        return int_adapter<int_type>(value_ / rhs.value_);
      }
    }
    return int_adapter<int_type>(value_ / rhs.value_);
  }
  int_adapter operator/(const int rhs) const
  {
    if(is_special() && rhs != 0)
    {
      return mult_div_specials(rhs);
    }
    return int_adapter<int_type>(value_ / rhs);
  }
  int_adapter operator%(const int_adapter& rhs)const
  {
    if(this->is_special() || rhs.is_special())
    {
      if(is_infinity() && rhs.is_infinity())
      {
        return int_adapter<int_type>(not_a_number());
      }
      if(rhs != 0)
      {
        return mult_div_specials(rhs);
      }
      else {
        return int_adapter<int_type>(value_ % rhs.value_);
      }
    }
    return int_adapter<int_type>(value_ % rhs.value_);
  }
  int_adapter operator%(const int rhs) const
  {
    if(is_special() && rhs != 0)
    {
      return mult_div_specials(rhs);
    }
    return int_adapter<int_type>(value_ % rhs);
  }
private:
  int_type value_;
  int compare(const int_adapter& rhs)const
  {
    if(this->is_special() || rhs.is_special())
    {
      if(this->is_nan() || rhs.is_nan()) {
        if(this->is_nan() && rhs.is_nan()) {
          return 0;
        }
        else {
          return 2;
        }
      }
      if((is_neg_inf(value_) && !is_neg_inf(rhs.value_)) ||
         (is_pos_inf(rhs.value_) && !is_pos_inf(value_)) )
        {
          return -1;
        }
      if((is_pos_inf(value_) && !is_pos_inf(rhs.value_)) ||
         (is_neg_inf(rhs.value_) && !is_neg_inf(value_)) ) {
        return 1;
      }
    }
    if(value_ < rhs.value_) return -1;
    if(value_ > rhs.value_) return 1;
    return 0;
  }
  int_adapter mult_div_specials(const int_adapter& rhs)const
  {
    int min_value;
    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(is_signed) {
      min_value = 0;
    }
    else {
      min_value = 1;
    }
    if(this->is_nan() || rhs.is_nan()) {
      return int_adapter<int_type>(not_a_number());
    }
    if((*this > 0 && rhs > 0) || (*this < min_value && rhs < min_value)) {
        return int_adapter<int_type>(pos_infinity());
    }
    if((*this > 0 && rhs < min_value) || (*this < min_value && rhs > 0)) {
        return int_adapter<int_type>(neg_infinity());
    }
    return int_adapter<int_type>(not_a_number());
  }
  int_adapter mult_div_specials(const int& rhs) const
  {
    int min_value;
    bool is_signed = std::numeric_limits<int_type>::is_signed;
    if(is_signed) {
      min_value = 0;
    }
    else {
      min_value = 1;
    }
    if(this->is_nan()) {
      return int_adapter<int_type>(not_a_number());
    }
    if((*this > 0 && rhs > 0) || (*this < min_value && rhs < 0)) {
        return int_adapter<int_type>(pos_infinity());
    }
    if((*this > 0 && rhs < 0) || (*this < min_value && rhs > 0)) {
        return int_adapter<int_type>(neg_infinity());
    }
    return int_adapter<int_type>(not_a_number());
  }
};
  template<class charT, class traits, typename int_type>
  inline
  std::basic_ostream<charT, traits>&
  operator<<(std::basic_ostream<charT, traits>& os, const int_adapter<int_type>& ia)
  {
    if(ia.is_special()) {
      switch(ia.as_special())
        {
      case not_a_date_time:
        os << "not-a-number";
        break;
      case pos_infin:
        os << "+infinity";
        break;
      case neg_infin:
        os << "-infinity";
        break;
      default:
        os << "";
      }
    }
    else {
      os << ia.as_number();
    }
    return os;
  }
} }
namespace boost {
namespace date_time {
  template <typename T>
  inline T absolute_value(T x)
  {
    return x < 0 ? -x : x;
  }
  struct time_resolution_traits_bi32_impl {
    typedef boost::int32_t int_type;
    typedef boost::int32_t impl_type;
    static int_type as_number(impl_type i){ return i;}
    static bool is_adapted() { return false;}
  };
  struct time_resolution_traits_adapted32_impl {
    typedef boost::int32_t int_type;
    typedef boost::date_time::int_adapter<boost::int32_t> impl_type;
    static int_type as_number(impl_type i){ return i.as_number();}
    static bool is_adapted() { return true;}
  };
  struct time_resolution_traits_bi64_impl {
    typedef boost::int64_t int_type;
    typedef boost::int64_t impl_type;
    static int_type as_number(impl_type i){ return i;}
    static bool is_adapted() { return false;}
  };
  struct time_resolution_traits_adapted64_impl {
    typedef boost::int64_t int_type;
    typedef boost::date_time::int_adapter<boost::int64_t> impl_type;
    static int_type as_number(impl_type i){ return i.as_number();}
    static bool is_adapted() { return true;}
  };
  template<typename frac_sec_type,
           time_resolutions res,
           typename frac_sec_type::int_type resolution_adjust,
           unsigned short frac_digits,
           typename v_type = boost::int32_t >
  class time_resolution_traits {
  public:
    typedef typename frac_sec_type::int_type fractional_seconds_type;
    typedef typename frac_sec_type::int_type tick_type;
    typedef typename frac_sec_type::impl_type impl_type;
    typedef v_type day_type;
    typedef v_type hour_type;
    typedef v_type min_type;
    typedef v_type sec_type;
    static fractional_seconds_type as_number(impl_type i)
    {
      return frac_sec_type::as_number(i);
    }
    static bool is_adapted()
    {
      return frac_sec_type::is_adapted();
    }
    static const fractional_seconds_type ticks_per_second = resolution_adjust;
    static time_resolutions resolution()
    {
      return res;
    }
    static unsigned short num_fractional_digits()
    {
      return frac_digits;
    }
    static fractional_seconds_type res_adjust()
    {
      return resolution_adjust;
    }
    static tick_type to_tick_count(hour_type hours,
                                   min_type minutes,
                                   sec_type seconds,
                                   fractional_seconds_type fs)
    {
      if(hours < 0 || minutes < 0 || seconds < 0 || fs < 0)
      {
        hours = absolute_value(hours);
        minutes = absolute_value(minutes);
        seconds = absolute_value(seconds);
        fs = absolute_value(fs);
        return (((((fractional_seconds_type(hours)*3600)
                   + (fractional_seconds_type(minutes)*60)
                   + seconds)*res_adjust()) + fs) * -1);
      }
      return (((fractional_seconds_type(hours)*3600)
               + (fractional_seconds_type(minutes)*60)
               + seconds)*res_adjust()) + fs;
    }
  };
  typedef time_resolution_traits<time_resolution_traits_adapted32_impl, milli, 1000, 3 > milli_res;
  typedef time_resolution_traits<time_resolution_traits_adapted64_impl, micro, 1000000, 6 > micro_res;
  typedef time_resolution_traits<time_resolution_traits_adapted64_impl, nano, 1000000000, 9 > nano_res;
} }
namespace boost {
namespace date_time {
  template<typename YearType, typename MonthType, typename DayType>
  struct year_month_day_base {
    year_month_day_base(YearType year,
                        MonthType month,
                        DayType day);
    YearType year;
    MonthType month;
    DayType day;
    typedef YearType year_type;
    typedef MonthType month_type;
    typedef DayType day_type;
  };
  template<typename YearType, typename MonthType, typename DayType>
  inline
  year_month_day_base<YearType,MonthType,DayType>::year_month_day_base(YearType y,
                                                                       MonthType m,
                                                                       DayType d) :
    year(y),
    month(m),
    day(d)
  {}
} }
namespace boost {
namespace date_time {
  template<class T, class calendar, class duration_type_>
  class date : private
       boost::less_than_comparable<T
     , boost::equality_comparable<T
    > >
  {
  public:
    typedef T date_type;
    typedef calendar calendar_type;
    typedef typename calendar::date_traits_type traits_type;
    typedef duration_type_ duration_type;
    typedef typename calendar::year_type year_type;
    typedef typename calendar::month_type month_type;
    typedef typename calendar::day_type day_type;
    typedef typename calendar::ymd_type ymd_type;
    typedef typename calendar::date_rep_type date_rep_type;
    typedef typename calendar::date_int_type date_int_type;
    typedef typename calendar::day_of_week_type day_of_week_type;
    date(year_type y, month_type m, day_type d)
      : days_(calendar::day_number(ymd_type(y, m, d)))
    {}
    date(const ymd_type& ymd)
      : days_(calendar::day_number(ymd))
    {}
    year_type year() const
    {
      ymd_type ymd = calendar::from_day_number(days_);
      return ymd.year;
    }
    month_type month() const
    {
      ymd_type ymd = calendar::from_day_number(days_);
      return ymd.month;
    }
    day_type day() const
    {
      ymd_type ymd = calendar::from_day_number(days_);
      return ymd.day;
    }
    day_of_week_type day_of_week() const
    {
      ymd_type ymd = calendar::from_day_number(days_);
      return calendar::day_of_week(ymd);
    }
    ymd_type year_month_day() const
    {
      return calendar::from_day_number(days_);
    }
    bool operator<(const date_type& rhs) const
    {
      return days_ < rhs.days_;
    }
    bool operator==(const date_type& rhs) const
    {
      return days_ == rhs.days_;
    }
    bool is_special()const
    {
      return(is_not_a_date() || is_infinity());
    }
    bool is_not_a_date() const
    {
      return traits_type::is_not_a_number(days_);
    }
    bool is_infinity() const
    {
      return traits_type::is_inf(days_);
    }
    bool is_pos_infinity() const
    {
      return traits_type::is_pos_inf(days_);
    }
    bool is_neg_infinity() const
    {
      return traits_type::is_neg_inf(days_);
    }
    special_values as_special() const
    {
      return traits_type::to_special(days_);
    }
    duration_type operator-(const date_type& d) const
    {
      if (!this->is_special() && !d.is_special())
      {
        typedef typename duration_type::duration_rep_type duration_rep_type;
        return duration_type(static_cast< duration_rep_type >(days_) - static_cast< duration_rep_type >(d.days_));
      }
      else
      {
        date_rep_type val = date_rep_type(days_) - date_rep_type(d.days_);
        return duration_type(val.as_special());
      }
    }
    date_type operator-(const duration_type& dd) const
    {
      if(dd.is_special())
      {
        return date_type(date_rep_type(days_) - dd.get_rep());
      }
      return date_type(date_rep_type(days_) - dd.days());
    }
    date_type operator-=(const duration_type& dd)
    {
      *this = *this - dd;
      return date_type(days_);
    }
    date_rep_type day_count() const
    {
      return days_;
    }
    date_type operator+(const duration_type& dd) const
    {
      if(dd.is_special())
      {
        return date_type(date_rep_type(days_) + dd.get_rep());
      }
      return date_type(date_rep_type(days_) + dd.days());
    }
    date_type operator+=(const duration_type& dd)
    {
      *this = *this + dd;
      return date_type(days_);
    }
  protected:
    explicit date(date_int_type days) : days_(days) {};
    explicit date(date_rep_type days) : days_(days.as_number()) {};
    date_int_type days_;
  };
} }
namespace boost {
namespace date_time {
  template<class point_rep, class duration_rep>
  class period : private
      boost::less_than_comparable<period<point_rep, duration_rep>
    , boost::equality_comparable< period<point_rep, duration_rep>
    > >
  {
  public:
    typedef point_rep point_type;
    typedef duration_rep duration_type;
    period(point_rep first_point, point_rep end_point);
    period(point_rep first_point, duration_rep len);
    point_rep begin() const;
    point_rep end() const;
    point_rep last() const;
    duration_rep length() const;
    bool is_null() const;
    bool operator==(const period& rhs) const;
    bool operator<(const period& rhs) const;
    void shift(const duration_rep& d);
    void expand(const duration_rep& d);
    bool contains(const point_rep& point) const;
    bool contains(const period& other) const;
    bool intersects(const period& other) const;
    bool is_adjacent(const period& other) const;
    bool is_before(const point_rep& point) const;
    bool is_after(const point_rep& point) const;
    period intersection(const period& other) const;
    period merge(const period& other) const;
    period span(const period& other) const;
  private:
    point_rep begin_;
    point_rep last_;
  };
  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>::period(point_rep first_point,
                                         point_rep end_point) :
    begin_(first_point),
    last_(end_point - duration_rep::unit())
  {}
  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>::period(point_rep first_point, duration_rep len) :
    begin_(first_point),
    last_(first_point + len-duration_rep::unit())
  { }
  template<class point_rep, class duration_rep>
  inline
  point_rep period<point_rep,duration_rep>::begin() const
  {
    return begin_;
  }
  template<class point_rep, class duration_rep>
  inline
  point_rep period<point_rep,duration_rep>::end() const
  {
    return last_ + duration_rep::unit();
  }
  template<class point_rep, class duration_rep>
  inline
  point_rep period<point_rep,duration_rep>::last() const
  {
    return last_;
  }
  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::is_null() const
  {
    return end() <= begin_;
  }
  template<class point_rep, class duration_rep>
  inline
  duration_rep period<point_rep,duration_rep>::length() const
  {
    if(last_ < begin_){
      return last_+duration_rep::unit() - begin_;
    }
    else{
      return end() - begin_;
    }
  }
  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::operator==(const period& rhs) const
  {
    return ((begin_ == rhs.begin_) &&
             (last_ == rhs.last_));
  }
  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::operator<(const period& rhs) const
  {
    return (last_ < rhs.begin_);
  }
  template<class point_rep, class duration_rep>
  inline
  void period<point_rep,duration_rep>::shift(const duration_rep& d)
  {
    begin_ = begin_ + d;
    last_ = last_ + d;
  }
  template<class point_rep, class duration_rep>
  inline
  void period<point_rep,duration_rep>::expand(const duration_rep& d)
  {
    begin_ = begin_ - d;
    last_ = last_ + d;
  }
  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::contains(const point_rep& point) const
  {
    return ((point >= begin_) &&
            (point <= last_));
  }
  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::contains(const period<point_rep,duration_rep>& other) const
  {
    return ((begin_ <= other.begin_) && (last_ >= other.last_));
  }
  template<class point_rep, class duration_rep>
  inline
  bool
  period<point_rep,duration_rep>::is_adjacent(const period<point_rep,duration_rep>& other) const
  {
    return (other.begin() == end() ||
            begin_ == other.end());
  }
  template<class point_rep, class duration_rep>
  inline
  bool
  period<point_rep,duration_rep>::is_after(const point_rep& t) const
  {
    if (is_null())
    {
      return false;
    }
    return t < begin_;
  }
  template<class point_rep, class duration_rep>
  inline
  bool
  period<point_rep,duration_rep>::is_before(const point_rep& t) const
  {
    if (is_null())
    {
      return false;
    }
    return last_ < t;
  }
  template<class point_rep, class duration_rep>
  inline
  bool period<point_rep,duration_rep>::intersects(const period<point_rep,duration_rep>& other) const
  {
    return ( contains(other.begin_) ||
             other.contains(begin_) ||
             ((other.begin_ < begin_) && (other.last_ >= begin_)));
  }
  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>
  period<point_rep,duration_rep>::intersection(const period<point_rep,duration_rep>& other) const
  {
    if (begin_ > other.begin_) {
      if (last_ <= other.last_) {
        return *this;
      }
      return period<point_rep,duration_rep>(begin_, other.end());
    }
    else {
      if (last_ <= other.last_) {
        return period<point_rep,duration_rep>(other.begin_, this->end());
      }
      return other;
    }
  }
  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>
  period<point_rep,duration_rep>::merge(const period<point_rep,duration_rep>& other) const
  {
    if (this->intersects(other)) {
      if (begin_ < other.begin_) {
        return period<point_rep,duration_rep>(begin_, last_ > other.last_ ? this->end() : other.end());
      }
      return period<point_rep,duration_rep>(other.begin_, last_ > other.last_ ? this->end() : other.end());
    }
    return period<point_rep,duration_rep>(begin_,begin_);
  }
  template<class point_rep, class duration_rep>
  inline
  period<point_rep,duration_rep>
  period<point_rep,duration_rep>::span(const period<point_rep,duration_rep>& other) const
  {
    point_rep start((begin_ < other.begin_) ? begin() : other.begin());
    point_rep newend((last_ < other.last_) ? other.end() : this->end());
    return period<point_rep,duration_rep>(start, newend);
  }
} }
namespace boost {
namespace detail {
template <typename B, typename D>
struct is_base_and_derived_impl
{
    typedef typename remove_cv<B>::type ncvB;
    typedef typename remove_cv<D>::type ncvD;
    static const bool value = ((__is_base_of(B,D) && !is_same<B,D>::value) && ! ::boost::is_same<ncvB,ncvD>::value);
};
}
template< typename Base, typename Derived > struct is_base_and_derived : public ::boost::integral_constant<bool,(::boost::detail::is_base_and_derived_impl<Base,Derived>::value)> { public: };
template< typename Base, typename Derived > struct is_base_and_derived< Base&,Derived > : public ::boost::integral_constant<bool,false> { public: };
template< typename Base, typename Derived > struct is_base_and_derived< Base,Derived& > : public ::boost::integral_constant<bool,false> { public: };
template< typename Base, typename Derived > struct is_base_and_derived< Base&,Derived& > : public ::boost::integral_constant<bool,false> { public: };
}
namespace boost {
   namespace detail{
      template <class B, class D>
      struct is_base_of_imp
      {
          typedef typename remove_cv<B>::type ncvB;
          typedef typename remove_cv<D>::type ncvD;
          static const bool value = (::boost::type_traits::ice_or< (::boost::detail::is_base_and_derived_impl<ncvB,ncvD>::value), (::boost::type_traits::ice_and< ::boost::is_same<ncvB,ncvD>::value, ::boost::is_class<ncvB>::value>::value)>::value);
      };
   }
template< typename Base, typename Derived > struct is_base_of : public ::boost::integral_constant<bool,(::boost::detail::is_base_of_imp<Base, Derived>::value)> { public: };
template< typename Base, typename Derived > struct is_base_of< Base&,Derived > : public ::boost::integral_constant<bool,false> { public: };
template< typename Base, typename Derived > struct is_base_of< Base,Derived& > : public ::boost::integral_constant<bool,false> { public: };
template< typename Base, typename Derived > struct is_base_of< Base&,Derived& > : public ::boost::integral_constant<bool,false> { public: };
}
namespace boost {
namespace CV {
  enum violation_enum {min_violation, max_violation};
  template<class value_policies>
  class constrained_value {
  public:
    typedef typename value_policies::value_type value_type;
    constrained_value(value_type value) : value_((min)())
    {
      assign(value);
    }
    constrained_value& operator=(value_type v)
    {
      assign(v);
      return *this;
    }
    static value_type max () {return (value_policies::max)();}
    static value_type min () {return (value_policies::min)();}
    operator value_type() const {return value_;}
  protected:
    value_type value_;
  private:
    void assign(value_type value)
    {
      if (value+1 < (min)()+1) {
        value_policies::on_error(value_, value, min_violation);
        return;
      }
      if (value > (max)()) {
        value_policies::on_error(value_, value, max_violation);
        return;
      }
      value_ = value;
    }
};
  template<typename rep_type, rep_type min_value,
           rep_type max_value, class exception_type>
  class simple_exception_policy
  {
    struct exception_wrapper : public exception_type
    {
      operator std::out_of_range () const
      {
        return std::out_of_range("constrained value boundary has been violated");
      }
    };
    typedef typename mpl::if_<
      is_base_of< std::exception, exception_type >,
      exception_type,
      exception_wrapper
    >::type actual_exception_type;
  public:
    typedef rep_type value_type;
    static rep_type min () { return min_value; }
    static rep_type max () { return max_value; }
    static void on_error(rep_type, rep_type, violation_enum)
    {
      boost::throw_exception(actual_exception_type());
    }
  };
} }
namespace boost {
namespace date_time {
  enum weekdays {Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday};
  enum months_of_year {Jan=1,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec,NotAMonth,NumMonths};
} }
namespace boost {
namespace gregorian {
  using date_time::Sunday;
  using date_time::Monday;
  using date_time::Tuesday;
  using date_time::Wednesday;
  using date_time::Thursday;
  using date_time::Friday;
  using date_time::Saturday;
  struct bad_weekday : public std::out_of_range
  {
    bad_weekday() : std::out_of_range(std::string("Weekday is out of range 0..6")) {}
  };
  typedef CV::simple_exception_policy<unsigned short, 0, 6, bad_weekday> greg_weekday_policies;
  typedef CV::constrained_value<greg_weekday_policies> greg_weekday_rep;
  class greg_weekday : public greg_weekday_rep {
  public:
    typedef boost::date_time::weekdays weekday_enum;
    greg_weekday(unsigned short day_of_week_num) :
      greg_weekday_rep(day_of_week_num)
    {}
    unsigned short as_number() const {return value_;}
    const char* as_short_string() const;
    const char* as_long_string() const;
    const wchar_t* as_short_wstring() const;
    const wchar_t* as_long_wstring() const;
    weekday_enum as_enum() const {return static_cast<weekday_enum>(value_);}
  };
} }
namespace boost {
namespace gregorian {
  struct bad_day_of_year : public std::out_of_range
  {
    bad_day_of_year() :
      std::out_of_range(std::string("Day of year value is out of range 1..366"))
    {}
  };
  typedef CV::simple_exception_policy<unsigned short,1,366,bad_day_of_year> greg_day_of_year_policies;
  typedef CV::constrained_value<greg_day_of_year_policies> greg_day_of_year_rep;
} }
namespace boost {
namespace date_time {
  template<typename ymd_type_, typename date_int_type_>
  class gregorian_calendar_base {
  public:
    typedef ymd_type_ ymd_type;
    typedef typename ymd_type::month_type month_type;
    typedef typename ymd_type::day_type day_type;
    typedef typename ymd_type::year_type year_type;
    typedef date_int_type_ date_int_type;
    static unsigned short day_of_week(const ymd_type& ymd);
    static int week_number(const ymd_type&ymd);
    static date_int_type day_number(const ymd_type& ymd);
    static date_int_type julian_day_number(const ymd_type& ymd);
    static date_int_type modjulian_day_number(const ymd_type& ymd);
    static ymd_type from_day_number(date_int_type);
    static ymd_type from_julian_day_number(date_int_type);
    static ymd_type from_modjulian_day_number(date_int_type);
    static bool is_leap_year(year_type);
    static unsigned short end_of_month_day(year_type y, month_type m);
    static ymd_type epoch();
    static unsigned short days_in_week();
  };
} }
namespace boost {
namespace date_time {
  template<typename ymd_type_, typename date_int_type_>
  inline
  unsigned short
  gregorian_calendar_base<ymd_type_,date_int_type_>::day_of_week(const ymd_type& ymd) {
    unsigned short a = static_cast<unsigned short>((14-ymd.month)/12);
    unsigned short y = static_cast<unsigned short>(ymd.year - a);
    unsigned short m = static_cast<unsigned short>(ymd.month + 12*a - 2);
    unsigned short d = static_cast<unsigned short>((ymd.day + y + (y/4) - (y/100) + (y/400) + (31*m)/12) % 7);
    return d;
  }
  template<typename ymd_type_, typename date_int_type_>
  inline
  int
  gregorian_calendar_base<ymd_type_,date_int_type_>::week_number(const ymd_type& ymd) {
    unsigned long julianbegin = julian_day_number(ymd_type(ymd.year,1,1));
    unsigned long juliantoday = julian_day_number(ymd);
    unsigned long day = (julianbegin + 3) % 7;
    unsigned long week = (juliantoday + day - julianbegin + 4)/7;
    if ((week >= 1) && (week <= 52)) {
      return week;
    }
    if (week == 53) {
      if((day==6) ||(day == 5 && is_leap_year(ymd.year))) {
        return week;
      } else {
        return 1;
      }
    }
    else if (week == 0) {
      julianbegin = julian_day_number(ymd_type(static_cast<unsigned short>(ymd.year-1),1,1));
      juliantoday = julian_day_number(ymd);
      day = (julianbegin + 3) % 7;
      week = (juliantoday + day - julianbegin + 4)/7;
      return week;
    }
    return week;
  }
  template<typename ymd_type_, typename date_int_type_>
  inline
  date_int_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::day_number(const ymd_type& ymd)
  {
    unsigned short a = static_cast<unsigned short>((14-ymd.month)/12);
    unsigned short y = static_cast<unsigned short>(ymd.year + 4800 - a);
    unsigned short m = static_cast<unsigned short>(ymd.month + 12*a - 3);
    unsigned long d = ymd.day + ((153*m + 2)/5) + 365*y + (y/4) - (y/100) + (y/400) - 32045;
    return d;
  }
  template<typename ymd_type_, typename date_int_type_>
  inline
  date_int_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::julian_day_number(const ymd_type& ymd)
  {
    return day_number(ymd);
  }
  template<typename ymd_type_, typename date_int_type_>
  inline
  date_int_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::modjulian_day_number(const ymd_type& ymd)
  {
    return julian_day_number(ymd)-2400001;
  }
  template<typename ymd_type_, typename date_int_type_>
  inline
  ymd_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::from_day_number(date_int_type dayNumber)
  {
    date_int_type a = dayNumber + 32044;
    date_int_type b = (4*a + 3)/146097;
    date_int_type c = a-((146097*b)/4);
    date_int_type d = (4*c + 3)/1461;
    date_int_type e = c - (1461*d)/4;
    date_int_type m = (5*e + 2)/153;
    unsigned short day = static_cast<unsigned short>(e - ((153*m + 2)/5) + 1);
    unsigned short month = static_cast<unsigned short>(m + 3 - 12 * (m/10));
    year_type year = static_cast<unsigned short>(100*b + d - 4800 + (m/10));
    return ymd_type(static_cast<unsigned short>(year),month,day);
  }
  template<typename ymd_type_, typename date_int_type_>
  inline
  ymd_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::from_julian_day_number(date_int_type dayNumber)
  {
    date_int_type a = dayNumber + 32044;
    date_int_type b = (4*a+3)/146097;
    date_int_type c = a - ((146097*b)/4);
    date_int_type d = (4*c + 3)/1461;
    date_int_type e = c - ((1461*d)/4);
    date_int_type m = (5*e + 2)/153;
    unsigned short day = static_cast<unsigned short>(e - ((153*m + 2)/5) + 1);
    unsigned short month = static_cast<unsigned short>(m + 3 - 12 * (m/10));
    year_type year = static_cast<year_type>(100*b + d - 4800 + (m/10));
    return ymd_type(year,month,day);
  }
  template<typename ymd_type_, typename date_int_type_>
  inline
  ymd_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::from_modjulian_day_number(date_int_type dayNumber) {
    date_int_type jd = dayNumber + 2400001;
    return from_julian_day_number(jd);
  }
  template<typename ymd_type_, typename date_int_type_>
  inline
  bool
  gregorian_calendar_base<ymd_type_,date_int_type_>::is_leap_year(year_type year)
  {
    return (!(year % 4)) && ((year % 100) || (!(year % 400)));
  }
  template<typename ymd_type_, typename date_int_type_>
  inline
  unsigned short
  gregorian_calendar_base<ymd_type_,date_int_type_>::end_of_month_day(year_type year,
                                                                      month_type month)
  {
    switch (month) {
    case 2:
      if (is_leap_year(year)) {
        return 29;
      } else {
        return 28;
      };
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
    default:
      return 31;
    };
  }
  template<typename ymd_type_, typename date_int_type_>
  inline
  ymd_type_
  gregorian_calendar_base<ymd_type_,date_int_type_>::epoch()
  {
    return ymd_type(1400,1,1);
  }
  template<typename ymd_type_, typename date_int_type_>
  inline
  unsigned short
  gregorian_calendar_base<ymd_type_,date_int_type_>::days_in_week()
  {
    return 7;
  }
} }
namespace boost {
namespace gregorian {
  struct bad_day_of_month : public std::out_of_range
  {
    bad_day_of_month() :
      std::out_of_range(std::string("Day of month value is out of range 1..31"))
    {}
    bad_day_of_month(const std::string& s) :
      std::out_of_range(s)
    {}
  };
  typedef CV::simple_exception_policy<unsigned short, 1, 31, bad_day_of_month> greg_day_policies;
  typedef CV::constrained_value<greg_day_policies> greg_day_rep;
  class greg_day : public greg_day_rep {
  public:
    greg_day(unsigned short day_of_month) : greg_day_rep(day_of_month) {}
    unsigned short as_number() const {return value_;}
    operator unsigned short() const {return value_;}
  private:
  };
} }
namespace boost {
namespace gregorian {
  struct bad_year : public std::out_of_range
  {
    bad_year() :
      std::out_of_range(std::string("Year is out of valid range: 1400..10000"))
    {}
  };
  typedef CV::simple_exception_policy<unsigned short, 1400, 10000, bad_year> greg_year_policies;
  typedef CV::constrained_value<greg_year_policies> greg_year_rep;
  class greg_year : public greg_year_rep {
  public:
    greg_year(unsigned short year) : greg_year_rep(year) {}
    operator unsigned short() const {return value_;}
  private:
  };
} }
       
namespace boost {
namespace gregorian {
  typedef date_time::months_of_year months_of_year;
  using date_time::Jan;
  using date_time::Feb;
  using date_time::Mar;
  using date_time::Apr;
  using date_time::May;
  using date_time::Jun;
  using date_time::Jul;
  using date_time::Aug;
  using date_time::Sep;
  using date_time::Oct;
  using date_time::Nov;
  using date_time::Dec;
  using date_time::NotAMonth;
  using date_time::NumMonths;
  struct bad_month : public std::out_of_range
  {
    bad_month() : std::out_of_range(std::string("Month number is out of range 1..12")) {}
  };
  typedef CV::simple_exception_policy<unsigned short, 1, 12, bad_month> greg_month_policies;
  typedef CV::constrained_value<greg_month_policies> greg_month_rep;
  class greg_month : public greg_month_rep {
  public:
    typedef date_time::months_of_year month_enum;
    typedef std::map<std::string, unsigned short> month_map_type;
    typedef boost::shared_ptr<month_map_type> month_map_ptr_type;
    greg_month(month_enum theMonth) :
      greg_month_rep(static_cast<greg_month_rep::value_type>(theMonth)) {}
    greg_month(unsigned short theMonth) : greg_month_rep(theMonth) {}
    operator unsigned short() const {return value_;}
    unsigned short as_number() const {return value_;}
    month_enum as_enum() const {return static_cast<month_enum>(value_);}
    const char* as_short_string() const;
    const char* as_long_string() const;
    const wchar_t* as_short_wstring() const;
    const wchar_t* as_long_wstring() const;
    static month_map_ptr_type get_month_map_ptr();
    const char* as_short_string(char) const
    {
      return as_short_string();
    }
    const char* as_long_string(char) const
    {
      return as_long_string();
    }
    const wchar_t* as_short_string(wchar_t) const
    {
      return as_short_wstring();
    }
    const wchar_t* as_long_string(wchar_t) const
    {
      return as_long_wstring();
    }
  };
} }
namespace boost {
namespace gregorian {
  typedef date_time::year_month_day_base<greg_year,
                                         greg_month,
                                         greg_day> greg_year_month_day;
} }
namespace boost {
namespace gregorian {
  typedef date_time::int_adapter<uint32_t> fancy_date_rep;
  class gregorian_calendar :
    public date_time::gregorian_calendar_base<greg_year_month_day, fancy_date_rep::int_type> {
  public:
    typedef greg_weekday day_of_week_type;
    typedef greg_day_of_year_rep day_of_year_type;
    typedef fancy_date_rep date_rep_type;
    typedef fancy_date_rep date_traits_type;
  private:
  };
} }
namespace boost {
namespace date_time {
  template<class duration_rep_traits>
  class date_duration : private
              boost::less_than_comparable1< date_duration< duration_rep_traits >
            , boost::equality_comparable1< date_duration< duration_rep_traits >
            , boost::addable1< date_duration< duration_rep_traits >
            , boost::subtractable1< date_duration< duration_rep_traits >
            , boost::dividable2< date_duration< duration_rep_traits >, int
            > > > > >
  {
  public:
    typedef typename duration_rep_traits::int_type duration_rep_type;
    typedef typename duration_rep_traits::impl_type duration_rep;
    explicit date_duration(duration_rep day_count) : days_(day_count) {};
    date_duration(special_values sv) :
            days_(duration_rep::from_special(sv))
    {}
    date_duration(const date_duration<duration_rep_traits>& other) :
            days_(other.days_)
    {}
    duration_rep get_rep()const
    {
        return days_;
    }
    bool is_special()const
    {
        return days_.is_special();
    }
    duration_rep_type days() const
    {
        return duration_rep_traits::as_number(days_);
    }
    static date_duration unit()
    {
        return date_duration<duration_rep_traits>(1);
    }
    bool operator==(const date_duration& rhs) const
    {
        return days_ == rhs.days_;
    }
    bool operator<(const date_duration& rhs) const
    {
        return days_ < rhs.days_;
    }
    date_duration& operator-=(const date_duration& rhs)
    {
        days_ = days_ - rhs.days_;
        return *this;
    }
    date_duration& operator+=(const date_duration& rhs)
    {
        days_ = days_ + rhs.days_;
        return *this;
    }
    date_duration operator-() const
    {
        return date_duration<duration_rep_traits>(get_rep() * (-1));
    }
    date_duration& operator/=(int divisor)
    {
        days_ = days_ / divisor;
        return *this;
    }
    bool is_negative() const
    {
        return days_ < 0;
    }
  private:
    duration_rep days_;
  };
  struct duration_traits_long
  {
    typedef long int_type;
    typedef long impl_type;
    static int_type as_number(impl_type i) { return i; };
  };
  struct duration_traits_adapted
  {
    typedef long int_type;
    typedef boost::date_time::int_adapter<long> impl_type;
    static int_type as_number(impl_type i) { return i.as_number(); };
  };
} }
namespace boost {
namespace gregorian {
  typedef boost::date_time::duration_traits_adapted date_duration_rep;
  class date_duration :
    public boost::date_time::date_duration< date_duration_rep >
  {
    typedef boost::date_time::date_duration< date_duration_rep > base_type;
  public:
    typedef base_type::duration_rep duration_rep;
    explicit date_duration(duration_rep day_count = 0) : base_type(day_count) {}
    date_duration(date_time::special_values sv) : base_type(sv) {}
    date_duration(const date_duration& other) : base_type(static_cast< base_type const& >(other))
    {}
    date_duration(const base_type& other) : base_type(other)
    {}
    bool operator== (const date_duration& rhs) const
    {
      return base_type::operator== (rhs);
    }
    bool operator!= (const date_duration& rhs) const
    {
      return !operator== (rhs);
    }
    bool operator< (const date_duration& rhs) const
    {
      return base_type::operator< (rhs);
    }
    bool operator> (const date_duration& rhs) const
    {
      return !(base_type::operator< (rhs) || base_type::operator== (rhs));
    }
    bool operator<= (const date_duration& rhs) const
    {
      return (base_type::operator< (rhs) || base_type::operator== (rhs));
    }
    bool operator>= (const date_duration& rhs) const
    {
      return !base_type::operator< (rhs);
    }
    date_duration& operator-= (const date_duration& rhs)
    {
      base_type::operator-= (rhs);
      return *this;
    }
    friend date_duration operator- (date_duration rhs, date_duration const& lhs)
    {
      rhs -= lhs;
      return rhs;
    }
    date_duration& operator+= (const date_duration& rhs)
    {
      base_type::operator+= (rhs);
      return *this;
    }
    friend date_duration operator+ (date_duration rhs, date_duration const& lhs)
    {
      rhs += lhs;
      return rhs;
    }
    date_duration operator- ()const
    {
      return date_duration(get_rep() * (-1));
    }
    date_duration& operator/= (int divisor)
    {
      base_type::operator/= (divisor);
      return *this;
    }
    friend date_duration operator/ (date_duration rhs, int lhs)
    {
      rhs /= lhs;
      return rhs;
    }
    static date_duration unit()
    {
      return date_duration(base_type::unit().get_rep());
    }
  };
  typedef date_duration days;
} }
namespace boost {
namespace date_time {
  template <class duration_config>
  class weeks_duration : public date_duration<duration_config> {
  public:
    weeks_duration(typename duration_config::impl_type w)
      : date_duration<duration_config>(w * 7) {}
    weeks_duration(special_values sv)
      : date_duration<duration_config>(sv) {}
  };
  template<class t>
  class years_duration;
  template<class base_config>
  class months_duration
  {
    private:
      typedef typename base_config::int_rep int_rep;
      typedef typename int_rep::int_type int_type;
      typedef typename base_config::date_type date_type;
      typedef typename date_type::duration_type duration_type;
      typedef typename base_config::month_adjustor_type month_adjustor_type;
      typedef months_duration<base_config> months_type;
      typedef years_duration<base_config> years_type;
    public:
      months_duration(int_rep num) : _m(num) {}
      months_duration(special_values sv) : _m(sv)
      {
        _m = int_rep::from_special(sv);
      }
      int_rep number_of_months() const { return _m; }
      duration_type get_neg_offset(const date_type& d) const
      {
        month_adjustor_type m_adj(_m.as_number());
        return duration_type(m_adj.get_neg_offset(d));
      }
      duration_type get_offset(const date_type& d) const
      {
        month_adjustor_type m_adj(_m.as_number());
        return duration_type(m_adj.get_offset(d));
      }
      bool operator==(const months_type& rhs) const
      {
        return(_m == rhs._m);
      }
      bool operator!=(const months_type& rhs) const
      {
        return(_m != rhs._m);
      }
      months_type operator+(const months_type& rhs)const
      {
        return months_type(_m + rhs._m);
      }
      months_type& operator+=(const months_type& rhs)
      {
        _m = _m + rhs._m;
        return *this;
      }
      months_type operator-(const months_type& rhs)const
      {
        return months_type(_m - rhs._m);
      }
      months_type& operator-=(const months_type& rhs)
      {
        _m = _m - rhs._m;
        return *this;
      }
      months_type operator*(const int_type rhs)const
      {
        return months_type(_m * rhs);
      }
      months_type& operator*=(const int_type rhs)
      {
        _m = _m * rhs;
        return *this;
      }
      months_type operator/(const int_type rhs)const
      {
        return months_type(_m / rhs);
      }
      months_type& operator/=(const int_type rhs)
      {
        _m = _m / rhs;
        return *this;
      }
      months_type operator+(const years_type& y)const
      {
        return months_type(y.number_of_years() * 12 + _m);
      }
      months_type& operator+=(const years_type& y)
      {
        _m = y.number_of_years() * 12 + _m;
        return *this;
      }
      months_type operator-(const years_type& y) const
      {
        return months_type(_m - y.number_of_years() * 12);
      }
      months_type& operator-=(const years_type& y)
      {
        _m = _m - y.number_of_years() * 12;
        return *this;
      }
      friend date_type operator+(const date_type& d, const months_type& m)
      {
        return d + m.get_offset(d);
      }
      friend date_type operator+=(date_type& d, const months_type& m)
      {
        return d += m.get_offset(d);
      }
      friend date_type operator-(const date_type& d, const months_type& m)
      {
        return d + m.get_neg_offset(d);
      }
      friend date_type operator-=(date_type& d, const months_type& m)
      {
        return d += m.get_neg_offset(d);
      }
    private:
      int_rep _m;
  };
  template<class base_config>
  class years_duration
  {
    private:
      typedef typename base_config::int_rep int_rep;
      typedef typename int_rep::int_type int_type;
      typedef typename base_config::date_type date_type;
      typedef typename date_type::duration_type duration_type;
      typedef typename base_config::month_adjustor_type month_adjustor_type;
      typedef years_duration<base_config> years_type;
      typedef months_duration<base_config> months_type;
    public:
      years_duration(int_rep num) : _y(num) {}
      years_duration(special_values sv) : _y(sv)
      {
        _y = int_rep::from_special(sv);
      }
      int_rep number_of_years() const { return _y; }
      duration_type get_neg_offset(const date_type& d) const
      {
        month_adjustor_type m_adj(_y.as_number() * 12);
        return duration_type(m_adj.get_neg_offset(d));
      }
      duration_type get_offset(const date_type& d) const
      {
        month_adjustor_type m_adj(_y.as_number() * 12);
        return duration_type(m_adj.get_offset(d));
      }
      bool operator==(const years_type& rhs) const
      {
        return(_y == rhs._y);
      }
      bool operator!=(const years_type& rhs) const
      {
        return(_y != rhs._y);
      }
      years_type operator+(const years_type& rhs)const
      {
        return years_type(_y + rhs._y);
      }
      years_type& operator+=(const years_type& rhs)
      {
        _y = _y + rhs._y;
        return *this;
      }
      years_type operator-(const years_type& rhs)const
      {
        return years_type(_y - rhs._y);
      }
      years_type& operator-=(const years_type& rhs)
      {
        _y = _y - rhs._y;
        return *this;
      }
      years_type operator*(const int_type rhs)const
      {
        return years_type(_y * rhs);
      }
      years_type& operator*=(const int_type rhs)
      {
        _y = _y * rhs;
        return *this;
      }
      years_type operator/(const int_type rhs)const
      {
        return years_type(_y / rhs);
      }
      years_type& operator/=(const int_type rhs)
      {
        _y = _y / rhs;
        return *this;
      }
      months_type operator+(const months_type& m) const
      {
        return(months_type(_y * 12 + m.number_of_months()));
      }
      months_type operator-(const months_type& m) const
      {
        return(months_type(_y * 12 - m.number_of_months()));
      }
      friend date_type operator+(const date_type& d, const years_type& y)
      {
        return d + y.get_offset(d);
      }
      friend date_type operator+=(date_type& d, const years_type& y)
      {
        return d += y.get_offset(d);
      }
      friend date_type operator-(const date_type& d, const years_type& y)
      {
        return d + y.get_neg_offset(d);
      }
      friend date_type operator-=(date_type& d, const years_type& y)
      {
        return d += y.get_neg_offset(d);
      }
    private:
      int_rep _y;
  };
}}
namespace boost {
namespace gregorian {
  using date_time::special_values;
  using date_time::not_special;
  using date_time::neg_infin;
  using date_time::pos_infin;
  using date_time::not_a_date_time;
  using date_time::max_date_time;
  using date_time::min_date_time;
  class date : public date_time::date<date, gregorian_calendar, date_duration>
  {
   public:
    typedef gregorian_calendar::year_type year_type;
    typedef gregorian_calendar::month_type month_type;
    typedef gregorian_calendar::day_type day_type;
    typedef gregorian_calendar::day_of_year_type day_of_year_type;
    typedef gregorian_calendar::ymd_type ymd_type;
    typedef gregorian_calendar::date_rep_type date_rep_type;
    typedef gregorian_calendar::date_int_type date_int_type;
    typedef date_duration duration_type;
    date():
      date_time::date<date, gregorian_calendar, date_duration>(date_rep_type::from_special(not_a_date_time))
    {}
    date(year_type y, month_type m, day_type d)
      : date_time::date<date, gregorian_calendar, date_duration>(y, m, d)
    {
      if (gregorian_calendar::end_of_month_day(y, m) < d) {
        boost::throw_exception(bad_day_of_month(std::string("Day of month is not valid for year")));
      }
    }
    explicit date(const ymd_type& ymd)
      : date_time::date<date, gregorian_calendar, date_duration>(ymd)
    {}
    explicit date(const date_int_type& rhs):
      date_time::date<date,gregorian_calendar, date_duration>(rhs)
    {}
    explicit date(date_rep_type rhs):
      date_time::date<date,gregorian_calendar, date_duration>(rhs)
    {}
    explicit date(special_values sv):
      date_time::date<date, gregorian_calendar, date_duration>(date_rep_type::from_special(sv))
    {
      if (sv == min_date_time)
      {
        *this = date(1400, 1, 1);
      }
      if (sv == max_date_time)
      {
        *this = date(9999, 12, 31);
      }
    }
    date_int_type julian_day() const
    {
      ymd_type ymd = year_month_day();
      return gregorian_calendar::julian_day_number(ymd);
    }
    day_of_year_type day_of_year() const
    {
      date start_of_year(year(), 1, 1);
      unsigned short doy = static_cast<unsigned short>((*this-start_of_year).days() + 1);
      return day_of_year_type(doy);
    }
    date_int_type modjulian_day() const
    {
      ymd_type ymd = year_month_day();
      return gregorian_calendar::modjulian_day_number(ymd);
    }
    int week_number() const
    {
      ymd_type ymd = year_month_day();
      return gregorian_calendar::week_number(ymd);
    }
    date_int_type day_number() const
    {
      return days_;
    }
    date end_of_month() const
    {
      ymd_type ymd = year_month_day();
      short eom_day = gregorian_calendar::end_of_month_day(ymd.year, ymd.month);
      return date(ymd.year, ymd.month, eom_day);
    }
   private:
  };
} }
namespace boost {
namespace date_time {
template<typename int_type_, int_type_ wrap_val>
class wrapping_int {
public:
  typedef int_type_ int_type;
  static int_type wrap_value() {return wrap_val;}
  wrapping_int(int_type v) : value_(v) {};
  int_type as_int() const {return value_;}
  operator int_type() const {return value_;}
  template< typename IntT >
  IntT add(IntT v)
  {
    int_type remainder = static_cast<int_type>(v % (wrap_val));
    IntT overflow = static_cast<IntT>(v / (wrap_val));
    value_ = static_cast<int_type>(value_ + remainder);
    return calculate_wrap(overflow);
  }
  template< typename IntT >
  IntT subtract(IntT v)
  {
    int_type remainder = static_cast<int_type>(v % (wrap_val));
    IntT underflow = static_cast<IntT>(-(v / (wrap_val)));
    value_ = static_cast<int_type>(value_ - remainder);
    return calculate_wrap(underflow) * -1;
  }
private:
  int_type value_;
  template< typename IntT >
  IntT calculate_wrap(IntT wrap)
  {
    if ((value_) >= wrap_val)
    {
      ++wrap;
      value_ -= (wrap_val);
    }
    else if(value_ < 0)
    {
      --wrap;
      value_ += (wrap_val);
    }
    return wrap;
  }
};
template<typename int_type_, int_type_ wrap_min, int_type_ wrap_max>
class wrapping_int2 {
public:
  typedef int_type_ int_type;
  static int_type wrap_value() {return wrap_max;}
  static int_type min_value() {return wrap_min;}
  wrapping_int2(int_type v) : value_(v) {
    if(value_ < wrap_min)
    {
      value_ = wrap_min;
    }
    if(value_ > wrap_max)
    {
      value_ = wrap_max;
    }
  }
  int_type as_int() const {return value_;}
  operator int_type() const {return value_;}
  template< typename IntT >
  IntT add(IntT v)
  {
    int_type remainder = static_cast<int_type>(v % (wrap_max - wrap_min + 1));
    IntT overflow = static_cast<IntT>(v / (wrap_max - wrap_min + 1));
    value_ = static_cast<int_type>(value_ + remainder);
    return calculate_wrap(overflow);
  }
  template< typename IntT >
  IntT subtract(IntT v)
  {
    int_type remainder = static_cast<int_type>(v % (wrap_max - wrap_min + 1));
    IntT underflow = static_cast<IntT>(-(v / (wrap_max - wrap_min + 1)));
    value_ = static_cast<int_type>(value_ - remainder);
    return calculate_wrap(underflow);
  }
private:
  int_type value_;
  template< typename IntT >
  IntT calculate_wrap(IntT wrap)
  {
    if ((value_) > wrap_max)
    {
      ++wrap;
      value_ -= (wrap_max - wrap_min + 1);
    }
    else if((value_) < wrap_min)
    {
      --wrap;
      value_ += (wrap_max - wrap_min + 1);
    }
    return wrap;
  }
};
} }
namespace boost {
namespace date_time {
  template<class date_type>
  class day_functor
  {
  public:
    typedef typename date_type::duration_type duration_type;
    day_functor(int f) : f_(f) {}
    duration_type get_offset(const date_type& d) const
    {
      d.year();
      return duration_type(f_);
    }
    duration_type get_neg_offset(const date_type& d) const
    {
      d.year();
      return duration_type(-f_);
    }
  private:
    int f_;
  };
  template<class date_type>
  class month_functor
  {
  public:
    typedef typename date_type::duration_type duration_type;
    typedef typename date_type::calendar_type cal_type;
    typedef typename cal_type::ymd_type ymd_type;
    typedef typename cal_type::day_type day_type;
    month_functor(int f) : f_(f), origDayOfMonth_(0) {}
    duration_type get_offset(const date_type& d) const
    {
      ymd_type ymd(d.year_month_day());
      if (origDayOfMonth_ == 0) {
        origDayOfMonth_ = ymd.day;
        day_type endOfMonthDay(cal_type::end_of_month_day(ymd.year,ymd.month));
        if (endOfMonthDay == ymd.day) {
          origDayOfMonth_ = -1;
        }
      }
      typedef date_time::wrapping_int2<short,1,12> wrap_int2;
      typedef typename wrap_int2::int_type int_type;
      wrap_int2 wi(ymd.month);
      int_type year = wi.add(static_cast<int_type>(f_));
      year = static_cast<int_type>(year + ymd.year);
      day_type resultingEndOfMonthDay(cal_type::end_of_month_day(year, wi.as_int()));
      if (origDayOfMonth_ == -1) {
        return date_type(year, wi.as_int(), resultingEndOfMonthDay) - d;
      }
      day_type dayOfMonth = origDayOfMonth_;
      if (dayOfMonth > resultingEndOfMonthDay) {
        dayOfMonth = resultingEndOfMonthDay;
      }
      return date_type(year, wi.as_int(), dayOfMonth) - d;
    }
    duration_type get_neg_offset(const date_type& d) const
    {
      ymd_type ymd(d.year_month_day());
      if (origDayOfMonth_ == 0) {
        origDayOfMonth_ = ymd.day;
        day_type endOfMonthDay(cal_type::end_of_month_day(ymd.year,ymd.month));
        if (endOfMonthDay == ymd.day) {
          origDayOfMonth_ = -1;
        }
      }
      typedef date_time::wrapping_int2<short,1,12> wrap_int2;
      typedef typename wrap_int2::int_type int_type;
      wrap_int2 wi(ymd.month);
      int_type year = wi.subtract(static_cast<int_type>(f_));
      year = static_cast<int_type>(year + ymd.year);
      day_type resultingEndOfMonthDay(cal_type::end_of_month_day(year, wi.as_int()));
      if (origDayOfMonth_ == -1) {
        return date_type(year, wi.as_int(), resultingEndOfMonthDay) - d;
      }
      day_type dayOfMonth = origDayOfMonth_;
      if (dayOfMonth > resultingEndOfMonthDay) {
        dayOfMonth = resultingEndOfMonthDay;
      }
      return date_type(year, wi.as_int(), dayOfMonth) - d;
    }
  private:
    int f_;
    mutable short origDayOfMonth_;
  };
  template<class date_type>
  class week_functor
  {
  public:
    typedef typename date_type::duration_type duration_type;
    typedef typename date_type::calendar_type calendar_type;
    week_functor(int f) : f_(f) {}
    duration_type get_offset(const date_type& d) const
    {
      d.year();
      return duration_type(f_*calendar_type::days_in_week());
    }
    duration_type get_neg_offset(const date_type& d) const
    {
      d.year();
      return duration_type(-f_*calendar_type::days_in_week());
    }
  private:
    int f_;
  };
  template<class date_type>
  class year_functor
  {
  public:
    typedef typename date_type::duration_type duration_type;
    year_functor(int f) : _mf(f * 12) {}
    duration_type get_offset(const date_type& d) const
    {
      return _mf.get_offset(d);
    }
    duration_type get_neg_offset(const date_type& d) const
    {
      return _mf.get_neg_offset(d);
    }
  private:
    month_functor<date_type> _mf;
  };
} }
namespace boost {
namespace gregorian {
  struct greg_durations_config {
    typedef date date_type;
    typedef date_time::int_adapter<int> int_rep;
    typedef date_time::month_functor<date_type> month_adjustor_type;
  };
  typedef date_time::months_duration<greg_durations_config> months;
  typedef date_time::years_duration<greg_durations_config> years;
  class weeks_duration : public date_duration {
  public:
    weeks_duration(duration_rep w)
      : date_duration(w * 7) {}
    weeks_duration(date_time::special_values sv)
      : date_duration(sv) {}
  };
  typedef weeks_duration weeks;
}}
namespace boost {
namespace date_time {
  template<class date_type>
  class year_based_generator
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::year_type year_type;
    year_based_generator() {};
    virtual ~year_based_generator() {};
    virtual date_type get_date(year_type y) const = 0;
    virtual std::string to_string() const =0;
  };
  template<class date_type>
 class partial_date : public year_based_generator<date_type>
 {
 public:
   typedef typename date_type::calendar_type calendar_type;
   typedef typename calendar_type::day_type day_type;
   typedef typename calendar_type::month_type month_type;
   typedef typename calendar_type::year_type year_type;
   typedef typename date_type::duration_type duration_type;
   typedef typename duration_type::duration_rep duration_rep;
   partial_date(day_type d, month_type m) :
     day_(d),
     month_(m)
   {}
   partial_date(duration_rep days) :
     day_(1),
     month_(1)
   {
     date_type d1(2000,1,1);
     if(days > 1) {
       if(days > 366)
       {
         days = 366;
       }
       days = days - 1;
       duration_type dd(days);
       d1 = d1 + dd;
     }
     day_ = d1.day();
     month_ = d1.month();
   }
   date_type get_date(year_type y) const
   {
     if((day_ == 29) && (month_ == 2) && !(calendar_type::is_leap_year(y))) {
       std::ostringstream ss;
       ss << "No Feb 29th in given year of " << y << ".";
       boost::throw_exception(std::invalid_argument(ss.str()));
     }
     return date_type(y, month_, day_);
   }
   date_type operator()(year_type y) const
   {
     return get_date(y);
   }
   bool operator==(const partial_date& rhs) const
   {
     return (month_ == rhs.month_) && (day_ == rhs.day_);
   }
   bool operator<(const partial_date& rhs) const
   {
     if (month_ < rhs.month_) return true;
     if (month_ > rhs.month_) return false;
     return (day_ < rhs.day_);
   }
   month_type month() const
   {
     return month_;
   }
   day_type day() const
   {
     return day_;
   }
   virtual std::string to_string() const
   {
     std::ostringstream ss;
     date_type d(2004, month_, day_);
     unsigned short c = d.day_of_year();
     c--;
     ss << c;
     return ss.str();
   }
 private:
   day_type day_;
   month_type month_;
 };
  const char* nth_as_str(int n);
  template<class date_type>
  class nth_kday_of_month : public year_based_generator<date_type>
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename calendar_type::month_type month_type;
    typedef typename calendar_type::year_type year_type;
    typedef typename date_type::duration_type duration_type;
    enum week_num {first=1, second, third, fourth, fifth};
    nth_kday_of_month(week_num week_no,
                      day_of_week_type dow,
                      month_type m) :
      month_(m),
      wn_(week_no),
      dow_(dow)
    {}
    date_type get_date(year_type y) const
    {
      date_type d(y, month_, 1);
      duration_type one_day(1);
      duration_type one_week(7);
      while (dow_ != d.day_of_week()) {
        d = d + one_day;
      }
      int week = 1;
      while (week < wn_) {
        d = d + one_week;
        week++;
      }
      if(d.month() != month_) {
        d = d - one_week;
      }
      return d;
    }
    month_type month() const
    {
      return month_;
    }
    week_num nth_week() const
    {
      return wn_;
    }
    day_of_week_type day_of_week() const
    {
      return dow_;
    }
    const char* nth_week_as_str() const
    {
      return nth_as_str(wn_);
    }
    virtual std::string to_string() const
    {
     std::ostringstream ss;
     ss << 'M'
       << static_cast<int>(month_) << '.'
       << static_cast<int>(wn_) << '.'
       << static_cast<int>(dow_);
     return ss.str();
    }
  private:
    month_type month_;
    week_num wn_;
    day_of_week_type dow_;
  };
  template<class date_type>
  class first_kday_of_month : public year_based_generator<date_type>
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename calendar_type::month_type month_type;
    typedef typename calendar_type::year_type year_type;
    typedef typename date_type::duration_type duration_type;
    first_kday_of_month(day_of_week_type dow, month_type m) :
      month_(m),
      dow_(dow)
    {}
    date_type get_date(year_type year) const
    {
      date_type d(year, month_,1);
      duration_type one_day(1);
      while (dow_ != d.day_of_week()) {
        d = d + one_day;
      }
      return d;
    }
    month_type month() const
    {
      return month_;
    }
    day_of_week_type day_of_week() const
    {
      return dow_;
    }
    virtual std::string to_string() const
    {
     std::ostringstream ss;
     ss << 'M'
       << static_cast<int>(month_) << '.'
       << 1 << '.'
       << static_cast<int>(dow_);
     return ss.str();
    }
  private:
    month_type month_;
    day_of_week_type dow_;
  };
  template<class date_type>
  class last_kday_of_month : public year_based_generator<date_type>
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename calendar_type::month_type month_type;
    typedef typename calendar_type::year_type year_type;
    typedef typename date_type::duration_type duration_type;
    last_kday_of_month(day_of_week_type dow, month_type m) :
      month_(m),
      dow_(dow)
    {}
    date_type get_date(year_type year) const
    {
      date_type d(year, month_, calendar_type::end_of_month_day(year,month_));
      duration_type one_day(1);
      while (dow_ != d.day_of_week()) {
        d = d - one_day;
      }
      return d;
    }
    month_type month() const
    {
      return month_;
    }
    day_of_week_type day_of_week() const
    {
      return dow_;
    }
    virtual std::string to_string() const
    {
      std::ostringstream ss;
      ss << 'M'
         << static_cast<int>(month_) << '.'
         << 5 << '.'
         << static_cast<int>(dow_);
      return ss.str();
    }
  private:
    month_type month_;
    day_of_week_type dow_;
   };
  template<class date_type>
  class first_kday_after
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename date_type::duration_type duration_type;
    first_kday_after(day_of_week_type dow) :
      dow_(dow)
    {}
    date_type get_date(date_type start_day) const
    {
      duration_type one_day(1);
      date_type d = start_day + one_day;
      while (dow_ != d.day_of_week()) {
        d = d + one_day;
      }
      return d;
    }
    day_of_week_type day_of_week() const
    {
      return dow_;
    }
  private:
    day_of_week_type dow_;
  };
  template<class date_type>
  class first_kday_before
  {
  public:
    typedef typename date_type::calendar_type calendar_type;
    typedef typename calendar_type::day_of_week_type day_of_week_type;
    typedef typename date_type::duration_type duration_type;
    first_kday_before(day_of_week_type dow) :
      dow_(dow)
    {}
    date_type get_date(date_type start_day) const
    {
      duration_type one_day(1);
      date_type d = start_day - one_day;
      while (dow_ != d.day_of_week()) {
        d = d - one_day;
      }
      return d;
    }
    day_of_week_type day_of_week() const
    {
      return dow_;
    }
  private:
    day_of_week_type dow_;
  };
  template<typename date_type, class weekday_type>
  inline
  typename date_type::duration_type days_until_weekday(const date_type& d, const weekday_type& wd)
  {
    typedef typename date_type::duration_type duration_type;
    duration_type wks(0);
    duration_type dd(wd.as_number() - d.day_of_week().as_number());
    if(dd.is_negative()){
      wks = duration_type(7);
    }
    return dd + wks;
  }
  template<typename date_type, class weekday_type>
  inline
  typename date_type::duration_type days_before_weekday(const date_type& d, const weekday_type& wd)
  {
    typedef typename date_type::duration_type duration_type;
    duration_type wks(0);
    duration_type dd(wd.as_number() - d.day_of_week().as_number());
    if(dd.days() > 0){
      wks = duration_type(7);
    }
    return (-dd + wks);
  }
  template<class date_type, class weekday_type>
  inline
  date_type next_weekday(const date_type& d, const weekday_type& wd)
  {
    return d + days_until_weekday(d, wd);
  }
  template<class date_type, class weekday_type>
  inline
  date_type previous_weekday(const date_type& d, const weekday_type& wd)
  {
    return d - days_before_weekday(d, wd);
  }
} }
namespace boost {
namespace date_time {
  template<class date_type>
  class day_clock
  {
  public:
    typedef typename date_type::ymd_type ymd_type;
    static date_type local_day()
    {
      return date_type(local_day_ymd());
    }
    static typename date_type::ymd_type local_day_ymd()
    {
      ::std::tm result;
      ::std::tm* curr = get_local_time(result);
      return ymd_type(curr->tm_year + 1900,
                      curr->tm_mon + 1,
                      curr->tm_mday);
    }
    static typename date_type::ymd_type universal_day_ymd()
    {
      ::std::tm result;
      ::std::tm* curr = get_universal_time(result);
      return ymd_type(curr->tm_year + 1900,
                      curr->tm_mon + 1,
                      curr->tm_mday);
    }
    static date_type universal_day()
    {
      return date_type(universal_day_ymd());
    }
  private:
    static ::std::tm* get_local_time(std::tm& result)
    {
      ::std::time_t t;
      ::std::time(&t);
      return c_time::localtime(&t, &result);
    }
    static ::std::tm* get_universal_time(std::tm& result)
    {
      ::std::time_t t;
      ::std::time(&t);
      return c_time::gmtime(&t, &result);
    }
  };
} }
namespace boost {
namespace date_time {
  enum date_resolutions {day, week, months, year, decade, century, NumDateResolutions};
  template<class date_type>
  class date_itr_base {
  public:
    typedef typename date_type::duration_type duration_type;
    typedef date_type value_type;
    typedef std::input_iterator_tag iterator_category;
    date_itr_base(date_type d) : current_(d) {}
    virtual ~date_itr_base() {};
    date_itr_base& operator++()
    {
      current_ = current_ + get_offset(current_);
      return *this;
    }
    date_itr_base& operator--()
    {
      current_ = current_ + get_neg_offset(current_);
      return *this;
    }
    virtual duration_type get_offset(const date_type& current) const=0;
    virtual duration_type get_neg_offset(const date_type& current) const=0;
    date_type operator*() {return current_;};
    date_type* operator->() {return &current_;};
    bool operator< (const date_type& d) {return current_ < d;}
    bool operator<= (const date_type& d) {return current_ <= d;}
    bool operator> (const date_type& d) {return current_ > d;}
    bool operator>= (const date_type& d) {return current_ >= d;}
    bool operator== (const date_type& d) {return current_ == d;}
    bool operator!= (const date_type& d) {return current_ != d;}
  private:
    date_type current_;
  };
  template<class offset_functor, class date_type>
  class date_itr : public date_itr_base<date_type> {
  public:
    typedef typename date_type::duration_type duration_type;
    date_itr(date_type d, int factor=1) :
      date_itr_base<date_type>(d),
      of_(factor)
    {}
  private:
    virtual duration_type get_offset(const date_type& current) const
    {
      return of_.get_offset(current);
    }
    virtual duration_type get_neg_offset(const date_type& current) const
    {
      return of_.get_neg_offset(current);
    }
    offset_functor of_;
  };
} }
namespace boost {
namespace gregorian {
  typedef date_time::period<date, date_duration> date_period;
  typedef date_time::year_based_generator<date> year_based_generator;
  typedef date_time::partial_date<date> partial_date;
  typedef date_time::nth_kday_of_month<date> nth_kday_of_month;
  typedef nth_kday_of_month nth_day_of_the_week_in_month;
  typedef date_time::first_kday_of_month<date> first_kday_of_month;
  typedef first_kday_of_month first_day_of_the_week_in_month;
  typedef date_time::last_kday_of_month<date> last_kday_of_month;
  typedef last_kday_of_month last_day_of_the_week_in_month;
  typedef date_time::first_kday_after<date> first_kday_after;
  typedef first_kday_after first_day_of_the_week_after;
  typedef date_time::first_kday_before<date> first_kday_before;
  typedef first_kday_before first_day_of_the_week_before;
  typedef date_time::day_clock<date> day_clock;
  typedef date_time::date_itr_base<date> date_iterator;
  typedef date_time::date_itr<date_time::day_functor<date>,
                              date> day_iterator;
  typedef date_time::date_itr<date_time::week_functor<date>,
                              date> week_iterator;
  typedef date_time::date_itr<date_time::month_functor<date>,
                              date> month_iterator;
  typedef date_time::date_itr<date_time::year_functor<date>,
                              date> year_iterator;
  using date_time::days_until_weekday;
  using date_time::days_before_weekday;
  using date_time::next_weekday;
  using date_time::previous_weekday;
} }
namespace boost {
namespace posix_time {
  typedef date_time::time_resolution_traits<
    boost::date_time::time_resolution_traits_adapted64_impl, boost::date_time::micro,
                                            1000000, 6 > time_res_traits;
  class time_duration :
    public date_time::time_duration<time_duration, time_res_traits>
  {
  public:
    typedef time_res_traits rep_type;
    typedef time_res_traits::day_type day_type;
    typedef time_res_traits::hour_type hour_type;
    typedef time_res_traits::min_type min_type;
    typedef time_res_traits::sec_type sec_type;
    typedef time_res_traits::fractional_seconds_type fractional_seconds_type;
    typedef time_res_traits::tick_type tick_type;
    typedef time_res_traits::impl_type impl_type;
    time_duration(hour_type hour,
                  min_type min,
                  sec_type sec,
                  fractional_seconds_type fs=0) :
      date_time::time_duration<time_duration, time_res_traits>(hour,min,sec,fs)
    {}
    time_duration() :
      date_time::time_duration<time_duration, time_res_traits>(0,0,0)
    {}
    time_duration(boost::date_time::special_values sv) :
      date_time::time_duration<time_duration, time_res_traits>(sv)
    {}
    friend class date_time::time_duration<time_duration, time_res_traits>;
  private:
    explicit time_duration(impl_type tick_count) :
      date_time::time_duration<time_duration, time_res_traits>(tick_count)
    {}
  };
  class millisec_posix_time_system_config
  {
   public:
    typedef boost::int64_t time_rep_type;
    typedef gregorian::date date_type;
    typedef gregorian::date_duration date_duration_type;
    typedef time_duration time_duration_type;
    typedef time_res_traits::tick_type int_type;
    typedef time_res_traits::impl_type impl_type;
    typedef time_res_traits resolution_traits;
    static const boost::int64_t tick_per_second = 1000000;
  };
} }
namespace boost {
namespace date_time {
  template<typename config>
  class split_timedate_system
  {
   public:
    typedef typename config::time_rep_type time_rep_type;
    typedef typename config::date_type date_type;
    typedef typename config::time_duration_type time_duration_type;
    typedef typename config::date_duration_type date_duration_type;
    typedef typename config::int_type int_type;
    typedef typename config::resolution_traits resolution_traits;
   private:
     static const int_type ticks_per_day = (86400LL) * config::tick_per_second;
   public:
    typedef date_time::wrapping_int<int_type, ticks_per_day> wrap_int_type;
    static time_rep_type get_time_rep(special_values sv)
    {
      switch (sv) {
      case not_a_date_time:
        return time_rep_type(date_type(not_a_date_time),
                             time_duration_type(not_a_date_time));
      case pos_infin:
        return time_rep_type(date_type(pos_infin),
                             time_duration_type(pos_infin));
      case neg_infin:
        return time_rep_type(date_type(neg_infin),
                             time_duration_type(neg_infin));
      case max_date_time: {
        time_duration_type td = time_duration_type(24,0,0,0) - time_duration_type(0,0,0,1);
        return time_rep_type(date_type(max_date_time), td);
      }
      case min_date_time:
        return time_rep_type(date_type(min_date_time), time_duration_type(0,0,0,0));
      default:
        return time_rep_type(date_type(not_a_date_time),
                             time_duration_type(not_a_date_time));
      }
    }
    static time_rep_type get_time_rep(const date_type& day,
                                      const time_duration_type& tod,
                                      date_time::dst_flags = not_dst)
    {
      if(day.is_special() || tod.is_special()) {
        if(day.is_not_a_date() || tod.is_not_a_date_time()) {
          return time_rep_type(date_type(not_a_date_time),
                               time_duration_type(not_a_date_time));
        }
        else if(day.is_pos_infinity()) {
          if(tod.is_neg_infinity()) {
            return time_rep_type(date_type(not_a_date_time),
                                 time_duration_type(not_a_date_time));
          }
          else {
            return time_rep_type(day, time_duration_type(pos_infin));
          }
        }
        else if(day.is_neg_infinity()) {
          if(tod.is_pos_infinity()) {
            return time_rep_type(date_type(not_a_date_time),
                                 time_duration_type(not_a_date_time));
          }
          else {
            return time_rep_type(day, time_duration_type(neg_infin));
          }
        }
        else if(tod.is_pos_infinity()) {
          if(day.is_neg_infinity()) {
            return time_rep_type(date_type(not_a_date_time),
                                 time_duration_type(not_a_date_time));
          }
          else {
            return time_rep_type(date_type(pos_infin), tod);
          }
        }
        else if(tod.is_neg_infinity()) {
          if(day.is_pos_infinity()) {
            return time_rep_type(date_type(not_a_date_time),
                                 time_duration_type(not_a_date_time));
          }
          else {
            return time_rep_type(date_type(neg_infin), tod);
          }
        }
      }
      return time_rep_type(day, tod);
    }
    static date_type get_date(const time_rep_type& val)
    {
      return date_type(val.day);
    }
    static time_duration_type get_time_of_day(const time_rep_type& val)
    {
      return time_duration_type(val.time_of_day);
    }
    static std::string zone_name(const time_rep_type&)
    {
      return std::string();
    }
    static bool is_equal(const time_rep_type& lhs, const time_rep_type& rhs)
    {
      return ((lhs.day == rhs.day) && (lhs.time_of_day == rhs.time_of_day));
    }
    static bool is_less(const time_rep_type& lhs, const time_rep_type& rhs)
    {
      if (lhs.day < rhs.day) return true;
      if (lhs.day > rhs.day) return false;
      return (lhs.time_of_day < rhs.time_of_day);
    }
    static time_rep_type add_days(const time_rep_type& base,
                                  const date_duration_type& dd)
    {
      return time_rep_type(base.day+dd, base.time_of_day);
    }
    static time_rep_type subtract_days(const time_rep_type& base,
                                       const date_duration_type& dd)
    {
      return split_timedate_system::get_time_rep(base.day-dd, base.time_of_day);
    }
    static time_rep_type subtract_time_duration(const time_rep_type& base,
                                                const time_duration_type& td)
    {
      if(base.day.is_special() || td.is_special())
      {
        return split_timedate_system::get_time_rep(base.day, -td);
      }
      if (td.is_negative()) {
        time_duration_type td1 = td.invert_sign();
        return add_time_duration(base,td1);
      }
      wrap_int_type day_offset(base.time_of_day.ticks());
      date_duration_type day_overflow(static_cast<typename date_duration_type::duration_rep_type>(day_offset.subtract(td.ticks())));
      return time_rep_type(base.day-day_overflow,
                           time_duration_type(0,0,0,day_offset.as_int()));
    }
    static time_rep_type add_time_duration(const time_rep_type& base,
                                           time_duration_type td)
    {
      if(base.day.is_special() || td.is_special()) {
        return split_timedate_system::get_time_rep(base.day, td);
      }
      if (td.is_negative()) {
        time_duration_type td1 = td.invert_sign();
        return subtract_time_duration(base,td1);
      }
      wrap_int_type day_offset(base.time_of_day.ticks());
      date_duration_type day_overflow(static_cast< typename date_duration_type::duration_rep_type >(day_offset.add(td.ticks())));
      return time_rep_type(base.day+day_overflow,
                           time_duration_type(0,0,0,day_offset.as_int()));
    }
    static time_duration_type subtract_times(const time_rep_type& lhs,
                                             const time_rep_type& rhs)
    {
      date_duration_type dd = lhs.day - rhs.day;
      time_duration_type td(dd.days()*24,0,0);
      time_duration_type td2 = lhs.time_of_day - rhs.time_of_day;
      return td+td2;
    }
  };
} }
namespace boost {
namespace date_time {
  template<class config>
  struct counted_time_rep
  {
    typedef typename config::int_type int_type;
    typedef typename config::date_type date_type;
    typedef typename config::impl_type impl_type;
    typedef typename date_type::duration_type date_duration_type;
    typedef typename date_type::calendar_type calendar_type;
    typedef typename date_type::ymd_type ymd_type;
    typedef typename config::time_duration_type time_duration_type;
    typedef typename config::resolution_traits resolution_traits;
    counted_time_rep(const date_type& d, const time_duration_type& time_of_day)
      : time_count_(1)
    {
      if(d.is_infinity() || d.is_not_a_date() || time_of_day.is_special()) {
        time_count_ = time_of_day.get_rep() + d.day_count();
      }
      else {
        time_count_ = (d.day_number() * frac_sec_per_day()) + time_of_day.ticks();
      }
    }
    explicit counted_time_rep(int_type count) :
      time_count_(count)
    {}
    explicit counted_time_rep(impl_type count) :
      time_count_(count)
    {}
    date_type date() const
    {
      if(time_count_.is_special()) {
        return date_type(time_count_.as_special());
      }
      else {
        typename calendar_type::date_int_type dc = day_count();
        ymd_type ymd = calendar_type::from_day_number(dc);
        return date_type(ymd);
      }
    }
    unsigned long day_count() const
    {
      return static_cast<unsigned long>(resolution_traits::as_number(time_count_) / frac_sec_per_day());
    }
    int_type time_count() const
    {
      return resolution_traits::as_number(time_count_);
    }
    int_type tod() const
    {
      return resolution_traits::as_number(time_count_) % frac_sec_per_day();
    }
    static int_type frac_sec_per_day()
    {
      int_type seconds_per_day = 60*60*24;
      int_type fractional_sec_per_sec(resolution_traits::res_adjust());
      return seconds_per_day*fractional_sec_per_sec;
    }
    bool is_pos_infinity()const
    {
      return impl_type::is_pos_inf(time_count_.as_number());
    }
    bool is_neg_infinity()const
    {
      return impl_type::is_neg_inf(time_count_.as_number());
    }
    bool is_not_a_date_time()const
    {
      return impl_type::is_not_a_number(time_count_.as_number());
    }
    bool is_special()const
    {
      return time_count_.is_special();
    }
    impl_type get_rep()const
    {
      return time_count_;
    }
  private:
    impl_type time_count_;
  };
  template<class time_rep>
  class counted_time_system
  {
   public:
    typedef time_rep time_rep_type;
    typedef typename time_rep_type::impl_type impl_type;
    typedef typename time_rep_type::time_duration_type time_duration_type;
    typedef typename time_duration_type::fractional_seconds_type fractional_seconds_type;
    typedef typename time_rep_type::date_type date_type;
    typedef typename time_rep_type::date_duration_type date_duration_type;
    template<class T> static void unused_var(const T&) {}
    static time_rep_type get_time_rep(const date_type& day,
                                      const time_duration_type& tod,
                                      date_time::dst_flags dst=not_dst)
    {
      unused_var(dst);
      return time_rep_type(day, tod);
    }
    static time_rep_type get_time_rep(special_values sv)
    {
      switch (sv) {
      case not_a_date_time:
        return time_rep_type(date_type(not_a_date_time),
                             time_duration_type(not_a_date_time));
      case pos_infin:
        return time_rep_type(date_type(pos_infin),
                             time_duration_type(pos_infin));
      case neg_infin:
        return time_rep_type(date_type(neg_infin),
                             time_duration_type(neg_infin));
      case max_date_time: {
        time_duration_type td = time_duration_type(24,0,0,0) - time_duration_type(0,0,0,1);
        return time_rep_type(date_type(max_date_time), td);
      }
      case min_date_time:
        return time_rep_type(date_type(min_date_time), time_duration_type(0,0,0,0));
      default:
        return time_rep_type(date_type(not_a_date_time),
                             time_duration_type(not_a_date_time));
      }
    }
    static date_type get_date(const time_rep_type& val)
    {
      return val.date();
    }
    static time_duration_type get_time_of_day(const time_rep_type& val)
    {
      if(val.is_special()) {
        return time_duration_type(val.get_rep().as_special());
      }
      else{
        return time_duration_type(0,0,0,val.tod());
      }
    }
    static std::string zone_name(const time_rep_type&)
    {
      return "";
    }
    static bool is_equal(const time_rep_type& lhs, const time_rep_type& rhs)
    {
      return (lhs.time_count() == rhs.time_count());
    }
    static bool is_less(const time_rep_type& lhs, const time_rep_type& rhs)
    {
      return (lhs.time_count() < rhs.time_count());
    }
    static time_rep_type add_days(const time_rep_type& base,
                                  const date_duration_type& dd)
    {
      if(base.is_special() || dd.is_special()) {
        return(time_rep_type(base.get_rep() + dd.get_rep()));
      }
      else {
        return time_rep_type(base.time_count() + (dd.days() * time_rep_type::frac_sec_per_day()));
      }
    }
    static time_rep_type subtract_days(const time_rep_type& base,
                                       const date_duration_type& dd)
    {
      if(base.is_special() || dd.is_special()) {
        return(time_rep_type(base.get_rep() - dd.get_rep()));
      }
      else{
        return time_rep_type(base.time_count() - (dd.days() * time_rep_type::frac_sec_per_day()));
      }
    }
    static time_rep_type subtract_time_duration(const time_rep_type& base,
                                                const time_duration_type& td)
    {
      if(base.is_special() || td.is_special()) {
        return(time_rep_type(base.get_rep() - td.get_rep()));
      }
      else {
        return time_rep_type(base.time_count() - td.ticks());
      }
    }
    static time_rep_type add_time_duration(const time_rep_type& base,
                                           time_duration_type td)
    {
      if(base.is_special() || td.is_special()) {
        return(time_rep_type(base.get_rep() + td.get_rep()));
      }
      else {
        return time_rep_type(base.time_count() + td.ticks());
      }
    }
    static time_duration_type subtract_times(const time_rep_type& lhs,
                                             const time_rep_type& rhs)
    {
      if(lhs.is_special() || rhs.is_special()) {
        return(time_duration_type(
          impl_type::to_special((lhs.get_rep() - rhs.get_rep()).as_number())));
      }
      else {
        fractional_seconds_type fs = lhs.time_count() - rhs.time_count();
        return time_duration_type(0,0,0,fs);
      }
    }
  };
} }
namespace boost {
namespace posix_time {
  typedef date_time::counted_time_rep<millisec_posix_time_system_config> int64_time_rep;
  typedef date_time::counted_time_system<int64_time_rep> posix_time_system;
} }
namespace boost {
namespace date_time {
  template <class T, class time_system>
  class base_time : private
      boost::less_than_comparable<T
    , boost::equality_comparable<T
      > >
  {
  public:
    typedef T time_type;
    typedef typename time_system::time_rep_type time_rep_type;
    typedef typename time_system::date_type date_type;
    typedef typename time_system::date_duration_type date_duration_type;
    typedef typename time_system::time_duration_type time_duration_type;
    base_time(const date_type& day,
              const time_duration_type& td,
              dst_flags dst=not_dst) :
      time_(time_system::get_time_rep(day, td, dst))
    {}
    base_time(special_values sv) :
      time_(time_system::get_time_rep(sv))
    {}
    base_time(const time_rep_type& rhs) :
      time_(rhs)
    {}
    date_type date() const
    {
      return time_system::get_date(time_);
    }
    time_duration_type time_of_day() const
    {
      return time_system::get_time_of_day(time_);
    }
    std::string zone_name(bool =false) const
    {
      return time_system::zone_name(time_);
    }
    std::string zone_abbrev(bool =false) const
    {
      return time_system::zone_name(time_);
    }
    std::string zone_as_posix_string() const
    {
      return std::string();
    }
    bool is_not_a_date_time() const
    {
      return time_.is_not_a_date_time();
    }
    bool is_infinity() const
    {
      return (is_pos_infinity() || is_neg_infinity());
    }
    bool is_pos_infinity() const
    {
      return time_.is_pos_infinity();
    }
    bool is_neg_infinity() const
    {
      return time_.is_neg_infinity();
    }
    bool is_special() const
    {
      return(is_not_a_date_time() || is_infinity());
    }
    bool operator==(const time_type& rhs) const
    {
      return time_system::is_equal(time_,rhs.time_);
    }
    bool operator<(const time_type& rhs) const
    {
      return time_system::is_less(time_,rhs.time_);
    }
    time_duration_type operator-(const time_type& rhs) const
    {
      return time_system::subtract_times(time_, rhs.time_);
    }
    time_type operator+(const date_duration_type& dd) const
    {
      return time_system::add_days(time_, dd);
    }
    time_type operator+=(const date_duration_type& dd)
    {
      time_ = (time_system::get_time_rep(date() + dd, time_of_day()));
      return time_type(time_);
    }
    time_type operator-(const date_duration_type& dd) const
    {
      return time_system::subtract_days(time_, dd);
    }
    time_type operator-=(const date_duration_type& dd)
    {
      time_ = (time_system::get_time_rep(date() - dd, time_of_day()));
      return time_type(time_);
    }
    time_type operator+(const time_duration_type& td) const
    {
      return time_type(time_system::add_time_duration(time_, td));
    }
    time_type operator+=(const time_duration_type& td)
    {
      time_ = (time_system::get_time_rep(date(), time_of_day() + td));
      return time_type(time_);
    }
    time_type operator-(const time_duration_type& rhs) const
    {
      return time_system::subtract_time_duration(time_, rhs);
    }
    time_type operator-=(const time_duration_type& td)
    {
      time_ = (time_system::get_time_rep(date(), time_of_day() - td));
      return time_type(time_);
    }
  protected:
    time_rep_type time_;
  };
} }
namespace boost {
namespace posix_time {
  using date_time::special_values;
  using date_time::not_special;
  using date_time::neg_infin;
  using date_time::pos_infin;
  using date_time::not_a_date_time;
  using date_time::max_date_time;
  using date_time::min_date_time;
  class ptime : public date_time::base_time<ptime, posix_time_system>
  {
  public:
    typedef posix_time_system time_system_type;
    typedef time_system_type::time_rep_type time_rep_type;
    typedef time_system_type::time_duration_type time_duration_type;
    typedef ptime time_type;
    ptime(gregorian::date d,time_duration_type td) : date_time::base_time<time_type,time_system_type>(d,td)
    {}
    explicit ptime(gregorian::date d) : date_time::base_time<time_type,time_system_type>(d,time_duration_type(0,0,0))
    {}
    ptime(const time_rep_type& rhs):
      date_time::base_time<time_type,time_system_type>(rhs)
    {}
    ptime(const special_values sv) : date_time::base_time<time_type,time_system_type>(sv)
    {}
    ptime() : date_time::base_time<time_type,time_system_type>(gregorian::date(not_a_date_time), time_duration_type(not_a_date_time))
    {}
  };
} }
namespace boost {
namespace posix_time {
  inline
  ptime
  operator+(const ptime& t, const boost::gregorian::months& m)
  {
    return t + m.get_offset(t.date());
  }
  inline
  ptime
  operator+=(ptime& t, const boost::gregorian::months& m)
  {
    return t += m.get_offset(t.date());
  }
  inline
  ptime
  operator-(const ptime& t, const boost::gregorian::months& m)
  {
    return t + m.get_neg_offset(t.date());
  }
  inline
  ptime
  operator-=(ptime& t, const boost::gregorian::months& m)
  {
    return t += m.get_neg_offset(t.date());
  }
  inline
  ptime
  operator+(const ptime& t, const boost::gregorian::years& y)
  {
    return t + y.get_offset(t.date());
  }
  inline
  ptime
  operator+=(ptime& t, const boost::gregorian::years& y)
  {
    return t += y.get_offset(t.date());
  }
  inline
  ptime
  operator-(const ptime& t, const boost::gregorian::years& y)
  {
    return t + y.get_neg_offset(t.date());
  }
  inline
  ptime
  operator-=(ptime& t, const boost::gregorian::years& y)
  {
    return t += y.get_neg_offset(t.date());
  }
}}
namespace boost {
namespace posix_time {
  class hours : public time_duration
  {
  public:
    explicit hours(long h) :
      time_duration(h,0,0)
    {}
  };
  class minutes : public time_duration
  {
  public:
    explicit minutes(long m) :
      time_duration(0,m,0)
    {}
  };
  class seconds : public time_duration
  {
  public:
    explicit seconds(long s) :
      time_duration(0,0,s)
    {}
  };
  typedef date_time::subsecond_duration<time_duration,1000> millisec;
  typedef date_time::subsecond_duration<time_duration,1000> milliseconds;
  typedef date_time::subsecond_duration<time_duration,1000000> microsec;
  typedef date_time::subsecond_duration<time_duration,1000000> microseconds;
} }
namespace boost {
namespace posix_time {
  typedef date_time::period<ptime, time_duration> time_period;
} }
namespace boost {
namespace date_time {
  template<class time_type>
  class time_itr {
  public:
    typedef typename time_type::time_duration_type time_duration_type;
    time_itr(time_type t, time_duration_type d) : current_(t), offset_(d) {};
    time_itr& operator++()
    {
      current_ = current_ + offset_;
      return *this;
    }
    time_itr& operator--()
    {
      current_ = current_ - offset_;
      return *this;
    }
    time_type operator*() {return current_;};
    time_type* operator->() {return &current_;};
    bool operator< (const time_type& t) {return current_ < t;};
    bool operator<= (const time_type& t) {return current_ <= t;};
    bool operator!= (const time_type& t) {return current_ != t;};
    bool operator== (const time_type& t) {return current_ == t;};
    bool operator> (const time_type& t) {return current_ > t;};
    bool operator>= (const time_type& t) {return current_ >= t;};
  private:
    time_type current_;
    time_duration_type offset_;
  };
} }
namespace boost {
  namespace date_time {
    enum time_is_dst_result {is_not_in_dst, is_in_dst,
                             ambiguous, invalid_time_label};
    template<class date_type_,
             class time_duration_type_>
    class dst_calculator
    {
    public:
      typedef time_duration_type_ time_duration_type;
      typedef date_type_ date_type;
      static time_is_dst_result
      process_local_dst_start_day(const time_duration_type& time_of_day,
                                  unsigned int dst_start_offset_minutes,
                                  long dst_length_minutes)
      {
        if (time_of_day < time_duration_type(0,dst_start_offset_minutes,0)) {
          return is_not_in_dst;
        }
        long offset = dst_start_offset_minutes + dst_length_minutes;
        if (time_of_day >= time_duration_type(0,offset,0)) {
          return is_in_dst;
        }
        return invalid_time_label;
      }
      static time_is_dst_result
      process_local_dst_end_day(const time_duration_type& time_of_day,
                                unsigned int dst_end_offset_minutes,
                                long dst_length_minutes)
      {
        int offset = dst_end_offset_minutes-dst_length_minutes;
        if (time_of_day < time_duration_type(0,offset,0)) {
          return is_in_dst;
        }
        if (time_of_day >= time_duration_type(0,dst_end_offset_minutes,0)) {
          return is_not_in_dst;
        }
        return ambiguous;
      }
      static time_is_dst_result
      local_is_dst(const date_type& current_day,
                   const time_duration_type& time_of_day,
                   const date_type& dst_start_day,
                   const time_duration_type& dst_start_offset,
                   const date_type& dst_end_day,
                   const time_duration_type& dst_end_offset,
                   const time_duration_type& dst_length_minutes)
      {
        unsigned int start_minutes =
          dst_start_offset.hours() * 60 + dst_start_offset.minutes();
        unsigned int end_minutes =
          dst_end_offset.hours() * 60 + dst_end_offset.minutes();
        long length_minutes =
          dst_length_minutes.hours() * 60 + dst_length_minutes.minutes();
        return local_is_dst(current_day, time_of_day,
                            dst_start_day, start_minutes,
                            dst_end_day, end_minutes,
                            length_minutes);
      }
      static time_is_dst_result
      local_is_dst(const date_type& current_day,
                   const time_duration_type& time_of_day,
                   const date_type& dst_start_day,
                   unsigned int dst_start_offset_minutes,
                   const date_type& dst_end_day,
                   unsigned int dst_end_offset_minutes,
                   long dst_length_minutes)
      {
        if (dst_start_day < dst_end_day) {
          if ((current_day > dst_start_day) && (current_day < dst_end_day)) {
            return is_in_dst;
          }
          if ((current_day < dst_start_day) || (current_day > dst_end_day)) {
            return is_not_in_dst;
          }
        }
        else {
          if ((current_day < dst_start_day) && (current_day > dst_end_day)) {
            return is_not_in_dst;
          }
          if ((current_day > dst_start_day) || (current_day < dst_end_day)) {
            return is_in_dst;
          }
        }
        if (current_day == dst_start_day) {
          return process_local_dst_start_day(time_of_day,
                                             dst_start_offset_minutes,
                                             dst_length_minutes);
        }
        if (current_day == dst_end_day) {
          return process_local_dst_end_day(time_of_day,
                                           dst_end_offset_minutes,
                                           dst_length_minutes);
        }
        return invalid_time_label;
      }
    };
    template<class date_type,
             class time_duration_type,
             class dst_traits>
    class dst_calc_engine
    {
    public:
      typedef typename date_type::year_type year_type;
      typedef typename date_type::calendar_type calendar_type;
      typedef dst_calculator<date_type, time_duration_type> dstcalc;
      static time_is_dst_result local_is_dst(const date_type& d,
                                             const time_duration_type& td)
      {
        year_type y = d.year();
        date_type dst_start = local_dst_start_day(y);
        date_type dst_end = local_dst_end_day(y);
        return dstcalc::local_is_dst(d,td,
                                     dst_start,
                                     dst_traits::dst_start_offset_minutes(),
                                     dst_end,
                                     dst_traits::dst_end_offset_minutes(),
                                     dst_traits::dst_shift_length_minutes());
      }
      static bool is_dst_boundary_day(date_type d)
      {
        year_type y = d.year();
        return ((d == local_dst_start_day(y)) ||
                (d == local_dst_end_day(y)));
      }
      static time_duration_type dst_offset()
      {
        return time_duration_type(0,dst_traits::dst_shift_length_minutes(),0);
      }
      static date_type local_dst_start_day(year_type year)
      {
        return dst_traits::local_dst_start_day(year);
      }
      static date_type local_dst_end_day(year_type year)
      {
        return dst_traits::local_dst_end_day(year);
      }
    };
    template<class date_type_,
             class time_duration_type_,
             unsigned int dst_start_offset_minutes=120,
             short dst_length_minutes=60>
    class us_dst_rules
    {
    public:
      typedef time_duration_type_ time_duration_type;
      typedef date_type_ date_type;
      typedef typename date_type::year_type year_type;
      typedef typename date_type::calendar_type calendar_type;
      typedef date_time::last_kday_of_month<date_type> lkday;
      typedef date_time::first_kday_of_month<date_type> fkday;
      typedef date_time::nth_kday_of_month<date_type> nkday;
      typedef dst_calculator<date_type, time_duration_type> dstcalc;
      static time_is_dst_result local_is_dst(const date_type& d,
                                             const time_duration_type& td)
      {
        year_type y = d.year();
        date_type dst_start = local_dst_start_day(y);
        date_type dst_end = local_dst_end_day(y);
        return dstcalc::local_is_dst(d,td,
                                     dst_start,dst_start_offset_minutes,
                                     dst_end, dst_start_offset_minutes,
                                     dst_length_minutes);
      }
      static bool is_dst_boundary_day(date_type d)
      {
        year_type y = d.year();
        return ((d == local_dst_start_day(y)) ||
                (d == local_dst_end_day(y)));
      }
      static date_type local_dst_start_day(year_type year)
      {
        if (year >= year_type(2007)) {
          nkday ssim(nkday::second, Sunday, gregorian::Mar);
          return ssim.get_date(year);
        } else {
          fkday fsia(Sunday, gregorian::Apr);
          return fsia.get_date(year);
        }
      }
      static date_type local_dst_end_day(year_type year)
      {
        if (year >= year_type(2007)) {
          fkday fsin(Sunday, gregorian::Nov);
          return fsin.get_date(year);
        } else {
          lkday lsio(Sunday, gregorian::Oct);
          return lsio.get_date(year);
        }
      }
      static time_duration_type dst_offset()
      {
        return time_duration_type(0,dst_length_minutes,0);
      }
     private:
    };
    template<class date_type_, class time_duration_type_>
    class null_dst_rules
    {
    public:
      typedef time_duration_type_ time_duration_type;
      typedef date_type_ date_type;
      static time_is_dst_result local_is_dst(const date_type&,
                                             const time_duration_type&)
      {
        return is_not_in_dst;
      }
      static time_is_dst_result utc_is_dst(const date_type&,
                                           const time_duration_type&)
      {
        return is_not_in_dst;
      }
      static bool is_dst_boundary_day(date_type d)
      {
        return false;
      }
      static time_duration_type dst_offset()
      {
        return time_duration_type(0,0,0);
      }
    };
  } }
namespace boost {
namespace posix_time {
  typedef date_time::time_itr<ptime> time_iterator;
  typedef date_time::second_clock<ptime> second_clock;
  typedef date_time::microsec_clock<ptime> microsec_clock;
  typedef date_time::null_dst_rules<ptime::date_type, time_duration> no_dst;
  typedef date_time::us_dst_rules<ptime::date_type, time_duration> us_dst;
} }
namespace boost
{
    typedef boost::posix_time::ptime system_time;
    inline system_time get_system_time()
    {
        return boost::date_time::microsec_clock<system_time>::universal_time();
    }
    namespace detail
    {
        inline system_time get_system_time_sentinel()
        {
            return system_time(boost::posix_time::pos_infin);
        }
        inline unsigned long get_milliseconds_until(system_time const& target_time)
        {
            if(target_time.is_pos_infinity())
            {
                return ~(unsigned long)0;
            }
            system_time const now=get_system_time();
            if(target_time<=now)
            {
                return 0;
            }
            return static_cast<unsigned long>((target_time-now).total_milliseconds()+1);
        }
    }
}
namespace boost
{
    struct xtime;
    namespace detail
    {
        template<typename T, bool=boost::is_class<T>::value> struct has_member_called_lock { static const bool value=false; }; template<typename T> struct has_member_called_lock<T,true> { typedef char true_type; struct false_type { true_type dummy[2]; }; struct fallback { int lock; }; struct derived: T, fallback { derived(); }; template<int fallback::*> struct tester; template<typename U> static false_type has_member(tester<&U::lock>*); template<typename U> static true_type has_member(...); static const bool value=sizeof(has_member<derived>(0))==sizeof(true_type); };
        template<typename T, bool=boost::is_class<T>::value> struct has_member_called_unlock { static const bool value=false; }; template<typename T> struct has_member_called_unlock<T,true> { typedef char true_type; struct false_type { true_type dummy[2]; }; struct fallback { int unlock; }; struct derived: T, fallback { derived(); }; template<int fallback::*> struct tester; template<typename U> static false_type has_member(tester<&U::unlock>*); template<typename U> static true_type has_member(...); static const bool value=sizeof(has_member<derived>(0))==sizeof(true_type); };
        template<typename T, bool=boost::is_class<T>::value> struct has_member_called_try_lock { static const bool value=false; }; template<typename T> struct has_member_called_try_lock<T,true> { typedef char true_type; struct false_type { true_type dummy[2]; }; struct fallback { int try_lock; }; struct derived: T, fallback { derived(); }; template<int fallback::*> struct tester; template<typename U> static false_type has_member(tester<&U::try_lock>*); template<typename U> static true_type has_member(...); static const bool value=sizeof(has_member<derived>(0))==sizeof(true_type); };
        template<typename T,bool=has_member_called_lock<T>::value >
        struct has_member_lock
        {
            static const bool value=false;
        };
        template<typename T>
        struct has_member_lock<T,true>
        {
            typedef char true_type;
            struct false_type
            {
                true_type dummy[2];
            };
            template<typename U,typename V>
            static true_type has_member(V (U::*)());
            template<typename U>
            static false_type has_member(U);
            static const bool value=sizeof(has_member_lock<T>::has_member(&T::lock))==sizeof(true_type);
        };
        template<typename T,bool=has_member_called_unlock<T>::value >
        struct has_member_unlock
        {
            static const bool value=false;
        };
        template<typename T>
        struct has_member_unlock<T,true>
        {
            typedef char true_type;
            struct false_type
            {
                true_type dummy[2];
            };
            template<typename U,typename V>
            static true_type has_member(V (U::*)());
            template<typename U>
            static false_type has_member(U);
            static const bool value=sizeof(has_member_unlock<T>::has_member(&T::unlock))==sizeof(true_type);
        };
        template<typename T,bool=has_member_called_try_lock<T>::value >
        struct has_member_try_lock
        {
            static const bool value=false;
        };
        template<typename T>
        struct has_member_try_lock<T,true>
        {
            typedef char true_type;
            struct false_type
            {
                true_type dummy[2];
            };
            template<typename U>
            static true_type has_member(bool (U::*)());
            template<typename U>
            static false_type has_member(U);
            static const bool value=sizeof(has_member_try_lock<T>::has_member(&T::try_lock))==sizeof(true_type);
        };
    }
    template<typename T>
    struct is_mutex_type
    {
        static const bool value = detail::has_member_lock<T>::value && detail::has_member_unlock<T>::value && detail::has_member_try_lock<T>::value;
    };
    struct defer_lock_t
    {};
    struct try_to_lock_t
    {};
    struct adopt_lock_t
    {};
    const defer_lock_t defer_lock={};
    const try_to_lock_t try_to_lock={};
    const adopt_lock_t adopt_lock={};
    template<typename Mutex>
    class shared_lock;
    template<typename Mutex>
    class upgrade_lock;
    template<typename Mutex>
    class unique_lock;
    namespace detail
    {
        template<typename Mutex>
        class try_lock_wrapper;
    }
    template<typename Mutex>
    class lock_guard
    {
    private:
        Mutex& m;
        explicit lock_guard(lock_guard&);
        lock_guard& operator=(lock_guard&);
    public:
        explicit lock_guard(Mutex& m_):
            m(m_)
        {
            m.lock();
        }
        lock_guard(Mutex& m_,adopt_lock_t):
            m(m_)
        {}
        ~lock_guard()
        {
            m.unlock();
        }
    };
    template<typename Mutex>
    class unique_lock
    {
    private:
        Mutex* m;
        bool is_locked;
        unique_lock(unique_lock&);
        explicit unique_lock(upgrade_lock<Mutex>&);
        unique_lock& operator=(unique_lock&);
        unique_lock& operator=(upgrade_lock<Mutex>& other);
    public:
        unique_lock():
            m(0),is_locked(false)
        {}
        explicit unique_lock(Mutex& m_):
            m(&m_),is_locked(false)
        {
            lock();
        }
        unique_lock(Mutex& m_,adopt_lock_t):
            m(&m_),is_locked(true)
        {}
        unique_lock(Mutex& m_,defer_lock_t):
            m(&m_),is_locked(false)
        {}
        unique_lock(Mutex& m_,try_to_lock_t):
            m(&m_),is_locked(false)
        {
            try_lock();
        }
        template<typename TimeDuration>
        unique_lock(Mutex& m_,TimeDuration const& target_time):
            m(&m_),is_locked(false)
        {
            timed_lock(target_time);
        }
        unique_lock(Mutex& m_,system_time const& target_time):
            m(&m_),is_locked(false)
        {
            timed_lock(target_time);
        }
        unique_lock(unique_lock&& other):
            m(other.m),is_locked(other.is_locked)
        {
            other.is_locked=false;
            other.m=0;
        }
        explicit unique_lock(upgrade_lock<Mutex>&& other);
        unique_lock<Mutex>&& move()
        {
            return static_cast<unique_lock<Mutex>&&>(*this);
        }
        unique_lock& operator=(unique_lock&& other)
        {
            unique_lock temp(other.move());
            swap(temp);
            return *this;
        }
        unique_lock& operator=(upgrade_lock<Mutex>&& other)
        {
            unique_lock temp(other.move());
            swap(temp);
            return *this;
        }
        void swap(unique_lock&& other)
        {
            std::swap(m,other.m);
            std::swap(is_locked,other.is_locked);
        }
        void swap(unique_lock& other)
        {
            std::swap(m,other.m);
            std::swap(is_locked,other.is_locked);
        }
        ~unique_lock()
        {
            if(owns_lock())
            {
                m->unlock();
            }
        }
        void lock()
        {
            if(owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            m->lock();
            is_locked=true;
        }
        bool try_lock()
        {
            if(owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            is_locked=m->try_lock();
            return is_locked;
        }
        template<typename TimeDuration>
        bool timed_lock(TimeDuration const& relative_time)
        {
            is_locked=m->timed_lock(relative_time);
            return is_locked;
        }
        bool timed_lock(::boost::system_time const& absolute_time)
        {
            is_locked=m->timed_lock(absolute_time);
            return is_locked;
        }
        bool timed_lock(::boost::xtime const& absolute_time)
        {
            is_locked=m->timed_lock(absolute_time);
            return is_locked;
        }
        void unlock()
        {
            if(!owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            m->unlock();
            is_locked=false;
        }
        typedef void (unique_lock::*bool_type)();
        operator bool_type() const
        {
            return is_locked?&unique_lock::lock:0;
        }
        bool operator!() const
        {
            return !owns_lock();
        }
        bool owns_lock() const
        {
            return is_locked;
        }
        Mutex* mutex() const
        {
            return m;
        }
        Mutex* release()
        {
            Mutex* const res=m;
            m=0;
            is_locked=false;
            return res;
        }
        friend class shared_lock<Mutex>;
        friend class upgrade_lock<Mutex>;
    };
    template<typename Mutex>
    void swap(unique_lock<Mutex>&& lhs,unique_lock<Mutex>&& rhs)
    {
        lhs.swap(rhs);
    }
    template<typename Mutex>
    inline upgrade_lock<Mutex>&& move(upgrade_lock<Mutex>&& ul)
    {
        return static_cast<upgrade_lock<Mutex>&&>(ul);
    }
    template<typename Mutex>
    inline upgrade_lock<Mutex>&& move(upgrade_lock<Mutex>& ul)
    {
        return static_cast<upgrade_lock<Mutex>&&>(ul);
    }
    template<typename Mutex>
    void swap(unique_lock<Mutex>& lhs,unique_lock<Mutex>& rhs)
    {
        lhs.swap(rhs);
    }
    template<typename Mutex>
    inline unique_lock<Mutex>&& move(unique_lock<Mutex>&& ul)
    {
        return static_cast<unique_lock<Mutex>&&>(ul);
    }
    template<typename Mutex>
    inline unique_lock<Mutex>&& move(unique_lock<Mutex>& ul)
    {
        return static_cast<unique_lock<Mutex>&&>(ul);
    }
    template<typename Mutex>
    class shared_lock
    {
    protected:
        Mutex* m;
        bool is_locked;
    private:
        explicit shared_lock(shared_lock&);
        shared_lock& operator=(shared_lock&);
    public:
        shared_lock():
            m(0),is_locked(false)
        {}
        explicit shared_lock(Mutex& m_):
            m(&m_),is_locked(false)
        {
            lock();
        }
        shared_lock(Mutex& m_,adopt_lock_t):
            m(&m_),is_locked(true)
        {}
        shared_lock(Mutex& m_,defer_lock_t):
            m(&m_),is_locked(false)
        {}
        shared_lock(Mutex& m_,try_to_lock_t):
            m(&m_),is_locked(false)
        {
            try_lock();
        }
        shared_lock(Mutex& m_,system_time const& target_time):
            m(&m_),is_locked(false)
        {
            timed_lock(target_time);
        }
        shared_lock(detail::thread_move_t<shared_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            other->is_locked=false;
            other->m=0;
        }
        shared_lock(detail::thread_move_t<unique_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            if(is_locked)
            {
                m->unlock_and_lock_shared();
            }
            other->is_locked=false;
            other->m=0;
        }
        shared_lock(detail::thread_move_t<upgrade_lock<Mutex> > other):
            m(other->m),is_locked(other->is_locked)
        {
            if(is_locked)
            {
                m->unlock_upgrade_and_lock_shared();
            }
            other->is_locked=false;
            other->m=0;
        }
        operator detail::thread_move_t<shared_lock<Mutex> >()
        {
            return move();
        }
        detail::thread_move_t<shared_lock<Mutex> > move()
        {
            return detail::thread_move_t<shared_lock<Mutex> >(*this);
        }
        shared_lock& operator=(detail::thread_move_t<shared_lock<Mutex> > other)
        {
            shared_lock temp(other);
            swap(temp);
            return *this;
        }
        shared_lock& operator=(detail::thread_move_t<unique_lock<Mutex> > other)
        {
            shared_lock temp(other);
            swap(temp);
            return *this;
        }
        shared_lock& operator=(detail::thread_move_t<upgrade_lock<Mutex> > other)
        {
            shared_lock temp(other);
            swap(temp);
            return *this;
        }
        void swap(shared_lock&& other)
        {
            std::swap(m,other.m);
            std::swap(is_locked,other.is_locked);
        }
        void swap(shared_lock& other)
        {
            std::swap(m,other.m);
            std::swap(is_locked,other.is_locked);
        }
        Mutex* mutex() const
        {
            return m;
        }
        ~shared_lock()
        {
            if(owns_lock())
            {
                m->unlock_shared();
            }
        }
        void lock()
        {
            if(owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            m->lock_shared();
            is_locked=true;
        }
        bool try_lock()
        {
            if(owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            is_locked=m->try_lock_shared();
            return is_locked;
        }
        bool timed_lock(boost::system_time const& target_time)
        {
            if(owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            is_locked=m->timed_lock_shared(target_time);
            return is_locked;
        }
        template<typename Duration>
        bool timed_lock(Duration const& target_time)
        {
            if(owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            is_locked=m->timed_lock_shared(target_time);
            return is_locked;
        }
        void unlock()
        {
            if(!owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            m->unlock_shared();
            is_locked=false;
        }
        typedef void (shared_lock<Mutex>::*bool_type)();
        operator bool_type() const
        {
            return is_locked?&shared_lock::lock:0;
        }
        bool operator!() const
        {
            return !owns_lock();
        }
        bool owns_lock() const
        {
            return is_locked;
        }
    };
    template<typename Mutex>
    void swap(shared_lock<Mutex>&& lhs,shared_lock<Mutex>&& rhs)
    {
        lhs.swap(rhs);
    }
    template<typename Mutex>
    class upgrade_lock
    {
    protected:
        Mutex* m;
        bool is_locked;
    private:
        explicit upgrade_lock(upgrade_lock&);
        upgrade_lock& operator=(upgrade_lock&);
    public:
        upgrade_lock():
            m(0),is_locked(false)
        {}
        explicit upgrade_lock(Mutex& m_):
            m(&m_),is_locked(false)
        {
            lock();
        }
        upgrade_lock(Mutex& m_,adopt_lock_t):
            m(&m_),is_locked(true)
        {}
        upgrade_lock(Mutex& m_,defer_lock_t):
            m(&m_),is_locked(false)
        {}
        upgrade_lock(Mutex& m_,try_to_lock_t):
            m(&m_),is_locked(false)
        {
            try_lock();
        }
        upgrade_lock(upgrade_lock<Mutex>&& other):
            m(other.m),is_locked(other.is_locked)
        {
            other.is_locked=false;
            other.m=0;
        }
        upgrade_lock(unique_lock<Mutex>&& other):
            m(other.m),is_locked(other.is_locked)
        {
            if(is_locked)
            {
                m->unlock_and_lock_upgrade();
            }
            other.is_locked=false;
            other.m=0;
        }
        upgrade_lock& operator=(upgrade_lock<Mutex>&& other)
        {
            upgrade_lock temp(static_cast<upgrade_lock<Mutex>&&>(other));
            swap(temp);
            return *this;
        }
        upgrade_lock& operator=(unique_lock<Mutex>&& other)
        {
            upgrade_lock temp(static_cast<unique_lock<Mutex>&&>(other));
            swap(temp);
            return *this;
        }
        void swap(upgrade_lock& other)
        {
            std::swap(m,other.m);
            std::swap(is_locked,other.is_locked);
        }
        ~upgrade_lock()
        {
            if(owns_lock())
            {
                m->unlock_upgrade();
            }
        }
        void lock()
        {
            if(owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            m->lock_upgrade();
            is_locked=true;
        }
        bool try_lock()
        {
            if(owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            is_locked=m->try_lock_upgrade();
            return is_locked;
        }
        void unlock()
        {
            if(!owns_lock())
            {
                boost::throw_exception(boost::lock_error());
            }
            m->unlock_upgrade();
            is_locked=false;
        }
        typedef void (upgrade_lock::*bool_type)();
        operator bool_type() const
        {
            return is_locked?&upgrade_lock::lock:0;
        }
        bool operator!() const
        {
            return !owns_lock();
        }
        bool owns_lock() const
        {
            return is_locked;
        }
        friend class shared_lock<Mutex>;
        friend class unique_lock<Mutex>;
    };
    template<typename Mutex>
    unique_lock<Mutex>::unique_lock(upgrade_lock<Mutex>&& other):
        m(other.m),is_locked(other.is_locked)
    {
        other.is_locked=false;
        if(is_locked)
        {
            m->unlock_upgrade_and_lock();
        }
    }
    template <class Mutex>
    class upgrade_to_unique_lock
    {
    private:
        upgrade_lock<Mutex>* source;
        unique_lock<Mutex> exclusive;
        explicit upgrade_to_unique_lock(upgrade_to_unique_lock&);
        upgrade_to_unique_lock& operator=(upgrade_to_unique_lock&);
    public:
        explicit upgrade_to_unique_lock(upgrade_lock<Mutex>& m_):
            source(&m_),exclusive(move(*source))
        {}
        ~upgrade_to_unique_lock()
        {
            if(source)
            {
                *source=move(exclusive);
            }
        }
        upgrade_to_unique_lock(upgrade_to_unique_lock<Mutex>&& other):
            source(other.source),exclusive(move(other.exclusive))
        {
            other.source=0;
        }
        upgrade_to_unique_lock& operator=(upgrade_to_unique_lock<Mutex>&& other)
        {
            upgrade_to_unique_lock temp(other);
            swap(temp);
            return *this;
        }
        void swap(upgrade_to_unique_lock& other)
        {
            std::swap(source,other.source);
            exclusive.swap(other.exclusive);
        }
        typedef void (upgrade_to_unique_lock::*bool_type)(upgrade_to_unique_lock&);
        operator bool_type() const
        {
            return exclusive.owns_lock()?&upgrade_to_unique_lock::swap:0;
        }
        bool operator!() const
        {
            return !owns_lock();
        }
        bool owns_lock() const
        {
            return exclusive.owns_lock();
        }
    };
    namespace detail
    {
        template<typename Mutex>
        class try_lock_wrapper:
            private unique_lock<Mutex>
        {
            typedef unique_lock<Mutex> base;
        public:
            try_lock_wrapper()
            {}
            explicit try_lock_wrapper(Mutex& m):
                base(m,try_to_lock)
            {}
            try_lock_wrapper(Mutex& m_,adopt_lock_t):
                base(m_,adopt_lock)
            {}
            try_lock_wrapper(Mutex& m_,defer_lock_t):
                base(m_,defer_lock)
            {}
            try_lock_wrapper(Mutex& m_,try_to_lock_t):
                base(m_,try_to_lock)
            {}
            try_lock_wrapper(try_lock_wrapper&& other):
                base(other.move())
            {}
            try_lock_wrapper&& move()
            {
                return static_cast<try_lock_wrapper&&>(*this);
            }
            try_lock_wrapper& operator=(try_lock_wrapper<Mutex>&& other)
            {
                try_lock_wrapper temp(other.move());
                swap(temp);
                return *this;
            }
            void swap(try_lock_wrapper&& other)
            {
                base::swap(other);
            }
            void swap(try_lock_wrapper& other)
            {
                base::swap(other);
            }
            void lock()
            {
                base::lock();
            }
            bool try_lock()
            {
                return base::try_lock();
            }
            void unlock()
            {
                base::unlock();
            }
            bool owns_lock() const
            {
                return base::owns_lock();
            }
            Mutex* mutex() const
            {
                return base::mutex();
            }
            Mutex* release()
            {
                return base::release();
            }
            bool operator!() const
            {
                return !this->owns_lock();
            }
            typedef typename base::bool_type bool_type;
            operator bool_type() const
            {
                return base::operator bool_type();
            }
        };
        template<typename Mutex>
        void swap(try_lock_wrapper<Mutex>&& lhs,try_lock_wrapper<Mutex>&& rhs)
        {
            lhs.swap(rhs);
        }
        template<typename MutexType1,typename MutexType2>
        unsigned try_lock_internal(MutexType1& m1,MutexType2& m2)
        {
            boost::unique_lock<MutexType1> l1(m1,boost::try_to_lock);
            if(!l1)
            {
                return 1;
            }
            if(!m2.try_lock())
            {
                return 2;
            }
            l1.release();
            return 0;
        }
        template<typename MutexType1,typename MutexType2,typename MutexType3>
        unsigned try_lock_internal(MutexType1& m1,MutexType2& m2,MutexType3& m3)
        {
            boost::unique_lock<MutexType1> l1(m1,boost::try_to_lock);
            if(!l1)
            {
                return 1;
            }
            if(unsigned const failed_lock=try_lock_internal(m2,m3))
            {
                return failed_lock+1;
            }
            l1.release();
            return 0;
        }
        template<typename MutexType1,typename MutexType2,typename MutexType3,
                 typename MutexType4>
        unsigned try_lock_internal(MutexType1& m1,MutexType2& m2,MutexType3& m3,
                                   MutexType4& m4)
        {
            boost::unique_lock<MutexType1> l1(m1,boost::try_to_lock);
            if(!l1)
            {
                return 1;
            }
            if(unsigned const failed_lock=try_lock_internal(m2,m3,m4))
            {
                return failed_lock+1;
            }
            l1.release();
            return 0;
        }
        template<typename MutexType1,typename MutexType2,typename MutexType3,
                 typename MutexType4,typename MutexType5>
        unsigned try_lock_internal(MutexType1& m1,MutexType2& m2,MutexType3& m3,
                                   MutexType4& m4,MutexType5& m5)
        {
            boost::unique_lock<MutexType1> l1(m1,boost::try_to_lock);
            if(!l1)
            {
                return 1;
            }
            if(unsigned const failed_lock=try_lock_internal(m2,m3,m4,m5))
            {
                return failed_lock+1;
            }
            l1.release();
            return 0;
        }
        template<typename MutexType1,typename MutexType2>
        unsigned lock_helper(MutexType1& m1,MutexType2& m2)
        {
            boost::unique_lock<MutexType1> l1(m1);
            if(!m2.try_lock())
            {
                return 1;
            }
            l1.release();
            return 0;
        }
        template<typename MutexType1,typename MutexType2,typename MutexType3>
        unsigned lock_helper(MutexType1& m1,MutexType2& m2,MutexType3& m3)
        {
            boost::unique_lock<MutexType1> l1(m1);
            if(unsigned const failed_lock=try_lock_internal(m2,m3))
            {
                return failed_lock;
            }
            l1.release();
            return 0;
        }
        template<typename MutexType1,typename MutexType2,typename MutexType3,
                 typename MutexType4>
        unsigned lock_helper(MutexType1& m1,MutexType2& m2,MutexType3& m3,
                             MutexType4& m4)
        {
            boost::unique_lock<MutexType1> l1(m1);
            if(unsigned const failed_lock=try_lock_internal(m2,m3,m4))
            {
                return failed_lock;
            }
            l1.release();
            return 0;
        }
        template<typename MutexType1,typename MutexType2,typename MutexType3,
                 typename MutexType4,typename MutexType5>
        unsigned lock_helper(MutexType1& m1,MutexType2& m2,MutexType3& m3,
                             MutexType4& m4,MutexType5& m5)
        {
            boost::unique_lock<MutexType1> l1(m1);
            if(unsigned const failed_lock=try_lock_internal(m2,m3,m4,m5))
            {
                return failed_lock;
            }
            l1.release();
            return 0;
        }
    }
    namespace detail
    {
        template<bool x>
        struct is_mutex_type_wrapper
        {};
        template<typename MutexType1,typename MutexType2>
        void lock_impl(MutexType1& m1,MutexType2& m2,is_mutex_type_wrapper<true>)
        {
            unsigned const lock_count=2;
            unsigned lock_first=0;
            for(;;)
            {
                switch(lock_first)
                {
                case 0:
                    lock_first=detail::lock_helper(m1,m2);
                    if(!lock_first)
                        return;
                    break;
                case 1:
                    lock_first=detail::lock_helper(m2,m1);
                    if(!lock_first)
                        return;
                    lock_first=(lock_first+1)%lock_count;
                    break;
                }
            }
        }
        template<typename Iterator>
        void lock_impl(Iterator begin,Iterator end,is_mutex_type_wrapper<false>);
    }
    template<typename MutexType1,typename MutexType2>
    void lock(MutexType1& m1,MutexType2& m2)
    {
        detail::lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }
    template<typename MutexType1,typename MutexType2>
    void lock(const MutexType1& m1,MutexType2& m2)
    {
        detail::lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }
    template<typename MutexType1,typename MutexType2>
    void lock(MutexType1& m1,const MutexType2& m2)
    {
        detail::lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }
    template<typename MutexType1,typename MutexType2>
    void lock(const MutexType1& m1,const MutexType2& m2)
    {
        detail::lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }
    template<typename MutexType1,typename MutexType2,typename MutexType3>
    void lock(MutexType1& m1,MutexType2& m2,MutexType3& m3)
    {
        unsigned const lock_count=3;
        unsigned lock_first=0;
        for(;;)
        {
            switch(lock_first)
            {
            case 0:
                lock_first=detail::lock_helper(m1,m2,m3);
                if(!lock_first)
                    return;
                break;
            case 1:
                lock_first=detail::lock_helper(m2,m3,m1);
                if(!lock_first)
                    return;
                lock_first=(lock_first+1)%lock_count;
                break;
            case 2:
                lock_first=detail::lock_helper(m3,m1,m2);
                if(!lock_first)
                    return;
                lock_first=(lock_first+2)%lock_count;
                break;
            }
        }
    }
    template<typename MutexType1,typename MutexType2,typename MutexType3,
             typename MutexType4>
    void lock(MutexType1& m1,MutexType2& m2,MutexType3& m3,
              MutexType4& m4)
    {
        unsigned const lock_count=4;
        unsigned lock_first=0;
        for(;;)
        {
            switch(lock_first)
            {
            case 0:
                lock_first=detail::lock_helper(m1,m2,m3,m4);
                if(!lock_first)
                    return;
                break;
            case 1:
                lock_first=detail::lock_helper(m2,m3,m4,m1);
                if(!lock_first)
                    return;
                lock_first=(lock_first+1)%lock_count;
                break;
            case 2:
                lock_first=detail::lock_helper(m3,m4,m1,m2);
                if(!lock_first)
                    return;
                lock_first=(lock_first+2)%lock_count;
                break;
            case 3:
                lock_first=detail::lock_helper(m4,m1,m2,m3);
                if(!lock_first)
                    return;
                lock_first=(lock_first+3)%lock_count;
                break;
            }
        }
    }
    template<typename MutexType1,typename MutexType2,typename MutexType3,
             typename MutexType4,typename MutexType5>
    void lock(MutexType1& m1,MutexType2& m2,MutexType3& m3,
              MutexType4& m4,MutexType5& m5)
    {
        unsigned const lock_count=5;
        unsigned lock_first=0;
        for(;;)
        {
            switch(lock_first)
            {
            case 0:
                lock_first=detail::lock_helper(m1,m2,m3,m4,m5);
                if(!lock_first)
                    return;
                break;
            case 1:
                lock_first=detail::lock_helper(m2,m3,m4,m5,m1);
                if(!lock_first)
                    return;
                lock_first=(lock_first+1)%lock_count;
                break;
            case 2:
                lock_first=detail::lock_helper(m3,m4,m5,m1,m2);
                if(!lock_first)
                    return;
                lock_first=(lock_first+2)%lock_count;
                break;
            case 3:
                lock_first=detail::lock_helper(m4,m5,m1,m2,m3);
                if(!lock_first)
                    return;
                lock_first=(lock_first+3)%lock_count;
                break;
            case 4:
                lock_first=detail::lock_helper(m5,m1,m2,m3,m4);
                if(!lock_first)
                    return;
                lock_first=(lock_first+4)%lock_count;
                break;
            }
        }
    }
    namespace detail
    {
        template<typename Mutex,bool x=is_mutex_type<Mutex>::value>
        struct try_lock_impl_return
        {
            typedef int type;
        };
        template<typename Iterator>
        struct try_lock_impl_return<Iterator,false>
        {
            typedef Iterator type;
        };
        template<typename MutexType1,typename MutexType2>
        int try_lock_impl(MutexType1& m1,MutexType2& m2,is_mutex_type_wrapper<true>)
        {
            return ((int)detail::try_lock_internal(m1,m2))-1;
        }
        template<typename Iterator>
        Iterator try_lock_impl(Iterator begin,Iterator end,is_mutex_type_wrapper<false>);
    }
    template<typename MutexType1,typename MutexType2>
    typename detail::try_lock_impl_return<MutexType1>::type try_lock(MutexType1& m1,MutexType2& m2)
    {
        return detail::try_lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }
    template<typename MutexType1,typename MutexType2>
    typename detail::try_lock_impl_return<MutexType1>::type try_lock(const MutexType1& m1,MutexType2& m2)
    {
        return detail::try_lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }
    template<typename MutexType1,typename MutexType2>
    typename detail::try_lock_impl_return<MutexType1>::type try_lock(MutexType1& m1,const MutexType2& m2)
    {
        return detail::try_lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }
    template<typename MutexType1,typename MutexType2>
    typename detail::try_lock_impl_return<MutexType1>::type try_lock(const MutexType1& m1,const MutexType2& m2)
    {
        return detail::try_lock_impl(m1,m2,detail::is_mutex_type_wrapper<is_mutex_type<MutexType1>::value>());
    }
    template<typename MutexType1,typename MutexType2,typename MutexType3>
    int try_lock(MutexType1& m1,MutexType2& m2,MutexType3& m3)
    {
        return ((int)detail::try_lock_internal(m1,m2,m3))-1;
    }
    template<typename MutexType1,typename MutexType2,typename MutexType3,typename MutexType4>
    int try_lock(MutexType1& m1,MutexType2& m2,MutexType3& m3,MutexType4& m4)
    {
        return ((int)detail::try_lock_internal(m1,m2,m3,m4))-1;
    }
    template<typename MutexType1,typename MutexType2,typename MutexType3,typename MutexType4,typename MutexType5>
    int try_lock(MutexType1& m1,MutexType2& m2,MutexType3& m3,MutexType4& m4,MutexType5& m5)
    {
        return ((int)detail::try_lock_internal(m1,m2,m3,m4,m5))-1;
    }
    namespace detail
    {
        template<typename Iterator>
        struct range_lock_guard
        {
            Iterator begin;
            Iterator end;
            range_lock_guard(Iterator begin_,Iterator end_):
                begin(begin_),end(end_)
            {
                lock(begin,end);
            }
            void release()
            {
                begin=end;
            }
            ~range_lock_guard()
            {
                for(;begin!=end;++begin)
                {
                    begin->unlock();
                }
            }
        };
        template<typename Iterator>
        Iterator try_lock_impl(Iterator begin,Iterator end,is_mutex_type_wrapper<false>)
        {
            if(begin==end)
            {
                return end;
            }
            typedef typename std::iterator_traits<Iterator>::value_type lock_type;
            unique_lock<lock_type> guard(*begin,try_to_lock);
            if(!guard.owns_lock())
            {
                return begin;
            }
            Iterator const failed=try_lock(++begin,end);
            if(failed==end)
            {
                guard.release();
            }
            return failed;
        }
    }
    namespace detail
    {
        template<typename Iterator>
        void lock_impl(Iterator begin,Iterator end,is_mutex_type_wrapper<false>)
        {
            typedef typename std::iterator_traits<Iterator>::value_type lock_type;
            if(begin==end)
            {
                return;
            }
            bool start_with_begin=true;
            Iterator second=begin;
            ++second;
            Iterator next=second;
            for(;;)
            {
                unique_lock<lock_type> begin_lock(*begin,defer_lock);
                if(start_with_begin)
                {
                    begin_lock.lock();
                    Iterator const failed_lock=try_lock(next,end);
                    if(failed_lock==end)
                    {
                        begin_lock.release();
                        return;
                    }
                    start_with_begin=false;
                    next=failed_lock;
                }
                else
                {
                    detail::range_lock_guard<Iterator> guard(next,end);
                    if(begin_lock.try_lock())
                    {
                        Iterator const failed_lock=try_lock(second,next);
                        if(failed_lock==next)
                        {
                            begin_lock.release();
                            guard.release();
                            return;
                        }
                        start_with_begin=false;
                        next=failed_lock;
                    }
                    else
                    {
                        start_with_begin=true;
                        next=second;
                    }
                }
            }
        }
    }
}
       
       
       
       
namespace boost {
namespace gregorian {
  inline
  std::tm to_tm(const date& d)
  {
    if (d.is_special())
    {
        std::string s = "tm unable to handle ";
        switch (d.as_special())
        {
        case date_time::not_a_date_time:
            s += "not-a-date-time value"; break;
        case date_time::neg_infin:
            s += "-infinity date value"; break;
        case date_time::pos_infin:
            s += "+infinity date value"; break;
        default:
            s += "a special date value"; break;
        }
        boost::throw_exception(std::out_of_range(s));
    }
    std::tm datetm;
    std::memset(&datetm, 0, sizeof(datetm));
    boost::gregorian::date::ymd_type ymd = d.year_month_day();
    datetm.tm_year = ymd.year - 1900;
    datetm.tm_mon = ymd.month - 1;
    datetm.tm_mday = ymd.day;
    datetm.tm_wday = d.day_of_week();
    datetm.tm_yday = d.day_of_year() - 1;
    datetm.tm_isdst = -1;
    return datetm;
  }
  inline
  date date_from_tm(const std::tm& datetm)
  {
    return date(static_cast<unsigned short>(datetm.tm_year+1900),
                static_cast<unsigned short>(datetm.tm_mon+1),
                static_cast<unsigned short>(datetm.tm_mday));
  }
} }
namespace boost {
namespace posix_time {
  inline
  ptime from_time_t(std::time_t t)
  {
    ptime start(gregorian::date(1970,1,1));
    return start + seconds(static_cast<long>(t));
  }
  inline
  std::tm to_tm(const boost::posix_time::ptime& t) {
    std::tm timetm = boost::gregorian::to_tm(t.date());
    boost::posix_time::time_duration td = t.time_of_day();
    timetm.tm_hour = td.hours();
    timetm.tm_min = td.minutes();
    timetm.tm_sec = td.seconds();
    timetm.tm_isdst = -1;
    return timetm;
  }
  inline
  std::tm to_tm(const boost::posix_time::time_duration& td) {
    std::tm timetm;
    std::memset(&timetm, 0, sizeof(timetm));
    timetm.tm_hour = date_time::absolute_value(td.hours());
    timetm.tm_min = date_time::absolute_value(td.minutes());
    timetm.tm_sec = date_time::absolute_value(td.seconds());
    timetm.tm_isdst = -1;
    return timetm;
  }
  inline
  ptime ptime_from_tm(const std::tm& timetm) {
    boost::gregorian::date d = boost::gregorian::date_from_tm(timetm);
    return ptime(d, time_duration(timetm.tm_hour, timetm.tm_min, timetm.tm_sec));
  }
} }
namespace boost {
enum xtime_clock_types
{
    TIME_UTC=1
};
struct xtime
{
    typedef int_fast64_t xtime_sec_t;
    typedef int_fast32_t xtime_nsec_t;
    xtime_sec_t sec;
    xtime_nsec_t nsec;
    operator system_time() const
    {
        return boost::posix_time::from_time_t(0)+
            boost::posix_time::seconds(static_cast<long>(sec))+
        boost::posix_time::microseconds((nsec+500)/1000);
    }
};
inline xtime get_xtime(boost::system_time const& abs_time)
{
    xtime res;
    boost::posix_time::time_duration const time_since_epoch=abs_time-boost::posix_time::from_time_t(0);
    res.sec=static_cast<xtime::xtime_sec_t>(time_since_epoch.total_seconds());
    res.nsec=static_cast<xtime::xtime_nsec_t>(time_since_epoch.fractional_seconds()*(1000000000/time_since_epoch.ticks_per_second()));
    return res;
}
inline int xtime_get(struct xtime* xtp, int clock_type)
{
    if (clock_type == TIME_UTC)
    {
        *xtp=get_xtime(get_system_time());
        return clock_type;
    }
    return 0;
}
inline int xtime_cmp(const xtime& xt1, const xtime& xt2)
{
    if (xt1.sec == xt2.sec)
        return (int)(xt1.nsec - xt2.nsec);
    else
        return (xt1.sec > xt2.sec) ? 1 : -1;
}
}
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
}
namespace boost
{
    namespace detail
    {
        inline struct timespec get_timespec(boost::system_time const& abs_time)
        {
            struct timespec timeout={0,0};
            boost::posix_time::time_duration const time_since_epoch=abs_time-boost::posix_time::from_time_t(0);
            timeout.tv_sec=time_since_epoch.total_seconds();
            timeout.tv_nsec=(long)(time_since_epoch.fractional_seconds()*(1000000000l/time_since_epoch.ticks_per_second()));
            return timeout;
        }
    }
}
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
}
namespace boost
{
    namespace pthread
    {
        class pthread_mutex_scoped_lock
        {
            pthread_mutex_t* m;
            bool locked;
        public:
            explicit pthread_mutex_scoped_lock(pthread_mutex_t* m_):
                m(m_),locked(true)
            {
                (__builtin_expect(!(!pthread_mutex_lock(m)), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp", 26, "!pthread_mutex_lock(m)") : (void)0);
            }
            void unlock()
            {
                (__builtin_expect(!(!pthread_mutex_unlock(m)), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp", 30, "!pthread_mutex_unlock(m)") : (void)0);
                locked=false;
            }
            ~pthread_mutex_scoped_lock()
            {
                if(locked)
                {
                    unlock();
                }
            }
        };
        class pthread_mutex_scoped_unlock
        {
            pthread_mutex_t* m;
        public:
            explicit pthread_mutex_scoped_unlock(pthread_mutex_t* m_):
                m(m_)
            {
                (__builtin_expect(!(!pthread_mutex_unlock(m)), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp", 51, "!pthread_mutex_unlock(m)") : (void)0);
            }
            ~pthread_mutex_scoped_unlock()
            {
                (__builtin_expect(!(!pthread_mutex_lock(m)), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/thread/pthread/pthread_mutex_scoped_lock.hpp", 55, "!pthread_mutex_lock(m)") : (void)0);
            }
        };
    }
}
namespace boost
{
    class mutex
    {
    private:
        mutex(mutex const&);
        mutex& operator=(mutex const&);
        pthread_mutex_t m;
    public:
        mutex()
        {
            int const res=pthread_mutex_init(&m,__null);
            if(res)
            {
                boost::throw_exception(thread_resource_error());
            }
        }
        ~mutex()
        {
            (__builtin_expect(!(!pthread_mutex_destroy(&m)), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/thread/pthread/mutex.hpp", 47, "!pthread_mutex_destroy(&m)") : (void)0);
        }
        void lock()
        {
            int const res=pthread_mutex_lock(&m);
            if(res)
            {
                boost::throw_exception(lock_error(res));
            }
        }
        void unlock()
        {
            (__builtin_expect(!(!pthread_mutex_unlock(&m)), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/thread/pthread/mutex.hpp", 61, "!pthread_mutex_unlock(&m)") : (void)0);
        }
        bool try_lock()
        {
            int const res=pthread_mutex_trylock(&m);
            if(res && (res!=16))
            {
                boost::throw_exception(lock_error(res));
            }
            return !res;
        }
        typedef pthread_mutex_t* native_handle_type;
        native_handle_type native_handle()
        {
            return &m;
        }
        typedef unique_lock<mutex> scoped_lock;
        typedef detail::try_lock_wrapper<mutex> scoped_try_lock;
    };
    typedef mutex try_mutex;
    class timed_mutex
    {
    private:
        timed_mutex(timed_mutex const&);
        timed_mutex& operator=(timed_mutex const&);
    private:
        pthread_mutex_t m;
        pthread_cond_t cond;
        bool is_locked;
    public:
        timed_mutex()
        {
            int const res=pthread_mutex_init(&m,__null);
            if(res)
            {
                boost::throw_exception(thread_resource_error());
            }
            int const res2=pthread_cond_init(&cond,__null);
            if(res2)
            {
                (__builtin_expect(!(!pthread_mutex_destroy(&m)), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/thread/pthread/mutex.hpp", 110, "!pthread_mutex_destroy(&m)") : (void)0);
                boost::throw_exception(thread_resource_error());
            }
            is_locked=false;
        }
        ~timed_mutex()
        {
            (__builtin_expect(!(!pthread_mutex_destroy(&m)), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/thread/pthread/mutex.hpp", 118, "!pthread_mutex_destroy(&m)") : (void)0);
            (__builtin_expect(!(!pthread_cond_destroy(&cond)), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/thread/pthread/mutex.hpp", 120, "!pthread_cond_destroy(&cond)") : (void)0);
        }
        template<typename TimeDuration>
        bool timed_lock(TimeDuration const & relative_time)
        {
            return timed_lock(get_system_time()+relative_time);
        }
        bool timed_lock(boost::xtime const & absolute_time)
        {
            return timed_lock(system_time(absolute_time));
        }
        void lock()
        {
            boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
            while(is_locked)
            {
                (__builtin_expect(!(!pthread_cond_wait(&cond,&m)), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/thread/pthread/mutex.hpp", 171, "!pthread_cond_wait(&cond,&m)") : (void)0);
            }
            is_locked=true;
        }
        void unlock()
        {
            boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
            is_locked=false;
            (__builtin_expect(!(!pthread_cond_signal(&cond)), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/thread/pthread/mutex.hpp", 180, "!pthread_cond_signal(&cond)") : (void)0);
        }
        bool try_lock()
        {
            boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
            if(is_locked)
            {
                return false;
            }
            is_locked=true;
            return true;
        }
        bool timed_lock(system_time const & abs_time)
        {
            struct timespec const timeout=detail::get_timespec(abs_time);
            boost::pthread::pthread_mutex_scoped_lock const local_lock(&m);
            while(is_locked)
            {
                int const cond_res=pthread_cond_timedwait(&cond,&m,&timeout);
                if(cond_res==60)
                {
                    return false;
                }
                (__builtin_expect(!(!cond_res), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/thread/pthread/mutex.hpp", 205, "!cond_res") : (void)0);
            }
            is_locked=true;
            return true;
        }
        typedef unique_lock<timed_mutex> scoped_timed_lock;
        typedef detail::try_lock_wrapper<timed_mutex> scoped_try_lock;
        typedef scoped_timed_lock scoped_lock;
    };
}
namespace boost { namespace cmt {
    const char* thread_name();
    namespace detail {
    inline boost::mutex& log_mutex() {
      static boost::mutex m; return m;
    }
    inline std::string short_name( const std::string& file_name ) { return file_name.substr( file_name.rfind( '/' ) + 1 ); }
    inline void log( std::ostream& os, const char* color, const char* file, uint32_t line, const char* method, const char* text ) {
        boost::unique_lock<mutex> lock(log_mutex());
        os<<color<<std::left<<std::setw(10)<<thread_name()<<" "<<short_name(file)<<":"<<line<<" "<<method<<"] "<<text<< "\033[0m" << std::endl;
    }
    template<typename P1>
    inline void log( std::ostream& os, const char* color, const char* file, uint32_t line, const char* method, const std::string& format, const P1& p1 ) {
        boost::unique_lock<mutex> lock(log_mutex());
        os<<color<<std::left<<std::setw(10)<<thread_name()<<" "<<short_name(file)<<":"<<line<<" "<<method<<"] "<< (boost::format(format) %p1) << "\033[0m" << std::endl;
    }
    template<typename P1, typename P2>
    inline void log( std::ostream& os, const char* color, const char* file, uint32_t line, const char* method, const std::string& format, const P1& p1, const P2& p2 ) {
        boost::unique_lock<mutex> lock(log_mutex());
        os<<color<<std::left<<std::setw(10)<<thread_name()<<" "<<short_name(file)<<":"<<line<<" "<<method<<"] "<< boost::format(format) %p1 %p2 << "\033[0m" << std::endl;
    }
    template<typename P1, typename P2, typename P3>
    inline void log( std::ostream& os, const char* color, const char* file, uint32_t line, const char* method, const std::string& format, const P1& p1, const P2& p2, const P3& p3 ) {
        boost::unique_lock<mutex> lock(log_mutex());
        os<<color<<std::left<<std::setw(10)<<thread_name()<<" "<<short_name(file)<<":"<<line<<" "<<method<<"] "<< (boost::format(format) %p1 %p2 %p3) << "\033[0m" << std::endl;
    }
    template<typename P1, typename P2, typename P3, typename P4>
    inline void log( std::ostream& os, const char* color, const char* file, uint32_t line, const char* method, const std::string& format, const P1& p1, const P2& p2, const P3& p3, const P4& p4 ) {
        boost::unique_lock<mutex> lock(log_mutex());
        os<<color<<std::left<<std::setw(10)<<thread_name()<<" "<<short_name(file)<<":"<<line<<" "<<method<<"] "<< (boost::format(format) %p1 %p2 %p3 %p4) << "\033[0m" << std::endl;
    }
    template<typename P1, typename P2, typename P3, typename P4, typename P5>
    inline void log( std::ostream& os, const char* color, const char* file, uint32_t line, const char* method, const std::string& format, const P1& p1, const P2& p2, const P3& p3, const P4& p4, const P5& p5 ) {
        boost::unique_lock<mutex> lock(log_mutex());
        os<<color<<std::left<<std::setw(10)<<thread_name()<<" "<<short_name(file)<<":"<<line<<" "<<method<<"] "<< (boost::format(format) %p1 %p2 %p3 %p4 %p5) << "\033[0m" << std::endl;
    }
    template<typename P1, typename P2, typename P3, typename P4, typename P5, typename P6>
    inline void log( std::ostream& os, const char* color, const char* file, uint32_t line, const char* method, const std::string& format, const P1& p1, const P2& p2, const P3& p3, const P4& p4, const P5& p5, const P6& p6 ) {
        boost::unique_lock<mutex> lock(log_mutex());
        os<<color<<std::left<<std::setw(10)<<thread_name()<<" "<<short_name(file)<<":"<<line<<" "<<method<<"] "<< (boost::format(format) %p1 %p2 %p3 %p4 %p5 %p6) << "\033[0m" << std::endl;
    }
} } }
       
namespace boost { template <class Tag,class T> class error_info; }
       
namespace boost
{
template<class T> class reference_wrapper
{
public:
    typedef T type;
    explicit reference_wrapper(T& t): t_(boost::addressof(t)) {}
    operator T& () const { return *t_; }
    T& get() const { return *t_; }
    T* get_pointer() const { return t_; }
private:
    T* t_;
};
template<class T> inline reference_wrapper<T> const ref(T & t)
{
    return reference_wrapper<T>(t);
}
template<class T> inline reference_wrapper<T const> const cref(T const & t)
{
    return reference_wrapper<T const>(t);
}
template<typename T>
class is_reference_wrapper
    : public mpl::false_
{
};
template<typename T>
class unwrap_reference
{
 public:
    typedef T type;
};
template<typename T> class is_reference_wrapper< reference_wrapper<T> > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> > { public: typedef T type; };
template<typename T> class is_reference_wrapper< reference_wrapper<T> const > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> const > { public: typedef T type; };
template<typename T> class is_reference_wrapper< reference_wrapper<T> volatile > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> volatile > { public: typedef T type; };
template<typename T> class is_reference_wrapper< reference_wrapper<T> const volatile > : public mpl::true_ { }; template<typename T> class unwrap_reference< reference_wrapper<T> const volatile > { public: typedef T type; };
template <class T> inline typename unwrap_reference<T>::type&
unwrap_ref(T& t)
{
    return t;
}
template<class T> inline T* get_pointer( reference_wrapper<T> const & r )
{
    return r.get_pointer();
}
}
namespace boost {
template< typename T > struct add_volatile { public: typedef T volatile type; };
template< typename T > struct add_volatile<T&> { public: typedef T& type; };
}
namespace boost {
template< typename T > struct add_cv { public: typedef T const volatile type; };
template< typename T > struct add_cv<T&> { public: typedef T& type; };
}
       
namespace boost {
namespace detail {
template <typename T, bool is_const>
struct remove_volatile_helper
{
    typedef T type;
};
template <typename T>
struct remove_volatile_helper<T,true>
{
    typedef T const type;
};
template <typename T>
struct remove_volatile_impl
{
    typedef typename remove_volatile_helper<
          typename cv_traits_imp<T*>::unqualified_type
        , ::boost::is_const<T>::value
        >::type type;
};
template <typename T>
struct remove_volatile_impl<T&&>
{
    typedef T&& type;
};
}
template< typename T > struct remove_volatile { public: typedef typename boost::detail::remove_volatile_impl<T>::type type; };
template< typename T > struct remove_volatile<T&> { public: typedef T& type; };
template< typename T, std::size_t N > struct remove_volatile<T volatile[N]> { public: typedef T type[N]; };
template< typename T, std::size_t N > struct remove_volatile<T const volatile[N]> { public: typedef T const type[N]; };
}
namespace boost {
namespace detail {
template<typename Function> struct function_traits_helper;
template<typename R>
struct function_traits_helper<R (*)(void)>
{
  static const unsigned arity = 0;
  typedef R result_type;
};
template<typename R, typename T1>
struct function_traits_helper<R (*)(T1)>
{
  static const unsigned arity = 1;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T1 argument_type;
};
template<typename R, typename T1, typename T2>
struct function_traits_helper<R (*)(T1, T2)>
{
  static const unsigned arity = 2;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T1 first_argument_type;
  typedef T2 second_argument_type;
};
template<typename R, typename T1, typename T2, typename T3>
struct function_traits_helper<R (*)(T1, T2, T3)>
{
  static const unsigned arity = 3;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
};
template<typename R, typename T1, typename T2, typename T3, typename T4>
struct function_traits_helper<R (*)(T1, T2, T3, T4)>
{
  static const unsigned arity = 4;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
};
template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5)>
{
  static const unsigned arity = 5;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
};
template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6)>
{
  static const unsigned arity = 6;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
};
template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7)>
{
  static const unsigned arity = 7;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
};
template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8)>
{
  static const unsigned arity = 8;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
};
template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8, typename T9>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9)>
{
  static const unsigned arity = 9;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
  typedef T9 arg9_type;
};
template<typename R, typename T1, typename T2, typename T3, typename T4,
         typename T5, typename T6, typename T7, typename T8, typename T9,
         typename T10>
struct function_traits_helper<R (*)(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)>
{
  static const unsigned arity = 10;
  typedef R result_type;
  typedef T1 arg1_type;
  typedef T2 arg2_type;
  typedef T3 arg3_type;
  typedef T4 arg4_type;
  typedef T5 arg5_type;
  typedef T6 arg6_type;
  typedef T7 arg7_type;
  typedef T8 arg8_type;
  typedef T9 arg9_type;
  typedef T10 arg10_type;
};
}
template<typename Function>
struct function_traits :
  public boost::detail::function_traits_helper<typename boost::add_pointer<Function>::type>
{
};
}
namespace boost {
namespace tuples {
struct null_type {};
namespace detail {
  inline const null_type cnull() { return null_type(); }
template <bool If, class Then, class Else> struct IF { typedef Then RET; };
template <class Then, class Else> struct IF<false, Then, Else> {
  typedef Else RET;
};
}
template <class HT, class TT> struct cons;
template <
  class T0 = null_type, class T1 = null_type, class T2 = null_type,
  class T3 = null_type, class T4 = null_type, class T5 = null_type,
  class T6 = null_type, class T7 = null_type, class T8 = null_type,
  class T9 = null_type>
class tuple;
template<class T> struct length;
namespace detail {
template<class T>
class generate_error;
template<int N>
struct drop_front {
    template<class Tuple>
    struct apply {
        typedef typename drop_front<N-1>::template
            apply<Tuple> next;
        typedef typename next::type::tail_type type;
        static const type& call(const Tuple& tup) {
            return next::call(tup).tail;
        }
    };
};
template<>
struct drop_front<0> {
    template<class Tuple>
    struct apply {
        typedef Tuple type;
        static const type& call(const Tuple& tup) {
            return tup;
        }
    };
};
}
template<int N, class T>
struct element
{
  typedef typename detail::drop_front<N>::template
      apply<T>::type::head_type type;
};
template<int N, class T>
struct element<N, const T>
{
private:
  typedef typename detail::drop_front<N>::template
      apply<T>::type::head_type unqualified_type;
public:
  typedef typename boost::add_const<unqualified_type>::type type;
};
template <class T> struct access_traits {
  typedef const T& const_type;
  typedef T& non_const_type;
  typedef const typename boost::remove_cv<T>::type& parameter_type;
};
template <class T> struct access_traits<T&> {
  typedef T& const_type;
  typedef T& non_const_type;
  typedef T& parameter_type;
};
template<int N, class HT, class TT>
inline typename access_traits<
                  typename element<N, cons<HT, TT> >::type
                >::non_const_type
get(cons<HT, TT>& c ) {
  typedef typename detail::drop_front<N>::template
      apply<cons<HT, TT> > impl;
  typedef typename impl::type cons_element;
  return const_cast<cons_element&>(impl::call(c)).head;
}
template<int N, class HT, class TT>
inline typename access_traits<
                  typename element<N, cons<HT, TT> >::type
                >::const_type
get(const cons<HT, TT>& c ) {
  typedef typename detail::drop_front<N>::template
      apply<cons<HT, TT> > impl;
  typedef typename impl::type cons_element;
  return impl::call(c).head;
}
namespace detail {
template <class T> class non_storeable_type {
  non_storeable_type();
};
template <class T> struct wrap_non_storeable_type {
  typedef typename IF<
    ::boost::is_function<T>::value, non_storeable_type<T>, T
  >::RET type;
};
template <> struct wrap_non_storeable_type<void> {
  typedef non_storeable_type<void> type;
};
}
template <class HT, class TT>
struct cons {
  typedef HT head_type;
  typedef TT tail_type;
  typedef typename
    detail::wrap_non_storeable_type<head_type>::type stored_head_type;
  stored_head_type head;
  tail_type tail;
  typename access_traits<stored_head_type>::non_const_type
  get_head() { return head; }
  typename access_traits<tail_type>::non_const_type
  get_tail() { return tail; }
  typename access_traits<stored_head_type>::const_type
  get_head() const { return head; }
  typename access_traits<tail_type>::const_type
  get_tail() const { return tail; }
  cons() : head(), tail() {}
  cons(typename access_traits<stored_head_type>::parameter_type h,
       const tail_type& t)
    : head (h), tail(t) {}
  template <class T1, class T2, class T3, class T4, class T5,
            class T6, class T7, class T8, class T9, class T10>
  cons( T1& t1, T2& t2, T3& t3, T4& t4, T5& t5,
        T6& t6, T7& t7, T8& t8, T9& t9, T10& t10 )
    : head (t1),
      tail (t2, t3, t4, t5, t6, t7, t8, t9, t10, detail::cnull())
      {}
  template <class T2, class T3, class T4, class T5,
            class T6, class T7, class T8, class T9, class T10>
  cons( const null_type& , T2& t2, T3& t3, T4& t4, T5& t5,
        T6& t6, T7& t7, T8& t8, T9& t9, T10& t10 )
    : head (),
      tail (t2, t3, t4, t5, t6, t7, t8, t9, t10, detail::cnull())
      {}
  template <class HT2, class TT2>
  cons( const cons<HT2, TT2>& u ) : head(u.head), tail(u.tail) {}
  template <class HT2, class TT2>
  cons& operator=( const cons<HT2, TT2>& u ) {
    head=u.head; tail=u.tail; return *this;
  }
  cons& operator=(const cons& u) {
    head = u.head; tail = u.tail; return *this;
  }
  template <class T1, class T2>
  cons& operator=( const std::pair<T1, T2>& u ) {
    static_assert(length<cons>::value == 2, "length<cons>::value == 2");
    head = u.first; tail.head = u.second; return *this;
  }
  template <int N>
  typename access_traits<
             typename element<N, cons<HT, TT> >::type
           >::non_const_type
  get() {
    return boost::tuples::get<N>(*this);
  }
  template <int N>
  typename access_traits<
             typename element<N, cons<HT, TT> >::type
           >::const_type
  get() const {
    return boost::tuples::get<N>(*this);
  }
};
template <class HT>
struct cons<HT, null_type> {
  typedef HT head_type;
  typedef null_type tail_type;
  typedef cons<HT, null_type> self_type;
  typedef typename
    detail::wrap_non_storeable_type<head_type>::type stored_head_type;
  stored_head_type head;
  typename access_traits<stored_head_type>::non_const_type
  get_head() { return head; }
  null_type get_tail() { return null_type(); }
  typename access_traits<stored_head_type>::const_type
  get_head() const { return head; }
  const null_type get_tail() const { return null_type(); }
  cons() : head() {}
  cons(typename access_traits<stored_head_type>::parameter_type h,
       const null_type& = null_type())
    : head (h) {}
  template<class T1>
  cons(T1& t1, const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&)
  : head (t1) {}
  cons(const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&,
       const null_type&, const null_type&, const null_type&)
  : head () {}
  template <class HT2>
  cons( const cons<HT2, null_type>& u ) : head(u.head) {}
  template <class HT2>
  cons& operator=(const cons<HT2, null_type>& u )
  { head = u.head; return *this; }
  cons& operator=(const cons& u) { head = u.head; return *this; }
  template <int N>
  typename access_traits<
             typename element<N, self_type>::type
            >::non_const_type
  get() {
    return boost::tuples::get<N>(*this);
  }
  template <int N>
  typename access_traits<
             typename element<N, self_type>::type
           >::const_type
  get() const {
    return boost::tuples::get<N>(*this);
  }
};
template<class T>
struct length {
  static const int value = 1 + length<typename T::tail_type>::value;
};
template<>
struct length<tuple<> > {
  static const int value = 0;
};
template<>
struct length<tuple<> const> {
  static const int value = 0;
};
template<>
struct length<null_type> {
  static const int value = 0;
};
template<>
struct length<null_type const> {
  static const int value = 0;
};
namespace detail {
template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>
struct map_tuple_to_cons
{
  typedef cons<T0,
               typename map_tuple_to_cons<T1, T2, T3, T4, T5,
                                          T6, T7, T8, T9, null_type>::type
              > type;
};
template <>
struct map_tuple_to_cons<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>
{
  typedef null_type type;
};
}
template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>
class tuple :
  public detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
{
public:
  typedef typename
    detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type inherited;
  typedef typename inherited::head_type head_type;
  typedef typename inherited::tail_type tail_type;
  tuple() {}
  tuple(typename access_traits<T0>::parameter_type t0)
    : inherited(t0, detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull()) {}
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1)
    : inherited(t0, t1, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull()) {}
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2)
    : inherited(t0, t1, t2, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull()) {}
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3)
    : inherited(t0, t1, t2, t3, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull(),
                detail::cnull()) {}
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4)
    : inherited(t0, t1, t2, t3, t4, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull(), detail::cnull()) {}
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5)
    : inherited(t0, t1, t2, t3, t4, t5, detail::cnull(), detail::cnull(),
                detail::cnull(), detail::cnull()) {}
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6)
    : inherited(t0, t1, t2, t3, t4, t5, t6, detail::cnull(),
                detail::cnull(), detail::cnull()) {}
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, detail::cnull(),
                detail::cnull()) {}
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7,
        typename access_traits<T8>::parameter_type t8)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, detail::cnull()) {}
  tuple(typename access_traits<T0>::parameter_type t0,
        typename access_traits<T1>::parameter_type t1,
        typename access_traits<T2>::parameter_type t2,
        typename access_traits<T3>::parameter_type t3,
        typename access_traits<T4>::parameter_type t4,
        typename access_traits<T5>::parameter_type t5,
        typename access_traits<T6>::parameter_type t6,
        typename access_traits<T7>::parameter_type t7,
        typename access_traits<T8>::parameter_type t8,
        typename access_traits<T9>::parameter_type t9)
    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {}
  template<class U1, class U2>
  tuple(const cons<U1, U2>& p) : inherited(p) {}
  template <class U1, class U2>
  tuple& operator=(const cons<U1, U2>& k) {
    inherited::operator=(k);
    return *this;
  }
  template <class U1, class U2>
  tuple& operator=(const std::pair<U1, U2>& k) {
    static_assert(length<tuple>::value == 2, "length<tuple>::value == 2");
    this->head = k.first;
    this->tail.head = k.second;
    return *this;
  }
};
template <>
class tuple<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type> :
  public null_type
{
public:
  typedef null_type inherited;
};
namespace detail {
struct swallow_assign;
typedef void (detail::swallow_assign::*ignore_t)();
struct swallow_assign {
  swallow_assign(ignore_t(*)(ignore_t)) {}
  template<typename T>
  swallow_assign const& operator=(const T&) const {
    return *this;
  }
};
}
inline detail::ignore_t ignore(detail::ignore_t) { return 0; }
template<class T>
struct make_tuple_traits {
  typedef T type;
};
template<class T>
struct make_tuple_traits<T&> {
  typedef typename
     detail::generate_error<T&>::
       do_not_use_with_reference_type error;
};
template<class T, int n> struct make_tuple_traits <T[n]> {
  typedef const T (&type)[n];
};
template<class T, int n>
struct make_tuple_traits<const T[n]> {
  typedef const T (&type)[n];
};
template<class T, int n> struct make_tuple_traits<volatile T[n]> {
  typedef const volatile T (&type)[n];
};
template<class T, int n>
struct make_tuple_traits<const volatile T[n]> {
  typedef const volatile T (&type)[n];
};
template<class T>
struct make_tuple_traits<reference_wrapper<T> >{
  typedef T& type;
};
template<class T>
struct make_tuple_traits<const reference_wrapper<T> >{
  typedef T& type;
};
template<>
struct make_tuple_traits<detail::ignore_t(detail::ignore_t)> {
  typedef detail::swallow_assign type;
};
namespace detail {
template <
  class T0 = null_type, class T1 = null_type, class T2 = null_type,
  class T3 = null_type, class T4 = null_type, class T5 = null_type,
  class T6 = null_type, class T7 = null_type, class T8 = null_type,
  class T9 = null_type
>
struct make_tuple_mapper {
  typedef
    tuple<typename make_tuple_traits<T0>::type,
          typename make_tuple_traits<T1>::type,
          typename make_tuple_traits<T2>::type,
          typename make_tuple_traits<T3>::type,
          typename make_tuple_traits<T4>::type,
          typename make_tuple_traits<T5>::type,
          typename make_tuple_traits<T6>::type,
          typename make_tuple_traits<T7>::type,
          typename make_tuple_traits<T8>::type,
          typename make_tuple_traits<T9>::type> type;
};
}
inline tuple<> make_tuple() {
  return tuple<>();
}
template<class T0>
inline typename detail::make_tuple_mapper<T0>::type
make_tuple(const T0& t0) {
  typedef typename detail::make_tuple_mapper<T0>::type t;
  return t(t0);
}
template<class T0, class T1>
inline typename detail::make_tuple_mapper<T0, T1>::type
make_tuple(const T0& t0, const T1& t1) {
  typedef typename detail::make_tuple_mapper<T0, T1>::type t;
  return t(t0, t1);
}
template<class T0, class T1, class T2>
inline typename detail::make_tuple_mapper<T0, T1, T2>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2>::type t;
  return t(t0, t1, t2);
}
template<class T0, class T1, class T2, class T3>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3>::type t;
  return t(t0, t1, t2, t3);
}
template<class T0, class T1, class T2, class T3, class T4>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type t;
  return t(t0, t1, t2, t3, t4);
}
template<class T0, class T1, class T2, class T3, class T4, class T5>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5) {
  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type t;
  return t(t0, t1, t2, t3, t4, t5);
}
template<class T0, class T1, class T2, class T3, class T4, class T5, class T6>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6);
}
template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7>
inline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6, const T7& t7) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7);
}
template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7, class T8>
inline typename detail::make_tuple_mapper
  <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6, const T7& t7,
                  const T8& t8) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8);
}
template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7, class T8, class T9>
inline typename detail::make_tuple_mapper
  <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
make_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,
                  const T4& t4, const T5& t5, const T6& t6, const T7& t7,
                  const T8& t8, const T9& t9) {
  typedef typename detail::make_tuple_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9);
}
namespace detail {
template<class T>
struct tie_traits {
  typedef T& type;
};
template<>
struct tie_traits<ignore_t(ignore_t)> {
  typedef swallow_assign type;
};
template<>
struct tie_traits<void> {
  typedef null_type type;
};
template <
  class T0 = void, class T1 = void, class T2 = void,
  class T3 = void, class T4 = void, class T5 = void,
  class T6 = void, class T7 = void, class T8 = void,
  class T9 = void
>
struct tie_mapper {
  typedef
    tuple<typename tie_traits<T0>::type,
          typename tie_traits<T1>::type,
          typename tie_traits<T2>::type,
          typename tie_traits<T3>::type,
          typename tie_traits<T4>::type,
          typename tie_traits<T5>::type,
          typename tie_traits<T6>::type,
          typename tie_traits<T7>::type,
          typename tie_traits<T8>::type,
          typename tie_traits<T9>::type> type;
};
}
template<class T0>
inline typename detail::tie_mapper<T0>::type
tie(T0& t0) {
  typedef typename detail::tie_mapper<T0>::type t;
  return t(t0);
}
template<class T0, class T1>
inline typename detail::tie_mapper<T0, T1>::type
tie(T0& t0, T1& t1) {
  typedef typename detail::tie_mapper<T0, T1>::type t;
  return t(t0, t1);
}
template<class T0, class T1, class T2>
inline typename detail::tie_mapper<T0, T1, T2>::type
tie(T0& t0, T1& t1, T2& t2) {
  typedef typename detail::tie_mapper<T0, T1, T2>::type t;
  return t(t0, t1, t2);
}
template<class T0, class T1, class T2, class T3>
inline typename detail::tie_mapper<T0, T1, T2, T3>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3) {
  typedef typename detail::tie_mapper<T0, T1, T2, T3>::type t;
  return t(t0, t1, t2, t3);
}
template<class T0, class T1, class T2, class T3, class T4>
inline typename detail::tie_mapper<T0, T1, T2, T3, T4>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4) {
  typedef typename detail::tie_mapper<T0, T1, T2, T3, T4>::type t;
  return t(t0, t1, t2, t3, t4);
}
template<class T0, class T1, class T2, class T3, class T4, class T5>
inline typename detail::tie_mapper<T0, T1, T2, T3, T4, T5>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4, T5& t5) {
  typedef typename detail::tie_mapper<T0, T1, T2, T3, T4, T5>::type t;
  return t(t0, t1, t2, t3, t4, t5);
}
template<class T0, class T1, class T2, class T3, class T4, class T5, class T6>
inline typename detail::tie_mapper<T0, T1, T2, T3, T4, T5, T6>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4, T5& t5, T6& t6) {
  typedef typename detail::tie_mapper
           <T0, T1, T2, T3, T4, T5, T6>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6);
}
template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7>
inline typename detail::tie_mapper<T0, T1, T2, T3, T4, T5, T6, T7>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4, T5& t5, T6& t6, T7& t7) {
  typedef typename detail::tie_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7);
}
template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7, class T8>
inline typename detail::tie_mapper
  <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4, T5& t5, T6& t6, T7& t7,
                  T8& t8) {
  typedef typename detail::tie_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8);
}
template<class T0, class T1, class T2, class T3, class T4, class T5, class T6,
         class T7, class T8, class T9>
inline typename detail::tie_mapper
  <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type
tie(T0& t0, T1& t1, T2& t2, T3& t3,
                  T4& t4, T5& t5, T6& t6, T7& t7,
                  T8& t8, T9& t9) {
  typedef typename detail::tie_mapper
           <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type t;
  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9);
}
template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>
void swap(tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& lhs,
          tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& rhs);
inline void swap(null_type&, null_type&) {}
template<class HH>
inline void swap(cons<HH, null_type>& lhs, cons<HH, null_type>& rhs) {
  ::boost::swap(lhs.head, rhs.head);
}
template<class HH, class TT>
inline void swap(cons<HH, TT>& lhs, cons<HH, TT>& rhs) {
  ::boost::swap(lhs.head, rhs.head);
  ::boost::tuples::swap(lhs.tail, rhs.tail);
}
template <class T0, class T1, class T2, class T3, class T4,
          class T5, class T6, class T7, class T8, class T9>
inline void swap(tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& lhs,
          tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& rhs) {
  typedef tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> tuple_type;
  typedef typename tuple_type::inherited base;
  ::boost::tuples::swap(static_cast<base&>(lhs), static_cast<base&>(rhs));
}
}
}
namespace boost {
using tuples::tuple;
using tuples::make_tuple;
using tuples::tie;
using tuples::get;
}
namespace
boost
    {
    template <
        class E,
        class Tag1,class T1,
        class Tag2,class T2 >
    inline
    E const &
    operator<<(
        E const & x,
        tuple<
            error_info<Tag1,T1>,
            error_info<Tag2,T2> > const & v )
        {
        return x << v.template get<0>() << v.template get<1>();
        }
    template <
        class E,
        class Tag1,class T1,
        class Tag2,class T2,
        class Tag3,class T3 >
    inline
    E const &
    operator<<(
        E const & x,
        tuple<
            error_info<Tag1,T1>,
            error_info<Tag2,T2>,
            error_info<Tag3,T3> > const & v )
        {
        return x << v.template get<0>() << v.template get<1>() << v.template get<2>();
        }
    template <
        class E,
        class Tag1,class T1,
        class Tag2,class T2,
        class Tag3,class T3,
        class Tag4,class T4 >
    inline
    E const &
    operator<<(
        E const & x,
        tuple<
            error_info<Tag1,T1>,
            error_info<Tag2,T2>,
            error_info<Tag3,T3>,
            error_info<Tag4,T4> > const & v )
        {
        return x << v.template get<0>() << v.template get<1>() << v.template get<2>() << v.template get<3>();
        }
    }
namespace boost { template <class Tag,class T> class error_info; }
namespace
boost
    {
    typedef error_info<struct errinfo_api_function_,char const *> errinfo_api_function;
    }
namespace
boost
    {
    template <class Tag,class T> class error_info;
    typedef error_info<struct errinfo_at_line_,int> errinfo_at_line;
    }
       
namespace
boost
    {
    typedef error_info<struct errinfo_errno_,int> errinfo_errno;
    inline
    std::string
    to_string( errinfo_errno const & e )
        {
        std::ostringstream tmp;
        int v=e.value();
        tmp << v << ", \"" << strerror(v) << "\"";
        return tmp.str();
        }
    }
namespace
boost
    {
    template <class> class weak_ptr;
    template <class Tag,class T> class error_info;
    typedef error_info<struct errinfo_file_handle_,weak_ptr<FILE> > errinfo_file_handle;
    }
namespace
boost
    {
    template <class Tag,class T> class error_info;
    typedef error_info<struct errinfo_file_name_,std::string> errinfo_file_name;
    }
namespace
boost
    {
    template <class Tag,class T> class error_info;
    typedef error_info<struct errinfo_file_open_mode_,std::string> errinfo_file_open_mode;
    }
namespace
boost
    {
    template <class Tag,class T> class error_info;
    typedef error_info<struct errinfo_type_info_name_,std::string> errinfo_type_info_name;
    }
namespace
boost
    {
    namespace exception_detail { class clone_base; }
    template <class Tag,class T> class error_info;
    class exception_ptr;
    typedef error_info<struct errinfo_nested_exception_,exception_ptr> errinfo_nested_exception;
    }
       
namespace
boost
    {
    namespace
    exception_detail
        {
        class clone_base;
        namespace
        clone_current_exception_result
            {
            int const success=0;
            int const bad_alloc=1;
            int const bad_exception=2;
            int const not_supported=3;
            }
        inline
        int
        clone_current_exception( clone_base const * & cloned )
            {
            return clone_current_exception_result::not_supported;
            }
        }
    }
       
       
namespace
boost
    {
    class exception_ptr;
    __attribute__((noreturn)) void rethrow_exception( exception_ptr const & );
    exception_ptr current_exception();
    class
    exception_ptr
        {
        typedef boost::shared_ptr<exception_detail::clone_base const> impl;
        impl ptr_;
        friend void rethrow_exception( exception_ptr const & );
        typedef exception_detail::clone_base const * (impl::*unspecified_bool_type)() const;
        public:
        exception_ptr()
            {
            }
        explicit
        exception_ptr( impl const & ptr ):
            ptr_(ptr)
            {
            }
        bool
        operator==( exception_ptr const & other ) const
            {
            return ptr_==other.ptr_;
            }
        bool
        operator!=( exception_ptr const & other ) const
            {
            return ptr_!=other.ptr_;
            }
        operator unspecified_bool_type() const
            {
            return ptr_?&impl::get:0;
            }
        };
    template <class T>
    inline
    exception_ptr
    copy_exception( T const & e )
        {
        try
            {
            throw enable_current_exception(e);
            }
        catch(
        ... )
            {
            return current_exception();
            }
        }
    typedef error_info<struct tag_original_exception_type,std::type_info const *> original_exception_type;
    inline
    std::string
    to_string( original_exception_type const & x )
        {
        return x.value()->name();
        }
    namespace
    exception_detail
        {
        struct
        bad_alloc_:
            boost::exception,
            std::bad_alloc
                {
                ~bad_alloc_() throw() { }
                };
        struct
        bad_exception_:
            boost::exception,
            std::bad_exception
                {
                ~bad_exception_() throw() { }
                };
        template <class Exception>
        exception_ptr
        get_static_exception_object()
            {
            Exception ba;
            exception_detail::clone_impl<Exception> c(ba);
            c <<
                throw_function(__PRETTY_FUNCTION__) <<
                throw_file("/usr/local/include/boost/exception/detail/exception_ptr.hpp") <<
                throw_line(124);
            static exception_ptr ep(shared_ptr<exception_detail::clone_base const>(new exception_detail::clone_impl<Exception>(c)));
            return ep;
            }
        template <class Exception>
        struct
        exception_ptr_static_exception_object
            {
            static exception_ptr const e;
            };
        template <class Exception>
        exception_ptr const
        exception_ptr_static_exception_object<Exception>::
        e = get_static_exception_object<Exception>();
        }
#pragma GCC visibility push (default)
    class
    unknown_exception:
        public boost::exception,
        public std::exception
        {
        public:
        unknown_exception()
            {
            }
        explicit
        unknown_exception( std::exception const & e )
            {
            add_original_type(e);
            }
        explicit
        unknown_exception( boost::exception const & e ):
            boost::exception(e)
            {
            add_original_type(e);
            }
        ~unknown_exception() throw()
            {
            }
        private:
        template <class E>
        void
        add_original_type( E const & e )
            {
            (*this) << original_exception_type(&typeid(e));
            }
        };
#pragma GCC visibility pop
    namespace
    exception_detail
        {
        template <class T>
        class
        current_exception_std_exception_wrapper:
            public T,
            public boost::exception
            {
            public:
            explicit
            current_exception_std_exception_wrapper( T const & e1 ):
                T(e1)
                {
                add_original_type(e1);
                }
            current_exception_std_exception_wrapper( T const & e1, boost::exception const & e2 ):
                T(e1),
                boost::exception(e2)
                {
                add_original_type(e1);
                }
            ~current_exception_std_exception_wrapper() throw()
                {
                }
            private:
            template <class E>
            void
            add_original_type( E const & e )
                {
                (*this) << original_exception_type(&typeid(e));
                }
            };
        template <class T>
        boost::exception const *
        get_boost_exception( T const * x )
            {
            return dynamic_cast<boost::exception const *>(x);
            }
        template <class T>
        inline
        exception_ptr
        current_exception_std_exception( T const & e1 )
            {
            if( boost::exception const * e2 = get_boost_exception(&e1) )
                return boost::copy_exception(current_exception_std_exception_wrapper<T>(e1,*e2));
            else
                return boost::copy_exception(current_exception_std_exception_wrapper<T>(e1));
            }
        inline
        exception_ptr
        current_exception_unknown_exception()
            {
            return boost::copy_exception(unknown_exception());
            }
        inline
        exception_ptr
        current_exception_unknown_boost_exception( boost::exception const & e )
            {
            return boost::copy_exception(unknown_exception(e));
            }
        inline
        exception_ptr
        current_exception_unknown_std_exception( std::exception const & e )
            {
            if( boost::exception const * be = get_boost_exception(&e) )
                return current_exception_unknown_boost_exception(*be);
            else
                return boost::copy_exception(unknown_exception(e));
            }
        inline
        exception_ptr
        current_exception_impl()
            {
            exception_detail::clone_base const * e=0;
            switch(
            exception_detail::clone_current_exception(e) )
                {
                case exception_detail::clone_current_exception_result::
                success:
                    {
                    (__builtin_expect(!(e!=0), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/exception/detail/exception_ptr.hpp", 307, "e!=0") : (void)0);
                    return exception_ptr(shared_ptr<exception_detail::clone_base const>(e));
                    }
                case exception_detail::clone_current_exception_result::
                bad_alloc:
                    {
                    (__builtin_expect(!(!e), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/exception/detail/exception_ptr.hpp", 313, "!e") : (void)0);
                    return exception_detail::exception_ptr_static_exception_object<bad_alloc_>::e;
                    }
                case exception_detail::clone_current_exception_result::
                bad_exception:
                    {
                    (__builtin_expect(!(!e), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/exception/detail/exception_ptr.hpp", 319, "!e") : (void)0);
                    return exception_detail::exception_ptr_static_exception_object<bad_exception_>::e;
                    }
                default:
                    (__builtin_expect(!(0), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/exception/detail/exception_ptr.hpp", 323, "0") : (void)0);
                case exception_detail::clone_current_exception_result::
                not_supported:
                    {
                    (__builtin_expect(!(!e), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/exception/detail/exception_ptr.hpp", 327, "!e") : (void)0);
                    try
                        {
                        throw;
                        }
                    catch(
                    exception_detail::clone_base & e )
                        {
                        return exception_ptr(shared_ptr<exception_detail::clone_base const>(e.clone()));
                        }
                    catch(
                    std::domain_error & e )
                        {
                        return exception_detail::current_exception_std_exception(e);
                        }
                    catch(
                    std::invalid_argument & e )
                        {
                        return exception_detail::current_exception_std_exception(e);
                        }
                    catch(
                    std::length_error & e )
                        {
                        return exception_detail::current_exception_std_exception(e);
                        }
                    catch(
                    std::out_of_range & e )
                        {
                        return exception_detail::current_exception_std_exception(e);
                        }
                    catch(
                    std::logic_error & e )
                        {
                        return exception_detail::current_exception_std_exception(e);
                        }
                    catch(
                    std::range_error & e )
                        {
                        return exception_detail::current_exception_std_exception(e);
                        }
                    catch(
                    std::overflow_error & e )
                        {
                        return exception_detail::current_exception_std_exception(e);
                        }
                    catch(
                    std::underflow_error & e )
                        {
                        return exception_detail::current_exception_std_exception(e);
                        }
                    catch(
                    std::ios_base::failure & e )
                        {
                        return exception_detail::current_exception_std_exception(e);
                        }
                    catch(
                    std::runtime_error & e )
                        {
                        return exception_detail::current_exception_std_exception(e);
                        }
                    catch(
                    std::bad_alloc & e )
                        {
                        return exception_detail::current_exception_std_exception(e);
                        }
                    catch(
                    std::bad_cast & e )
                        {
                        return exception_detail::current_exception_std_exception(e);
                        }
                    catch(
                    std::bad_typeid & e )
                        {
                        return exception_detail::current_exception_std_exception(e);
                        }
                    catch(
                    std::bad_exception & e )
                        {
                        return exception_detail::current_exception_std_exception(e);
                        }
                    catch(
                    std::exception & e )
                        {
                        return exception_detail::current_exception_unknown_std_exception(e);
                        }
                    catch(
                    boost::exception & e )
                        {
                        return exception_detail::current_exception_unknown_boost_exception(e);
                        }
                    catch(
                    ... )
                        {
                        return exception_detail::current_exception_unknown_exception();
                        }
                    }
                }
            }
        }
    inline
    exception_ptr
    current_exception()
        {
        exception_ptr ret;
        try
            {
            ret=exception_detail::current_exception_impl();
            }
        catch(
        std::bad_alloc & )
            {
            ret=exception_detail::exception_ptr_static_exception_object<exception_detail::bad_alloc_>::e;
            }
        catch(
        ... )
            {
            ret=exception_detail::exception_ptr_static_exception_object<exception_detail::bad_exception_>::e;
            }
        (__builtin_expect(!(ret), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/exception/detail/exception_ptr.hpp", 448, "ret") : (void)0);
        return ret;
        }
    __attribute__((noreturn))
    inline
    void
    rethrow_exception( exception_ptr const & p )
        {
        (__builtin_expect(!(p), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/exception/detail/exception_ptr.hpp", 457, "p") : (void)0);
        p.ptr_->rethrow();
        (__builtin_expect(!(0), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/exception/detail/exception_ptr.hpp", 459, "0") : (void)0);
        std::abort();
        }
    inline
    std::string
    diagnostic_information( exception_ptr const & p )
        {
        if( p )
            try
                {
                rethrow_exception(p);
                }
            catch(
            ... )
                {
                return current_exception_diagnostic_information();
                }
        return "<empty>";
        }
    inline
    std::string
    to_string( exception_ptr const & p )
        {
        std::string s='\n'+diagnostic_information(p);
        std::string padding("  ");
        std::string r;
        bool f=false;
        for( std::string::const_iterator i=s.begin(),e=s.end(); i!=e; ++i )
            {
            if( f )
                r+=padding;
            char c=*i;
            r+=c;
            f=(c=='\n');
            }
        return r;
        }
    }
       
       
       
namespace boost { namespace mpl {
template< typename SourceTag, typename TargetTag > struct numeric_cast
{
    template< typename N > struct apply;
};
}}
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_tag { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::tag>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
namespace boost { namespace mpl {
namespace aux {
template< typename T > struct tag_impl
{
    typedef typename T::tag type;
};
}
template< typename T, typename Default = void_ > struct tag
    : if_<
          aux::has_tag<T>
        , aux::tag_impl<T>
        , Default
        >::type
{
};
}}
namespace boost { namespace mpl { namespace aux {
template<
      typename F
    , typename Tag1
    , typename Tag2
    >
struct cast1st_impl
{
    template< typename N1, typename N2 > struct apply
        : apply_wrap2<
              F
            , typename apply_wrap1< numeric_cast<Tag1,Tag2>,N1 >::type
            , N2
            >
    {
    };
};
template<
      typename F
    , typename Tag1
    , typename Tag2
    >
struct cast2nd_impl
{
    template< typename N1, typename N2 > struct apply
        : apply_wrap2<
              F
            , N1
            , typename apply_wrap1< numeric_cast<Tag2,Tag1>,N2 >::type
            >
    {
    };
};
}}}
namespace boost { namespace mpl { namespace aux {
}}}
namespace boost { namespace mpl { namespace aux {
template< typename T > struct msvc_eti_base
    : T
{
    msvc_eti_base();
    typedef T type;
};
template<> struct msvc_eti_base<int>
{
    typedef msvc_eti_base type;
    typedef msvc_eti_base first;
    typedef msvc_eti_base second;
    typedef msvc_eti_base tag;
    enum { value = 0 };
};
}}}
namespace boost { namespace mpl {
template<
      typename Tag1
    , typename Tag2
    >
struct equal_to_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )
        , aux::cast2nd_impl< equal_to_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< equal_to_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};
template<> struct equal_to_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};
template< typename Tag > struct equal_to_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};
template< typename Tag > struct equal_to_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};
template< typename T > struct equal_to_tag
{
    typedef typename T::tag type;
};
template<
      typename N1 = na
    , typename N2 = na
    >
struct equal_to
    : equal_to_impl<
          typename equal_to_tag<N1>::type
        , typename equal_to_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   
};
template<> struct equal_to< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : equal_to< T1 , T2 > { }; }; template< typename Tag > struct lambda< equal_to< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef equal_to< na , na > result_; typedef equal_to< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< equal_to< T1 , T2 > > : int_<2> { }; template<> struct template_arity< equal_to< na , na > > : int_<-1> { }; }
}}
namespace boost { namespace mpl {
template<>
struct equal_to_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply
        : bool_< ( N1::value == N2::value ) >
    {
    };
};
}}
namespace boost { namespace numeric { namespace convdetail
{
   template< class T1, class T2>
   struct equal_to
   {
       enum { x = ( T1::value == T2::value ) };
       static const bool value = x;
       typedef mpl::bool_<value> type;
   };
  template<class Value,
           class Case0Val,
           class Case1Val,
           class Case2Val,
           class Case0Type,
           class Case1Type,
           class Case2Type,
           class DefaultType
          >
  struct ct_switch4
  {
    typedef mpl::identity<Case0Type> Case0TypeQ ;
    typedef mpl::identity<Case1Type> Case1TypeQ ;
    typedef equal_to<Value,Case0Val> is_case0 ;
    typedef equal_to<Value,Case1Val> is_case1 ;
    typedef equal_to<Value,Case2Val> is_case2 ;
    typedef mpl::if_<is_case2,Case2Type,DefaultType> choose_2_3Q ;
    typedef mpl::eval_if<is_case1,Case1TypeQ,choose_2_3Q> choose_1_2_3Q ;
    typedef typename
      mpl::eval_if<is_case0,Case0TypeQ,choose_1_2_3Q>::type
        type ;
  } ;
  template<class expr0, class expr1, class TT, class TF, class FT, class FF>
  struct for_both
  {
    typedef mpl::identity<TF> TF_Q ;
    typedef mpl::identity<TT> TT_Q ;
    typedef typename mpl::not_<expr0>::type not_expr0 ;
    typedef typename mpl::not_<expr1>::type not_expr1 ;
    typedef typename mpl::and_<expr0,expr1>::type caseTT ;
    typedef typename mpl::and_<expr0,not_expr1>::type caseTF ;
    typedef typename mpl::and_<not_expr0,expr1>::type caseFT ;
    typedef mpl::if_<caseFT,FT,FF> choose_FT_FF_Q ;
    typedef mpl::eval_if<caseTF,TF_Q,choose_FT_FF_Q> choose_TF_FT_FF_Q ;
    typedef typename mpl::eval_if<caseTT,TT_Q,choose_TF_FT_FF_Q>::type type ;
  } ;
} } }
namespace boost { namespace numeric
{
  enum int_float_mixture_enum
  {
     integral_to_integral
    ,integral_to_float
    ,float_to_integral
    ,float_to_float
  } ;
} }
namespace boost { namespace numeric { namespace convdetail
{
  typedef mpl::integral_c<int_float_mixture_enum, integral_to_integral> int2int_c ;
  typedef mpl::integral_c<int_float_mixture_enum, integral_to_float> int2float_c ;
  typedef mpl::integral_c<int_float_mixture_enum, float_to_integral> float2int_c ;
  typedef mpl::integral_c<int_float_mixture_enum, float_to_float> float2float_c ;
  template<class T,class S>
  struct get_int_float_mixture
  {
    typedef mpl::bool_< ::std::numeric_limits<S>::is_integer > S_int ;
    typedef mpl::bool_< ::std::numeric_limits<T>::is_integer > T_int ;
    typedef typename
      for_both<S_int, T_int, int2int_c, int2float_c, float2int_c, float2float_c>::type
        type ;
  } ;
  template<class IntFloatMixture, class Int2Int, class Int2Float, class Float2Int, class Float2Float>
  struct for_int_float_mixture
  {
    typedef typename
      ct_switch4<IntFloatMixture
                 ,int2int_c, int2float_c, float2int_c
                 ,Int2Int , Int2Float , Float2Int , Float2Float
                >::type
        type ;
  } ;
} } }
namespace boost { namespace numeric
{
  enum sign_mixture_enum
  {
     unsigned_to_unsigned
    ,signed_to_signed
    ,signed_to_unsigned
    ,unsigned_to_signed
  } ;
} }
namespace boost { namespace numeric { namespace convdetail
{
  typedef mpl::integral_c<sign_mixture_enum, unsigned_to_unsigned> unsig2unsig_c ;
  typedef mpl::integral_c<sign_mixture_enum, signed_to_signed> sig2sig_c ;
  typedef mpl::integral_c<sign_mixture_enum, signed_to_unsigned> sig2unsig_c ;
  typedef mpl::integral_c<sign_mixture_enum, unsigned_to_signed> unsig2sig_c ;
  template<class T,class S>
  struct get_sign_mixture
  {
    typedef mpl::bool_< ::std::numeric_limits<S>::is_signed > S_signed ;
    typedef mpl::bool_< ::std::numeric_limits<T>::is_signed > T_signed ;
    typedef typename
      for_both<S_signed, T_signed, sig2sig_c, sig2unsig_c, unsig2sig_c, unsig2unsig_c>::type
        type ;
  } ;
  template<class SignMixture, class Sig2Sig, class Sig2Unsig, class Unsig2Sig, class Unsig2Unsig>
  struct for_sign_mixture
  {
    typedef typename
      ct_switch4<SignMixture
                 , sig2sig_c, sig2unsig_c, unsig2sig_c
                 , Sig2Sig , Sig2Unsig , Unsig2Sig , Unsig2Unsig
                >::type
        type ;
  } ;
} } }
namespace boost { namespace numeric
{
  enum udt_builtin_mixture_enum
  {
     builtin_to_builtin
    ,builtin_to_udt
    ,udt_to_builtin
    ,udt_to_udt
  } ;
} }
namespace boost { namespace numeric { namespace convdetail
{
  typedef mpl::integral_c<udt_builtin_mixture_enum, builtin_to_builtin> builtin2builtin_c ;
  typedef mpl::integral_c<udt_builtin_mixture_enum, builtin_to_udt> builtin2udt_c ;
  typedef mpl::integral_c<udt_builtin_mixture_enum, udt_to_builtin> udt2builtin_c ;
  typedef mpl::integral_c<udt_builtin_mixture_enum, udt_to_udt> udt2udt_c ;
  template<class UdtMixture, class BuiltIn2BuiltIn, class BuiltIn2Udt, class Udt2BuiltIn, class Udt2Udt>
  struct for_udt_builtin_mixture
  {
    typedef typename
      ct_switch4<UdtMixture
                 , builtin2builtin_c, builtin2udt_c, udt2builtin_c
                 , BuiltIn2BuiltIn , BuiltIn2Udt , Udt2BuiltIn , Udt2Udt
                >::type
        type ;
  } ;
  template<class T,class S>
  struct get_udt_builtin_mixture
  {
    typedef is_arithmetic<S> S_builtin ;
    typedef is_arithmetic<T> T_builtin ;
    typedef typename
      for_both<S_builtin, T_builtin, builtin2builtin_c, builtin2udt_c, udt2builtin_c, udt2udt_c>::type
        type ;
  } ;
} } }
namespace boost { namespace mpl { namespace aux {
template< typename T > struct integral_rank;
template<> struct integral_rank<bool> : int_<1> {};
template<> struct integral_rank<signed char> : int_<2> {};
template<> struct integral_rank<char> : int_<3> {};
template<> struct integral_rank<unsigned char> : int_<4> {};
template<> struct integral_rank<wchar_t> : int_<5> {};
template<> struct integral_rank<short> : int_<6> {};
template<> struct integral_rank<unsigned short> : int_<7> {};
template<> struct integral_rank<int> : int_<8> {};
template<> struct integral_rank<unsigned int> : int_<9> {};
template<> struct integral_rank<long> : int_<10> {};
template<> struct integral_rank<unsigned long> : int_<11> {};
template<> struct integral_rank<long_long_type> : int_<12> {};
template<> struct integral_rank<ulong_long_type>: int_<13> {};
template< typename T1, typename T2 > struct largest_int
    : if_c<
          ( integral_rank<T1>::value >= integral_rank<T2>::value )
        , T1
        , T2
        >
{
};
}}}
namespace boost { namespace mpl {
template<
      typename Tag1
    , typename Tag2
    >
struct times_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )
        , aux::cast2nd_impl< times_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< times_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};
template<> struct times_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};
template< typename Tag > struct times_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};
template< typename Tag > struct times_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};
template< typename T > struct times_tag
{
    typedef typename T::tag type;
};
template<
      typename N1 = na
    , typename N2 = na
    , typename N3 = na, typename N4 = na, typename N5 = na
    >
struct times
    : times< times< times< times< N1,N2 >, N3>, N4>, N5>
{
   
};
template<
      typename N1, typename N2, typename N3, typename N4
    >
struct times< N1,N2,N3,N4,na >
    : times< times< times< N1,N2 >, N3>, N4>
{
   
};
template<
      typename N1, typename N2, typename N3
    >
struct times< N1,N2,N3,na,na >
    : times< times< N1,N2 >, N3>
{
   
};
template<
      typename N1, typename N2
    >
struct times< N1,N2,na,na,na >
    : times_impl<
          typename times_tag<N1>::type
        , typename times_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   
};
template<> struct times< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : times< T1 , T2 > { }; }; template< typename Tag > struct lambda< times< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef times< na , na > result_; typedef times< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< times< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< times< na , na > > : int_<-1> { }; }
}}
namespace boost { namespace mpl {
template<>
struct times_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply
        : integral_c<
              typename aux::largest_int<
                  typename N1::value_type
                , typename N2::value_type
                >::type
            , ( N1::value
                  * N2::value
                )
            >
    {
    };
};
}}
namespace boost { namespace mpl {
template<
      typename N1 = na , typename N2 = na , typename N3 = na , typename N4 = na , typename N5 = na
    >
struct multiplies
    : times< N1 , N2 , N3 , N4 , N5 >
{
   
};
template<> struct multiplies< na , na , na , na , na > { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct apply : multiplies< T1 , T2 , T3 , T4 , T5 > { }; }; template< typename Tag > struct lambda< multiplies< na , na , na , na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef multiplies< na , na , na , na , na > result_; typedef multiplies< na , na , na , na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< multiplies< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< multiplies< na , na , na , na , na > > : int_<-1> { }; }
}}
namespace boost { namespace mpl {
template<
      typename Tag1
    , typename Tag2
    >
struct less_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )
        , aux::cast2nd_impl< less_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< less_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};
template<> struct less_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};
template< typename Tag > struct less_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};
template< typename Tag > struct less_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};
template< typename T > struct less_tag
{
    typedef typename T::tag type;
};
template<
      typename N1 = na
    , typename N2 = na
    >
struct less
    : less_impl<
          typename less_tag<N1>::type
        , typename less_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   
};
template<> struct less< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : less< T1 , T2 > { }; }; template< typename Tag > struct lambda< less< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef less< na , na > result_; typedef less< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< less< T1 , T2 > > : int_<2> { }; template<> struct template_arity< less< na , na > > : int_<-1> { }; }
}}
namespace boost { namespace mpl {
template<>
struct less_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply
        : bool_< ( N2::value > N1::value ) >
    {
    };
};
}}
namespace boost { namespace numeric { namespace convdetail
{
    template<class T,class S>
    struct subranged_Sig2Unsig
    {
      typedef mpl::true_ type ;
    } ;
    template<class T,class S>
    struct subranged_Unsig2Sig
    {
       typedef mpl::int_< ::std::numeric_limits<S>::digits > S_digits ;
       typedef mpl::int_< ::std::numeric_limits<T>::digits > T_digits ;
       typedef typename T_digits::next u_T_digits ;
       typedef mpl::int_<2> Two ;
       typedef typename mpl::multiplies<S_digits,Two>::type S_digits_times_2 ;
       typedef typename mpl::less<u_T_digits,S_digits_times_2>::type type ;
    } ;
    template<class T,class S>
    struct subranged_SameSign
    {
       typedef mpl::int_< ::std::numeric_limits<S>::digits > S_digits ;
       typedef mpl::int_< ::std::numeric_limits<T>::digits > T_digits ;
       typedef typename mpl::less<T_digits,S_digits>::type type ;
    } ;
    template<class T,class S>
    struct subranged_Int2Float
    {
      typedef mpl::false_ type ;
    } ;
    template<class T,class S>
    struct subranged_Float2Int
    {
      typedef mpl::true_ type ;
    } ;
    template<class T,class S>
    struct subranged_Float2Float
    {
      typedef mpl::int_< ::std::numeric_limits<S>::digits > S_mantisa ;
      typedef mpl::int_< ::std::numeric_limits<T>::digits > T_mantisa ;
      typedef mpl::int_< ::std::numeric_limits<S>::max_exponent > S_exponent ;
      typedef mpl::int_< ::std::numeric_limits<T>::max_exponent > T_exponent ;
      typedef typename mpl::less<T_exponent,S_exponent>::type T_smaller_exponent ;
      typedef typename mpl::equal_to<T_exponent,S_exponent>::type equal_exponents ;
      typedef mpl::less<T_mantisa,S_mantisa> T_smaller_mantisa ;
      typedef mpl::eval_if<equal_exponents,T_smaller_mantisa,mpl::false_> not_bigger_exponent_case ;
      typedef typename
        mpl::eval_if<T_smaller_exponent,mpl::true_,not_bigger_exponent_case>::type
          type ;
    } ;
    template<class T,class S>
    struct subranged_Udt2BuiltIn
    {
      typedef mpl::true_ type ;
    } ;
    template<class T,class S>
    struct subranged_BuiltIn2Udt
    {
      typedef mpl::false_ type ;
    } ;
    template<class T,class S>
    struct subranged_Udt2Udt
    {
      typedef mpl::false_ type ;
    } ;
    template<class T,class S>
    struct get_subranged_Int2Int
    {
      typedef subranged_SameSign<T,S> Sig2Sig ;
      typedef subranged_Sig2Unsig<T,S> Sig2Unsig ;
      typedef subranged_Unsig2Sig<T,S> Unsig2Sig ;
      typedef Sig2Sig Unsig2Unsig ;
      typedef typename get_sign_mixture<T,S>::type sign_mixture ;
      typedef typename
        for_sign_mixture<sign_mixture, Sig2Sig, Sig2Unsig, Unsig2Sig, Unsig2Unsig>::type
           type ;
    } ;
    template<class T,class S>
    struct get_subranged_BuiltIn2BuiltIn
    {
      typedef get_subranged_Int2Int<T,S> Int2IntQ ;
      typedef subranged_Int2Float <T,S> Int2Float ;
      typedef subranged_Float2Int <T,S> Float2Int ;
      typedef subranged_Float2Float<T,S> Float2Float ;
      typedef mpl::identity<Int2Float > Int2FloatQ ;
      typedef mpl::identity<Float2Int > Float2IntQ ;
      typedef mpl::identity<Float2Float> Float2FloatQ ;
      typedef typename get_int_float_mixture<T,S>::type int_float_mixture ;
      typedef for_int_float_mixture<int_float_mixture, Int2IntQ, Int2FloatQ, Float2IntQ, Float2FloatQ> for_ ;
      typedef typename for_::type selected ;
      typedef typename selected::type type ;
    } ;
    template<class T,class S>
    struct get_subranged
    {
      typedef get_subranged_BuiltIn2BuiltIn<T,S> BuiltIn2BuiltInQ ;
      typedef subranged_BuiltIn2Udt<T,S> BuiltIn2Udt ;
      typedef subranged_Udt2BuiltIn<T,S> Udt2BuiltIn ;
      typedef subranged_Udt2Udt<T,S> Udt2Udt ;
      typedef mpl::identity<BuiltIn2Udt> BuiltIn2UdtQ ;
      typedef mpl::identity<Udt2BuiltIn> Udt2BuiltInQ ;
      typedef mpl::identity<Udt2Udt > Udt2UdtQ ;
      typedef typename get_udt_builtin_mixture<T,S>::type udt_builtin_mixture ;
      typedef typename
        for_udt_builtin_mixture<udt_builtin_mixture, BuiltIn2BuiltInQ, BuiltIn2UdtQ, Udt2BuiltInQ, Udt2UdtQ>::type
          selected ;
      typedef typename selected::type selected2 ;
      typedef typename selected2::type type ;
    } ;
  template<class T, class S>
  struct get_is_subranged
  {
    typedef get_subranged<T,S> non_trivial_case ;
    typedef mpl::identity<mpl::false_> trivial_case ;
    typedef is_same<T,S> is_trivial ;
    typedef typename mpl::if_<is_trivial,trivial_case,non_trivial_case>::type selected ;
    typedef typename selected::type type ;
  } ;
} } }
namespace boost { namespace numeric { namespace convdetail
{
  template<class T,class S>
  struct non_trivial_traits_impl
  {
    typedef typename get_int_float_mixture <T,S>::type int_float_mixture ;
    typedef typename get_sign_mixture <T,S>::type sign_mixture ;
    typedef typename get_udt_builtin_mixture <T,S>::type udt_builtin_mixture ;
    typedef typename get_is_subranged<T,S>::type subranged ;
    typedef mpl::false_ trivial ;
    typedef T target_type ;
    typedef S source_type ;
    typedef T result_type ;
    typedef typename mpl::if_< is_arithmetic<S>, S, S const&>::type argument_type ;
    typedef typename mpl::if_<subranged,S,T>::type supertype ;
    typedef typename mpl::if_<subranged,T,S>::type subtype ;
  } ;
  template<class N>
  struct trivial_traits_impl
  {
    typedef typename get_int_float_mixture <N,N>::type int_float_mixture ;
    typedef typename get_sign_mixture <N,N>::type sign_mixture ;
    typedef typename get_udt_builtin_mixture<N,N>::type udt_builtin_mixture ;
    typedef mpl::false_ subranged ;
    typedef mpl::true_ trivial ;
    typedef N target_type ;
    typedef N source_type ;
    typedef N const& result_type ;
    typedef N const& argument_type ;
    typedef N supertype ;
    typedef N subtype ;
  } ;
  template<class T, class S>
  struct get_conversion_traits
  {
    typedef typename remove_cv<T>::type target_type ;
    typedef typename remove_cv<S>::type source_type ;
    typedef typename is_same<target_type,source_type>::type is_trivial ;
    typedef trivial_traits_impl <target_type> trivial_imp ;
    typedef non_trivial_traits_impl<target_type,source_type> non_trivial_imp ;
    typedef typename mpl::if_<is_trivial,trivial_imp,non_trivial_imp>::type type ;
  } ;
} } }
namespace boost { namespace numeric
{
template<class T, class S>
struct conversion_traits
    : convdetail::get_conversion_traits<T,S>::type
{
} ;
} }
namespace boost { namespace numeric
{
template<class S>
struct Trunc
{
  typedef S source_type ;
  typedef typename mpl::if_< is_arithmetic<S>,S,S const&>::type argument_type ;
  static source_type nearbyint ( argument_type s )
  {
    using std::floor ;
    using std::ceil ;
    return s < static_cast<S>(0) ? ceil(s) : floor(s) ;
  }
  typedef mpl::integral_c< std::float_round_style, std::round_toward_zero> round_style ;
} ;
template<class S>
struct Floor
{
  typedef S source_type ;
  typedef typename mpl::if_< is_arithmetic<S>,S,S const&>::type argument_type ;
  static source_type nearbyint ( argument_type s )
  {
    using std::floor ;
    return floor(s) ;
  }
  typedef mpl::integral_c< std::float_round_style, std::round_toward_neg_infinity> round_style ;
} ;
template<class S>
struct Ceil
{
  typedef S source_type ;
  typedef typename mpl::if_< is_arithmetic<S>,S,S const&>::type argument_type ;
  static source_type nearbyint ( argument_type s )
  {
    using std::ceil ;
    return ceil(s) ;
  }
  typedef mpl::integral_c< std::float_round_style, std::round_toward_infinity> round_style ;
} ;
template<class S>
struct RoundEven
{
  typedef S source_type ;
  typedef typename mpl::if_< is_arithmetic<S>,S,S const&>::type argument_type ;
  static source_type nearbyint ( argument_type s )
  {
    using std::floor ;
    using std::ceil ;
    S prev = floor(s);
    S next = ceil(s);
    S rt = (s - prev) - (next - s);
    S const zero(0.0);
    S const two(2.0);
    if ( rt < zero )
      return prev;
    else if ( rt > zero )
      return next;
    else
    {
      bool is_prev_even = two * floor(prev / two) == prev ;
      return ( is_prev_even ? prev : next ) ;
    }
  }
  typedef mpl::integral_c< std::float_round_style, std::round_to_nearest> round_style ;
} ;
enum range_check_result
{
  cInRange = 0 ,
  cNegOverflow = 1 ,
  cPosOverflow = 2
} ;
class bad_numeric_cast : public std::bad_cast
{
  public:
    virtual const char * what() const throw()
      { return "bad numeric conversion: overflow"; }
};
class negative_overflow : public bad_numeric_cast
{
  public:
    virtual const char * what() const throw()
      { return "bad numeric conversion: negative overflow"; }
};
class positive_overflow : public bad_numeric_cast
{
  public:
    virtual const char * what() const throw()
      { return "bad numeric conversion: positive overflow"; }
};
struct def_overflow_handler
{
  void operator() ( range_check_result r )
  {
    if ( r == cNegOverflow )
      throw negative_overflow() ;
    else if ( r == cPosOverflow )
           throw positive_overflow() ;
  }
} ;
struct silent_overflow_handler
{
  void operator() ( range_check_result ) {}
} ;
template<class Traits>
struct raw_converter
{
  typedef typename Traits::result_type result_type ;
  typedef typename Traits::argument_type argument_type ;
  static result_type low_level_convert ( argument_type s ) { return static_cast<result_type>(s) ; }
} ;
struct UseInternalRangeChecker {} ;
} }
namespace boost { namespace numeric { namespace boundsdetail
{
  template<class N>
  class Integral
  {
      typedef std::numeric_limits<N> limits ;
    public :
      static N lowest () { return limits::min (); }
      static N highest () { return limits::max (); }
      static N smallest() { return static_cast<N>(1); }
  } ;
  template<class N>
  class Float
  {
      typedef std::numeric_limits<N> limits ;
    public :
      static N lowest () { return static_cast<N>(-limits::max ()) ; }
      static N highest () { return limits::max (); }
      static N smallest() { return limits::min (); }
  } ;
  template<class N>
  struct get_impl
  {
    typedef mpl::bool_< ::std::numeric_limits<N>::is_integer > is_int ;
    typedef Integral<N> impl_int ;
    typedef Float <N> impl_float ;
    typedef typename mpl::if_<is_int,impl_int,impl_float>::type type ;
  } ;
} } }
namespace boost { namespace numeric
{
template<class N>
struct bounds : boundsdetail::get_impl<N>::type
{} ;
} }
namespace boost { namespace numeric { namespace convdetail
{
  typedef mpl::integral_c<std::float_round_style, std::round_toward_zero> round2zero_c ;
  typedef mpl::integral_c<std::float_round_style, std::round_to_nearest> round2nearest_c ;
  typedef mpl::integral_c<std::float_round_style, std::round_toward_infinity> round2inf_c ;
  typedef mpl::integral_c<std::float_round_style, std::round_toward_neg_infinity> round2neg_inf_c ;
  template<class RoundStyle,class RoundToZero,class RoundToNearest,class RoundToInf,class RoundToNegInf>
  struct for_round_style
  {
    typedef ct_switch4<RoundStyle
                       , round2zero_c, round2nearest_c, round2inf_c
                       , RoundToZero , RoundToNearest , RoundToInf , RoundToNegInf
                      > selector ;
    typedef typename selector::type type ;
  } ;
  struct non_applicable { typedef mpl::false_ do_apply ; } ;
  struct applicable { typedef mpl::true_ do_apply ; } ;
    template<class Traits>
    struct LT_LoT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;
      static range_check_result apply ( argument_type s )
      {
        return s < static_cast<S>(bounds<T>::lowest()) ? cNegOverflow : cInRange ;
      }
    } ;
    template<class Traits>
    struct LT_Zero : applicable
    {
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;
      static range_check_result apply ( argument_type s )
      {
        return s < static_cast<S>(0) ? cNegOverflow : cInRange ;
      }
    } ;
    template<class Traits>
    struct LE_PrevLoT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;
      static range_check_result apply ( argument_type s )
      {
        return s <= static_cast<S>(bounds<T>::lowest()) - static_cast<S>(1.0)
                 ? cNegOverflow : cInRange ;
      }
    } ;
    template<class Traits>
    struct LT_HalfPrevLoT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;
      static range_check_result apply ( argument_type s )
      {
        return s < static_cast<S>(bounds<T>::lowest()) - static_cast<S>(0.5)
                 ? cNegOverflow : cInRange ;
      }
    } ;
    template<class Traits>
    struct GT_HiT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;
      static range_check_result apply ( argument_type s )
      {
        return s > static_cast<S>(bounds<T>::highest())
                 ? cPosOverflow : cInRange ;
      }
    } ;
    template<class Traits>
    struct GE_SuccHiT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;
      static range_check_result apply ( argument_type s )
      {
        return s >= static_cast<S>(bounds<T>::highest()) + static_cast<S>(1.0)
                 ? cPosOverflow : cInRange ;
      }
    } ;
    template<class Traits>
    struct GT_HalfSuccHiT : applicable
    {
      typedef typename Traits::target_type T ;
      typedef typename Traits::source_type S ;
      typedef typename Traits::argument_type argument_type ;
      static range_check_result apply ( argument_type s )
      {
        return s >= static_cast<S>(bounds<T>::highest()) + static_cast<S>(0.5)
                 ? cPosOverflow : cInRange ;
      }
    } ;
    template<class PredA, class PredB>
    struct applyBoth
    {
      typedef typename PredA::argument_type argument_type ;
      static range_check_result apply ( argument_type s )
      {
        range_check_result r = PredA::apply(s) ;
        if ( r == cInRange )
          r = PredB::apply(s);
        return r ;
      }
    } ;
    template<class PredA, class PredB>
    struct combine
    {
      typedef applyBoth<PredA,PredB> Both ;
      typedef void NNone ;
      typedef typename PredA::do_apply do_applyA ;
      typedef typename PredB::do_apply do_applyB ;
      typedef typename for_both<do_applyA, do_applyB, Both, PredA, PredB, NNone>::type type ;
    } ;
  template<class Traits>
  struct dummy_range_checker
  {
    typedef typename Traits::argument_type argument_type ;
    static range_check_result out_of_range ( argument_type ) { return cInRange ; }
    static void validate_range ( argument_type ) {}
  } ;
  template<class Traits, class IsNegOverflow, class IsPosOverflow, class OverflowHandler>
  struct generic_range_checker
  {
    typedef OverflowHandler overflow_handler ;
    typedef typename Traits::argument_type argument_type ;
    static range_check_result out_of_range ( argument_type s )
    {
      typedef typename combine<IsNegOverflow,IsPosOverflow>::type Predicate ;
      return Predicate::apply(s);
    }
    static void validate_range ( argument_type s )
      { OverflowHandler()( out_of_range(s) ) ; }
  } ;
  template<class Traits,class OverflowHandler>
  struct GetRC_Sig2Sig_or_Unsig2Unsig
  {
    typedef dummy_range_checker<Traits> Dummy ;
    typedef LT_LoT<Traits> Pred1 ;
    typedef GT_HiT<Traits> Pred2 ;
    typedef generic_range_checker<Traits,Pred1,Pred2,OverflowHandler> Normal ;
    typedef typename Traits::subranged subranged ;
    typedef typename mpl::if_<subranged,Normal,Dummy>::type type ;
  } ;
  template<class Traits, class OverflowHandler>
  struct GetRC_Sig2Unsig
  {
    typedef LT_Zero<Traits> Pred1 ;
    typedef GT_HiT <Traits> Pred2 ;
    typedef generic_range_checker<Traits,Pred1,Pred2,OverflowHandler> ChoiceA ;
    typedef generic_range_checker<Traits,Pred1,non_applicable,OverflowHandler> ChoiceB ;
    typedef typename Traits::target_type T ;
    typedef typename Traits::source_type S ;
    typedef typename subranged_Unsig2Sig<S,T>::type oposite_subranged ;
    typedef typename mpl::not_<oposite_subranged>::type positively_subranged ;
    typedef typename mpl::if_<positively_subranged,ChoiceA,ChoiceB>::type type ;
  } ;
  template<class Traits, class OverflowHandler>
  struct GetRC_Unsig2Sig
  {
    typedef GT_HiT<Traits> Pred1 ;
    typedef generic_range_checker<Traits,non_applicable,Pred1,OverflowHandler> type ;
  } ;
  template<class Traits,class OverflowHandler>
  struct GetRC_Int2Int
  {
    typedef GetRC_Sig2Sig_or_Unsig2Unsig<Traits,OverflowHandler> Sig2SigQ ;
    typedef GetRC_Sig2Unsig <Traits,OverflowHandler> Sig2UnsigQ ;
    typedef GetRC_Unsig2Sig <Traits,OverflowHandler> Unsig2SigQ ;
    typedef Sig2SigQ Unsig2UnsigQ ;
    typedef typename Traits::sign_mixture sign_mixture ;
    typedef typename
      for_sign_mixture<sign_mixture,Sig2SigQ,Sig2UnsigQ,Unsig2SigQ,Unsig2UnsigQ>::type
        selector ;
    typedef typename selector::type type ;
  } ;
  template<class Traits>
  struct GetRC_Int2Float
  {
    typedef dummy_range_checker<Traits> type ;
  } ;
  template<class Traits, class OverflowHandler, class Float2IntRounder>
  struct GetRC_Float2Int
  {
    typedef LE_PrevLoT <Traits> Pred1 ;
    typedef GE_SuccHiT <Traits> Pred2 ;
    typedef LT_HalfPrevLoT<Traits> Pred3 ;
    typedef GT_HalfSuccHiT<Traits> Pred4 ;
    typedef GT_HiT <Traits> Pred5 ;
    typedef LT_LoT <Traits> Pred6 ;
    typedef generic_range_checker<Traits,Pred1,Pred2,OverflowHandler> ToZero ;
    typedef generic_range_checker<Traits,Pred3,Pred4,OverflowHandler> ToNearest ;
    typedef generic_range_checker<Traits,Pred1,Pred5,OverflowHandler> ToInf ;
    typedef generic_range_checker<Traits,Pred6,Pred2,OverflowHandler> ToNegInf ;
    typedef typename Float2IntRounder::round_style round_style ;
    typedef typename for_round_style<round_style,ToZero,ToNearest,ToInf,ToNegInf>::type type ;
  } ;
  template<class Traits, class OverflowHandler>
  struct GetRC_Float2Float
  {
    typedef dummy_range_checker<Traits> Dummy ;
    typedef LT_LoT<Traits> Pred1 ;
    typedef GT_HiT<Traits> Pred2 ;
    typedef generic_range_checker<Traits,Pred1,Pred2,OverflowHandler> Normal ;
    typedef typename Traits::subranged subranged ;
    typedef typename mpl::if_<subranged,Normal,Dummy>::type type ;
  } ;
  template<class Traits, class OverflowHandler, class Float2IntRounder>
  struct GetRC_BuiltIn2BuiltIn
  {
    typedef GetRC_Int2Int<Traits,OverflowHandler> Int2IntQ ;
    typedef GetRC_Int2Float<Traits> Int2FloatQ ;
    typedef GetRC_Float2Int<Traits,OverflowHandler,Float2IntRounder> Float2IntQ ;
    typedef GetRC_Float2Float<Traits,OverflowHandler> Float2FloatQ ;
    typedef typename Traits::int_float_mixture int_float_mixture ;
    typedef typename for_int_float_mixture<int_float_mixture, Int2IntQ, Int2FloatQ, Float2IntQ, Float2FloatQ>::type selector ;
    typedef typename selector::type type ;
  } ;
  template<class Traits, class OverflowHandler, class Float2IntRounder>
  struct GetRC
  {
    typedef GetRC_BuiltIn2BuiltIn<Traits,OverflowHandler,Float2IntRounder> BuiltIn2BuiltInQ ;
    typedef dummy_range_checker<Traits> Dummy ;
    typedef mpl::identity<Dummy> DummyQ ;
    typedef typename Traits::udt_builtin_mixture udt_builtin_mixture ;
    typedef typename for_udt_builtin_mixture<udt_builtin_mixture,BuiltIn2BuiltInQ,DummyQ,DummyQ,DummyQ>::type selector ;
    typedef typename selector::type type ;
  } ;
  template<class Traits>
  struct trivial_converter_impl : public std::unary_function< typename Traits::argument_type
                                                              ,typename Traits::result_type
                                                            >
                                 ,public dummy_range_checker<Traits>
  {
    typedef Traits traits ;
    typedef typename Traits::source_type source_type ;
    typedef typename Traits::argument_type argument_type ;
    typedef typename Traits::result_type result_type ;
    static result_type low_level_convert ( argument_type s ) { return s ; }
    static source_type nearbyint ( argument_type s ) { return s ; }
    static result_type convert ( argument_type s ) { return s ; }
  } ;
  template<class Traits,class RangeChecker,class RawConverter,class Float2IntRounder>
  struct rounding_converter : public std::unary_function< typename Traits::argument_type
                                                          ,typename Traits::result_type
                                                        >
                             ,public RangeChecker
                             ,public Float2IntRounder
                             ,public RawConverter
  {
    typedef RangeChecker RangeCheckerBase ;
    typedef Float2IntRounder Float2IntRounderBase ;
    typedef RawConverter RawConverterBase ;
    typedef Traits traits ;
    typedef typename Traits::source_type source_type ;
    typedef typename Traits::argument_type argument_type ;
    typedef typename Traits::result_type result_type ;
    static result_type convert ( argument_type s )
    {
      RangeCheckerBase::validate_range(s);
      source_type s1 = Float2IntRounderBase::nearbyint(s);
      return RawConverterBase::low_level_convert(s1);
    }
  } ;
  template<class Traits,class RangeChecker,class RawConverter>
  struct non_rounding_converter : public std::unary_function< typename Traits::argument_type
                                                             ,typename Traits::result_type
                                                           >
                                 ,public RangeChecker
                                 ,public RawConverter
  {
    typedef RangeChecker RangeCheckerBase ;
    typedef RawConverter RawConverterBase ;
    typedef Traits traits ;
    typedef typename Traits::source_type source_type ;
    typedef typename Traits::argument_type argument_type ;
    typedef typename Traits::result_type result_type ;
    static source_type nearbyint ( argument_type s ) { return s ; }
    static result_type convert ( argument_type s )
    {
      RangeCheckerBase::validate_range(s);
      return RawConverterBase::low_level_convert(s);
    }
  } ;
  template<class Traits,class OverflowHandler,class Float2IntRounder,class RawConverter, class UserRangeChecker>
  struct get_non_trivial_converter
  {
    typedef GetRC<Traits,OverflowHandler,Float2IntRounder> InternalRangeCheckerQ ;
    typedef is_same<UserRangeChecker,UseInternalRangeChecker> use_internal_RC ;
    typedef mpl::identity<UserRangeChecker> UserRangeCheckerQ ;
    typedef typename
      mpl::eval_if<use_internal_RC,InternalRangeCheckerQ,UserRangeCheckerQ>::type
        RangeChecker ;
    typedef non_rounding_converter<Traits,RangeChecker,RawConverter> NonRounding ;
    typedef rounding_converter<Traits,RangeChecker,RawConverter,Float2IntRounder> Rounding ;
    typedef mpl::identity<NonRounding> NonRoundingQ ;
    typedef mpl::identity<Rounding> RoundingQ ;
    typedef typename Traits::int_float_mixture int_float_mixture ;
    typedef typename
      for_int_float_mixture<int_float_mixture, NonRoundingQ, NonRoundingQ, RoundingQ, NonRoundingQ>::type
        selector ;
    typedef typename selector::type type ;
  } ;
  template< class Traits
           ,class OverflowHandler
           ,class Float2IntRounder
           ,class RawConverter
           ,class UserRangeChecker
          >
  struct get_converter_impl
  {
    typedef trivial_converter_impl<Traits> Trivial ;
    typedef mpl::identity <Trivial> TrivialQ ;
    typedef get_non_trivial_converter< Traits
                                      ,OverflowHandler
                                      ,Float2IntRounder
                                      ,RawConverter
                                      ,UserRangeChecker
                                     > NonTrivialQ ;
    typedef typename Traits::trivial trivial ;
    typedef typename mpl::eval_if<trivial,TrivialQ,NonTrivialQ>::type type ;
  } ;
} } }
namespace boost { namespace numeric
{
template<class T,
         class S,
         class Traits = conversion_traits<T,S>,
         class OverflowHandler = def_overflow_handler,
         class Float2IntRounder = Trunc< typename Traits::source_type> ,
         class RawConverter = raw_converter<Traits>,
         class UserRangeChecker = UseInternalRangeChecker
        >
struct converter : convdetail::get_converter_impl<Traits,
                                                  OverflowHandler,
                                                  Float2IntRounder,
                                                  RawConverter,
                                                  UserRangeChecker
                                                 >::type
{
  typedef Traits traits ;
  typedef typename Traits::argument_type argument_type ;
  typedef typename Traits::result_type result_type ;
  result_type operator() ( argument_type s ) const { return this->convert(s) ; }
} ;
template<class S,
         class OverflowHandler = def_overflow_handler,
         class Float2IntRounder = Trunc<S> ,
         class UserRangeChecker = UseInternalRangeChecker
        >
struct make_converter_from
{
  template<class T,
           class Traits = conversion_traits<T,S>,
           class RawConverter = raw_converter<Traits>
          >
  struct to
  {
    typedef converter<T,S,Traits,OverflowHandler,Float2IntRounder,RawConverter,UserRangeChecker> type ;
  } ;
} ;
} }
namespace boost
{
  template<typename Target, typename Source>
  inline
  Target numeric_cast ( Source arg )
  {
    typedef boost::numeric::converter<Target,Source> Converter ;
    return Converter::convert(arg);
  }
  using numeric::bad_numeric_cast;
}
namespace boost {
namespace detail{
template <class T>
struct is_signed_values
{
   typedef typename remove_cv<T>::type no_cv_t;
   static const no_cv_t minus_one = (static_cast<no_cv_t>(-1));
   static const no_cv_t zero = (static_cast<no_cv_t>(0));
};
template <class T>
struct is_signed_helper
{
   typedef typename remove_cv<T>::type no_cv_t;
   static const bool value = (!(::boost::detail::is_signed_values<T>::minus_one > boost::detail::is_signed_values<T>::zero));
};
template <bool integral_type>
struct is_signed_select_helper
{
   template <class T>
   struct rebind
   {
      typedef is_signed_helper<T> type;
   };
};
template <>
struct is_signed_select_helper<false>
{
   template <class T>
   struct rebind
   {
      typedef false_type type;
   };
};
template <class T>
struct is_signed_imp
{
   typedef is_signed_select_helper<
      ::boost::type_traits::ice_or<
         ::boost::is_integral<T>::value,
         ::boost::is_enum<T>::value>::value
   > selector;
   typedef typename selector::template rebind<T> binder;
   typedef typename binder::type type;
   static const bool value = type::value;
};
}
template< typename T > struct is_signed : public ::boost::integral_constant<bool,::boost::detail::is_signed_imp<T>::value> { public: };
}
namespace boost {
namespace detail{
template <class T>
struct is_unsigned_values
{
   typedef typename remove_cv<T>::type no_cv_t;
   static const no_cv_t minus_one = (static_cast<no_cv_t>(-1));
   static const no_cv_t zero = (static_cast<no_cv_t>(0));
};
template <class T>
struct is_ununsigned_helper
{
   static const bool value = (::boost::detail::is_unsigned_values<T>::minus_one > ::boost::detail::is_unsigned_values<T>::zero);
};
template <bool integral_type>
struct is_ununsigned_select_helper
{
   template <class T>
   struct rebind
   {
      typedef is_ununsigned_helper<T> type;
   };
};
template <>
struct is_ununsigned_select_helper<false>
{
   template <class T>
   struct rebind
   {
      typedef false_type type;
   };
};
template <class T>
struct is_unsigned_imp
{
   typedef is_ununsigned_select_helper<
      ::boost::type_traits::ice_or<
         ::boost::is_integral<T>::value,
         ::boost::is_enum<T>::value>::value
   > selector;
   typedef typename selector::template rebind<T> binder;
   typedef typename binder::type type;
   static const bool value = type::value;
};
}
template< typename T > struct is_unsigned : public ::boost::integral_constant<bool,::boost::detail::is_unsigned_imp<T>::value> { public: };
}
namespace boost {
namespace detail {
template <class T>
struct make_unsigned_imp
{
   static_assert((::boost::type_traits::ice_or< ::boost::is_integral<T>::value, ::boost::is_enum<T>::value>::value), "(::boost::type_traits::ice_or< ::boost::is_integral<T>::value, ::boost::is_enum<T>::value>::value)");
   static_assert((::boost::type_traits::ice_not< ::boost::is_same< typename remove_cv<T>::type, bool>::value>::value), "(::boost::type_traits::ice_not< ::boost::is_same< typename remove_cv<T>::type, bool>::value>::value)");
   typedef typename remove_cv<T>::type t_no_cv;
   typedef typename mpl::if_c<
      (::boost::type_traits::ice_and<
         ::boost::is_unsigned<T>::value,
         ::boost::is_integral<T>::value,
         ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, char>::value>::value,
         ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, wchar_t>::value>::value,
         ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, bool>::value>::value >::value),
      T,
      typename mpl::if_c<
         (::boost::type_traits::ice_and<
            ::boost::is_integral<T>::value,
            ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, char>::value>::value,
            ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, wchar_t>::value>::value,
            ::boost::type_traits::ice_not< ::boost::is_same<t_no_cv, bool>::value>::value>
         ::value),
         typename mpl::if_<
            is_same<t_no_cv, signed char>,
            unsigned char,
            typename mpl::if_<
               is_same<t_no_cv, short>,
               unsigned short,
               typename mpl::if_<
                  is_same<t_no_cv, int>,
                  unsigned int,
                  typename mpl::if_<
                     is_same<t_no_cv, long>,
                     unsigned long,
                     boost::ulong_long_type
                  >::type
               >::type
            >::type
         >::type,
         typename mpl::if_c<
            sizeof(t_no_cv) == sizeof(unsigned char),
            unsigned char,
            typename mpl::if_c<
               sizeof(t_no_cv) == sizeof(unsigned short),
               unsigned short,
               typename mpl::if_c<
                  sizeof(t_no_cv) == sizeof(unsigned int),
                  unsigned int,
                  typename mpl::if_c<
                     sizeof(t_no_cv) == sizeof(unsigned long),
                     unsigned long,
                     boost::ulong_long_type
                  >::type
               >::type
            >::type
         >::type
      >::type
   >::type base_integer_type;
   typedef typename mpl::if_<
      is_const<T>,
      typename add_const<base_integer_type>::type,
      base_integer_type
   >::type const_base_integer_type;
   typedef typename mpl::if_<
      is_volatile<T>,
      typename add_volatile<const_base_integer_type>::type,
      const_base_integer_type
   >::type type;
};
}
template< typename T > struct make_unsigned { public: typedef typename boost::detail::make_unsigned_imp<T>::type type; };
}
       
namespace boost{
namespace detail{
template <typename T, bool small_>
struct ct_imp2
{
   typedef const T& param_type;
};
template <typename T>
struct ct_imp2<T, true>
{
   typedef const T param_type;
};
template <typename T, bool isp, bool b1>
struct ct_imp
{
   typedef const T& param_type;
};
template <typename T, bool isp>
struct ct_imp<T, isp, true>
{
   typedef typename ct_imp2<T, sizeof(T) <= sizeof(void*)>::param_type param_type;
};
template <typename T, bool b1>
struct ct_imp<T, true, b1>
{
   typedef const T param_type;
};
}
template <typename T>
struct call_traits
{
public:
   typedef T value_type;
   typedef T& reference;
   typedef const T& const_reference;
   typedef typename boost::detail::ct_imp<
      T,
      ::boost::is_pointer<T>::value,
      ::boost::is_arithmetic<T>::value
   >::param_type param_type;
};
template <typename T>
struct call_traits<T&>
{
   typedef T& value_type;
   typedef T& reference;
   typedef const T& const_reference;
   typedef T& param_type;
};
template <typename T, std::size_t N>
struct call_traits<T [N]>
{
private:
   typedef T array_type[N];
public:
   typedef const T* value_type;
   typedef array_type& reference;
   typedef const array_type& const_reference;
   typedef const T* const param_type;
};
template <typename T, std::size_t N>
struct call_traits<const T [N]>
{
private:
   typedef const T array_type[N];
public:
   typedef const T* value_type;
   typedef array_type& reference;
   typedef const array_type& const_reference;
   typedef const T* const param_type;
};
}
       
       
namespace boost {
template<class T>
class integer_traits : public std::numeric_limits<T>
{
public:
  static const bool is_integral = false;
};
namespace detail {
template<class T, T min_val, T max_val>
class integer_traits_base
{
public:
  static const bool is_integral = true;
  static const T const_min = min_val;
  static const T const_max = max_val;
};
template<class T, T min_val, T max_val>
const bool integer_traits_base<T, min_val, max_val>::is_integral;
template<class T, T min_val, T max_val>
const T integer_traits_base<T, min_val, max_val>::const_min;
template<class T, T min_val, T max_val>
const T integer_traits_base<T, min_val, max_val>::const_max;
}
template<>
class integer_traits<bool>
  : public std::numeric_limits<bool>,
    public detail::integer_traits_base<bool, false, true>
{ };
template<>
class integer_traits<char>
  : public std::numeric_limits<char>,
    public detail::integer_traits_base<char, (-127 - 1), 127>
{ };
template<>
class integer_traits<signed char>
  : public std::numeric_limits<signed char>,
    public detail::integer_traits_base<signed char, (-127 - 1), 127>
{ };
template<>
class integer_traits<unsigned char>
  : public std::numeric_limits<unsigned char>,
    public detail::integer_traits_base<unsigned char, 0, (127 * 2 + 1)>
{ };
template<>
class integer_traits<wchar_t>
  : public std::numeric_limits<wchar_t>,
    public detail::integer_traits_base<wchar_t, (-2147483647 - 1), 2147483647>
{ };
template<>
class integer_traits<short>
  : public std::numeric_limits<short>,
    public detail::integer_traits_base<short, (-32767 - 1), 32767>
{ };
template<>
class integer_traits<unsigned short>
  : public std::numeric_limits<unsigned short>,
    public detail::integer_traits_base<unsigned short, 0, (32767 * 2 + 1)>
{ };
template<>
class integer_traits<int>
  : public std::numeric_limits<int>,
    public detail::integer_traits_base<int, (-2147483647 - 1), 2147483647>
{ };
template<>
class integer_traits<unsigned int>
  : public std::numeric_limits<unsigned int>,
    public detail::integer_traits_base<unsigned int, 0, (2147483647 * 2U + 1U)>
{ };
template<>
class integer_traits<long>
  : public std::numeric_limits<long>,
    public detail::integer_traits_base<long, (-9223372036854775807L - 1L), 9223372036854775807L>
{ };
template<>
class integer_traits<unsigned long>
  : public std::numeric_limits<unsigned long>,
    public detail::integer_traits_base<unsigned long, 0, (9223372036854775807L * 2UL + 1UL)>
{ };
template<>
class integer_traits< ::boost::long_long_type>
  : public std::numeric_limits< ::boost::long_long_type>,
    public detail::integer_traits_base< ::boost::long_long_type, (-0x7fffffffffffffffLL-1), 0x7fffffffffffffffLL>
{ };
template<>
class integer_traits< ::boost::ulong_long_type>
  : public std::numeric_limits< ::boost::ulong_long_type>,
    public detail::integer_traits_base< ::boost::ulong_long_type, 0, 0xffffffffffffffffULL>
{ };
}
namespace boost { namespace detail {
class lcast_abstract_stub {};
template<class T>
struct lcast_precision
{
    typedef typename boost::mpl::if_<
        boost::is_abstract<T>
      , std::numeric_limits<lcast_abstract_stub>
      , std::numeric_limits<T>
      >::type limits;
    static const bool use_default_precision = !limits::is_specialized || limits::is_exact;
    static const bool is_specialized_bin = !use_default_precision && limits::radix == 2 && limits::digits > 0;
    static const bool is_specialized_dec = !use_default_precision && limits::radix == 10 && limits::digits10 > 0;
    static const std::streamsize streamsize_max = boost::integer_traits<std::streamsize>::const_max;
    static const unsigned int precision_dec = limits::digits10 + 1U;
    static_assert(!is_specialized_dec || precision_dec <= streamsize_max + 0UL, "!is_specialized_dec || precision_dec <= streamsize_max + 0UL");
    static const unsigned long precision_bin = 2UL + limits::digits * 30103UL / 100000UL;
    static_assert(!is_specialized_bin || (limits::digits + 0UL < (9223372036854775807L * 2UL + 1UL) / 30103UL && precision_bin > limits::digits10 + 0UL && precision_bin <= streamsize_max + 0UL), "!is_specialized_bin || (limits::digits + 0UL < ULONG_MAX / 30103UL && precision_bin > limits::digits10 + 0UL && precision_bin <= streamsize_max + 0UL)");
    static const std::streamsize value = is_specialized_bin ? precision_bin : is_specialized_dec ? precision_dec : 6;
};
template<class T>
inline std::streamsize lcast_get_precision(T* = 0)
{
    return lcast_precision<T>::value;
}
template<class T>
inline void lcast_set_precision(std::ios_base& stream, T*)
{
    stream.precision(lcast_get_precision<T>());
}
template<class Source, class Target>
inline void lcast_set_precision(std::ios_base& stream, Source*, Target*)
{
    std::streamsize const s = lcast_get_precision(static_cast<Source*>(0));
    std::streamsize const t = lcast_get_precision(static_cast<Target*>(0));
    stream.precision(s > t ? s : t);
}
}}
namespace boost
{
    class bad_lexical_cast :
        public std::bad_cast
    {
    public:
        bad_lexical_cast() :
          source(&typeid(void)), target(&typeid(void))
        {
        }
        bad_lexical_cast(
            const std::type_info &source_type_arg,
            const std::type_info &target_type_arg) :
            source(&source_type_arg), target(&target_type_arg)
        {
        }
        const std::type_info &source_type() const
        {
            return *source;
        }
        const std::type_info &target_type() const
        {
            return *target;
        }
        virtual const char *what() const throw()
        {
            return "bad lexical cast: "
                   "source type value could not be interpreted as target";
        }
        virtual ~bad_lexical_cast() throw()
        {
        }
    private:
        const std::type_info *source;
        const std::type_info *target;
    };
    namespace detail
    {
        template<typename Type>
        struct stream_char
        {
            typedef char type;
        };
        template<class CharT, class Traits, class Alloc>
        struct stream_char< std::basic_string<CharT,Traits,Alloc> >
        {
            typedef CharT type;
        };
        template<>
        struct stream_char<wchar_t>
        {
            typedef wchar_t type;
        };
        template<>
        struct stream_char<wchar_t *>
        {
            typedef wchar_t type;
        };
        template<>
        struct stream_char<const wchar_t *>
        {
            typedef wchar_t type;
        };
        template<typename TargetChar, typename SourceChar>
        struct widest_char
        {
            typedef TargetChar type;
        };
        template<>
        struct widest_char<char, wchar_t>
        {
            typedef wchar_t type;
        };
    }
    namespace detail
    {
        template<class CharT, class Target, class Source>
        struct deduce_char_traits
        {
            typedef std::char_traits<CharT> type;
        };
        template<class CharT, class Traits, class Alloc, class Source>
        struct deduce_char_traits< CharT
                                 , std::basic_string<CharT,Traits,Alloc>
                                 , Source
                                 >
        {
            typedef Traits type;
        };
        template<class CharT, class Target, class Traits, class Alloc>
        struct deduce_char_traits< CharT
                                 , Target
                                 , std::basic_string<CharT,Traits,Alloc>
                                 >
        {
            typedef Traits type;
        };
        template<class CharT, class Traits, class Alloc1, class Alloc2>
        struct deduce_char_traits< CharT
                                 , std::basic_string<CharT,Traits,Alloc1>
                                 , std::basic_string<CharT,Traits,Alloc2>
                                 >
        {
            typedef Traits type;
        };
    }
    namespace detail
    {
        template< class CharT
                , class Source
                >
        struct lcast_src_length
        {
            static const std::size_t value = 0;
            static void check_coverage() {}
        };
        template<>
        struct lcast_src_length<char, bool>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
        template<>
        struct lcast_src_length<char, char>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
        template<>
        struct lcast_src_length<char, signed char>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
        template<>
        struct lcast_src_length<char, unsigned char>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
        template<>
        struct lcast_src_length<char, signed char*>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
        template<>
        struct lcast_src_length<char, unsigned char*>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
        template<>
        struct lcast_src_length<char, signed char const*>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
        template<>
        struct lcast_src_length<char, unsigned char const*>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
        template<>
        struct lcast_src_length<wchar_t, bool>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
        template<>
        struct lcast_src_length<wchar_t, char>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
        template<>
        struct lcast_src_length<wchar_t, wchar_t>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
        template<>
        struct lcast_src_length<char, char const*>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
        template<>
        struct lcast_src_length<char, char*>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
        template<>
        struct lcast_src_length<wchar_t, wchar_t const*>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
        template<>
        struct lcast_src_length<wchar_t, wchar_t*>
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
        template<class CharT, class Traits, class Alloc>
        struct lcast_src_length< CharT, std::basic_string<CharT,Traits,Alloc> >
        {
            static const std::size_t value = 1;
            static void check_coverage() {}
        };
        template<class Source>
        struct lcast_src_length_integral
        {
            static const std::size_t value = std::numeric_limits<Source>::is_signed + std::numeric_limits<Source>::is_specialized + std::numeric_limits<Source>::digits10 * 2;
        };
        template<> struct lcast_src_length<char, short> : lcast_src_length_integral<short> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, short> : lcast_src_length_integral<short> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, unsigned short> : lcast_src_length_integral<unsigned short> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, unsigned short> : lcast_src_length_integral<unsigned short> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, int> : lcast_src_length_integral<int> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, int> : lcast_src_length_integral<int> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, unsigned int> : lcast_src_length_integral<unsigned int> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, unsigned int> : lcast_src_length_integral<unsigned int> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, long> : lcast_src_length_integral<long> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, long> : lcast_src_length_integral<long> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, unsigned long> : lcast_src_length_integral<unsigned long> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, unsigned long> : lcast_src_length_integral<unsigned long> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, boost::ulong_long_type> : lcast_src_length_integral<boost::ulong_long_type> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, boost::ulong_long_type> : lcast_src_length_integral<boost::ulong_long_type> { static void check_coverage() {} };
        template<> struct lcast_src_length<char, boost::long_long_type> : lcast_src_length_integral<boost::long_long_type> { static void check_coverage() {} }; template<> struct lcast_src_length<wchar_t, boost::long_long_type> : lcast_src_length_integral<boost::long_long_type> { static void check_coverage() {} };
        template<class Source>
        struct lcast_src_length_floating
        {
            static_assert(std::numeric_limits<Source>::max_exponent10 <= 999999L && std::numeric_limits<Source>::min_exponent10 >= -999999L, "std::numeric_limits<Source>::max_exponent10 <= 999999L && std::numeric_limits<Source>::min_exponent10 >= -999999L");
            static const std::size_t value = 5 + lcast_precision<Source>::value + 6;
        };
        template<>
        struct lcast_src_length<char,float>
          : lcast_src_length_floating<float>
        {
            static void check_coverage() {}
        };
        template<>
        struct lcast_src_length<char,double>
          : lcast_src_length_floating<double>
        {
            static void check_coverage() {}
        };
        template<>
        struct lcast_src_length<char,long double>
          : lcast_src_length_floating<long double>
        {
            static void check_coverage() {}
        };
    template<>
    struct lcast_src_length<wchar_t,float>
      : lcast_src_length_floating<float>
    {
        static void check_coverage() {}
    };
    template<>
    struct lcast_src_length<wchar_t,double>
      : lcast_src_length_floating<double>
    {
        static void check_coverage() {}
    };
    template<>
    struct lcast_src_length<wchar_t,long double>
      : lcast_src_length_floating<long double>
    {
        static void check_coverage() {}
    };
    }
    namespace detail
    {
        template<typename CharT> struct lcast_char_constants;
        template<>
        struct lcast_char_constants<char>
        {
            static const char zero = '0';
            static const char minus = '-';
            static const char plus = '+';
        };
        template<>
        struct lcast_char_constants<wchar_t>
        {
            static const wchar_t zero = L'0';
            static const wchar_t minus = L'-';
            static const wchar_t plus = L'+';
        };
    }
    namespace detail
    {
        struct lexical_streambuf_fake
        {
        };
    }
    namespace detail
    {
        template<class T>
        inline
        typename make_unsigned<T>::type lcast_to_unsigned(T value)
        {
            typedef typename make_unsigned<T>::type result_type;
            result_type uvalue = static_cast<result_type>(value);
            return value < 0 ? -uvalue : uvalue;
        }
    }
    namespace detail
    {
        template<class Traits, class T, class CharT>
        CharT* lcast_put_unsigned(T n, CharT* finish)
        {
            static_assert(!std::numeric_limits<T>::is_signed, "!std::numeric_limits<T>::is_signed");
            typedef typename Traits::int_type int_type;
            CharT const czero = lcast_char_constants<CharT>::zero;
            int_type const zero = Traits::to_int_type(czero);
            std::locale loc;
            typedef std::numpunct<CharT> numpunct;
            numpunct const& np = std::use_facet< numpunct >(loc);
            std::string const& grouping = np.grouping();
            std::string::size_type const grouping_size = grouping.size();
            if ( grouping_size && grouping[0] > 0 )
            {
            static_assert(std::numeric_limits<T>::digits10 < 127, "std::numeric_limits<T>::digits10 < CHAR_MAX");
                CharT thousands_sep = np.thousands_sep();
                std::string::size_type group = 0;
                char last_grp_size = grouping[0];
                char left = last_grp_size;
                do
                {
                    if(left == 0)
                    {
                        ++group;
                        if(group < grouping_size)
                        {
                            char const grp_size = grouping[group];
                            last_grp_size = grp_size <= 0 ? 127 : grp_size;
                        }
                        left = last_grp_size;
                        --finish;
                        Traits::assign(*finish, thousands_sep);
                    }
                    --left;
                    --finish;
                    int_type const digit = static_cast<int_type>(n % 10U);
                    Traits::assign(*finish, Traits::to_char_type(zero + digit));
                    n /= 10;
                } while(n);
            } else
            {
                do
                {
                    --finish;
                    int_type const digit = static_cast<int_type>(n % 10U);
                    Traits::assign(*finish, Traits::to_char_type(zero + digit));
                    n /= 10;
                } while(n);
            }
            return finish;
        }
    }
    namespace detail
    {
        template<class Traits, class T, class CharT>
        inline bool lcast_ret_unsigned(T& value, const CharT* const begin, const CharT* end)
        {
            static_assert(!std::numeric_limits<T>::is_signed, "!std::numeric_limits<T>::is_signed");
            typedef typename Traits::int_type int_type;
            CharT const czero = lcast_char_constants<CharT>::zero;
            --end;
            value = 0;
            if ( *end < czero || *end >= czero + 10 || begin > end)
                return false;
            value = *end - czero;
            --end;
            T multiplier = 1;
            std::locale loc;
            typedef std::numpunct<CharT> numpunct;
            numpunct const& np = std::use_facet< numpunct >(loc);
            std::string const& grouping = np.grouping();
            std::string::size_type const grouping_size = grouping.size();
            if (grouping_size && grouping[0] > 0)
            {
                unsigned char current_grouping = 0;
                CharT const thousands_sep = np.thousands_sep();
                char remained = grouping[current_grouping] - 1;
                bool shall_we_return = true;
                for(;end>=begin; --end)
                {
                    if (remained) {
                        T const new_sub_value = multiplier * 10 * (*end - czero);
                        if (*end < czero || *end >= czero + 10
                                || new_sub_value/10 != multiplier * (*end - czero)
                                || static_cast<T>((std::numeric_limits<T>::max)()-new_sub_value) < value
                                )
                            return false;
                        value += new_sub_value;
                        multiplier *= 10;
                        --remained;
                    } else {
                        if ( !Traits::eq(*end, thousands_sep) )
                        {
                            shall_we_return = false;
                            break;
                        } else {
                            if ( begin == end ) return false;
                            if (current_grouping < grouping_size-1 ) ++current_grouping;
                            remained = grouping[current_grouping];
                        }
                    }
                }
                if (shall_we_return) return true;
            }
            {
                while ( begin <= end )
                {
                    T const new_sub_value = multiplier * 10 * (*end - czero);
                    if (*end < czero || *end >= czero + 10
                            || new_sub_value/10 != multiplier * (*end - czero)
                            || static_cast<T>((std::numeric_limits<T>::max)()-new_sub_value) < value
                            )
                        return false;
                    value += new_sub_value;
                    multiplier *= 10;
                    --end;
                }
            }
            return true;
        }
    }
    namespace detail
    {
        template<typename Target, typename Source, typename Traits>
        class lexical_stream
        {
        private:
            typedef typename widest_char<
                typename stream_char<Target>::type,
                typename stream_char<Source>::type>::type char_type;
            typedef Traits traits_type;
        public:
            lexical_stream(char_type* = 0, char_type* = 0)
            {
                stream.unsetf(std::ios::skipws);
                lcast_set_precision(stream, static_cast<Source*>(0), static_cast<Target*>(0) );
            }
            ~lexical_stream()
            {
            }
            bool operator<<(const Source &input)
            {
                return !(stream << input).fail();
            }
            template<typename InputStreamable>
            bool operator>>(InputStreamable &output)
            {
                return !is_pointer<InputStreamable>::value &&
                       stream >> output &&
                       stream.get() ==
                           traits_type::eof();
            }
            bool operator>>(std::basic_string<char_type,traits_type>& output)
            {
                stream.str().swap(output);
                return true;
            }
            template<class Alloc>
            bool operator>>(std::basic_string<char_type,traits_type,Alloc>& out)
            {
                std::basic_string<char_type,traits_type> str(stream.str());
                out.assign(str.begin(), str.end());
                return true;
            }
        private:
            std::basic_stringstream<char_type,traits_type> stream;
        };
    }
    namespace detail
    {
        template< class CharT
                , class Base
                , class Traits
                >
        class lexical_stream_limited_src : public Base
        {
            CharT* start;
            CharT* finish;
        private:
            static void widen_and_assign(char*p, char ch)
            {
                Traits::assign(*p, ch);
            }
            static void widen_and_assign(wchar_t* p, char ch)
            {
                std::locale loc;
                wchar_t w = std::use_facet< std::ctype<wchar_t> >(loc).widen(ch);
                Traits::assign(*p, w);
            }
            static void widen_and_assign(wchar_t* p, wchar_t ch)
            {
                Traits::assign(*p, ch);
            }
            static void widen_and_assign(char*, wchar_t ch);
            template<class OutputStreamable>
            bool lcast_put(const OutputStreamable& input)
            {
                this->setp(start, finish);
                std::basic_ostream<CharT> stream(static_cast<Base*>(this));
                lcast_set_precision(stream, static_cast<OutputStreamable*>(0));
                bool const result = !(stream << input).fail();
                finish = this->pptr();
                return result;
            }
            lexical_stream_limited_src(lexical_stream_limited_src const&);
            void operator=(lexical_stream_limited_src const&);
        public:
            lexical_stream_limited_src(CharT* sta, CharT* fin)
              : start(sta)
              , finish(fin)
            {}
        public:
            template<class Alloc>
            bool operator<<(std::basic_string<CharT,Traits,Alloc> const& str)
            {
                start = const_cast<CharT*>(str.data());
                finish = start + str.length();
                return true;
            }
            bool operator<<(bool);
            bool operator<<(char);
            bool operator<<(unsigned char);
            bool operator<<(signed char);
            bool operator<<(wchar_t);
            bool operator<<(unsigned char const*);
            bool operator<<(signed char const*);
            bool operator<<(CharT const*);
            bool operator<<(short);
            bool operator<<(int);
            bool operator<<(long);
            bool operator<<(unsigned short);
            bool operator<<(unsigned int);
            bool operator<<(unsigned long);
            bool operator<<(boost::ulong_long_type);
            bool operator<<(boost::long_long_type );
            bool operator<<(float);
            bool operator<<(double);
            bool operator<<(long double);
        private:
            template <typename Type>
            bool input_operator_helper_unsigned(Type& output)
            {
                CharT const minus = lcast_char_constants<CharT>::minus;
                CharT const plus = lcast_char_constants<CharT>::plus;
                bool has_minus = false;
                if ( Traits::eq(minus,*start) )
                {
                    ++start;
                    has_minus = true;
                } else if ( Traits::eq( plus, *start ) )
                {
                    ++start;
                }
                bool const succeed = lcast_ret_unsigned<Traits>(output, start, finish);
                if (has_minus) output = static_cast<Type>(-output);
                return succeed;
            }
            template <typename Type>
            bool input_operator_helper_signed(Type& output)
            {
                CharT const minus = lcast_char_constants<CharT>::minus;
                CharT const plus = lcast_char_constants<CharT>::plus;
                typedef typename make_unsigned<Type>::type utype;
                utype out_tmp =0;
                bool has_minus = false;
                if ( Traits::eq(minus,*start) )
                {
                    ++start;
                    has_minus = true;
                } else if ( Traits::eq(plus, *start) )
                {
                    ++start;
                }
                bool succeed = lcast_ret_unsigned<Traits>(out_tmp, start, finish);
                if (has_minus) {
                    utype const comp_val = static_cast<utype>(-(std::numeric_limits<Type>::min)());
                    succeed = succeed && out_tmp<=comp_val;
                    output = -out_tmp;
                } else {
                    utype const comp_val = static_cast<utype>((std::numeric_limits<Type>::max)());
                    succeed = succeed && out_tmp<=comp_val;
                    output = out_tmp;
                }
                return succeed;
            }
        public:
            bool operator>>(unsigned short& output)
            {
                return input_operator_helper_unsigned(output);
            }
            bool operator>>(unsigned int& output)
            {
                return input_operator_helper_unsigned(output);
            }
            bool operator>>(unsigned long int& output)
            {
                return input_operator_helper_unsigned(output);
            }
            bool operator>>(short& output)
            {
                return input_operator_helper_signed(output);
            }
            bool operator>>(int& output)
            {
                return input_operator_helper_signed(output);
            }
            bool operator>>(long int& output)
            {
                return input_operator_helper_signed(output);
            }
            bool operator>>( boost::ulong_long_type& output)
            {
                return input_operator_helper_unsigned(output);
            }
            bool operator>>(boost::long_long_type& output)
            {
                return input_operator_helper_signed(output);
            }
            bool operator>>(bool& output)
            {
                CharT const zero = lcast_char_constants<CharT>::zero;
                CharT const plus = lcast_char_constants<CharT>::plus;
                CharT const minus = lcast_char_constants<CharT>::minus;
                switch(finish-start)
                {
                    case 1:
                        output = Traits::eq(start[0], zero+1);
                        return output || Traits::eq(start[0], zero );
                    case 2:
                        if ( Traits::eq( plus, *start) )
                        {
                            ++start;
                            output = Traits::eq(start[0], zero +1);
                            return output || Traits::eq(start[0], zero );
                        } else
                        {
                            output = false;
                            return Traits::eq( minus, *start)
                                && Traits::eq( zero, start[1]);
                        }
                    default:
                        output = false;
                        return false;
                }
            }
            template<typename InputStreamable>
            bool operator>>(InputStreamable& output)
            {
                if(is_pointer<InputStreamable>::value)
                    return false;
                this->setg(start, start, finish);
                std::basic_istream<CharT> stream(static_cast<Base*>(this));
                stream.unsetf(std::ios::skipws);
                lcast_set_precision(stream, static_cast<InputStreamable*>(0));
                return stream >> output &&
                    stream.get() ==
                Traits::eof();
            }
            bool operator>>(CharT&);
            bool operator>>(unsigned char&);
            bool operator>>(signed char&);
            template<class Alloc>
            bool operator>>(std::basic_string<CharT,Traits,Alloc>& str)
            {
                str.assign(start, finish);
                return true;
            }
        };
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                bool value)
        {
            typedef typename Traits::int_type int_type;
            CharT const czero = lcast_char_constants<CharT>::zero;
            int_type const zero = Traits::to_int_type(czero);
            Traits::assign(*start, Traits::to_char_type(zero + value));
            finish = start + 1;
            return true;
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                char ch)
        {
            widen_and_assign(start, ch);
            finish = start + 1;
            return true;
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
               unsigned char ch)
        {
            return ((*this) << static_cast<char>(ch));
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
               signed char ch)
        {
            return ((*this) << static_cast<char>(ch));
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
               unsigned char const* ch)
        {
            return ((*this) << reinterpret_cast<char const*>(ch));
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
               signed char const* ch)
        {
            return ((*this) << reinterpret_cast<char const*>(ch));
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                wchar_t ch)
        {
            widen_and_assign(start, ch);
            finish = start + 1;
            return true;
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                short n)
        {
            start = lcast_put_unsigned<Traits>(lcast_to_unsigned(n), finish);
            if(n < 0)
            {
                --start;
                CharT const minus = lcast_char_constants<CharT>::minus;
                Traits::assign(*start, minus);
            }
            return true;
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                int n)
        {
            start = lcast_put_unsigned<Traits>(lcast_to_unsigned(n), finish);
            if(n < 0)
            {
                --start;
                CharT const minus = lcast_char_constants<CharT>::minus;
                Traits::assign(*start, minus);
            }
            return true;
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                long n)
        {
            start = lcast_put_unsigned<Traits>(lcast_to_unsigned(n), finish);
            if(n < 0)
            {
                --start;
                CharT const minus = lcast_char_constants<CharT>::minus;
                Traits::assign(*start, minus);
            }
            return true;
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                boost::long_long_type n)
        {
            start = lcast_put_unsigned<Traits>(lcast_to_unsigned(n), finish);
            if(n < 0)
            {
                --start;
                CharT const minus = lcast_char_constants<CharT>::minus;
                Traits::assign(*start, minus);
            }
            return true;
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                unsigned short n)
        {
            start = lcast_put_unsigned<Traits>(n, finish);
            return true;
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                unsigned int n)
        {
            start = lcast_put_unsigned<Traits>(n, finish);
            return true;
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                unsigned long n)
        {
            start = lcast_put_unsigned<Traits>(n, finish);
            return true;
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                boost::ulong_long_type n)
        {
            start = lcast_put_unsigned<Traits>(n, finish);
            return true;
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                float val)
        {
            return this->lcast_put(val);
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                double val)
        {
            return this->lcast_put(val);
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                long double val)
        {
            return this->lcast_put(val);
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator<<(
                CharT const* str)
        {
            start = const_cast<CharT*>(str);
            finish = start + Traits::length(str);
            return true;
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator>>(
                CharT& output)
        {
            bool const ok = (finish - start == 1);
            if(ok)
                Traits::assign(output, *start);
            return ok;
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator>>(
                unsigned char& output)
        {
            static_assert(sizeof(CharT) == sizeof(unsigned char), "sizeof(CharT) == sizeof(unsigned char)");
            bool const ok = (finish - start == 1);
            if(ok) {
                CharT out;
                Traits::assign(out, *start);
                output = static_cast<signed char>(out);
            }
            return ok;
        }
        template<typename CharT, class Base, class Traits>
        inline bool lexical_stream_limited_src<CharT,Base,Traits>::operator>>(
                signed char& output)
        {
            static_assert(sizeof(CharT) == sizeof(signed char), "sizeof(CharT) == sizeof(signed char)");
            bool const ok = (finish - start == 1);
            if(ok) {
                CharT out;
                Traits::assign(out, *start);
                output = static_cast<signed char>(out);
            }
            return ok;
        }
    }
    namespace detail
    {
        template<class Source>
        struct lcast_streambuf_for_source
        {
            static const bool value = false;
        };
        template<>
        struct lcast_streambuf_for_source<float>
        {
            static const bool value = true;
        };
        template<>
        struct lcast_streambuf_for_source<double>
        {
            static const bool value = true;
        };
        template<>
        struct lcast_streambuf_for_source<long double>
        {
            static const bool value = true;
        };
    }
    namespace detail
    {
        template<class Target>
        struct lcast_streambuf_for_target
        {
            static const bool value = ( ::boost::type_traits::ice_not< is_integral<Target>::value >::value );
        };
        template<class Traits, class Alloc>
        struct lcast_streambuf_for_target<
                    std::basic_string<char,Traits,Alloc> >
        {
            static const bool value = false;
        };
        template<class Traits, class Alloc>
        struct lcast_streambuf_for_target<
                    std::basic_string<wchar_t,Traits,Alloc> >
        {
            static const bool value = false;
        };
    }
    namespace detail
    {
        template<class T>
        struct array_to_pointer_decay
        {
            typedef T type;
        };
        template<class T, std::size_t N>
        struct array_to_pointer_decay<T[N]>
        {
            typedef const T * type;
        };
        template< typename Target
                , typename Source
                , bool Unlimited
                , typename CharT
                >
        Target lexical_cast(
            typename boost::call_traits<Source>::param_type arg,
            CharT* buf, std::size_t src_len)
        {
            typedef typename
                deduce_char_traits<CharT,Target,Source>::type traits;
            typedef typename boost::mpl::if_c<
                lcast_streambuf_for_target<Target>::value ||
                lcast_streambuf_for_source<Source>::value
              , std::basic_streambuf<CharT>
              , lexical_streambuf_fake
              >::type base;
            typename boost::mpl::if_c<
                Unlimited
              , detail::lexical_stream<Target,Source,traits>
              , detail::lexical_stream_limited_src<CharT,base,traits>
              >::type interpreter(buf, buf + src_len);
            Target result;
            if(!(interpreter << arg && interpreter >> result))
              throw_exception(bad_lexical_cast(typeid(Source), typeid(Target)));
            return result;
        }
        template<typename T>
        struct is_stdstring
        {
            static const bool value = false;
        };
        template<typename CharT, typename Traits, typename Alloc>
        struct is_stdstring< std::basic_string<CharT, Traits, Alloc> >
        {
            static const bool value = true;
        };
        template<typename T>
        struct is_char_or_wchar
        {
            static const bool value = ( ::boost::type_traits::ice_or< is_same< T, char >::value, is_same< T, wchar_t >::value, is_same< T, unsigned char >::value, is_same< T, signed char >::value >::value );
        };
        template<typename Target, typename Source>
        struct is_arithmetic_and_not_xchars
        {
            static const bool value = ( ::boost::type_traits::ice_and< is_arithmetic<Source>::value, is_arithmetic<Target>::value, ::boost::type_traits::ice_not< detail::is_char_or_wchar<Target>::value >::value, ::boost::type_traits::ice_not< detail::is_char_or_wchar<Source>::value >::value >::value );
        };
        template<typename Target, typename Source>
        struct is_xchar_to_xchar
        {
            static const bool value = ( ::boost::type_traits::ice_or< ::boost::type_traits::ice_and< is_same<Source,Target>::value, is_char_or_wchar<Target>::value >::value, ::boost::type_traits::ice_and< ::boost::type_traits::ice_eq< sizeof(char),sizeof(Target)>::value, ::boost::type_traits::ice_eq< sizeof(char),sizeof(Source)>::value, is_char_or_wchar<Target>::value, is_char_or_wchar<Source>::value >::value >::value );
        };
        template<typename Target, typename Source>
        struct is_char_array_to_stdstring
        {
            static const bool value = false;
        };
        template<typename CharT, typename Traits, typename Alloc>
        struct is_char_array_to_stdstring< std::basic_string<CharT, Traits, Alloc>, CharT* >
        {
            static const bool value = true;
        };
        template<typename CharT, typename Traits, typename Alloc>
        struct is_char_array_to_stdstring< std::basic_string<CharT, Traits, Alloc>, const CharT* >
        {
            static const bool value = true;
        };
        template<typename Target, typename Source>
        struct lexical_cast_do_cast
        {
            static inline Target lexical_cast_impl(const Source &arg)
            {
                typedef typename detail::array_to_pointer_decay<Source>::type src;
                typedef typename detail::widest_char<
                typename detail::stream_char<Target>::type
                , typename detail::stream_char<src>::type
                >::type char_type;
                typedef detail::lcast_src_length<char_type, src> lcast_src_length;
                std::size_t const src_len = lcast_src_length::value;
                char_type buf[src_len + 1];
                lcast_src_length::check_coverage();
                return detail::lexical_cast<Target, src, !src_len>(arg, buf, src_len);
            }
        };
        template<typename Source>
        struct lexical_cast_copy
        {
            static inline Source lexical_cast_impl(const Source &arg)
            {
                return arg;
            }
        };
        class precision_loss_error : public boost::numeric::bad_numeric_cast
        {
         public:
            virtual const char * what() const throw()
             { return "bad numeric conversion: precision loss error"; }
        };
        template<class S >
        struct throw_on_precision_loss
        {
         typedef boost::numeric::Trunc<S> Rounder;
         typedef S source_type ;
         typedef typename mpl::if_< is_arithmetic<S>,S,S const&>::type argument_type ;
         static source_type nearbyint ( argument_type s )
         {
            source_type orig_div_round = s / Rounder::nearbyint(s);
            if ( (orig_div_round > 1 ? orig_div_round - 1 : 1 - orig_div_round) > std::numeric_limits<source_type>::epsilon() )
               ::boost::exception_detail::throw_exception_(precision_loss_error(),__PRETTY_FUNCTION__,"/usr/local/include/boost/lexical_cast.hpp",1686);
            return s ;
         }
         typedef typename Rounder::round_style round_style;
        } ;
        template<typename Target, typename Source>
        struct lexical_cast_dynamic_num_not_ignoring_minus
        {
            static inline Target lexical_cast_impl(const Source &arg)
            {
                try{
                    typedef boost::numeric::converter<
                            Target,
                            Source,
                            boost::numeric::conversion_traits<Target,Source>,
                            boost::numeric::def_overflow_handler,
                            throw_on_precision_loss<Source>
                    > Converter ;
                    return Converter::convert(arg);
                } catch( ::boost::numeric::bad_numeric_cast const& ) {
                    throw_exception(bad_lexical_cast(typeid(Source), typeid(Target)));
                }
            }
        };
        template<typename Target, typename Source>
        struct lexical_cast_dynamic_num_ignoring_minus
        {
            static inline Target lexical_cast_impl(const Source &arg)
            {
                try{
                    typedef boost::numeric::converter<
                            Target,
                            Source,
                            boost::numeric::conversion_traits<Target,Source>,
                            boost::numeric::def_overflow_handler,
                            throw_on_precision_loss<Source>
                    > Converter ;
                    bool has_minus = ( arg < 0);
                    if ( has_minus ) {
                        return static_cast<Target>(-Converter::convert(-arg));
                    } else {
                        return Converter::convert(arg);
                    }
                } catch( ::boost::numeric::bad_numeric_cast const& ) {
                    throw_exception(bad_lexical_cast(typeid(Source), typeid(Target)));
                }
            }
        };
        template<typename Target, typename Source>
        struct lexical_cast_dynamic_num
        {
            static inline Target lexical_cast_impl(const Source &arg)
            {
                typedef typename ::boost::mpl::if_c<
                    ::boost::type_traits::ice_and<
                        ::boost::type_traits::ice_or<
                            ::boost::is_signed<Source>::value,
                            ::boost::is_float<Source>::value
                        >::value,
                        ::boost::type_traits::ice_not<
                            is_same<Source, bool>::value
                        >::value,
                        ::boost::type_traits::ice_not<
                            is_same<Target, bool>::value
                        >::value,
                        ::boost::is_unsigned<Target>::value
                    >::value,
                    lexical_cast_dynamic_num_ignoring_minus<Target, Source>,
                    lexical_cast_dynamic_num_not_ignoring_minus<Target, Source>
                >::type caster_type;
                return caster_type::lexical_cast_impl(arg);
            }
        };
    }
    template<typename Target, typename Source>
    inline Target lexical_cast(const Source &arg)
    {
        typedef typename detail::array_to_pointer_decay<Source>::type src;
        typedef typename ::boost::type_traits::ice_or<
                detail::is_xchar_to_xchar<Target, src>::value,
                detail::is_char_array_to_stdstring<Target,src>::value,
                ::boost::type_traits::ice_and<
                     is_same<Target, src>::value,
                     detail::is_stdstring<Target>::value
                >::value
        > do_copy_type;
        typedef typename
                detail::is_arithmetic_and_not_xchars<Target, src> do_copy_with_dynamic_check_type;
        typedef typename ::boost::mpl::if_c<
            do_copy_type::value,
            detail::lexical_cast_copy<src>,
            typename ::boost::mpl::if_c<
                 do_copy_with_dynamic_check_type::value,
                 detail::lexical_cast_dynamic_num<Target, src>,
                 detail::lexical_cast_do_cast<Target, src>
            >::type
        >::type caster_type;
        return caster_type::lexical_cast_impl(arg);
    }
}
namespace boost { namespace reflect {
    typedef boost::error_info<struct err_msg_,std::string> err_msg;
    class bad_value_cast : public std::bad_cast {
        public:
            virtual const char * what() const throw() {
                return "boost::reflect::bad_value_cast: "
                       "failed conversion using boost::value";
            }
    };
    class unknown_field : public virtual boost::exception, public virtual std::exception {
        public:
            virtual const char * what() const throw() {
                return "boost::reflect::unknown_field: "
                       "attempted to access an unknown field";
            }
    };
} }
namespace boost { namespace reflect {
  class value_cref;
  class value_ref;
  struct read_value_visitor {
      virtual ~read_value_visitor(){}
      template<typename T>
      void operator()( const T& s ){ (*this)(value_cref(s)); }
      virtual void operator()(){}
      virtual void operator()( const value_cref& s ){}
      virtual void operator()( const std::string& s ){}
      virtual void operator()( const uint64_t& s ){}
      virtual void operator()( const int64_t& s ){}
      virtual void operator()( const uint32_t& s ){}
      virtual void operator()( const int32_t& s ){}
      virtual void operator()( const uint16_t& s ){}
      virtual void operator()( const int16_t& s ){}
      virtual void operator()( const uint8_t& s ){}
      virtual void operator()( const int8_t& s ){}
      virtual void operator()( const double& s ){}
      virtual void operator()( const float& s ){}
      virtual void operator()( const bool& s ){}
  };
  struct write_value_visitor {
      virtual ~write_value_visitor(){}
      template<typename T>
      void operator()( T& s ){ value_ref vr(s); (*this)(vr); }
      virtual void operator()(){}
      virtual void operator()( value_ref& v ){}
      virtual void operator()( std::string& s ){}
      virtual void operator()( uint64_t& s ){}
      virtual void operator()( int64_t& s ){}
      virtual void operator()( uint32_t& s ){}
      virtual void operator()( int32_t& s ){}
      virtual void operator()( uint16_t& s ){};
      virtual void operator()( int16_t& s ){}
      virtual void operator()( uint8_t& s ){}
      virtual void operator()( int8_t& s ){}
      virtual void operator()( double& s ){}
      virtual void operator()( float& s ){}
      virtual void operator()( bool& s ){}
  };
  template<typename T>
  struct get_visitor : read_value_visitor {
    T& m_val;
    get_visitor( T& v ):m_val(v){}
      virtual void operator()( const std::string& s ) { m_val = boost::lexical_cast<T>(s); }
      virtual void operator()( const uint64_t& s ) { m_val = boost::lexical_cast<T>(s); }
      virtual void operator()( const int64_t& s ) { m_val = boost::lexical_cast<T>(s); }
      virtual void operator()( const uint32_t& s ) { m_val = boost::lexical_cast<T>(s); }
      virtual void operator()( const int32_t& s ) { m_val = boost::lexical_cast<T>(s); }
      virtual void operator()( const uint16_t& s ) { m_val = boost::lexical_cast<T>(s); }
      virtual void operator()( const int16_t& s ) { m_val = boost::lexical_cast<T>(s); }
      virtual void operator()( const uint8_t& s ) { m_val = boost::lexical_cast<T>(s); }
      virtual void operator()( const int8_t& s ) { m_val = boost::lexical_cast<T>(s); }
      virtual void operator()( const double& s ) { m_val = boost::lexical_cast<T>(s); }
      virtual void operator()( const float& s ) { m_val = boost::lexical_cast<T>(s); }
      virtual void operator()( const bool& s ) { m_val = boost::lexical_cast<T>(s); }
  };
  template<typename T>
  struct set_visitor : write_value_visitor {
      const T& m_val;
      set_visitor( const T& v ):m_val(v){}
      virtual void operator()( std::string& s ) { s = boost::lexical_cast<std::string>(m_val); }
      virtual void operator()( uint64_t& s ) { s = boost::lexical_cast<uint64_t>(m_val); }
      virtual void operator()( int64_t& s ) { s = boost::lexical_cast<int64_t>(m_val); }
      virtual void operator()( uint32_t& s ) { s = boost::lexical_cast<uint32_t>(m_val); }
      virtual void operator()( int32_t& s ) { s = boost::lexical_cast<int32_t>(m_val); }
      virtual void operator()( uint16_t& s ) { s = boost::lexical_cast<uint16_t>(m_val); }
      virtual void operator()( int16_t& s ) { s = boost::lexical_cast<int16_t>(m_val); }
      virtual void operator()( uint8_t& s ) { s = boost::lexical_cast<uint8_t>(m_val); }
      virtual void operator()( int8_t& s ) { s = boost::lexical_cast<int8_t>(m_val); }
      virtual void operator()( double& s ) { s = boost::lexical_cast<double>(m_val); }
      virtual void operator()( float& s ) { s = boost::lexical_cast<float>(m_val); }
      virtual void operator()( bool& s ) { s = boost::lexical_cast<bool>(m_val); }
  };
} }
namespace boost { namespace reflect {
  namespace detail {
    class place_holder;
  };
class iterator;
class value;
class const_iterator;
  class value_base {
    public:
      value_base();
      value_base( const value_base& );
      ~value_base();
    bool is_array()const;
    bool is_function()const;
    size_t size()const;
    iterator begin();
    const_iterator begin()const;
    iterator end();
    const_iterator end()const;
      value operator()()const;
      value operator()();
      template<typename P1>
      value operator()(P1)const;
      template<typename P1>
      value operator()(P1);
      template<typename P1, typename P2>
      value operator()(P1,P2)const;
      template<typename P1,typename P2>
      value operator()(P1,P2);
      const char* type()const;
      void visit( read_value_visitor&& v )const;
      void visit( write_value_visitor&& v );
      template<typename T>
      T as()const;
      template<typename T>
      void set_as( const T&& );
      bool operator!()const;
      template<typename T>
      inline T& get();
      template<typename T>
      inline const T& get()const;
      template<typename T>
      inline const T* ptr()const;
      template<typename T>
      inline T* ptr();
      bool has_field( const std::string& field )const;
    protected:
      friend class value;
      friend class value_ref;
      friend class value_cref;
      inline const detail::place_holder* get_holder()const;
      inline detail::place_holder* get_holder();
      char held[3*sizeof(void*)];
  };
} }
namespace boost { namespace reflect {
class value_cref : public value_base {
    public:
        template<typename T> value_cref( const T& v );
        template<typename T> value_cref( const T&& t );
        value_cref( const struct value& t );
        value_cref( const value_cref& c );
        value_cref( value_cref&& t );
        value_cref operator[]( const std::string& field )const;
        template<typename T>
        inline const T& get()const;
        template<typename T>
        inline const T* const_ptr()const;
    private:
        friend class value;
        template<typename T>
        inline T& get();
        template<typename T>
        inline T* ptr();
        using value_base::get;
        using value_base::ptr;
        using value_base::set_as;
        value_cref(){};
        template<typename T>
        void set_as(const T&&);
        template<typename T>
        value_cref operator = (T){ return *this; }
        value_cref operator = ( const value_cref& v );
};
} }
namespace boost { namespace reflect {
class value_ref : public value_base {
    public:
        template<typename T>
        value_ref( T& v );
        value_ref( const value_ref& );
        value_ref( value_ref&& );
        operator value_cref()const;
        value_cref operator[]( const std::string& field )const;
        value_ref operator[]( const std::string& field );
        template<typename T>
        value_ref& operator=( const T& r );
    private:
        friend class value;
        value_ref(){}
        value_ref(const class value_cref& ){}
        value_ref(const class value& ){}
        template<typename T>
        value_ref operator = (T){ return *this; }
        value_ref operator = ( const value_ref& v );
        template<typename T>
        value_ref( const T& );
};
} }
namespace boost { namespace reflect {
class value : public value_base {
  public:
    value(){}
    template<typename T>
    value( const T& v );
    value( value&& v );
    template<typename T>
    value( typename boost::remove_reference<T>::type&& v );
    value( const value_cref& );
    value( const value_ref& );
    template<typename T>
    value& operator=( const T& v );
    template<typename T>
    value& operator=( T&& v );
    template<typename T>
    value& operator=( value&& v );
    template<typename T>
    value& operator=( const value& v );
    template<typename T>
    value& operator=( const value_ref& v );
    template<typename T>
    value& operator=( const value_cref& v );
    value_cref operator[]( const std::string& field )const;
    value_ref operator[]( const std::string& field );
    value_cref operator[]( uint64_t idx )const;
    value_ref operator[]( uint64_t idx );
};
} }
       
namespace boost
{
    template <class T> struct hash;
    template <class T> void hash_combine(std::size_t& seed, T const& v);
    template <class It> std::size_t hash_range(It, It);
    template <class It> void hash_range(std::size_t&, It, It);
}
namespace boost
{
    template <class K,
        class T,
        class H = hash<K>,
        class P = std::equal_to<K>,
        class A = std::allocator<std::pair<const K, T> > >
    class unordered_map;
    template <class K, class T, class H, class P, class A>
    inline bool operator==(unordered_map<K, T, H, P, A> const&,
        unordered_map<K, T, H, P, A> const&);
    template <class K, class T, class H, class P, class A>
    inline bool operator!=(unordered_map<K, T, H, P, A> const&,
        unordered_map<K, T, H, P, A> const&);
    template <class K, class T, class H, class P, class A>
    inline void swap(unordered_map<K, T, H, P, A>&,
            unordered_map<K, T, H, P, A>&);
    template <class K,
        class T,
        class H = hash<K>,
        class P = std::equal_to<K>,
        class A = std::allocator<std::pair<const K, T> > >
    class unordered_multimap;
    template <class K, class T, class H, class P, class A>
    inline bool operator==(unordered_multimap<K, T, H, P, A> const&,
        unordered_multimap<K, T, H, P, A> const&);
    template <class K, class T, class H, class P, class A>
    inline bool operator!=(unordered_multimap<K, T, H, P, A> const&,
        unordered_multimap<K, T, H, P, A> const&);
    template <class K, class T, class H, class P, class A>
    inline void swap(unordered_multimap<K, T, H, P, A>&,
            unordered_multimap<K, T, H, P, A>&);
}
namespace boost {
    namespace hash_detail {
        struct not_found {
            inline operator float() const { return 0; }
            inline operator long double() const { return 0; }
        };
        template <typename T> struct is;
        template <> struct is<float> { char x[10]; };
        template <> struct is<double> { char x[20]; };
        template <> struct is<long double> { char x[30]; };
        template <> struct is<boost::hash_detail::not_found> { char x[40]; };
        template <typename T> is<T> float_type(T);
        template <typename Float> struct call_ldexp
        {
            typedef double float_type;
            inline double operator()(double a, int b) const
            {
                using namespace std;
                return ldexp(a, b);
            }
        };
        template <typename Float> struct call_frexp
        {
            typedef double float_type;
            inline double operator()(double a, int* b) const
            {
                using namespace std;
                return frexp(a, b);
            }
        };
    }
}
namespace boost_hash_detect_float_functions {
    template <class Float> boost::hash_detail::not_found ldexp(Float, int);
    template <class Float> boost::hash_detail::not_found frexp(Float, int*);
}
namespace boost_hash_detect_float_functions { template <class Float> boost::hash_detail::not_found ldexpf(Float, int); } namespace boost { namespace hash_detail { namespace ldexpf_detect { using namespace std; using namespace boost_hash_detect_float_functions; struct check { static float x; static int y; static const bool cpp = sizeof(float_type(ldexp(x,y))) == sizeof(is<float>); static const bool c99 = sizeof(float_type(ldexpf(x,y))) == sizeof(is<float>); }; } template <bool x> struct call_c99_ldexpf : boost::hash_detail::call_ldexp<double> {}; template <> struct call_c99_ldexpf<true> { typedef float float_type; template <typename T> inline float operator()(float a, T b) const { using namespace std; return ldexpf(a, b); } }; template <bool x> struct call_cpp_ldexpf : call_c99_ldexpf< ::boost::hash_detail::ldexpf_detect::check::c99 > {}; template <> struct call_cpp_ldexpf<true> { typedef float float_type; template <typename T> inline float operator()(float a, T b) const { using namespace std; return ldexp(a, b); } }; template <> struct call_ldexp<float> : call_cpp_ldexpf< ::boost::hash_detail::ldexpf_detect::check::cpp > {}; } }
namespace boost_hash_detect_float_functions { template <class Float> boost::hash_detail::not_found ldexpl(Float, int); } namespace boost { namespace hash_detail { namespace ldexpl_detect { using namespace std; using namespace boost_hash_detect_float_functions; struct check { static long double x; static int y; static const bool cpp = sizeof(float_type(ldexp(x,y))) == sizeof(is<long double>); static const bool c99 = sizeof(float_type(ldexpl(x,y))) == sizeof(is<long double>); }; } template <bool x> struct call_c99_ldexpl : boost::hash_detail::call_ldexp<double> {}; template <> struct call_c99_ldexpl<true> { typedef long double float_type; template <typename T> inline long double operator()(long double a, T b) const { using namespace std; return ldexpl(a, b); } }; template <bool x> struct call_cpp_ldexpl : call_c99_ldexpl< ::boost::hash_detail::ldexpl_detect::check::c99 > {}; template <> struct call_cpp_ldexpl<true> { typedef long double float_type; template <typename T> inline long double operator()(long double a, T b) const { using namespace std; return ldexp(a, b); } }; template <> struct call_ldexp<long double> : call_cpp_ldexpl< ::boost::hash_detail::ldexpl_detect::check::cpp > {}; } }
namespace boost_hash_detect_float_functions { template <class Float> boost::hash_detail::not_found frexpf(Float, int*); } namespace boost { namespace hash_detail { namespace frexpf_detect { using namespace std; using namespace boost_hash_detect_float_functions; struct check { static float x; static int* y; static const bool cpp = sizeof(float_type(frexp(x,y))) == sizeof(is<float>); static const bool c99 = sizeof(float_type(frexpf(x,y))) == sizeof(is<float>); }; } template <bool x> struct call_c99_frexpf : boost::hash_detail::call_frexp<double> {}; template <> struct call_c99_frexpf<true> { typedef float float_type; template <typename T> inline float operator()(float a, T b) const { using namespace std; return frexpf(a, b); } }; template <bool x> struct call_cpp_frexpf : call_c99_frexpf< ::boost::hash_detail::frexpf_detect::check::c99 > {}; template <> struct call_cpp_frexpf<true> { typedef float float_type; template <typename T> inline float operator()(float a, T b) const { using namespace std; return frexp(a, b); } }; template <> struct call_frexp<float> : call_cpp_frexpf< ::boost::hash_detail::frexpf_detect::check::cpp > {}; } }
namespace boost_hash_detect_float_functions { template <class Float> boost::hash_detail::not_found frexpl(Float, int*); } namespace boost { namespace hash_detail { namespace frexpl_detect { using namespace std; using namespace boost_hash_detect_float_functions; struct check { static long double x; static int* y; static const bool cpp = sizeof(float_type(frexp(x,y))) == sizeof(is<long double>); static const bool c99 = sizeof(float_type(frexpl(x,y))) == sizeof(is<long double>); }; } template <bool x> struct call_c99_frexpl : boost::hash_detail::call_frexp<double> {}; template <> struct call_c99_frexpl<true> { typedef long double float_type; template <typename T> inline long double operator()(long double a, T b) const { using namespace std; return frexpl(a, b); } }; template <bool x> struct call_cpp_frexpl : call_c99_frexpl< ::boost::hash_detail::frexpl_detect::check::c99 > {}; template <> struct call_cpp_frexpl<true> { typedef long double float_type; template <typename T> inline long double operator()(long double a, T b) const { using namespace std; return frexp(a, b); } }; template <> struct call_frexp<long double> : call_cpp_frexpl< ::boost::hash_detail::frexpl_detect::check::cpp > {}; } }
namespace boost
{
    namespace hash_detail
    {
        template <typename Float1, typename Float2>
        struct select_hash_type_impl {
            typedef double type;
        };
        template <>
        struct select_hash_type_impl<float, float> {
            typedef float type;
        };
        template <>
        struct select_hash_type_impl<long double, long double> {
            typedef long double type;
        };
        template <typename Float>
        struct select_hash_type : select_hash_type_impl<
                typename call_ldexp<Float>::float_type,
                typename call_frexp<Float>::float_type
            > {};
    }
}
namespace boost
{
    namespace hash_detail
    {
        template <class T>
        struct limits : std::numeric_limits<T> {};
    }
}
       
       
namespace boost
{
     typedef boost::uintmax_t static_min_max_unsigned_type;
     typedef boost::intmax_t static_min_max_signed_type;
     typedef boost::uintmax_t static_log2_argument_type;
     typedef int static_log2_result_type;
template < class T >
    class integer_traits;
template < >
    class integer_traits< bool >;
template < >
    class integer_traits< char >;
template < >
    class integer_traits< signed char >;
template < >
    class integer_traits< unsigned char >;
template < >
    class integer_traits< wchar_t >;
template < >
    class integer_traits< short >;
template < >
    class integer_traits< unsigned short >;
template < >
    class integer_traits< int >;
template < >
    class integer_traits< unsigned int >;
template < >
    class integer_traits< long >;
template < >
    class integer_traits< unsigned long >;
template < >
class integer_traits< ::boost::long_long_type>;
template < >
class integer_traits< ::boost::ulong_long_type >;
template < typename LeastInt >
    struct int_fast_t;
template< int Bits >
    struct int_t;
template< int Bits >
    struct uint_t;
    template< boost::long_long_type MaxValue >
    struct int_max_value_t;
  template< boost::long_long_type MinValue >
    struct int_min_value_t;
  template< boost::ulong_long_type MaxValue >
    struct uint_value_t;
template < std::size_t Bit >
    struct high_bit_mask_t;
template < std::size_t Bits >
    struct low_bits_mask_t;
template < >
    struct low_bits_mask_t< ::std::numeric_limits<unsigned char>::digits >;
template <static_log2_argument_type Value >
    struct static_log2;
template <> struct static_log2<0u>;
template <static_min_max_signed_type Value1, static_min_max_signed_type Value2>
    struct static_signed_min;
template <static_min_max_signed_type Value1, static_min_max_signed_type Value2>
    struct static_signed_max;
template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
    struct static_unsigned_min;
template <static_min_max_unsigned_type Value1, static_min_max_unsigned_type Value2>
    struct static_unsigned_max;
}
namespace boost {
 namespace detail {
     namespace static_log2_impl {
     typedef boost::static_log2_argument_type argument_type;
     typedef boost::static_log2_result_type result_type;
     template <result_type n>
     struct choose_initial_n {
         static const bool c = (argument_type(1) << n << n) != 0;
         static const result_type value = !c*n + choose_initial_n<2*c*n>::value;
     };
     template <>
     struct choose_initial_n<0> {
         static const result_type value = 0;
     };
     const result_type n_zero = 16;
     const result_type initial_n = choose_initial_n<n_zero>::value;
     template <argument_type x, result_type n = initial_n>
     struct static_log2_impl {
         static const bool c = (x >> n) > 0;
         static const result_type value = c*n + (static_log2_impl< (x>>c*n), n/2 >::value);
     };
     template <>
     struct static_log2_impl<1, 0> {
        static const result_type value = 0;
     };
     }
 }
 template <static_log2_argument_type x>
 struct static_log2 {
     static const static_log2_result_type value = detail::static_log2_impl::static_log2_impl<x>::value;
 };
 template <>
 struct static_log2<0> { };
}
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
}
namespace boost
{
    namespace hash_detail
    {
        inline void hash_float_combine(std::size_t& seed, std::size_t value)
        {
            seed ^= value + (seed<<6) + (seed>>2);
        }
        template <class T>
        inline std::size_t float_hash_impl2(T v)
        {
            boost::hash_detail::call_frexp<T> frexp;
            boost::hash_detail::call_ldexp<T> ldexp;
            int exp = 0;
            v = frexp(v, &exp);
            if(v < 0) {
                v = -v;
                exp += limits<T>::max_exponent -
                    limits<T>::min_exponent;
            }
            v = ldexp(v, limits<std::size_t>::digits);
            std::size_t seed = static_cast<std::size_t>(v);
            v -= static_cast<T>(seed);
            std::size_t const length
                = (limits<T>::digits *
                        boost::static_log2<limits<T>::radix>::value
                        + limits<std::size_t>::digits - 1)
                / limits<std::size_t>::digits;
            for(std::size_t i = 0; i != length; ++i)
            {
                v = ldexp(v, limits<std::size_t>::digits);
                std::size_t part = static_cast<std::size_t>(v);
                v -= static_cast<T>(part);
                hash_float_combine(seed, part);
            }
            hash_float_combine(seed, exp);
            return seed;
        }
        template <class T>
        inline std::size_t float_hash_impl(T v)
        {
            typedef typename select_hash_type<T>::type type;
            return float_hash_impl2(static_cast<type>(v));
        }
    }
}
namespace boost
{
    namespace hash_detail
    {
        template <class T>
        inline std::size_t float_hash_value(T v)
        {
            return v == 0 ? 0 : float_hash_impl(v);
        }
    }
}
namespace boost
{
    std::size_t hash_value(bool);
    std::size_t hash_value(char);
    std::size_t hash_value(unsigned char);
    std::size_t hash_value(signed char);
    std::size_t hash_value(short);
    std::size_t hash_value(unsigned short);
    std::size_t hash_value(int);
    std::size_t hash_value(unsigned int);
    std::size_t hash_value(long);
    std::size_t hash_value(unsigned long);
    std::size_t hash_value(wchar_t);
    std::size_t hash_value(boost::long_long_type);
    std::size_t hash_value(boost::ulong_long_type);
    template <class T> std::size_t hash_value(T* const&);
    template< class T, unsigned N >
    std::size_t hash_value(const T (&x)[N]);
    template< class T, unsigned N >
    std::size_t hash_value(T (&x)[N]);
    std::size_t hash_value(float v);
    std::size_t hash_value(double v);
    std::size_t hash_value(long double v);
    template <class Ch, class A>
    std::size_t hash_value(
        std::basic_string<Ch, std::char_traits<Ch>, A> const&);
    namespace hash_detail
    {
        template <class T>
        inline std::size_t hash_value_signed(T val)
        {
             const int size_t_bits = std::numeric_limits<std::size_t>::digits;
             const int length = (std::numeric_limits<T>::digits - 1)
                 / size_t_bits;
             std::size_t seed = 0;
             T positive = val < 0 ? -1 - val : val;
             for(unsigned int i = length * size_t_bits; i > 0; i -= size_t_bits)
             {
                 seed ^= (std::size_t) (positive >> i) + (seed<<6) + (seed>>2);
             }
             seed ^= (std::size_t) val + (seed<<6) + (seed>>2);
             return seed;
        }
        template <class T>
        inline std::size_t hash_value_unsigned(T val)
        {
             const int size_t_bits = std::numeric_limits<std::size_t>::digits;
             const int length = (std::numeric_limits<T>::digits - 1)
                 / size_t_bits;
             std::size_t seed = 0;
             for(unsigned int i = length * size_t_bits; i > 0; i -= size_t_bits)
             {
                 seed ^= (std::size_t) (val >> i) + (seed<<6) + (seed>>2);
             }
             seed ^= (std::size_t) val + (seed<<6) + (seed>>2);
             return seed;
        }
    }
    inline std::size_t hash_value(bool v)
    {
        return static_cast<std::size_t>(v);
    }
    inline std::size_t hash_value(char v)
    {
        return static_cast<std::size_t>(v);
    }
    inline std::size_t hash_value(unsigned char v)
    {
        return static_cast<std::size_t>(v);
    }
    inline std::size_t hash_value(signed char v)
    {
        return static_cast<std::size_t>(v);
    }
    inline std::size_t hash_value(short v)
    {
        return static_cast<std::size_t>(v);
    }
    inline std::size_t hash_value(unsigned short v)
    {
        return static_cast<std::size_t>(v);
    }
    inline std::size_t hash_value(int v)
    {
        return static_cast<std::size_t>(v);
    }
    inline std::size_t hash_value(unsigned int v)
    {
        return static_cast<std::size_t>(v);
    }
    inline std::size_t hash_value(long v)
    {
        return static_cast<std::size_t>(v);
    }
    inline std::size_t hash_value(unsigned long v)
    {
        return static_cast<std::size_t>(v);
    }
    inline std::size_t hash_value(wchar_t v)
    {
        return static_cast<std::size_t>(v);
    }
    inline std::size_t hash_value(boost::long_long_type v)
    {
        return hash_detail::hash_value_signed(v);
    }
    inline std::size_t hash_value(boost::ulong_long_type v)
    {
        return hash_detail::hash_value_unsigned(v);
    }
    template <class T> std::size_t hash_value(T* const& v)
    {
        std::size_t x = static_cast<std::size_t>(
           reinterpret_cast<std::ptrdiff_t>(v));
        return x + (x >> 3);
    }
    template <class T>
    inline void hash_combine(std::size_t& seed, T const& v)
    {
        boost::hash<T> hasher;
        seed ^= hasher(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);
    }
    template <class It>
    inline std::size_t hash_range(It first, It last)
    {
        std::size_t seed = 0;
        for(; first != last; ++first)
        {
            hash_combine(seed, *first);
        }
        return seed;
    }
    template <class It>
    inline void hash_range(std::size_t& seed, It first, It last)
    {
        for(; first != last; ++first)
        {
            hash_combine(seed, *first);
        }
    }
    template< class T, unsigned N >
    inline std::size_t hash_value(const T (&x)[N])
    {
        return hash_range(x, x + N);
    }
    template< class T, unsigned N >
    inline std::size_t hash_value(T (&x)[N])
    {
        return hash_range(x, x + N);
    }
    template <class Ch, class A>
    inline std::size_t hash_value(
        std::basic_string<Ch, std::char_traits<Ch>, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }
    inline std::size_t hash_value(float v)
    {
        return boost::hash_detail::float_hash_value(v);
    }
    inline std::size_t hash_value(double v)
    {
        return boost::hash_detail::float_hash_value(v);
    }
    inline std::size_t hash_value(long double v)
    {
        return boost::hash_detail::float_hash_value(v);
    }
    template <> struct hash<bool> : public std::unary_function<bool, std::size_t> { std::size_t operator()(bool v) const { return boost::hash_value(v); } };
    template <> struct hash<char> : public std::unary_function<char, std::size_t> { std::size_t operator()(char v) const { return boost::hash_value(v); } };
    template <> struct hash<signed char> : public std::unary_function<signed char, std::size_t> { std::size_t operator()(signed char v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned char> : public std::unary_function<unsigned char, std::size_t> { std::size_t operator()(unsigned char v) const { return boost::hash_value(v); } };
    template <> struct hash<wchar_t> : public std::unary_function<wchar_t, std::size_t> { std::size_t operator()(wchar_t v) const { return boost::hash_value(v); } };
    template <> struct hash<short> : public std::unary_function<short, std::size_t> { std::size_t operator()(short v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned short> : public std::unary_function<unsigned short, std::size_t> { std::size_t operator()(unsigned short v) const { return boost::hash_value(v); } };
    template <> struct hash<int> : public std::unary_function<int, std::size_t> { std::size_t operator()(int v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned int> : public std::unary_function<unsigned int, std::size_t> { std::size_t operator()(unsigned int v) const { return boost::hash_value(v); } };
    template <> struct hash<long> : public std::unary_function<long, std::size_t> { std::size_t operator()(long v) const { return boost::hash_value(v); } };
    template <> struct hash<unsigned long> : public std::unary_function<unsigned long, std::size_t> { std::size_t operator()(unsigned long v) const { return boost::hash_value(v); } };
    template <> struct hash<float> : public std::unary_function<float, std::size_t> { std::size_t operator()(float v) const { return boost::hash_value(v); } };
    template <> struct hash<double> : public std::unary_function<double, std::size_t> { std::size_t operator()(double v) const { return boost::hash_value(v); } };
    template <> struct hash<long double> : public std::unary_function<long double, std::size_t> { std::size_t operator()(long double v) const { return boost::hash_value(v); } };
    template <> struct hash<std::string> : public std::unary_function<std::string, std::size_t> { std::size_t operator()(std::string const& v) const { return boost::hash_value(v); } };
    template <> struct hash<std::wstring> : public std::unary_function<std::wstring, std::size_t> { std::size_t operator()(std::wstring const& v) const { return boost::hash_value(v); } };
    template <> struct hash<boost::long_long_type> : public std::unary_function<boost::long_long_type, std::size_t> { std::size_t operator()(boost::long_long_type v) const { return boost::hash_value(v); } };
    template <> struct hash<boost::ulong_long_type> : public std::unary_function<boost::ulong_long_type, std::size_t> { std::size_t operator()(boost::ulong_long_type v) const { return boost::hash_value(v); } };
    template <class T>
    struct hash<T*>
        : public std::unary_function<T*, std::size_t>
    {
        std::size_t operator()(T* v) const
        {
            return boost::hash_value(v);
        }
    };
}
       
namespace std
{
    template <class T> class allocator;
    template <class charT, class traits, class Allocator> class basic_string;
    template <class charT> struct char_traits;
        template <class T> class complex;
}
namespace std
{
    template <class T, class Allocator> class deque;
    template <class T, class Allocator> class list;
    template <class T, class Allocator> class vector;
    template <class Key, class T, class Compare, class Allocator> class map;
    template <class Key, class T, class Compare, class Allocator>
    class multimap;
    template <class Key, class Compare, class Allocator> class set;
    template <class Key, class Compare, class Allocator> class multiset;
    template <size_t N> class bitset;
    template <class T1, class T2> struct pair;
}
namespace boost
{
    template <class A, class B>
    std::size_t hash_value(std::pair<A, B> const&);
    template <class T, class A>
    std::size_t hash_value(std::vector<T, A> const&);
    template <class T, class A>
    std::size_t hash_value(std::list<T, A> const& v);
    template <class T, class A>
    std::size_t hash_value(std::deque<T, A> const& v);
    template <class K, class C, class A>
    std::size_t hash_value(std::set<K, C, A> const& v);
    template <class K, class C, class A>
    std::size_t hash_value(std::multiset<K, C, A> const& v);
    template <class K, class T, class C, class A>
    std::size_t hash_value(std::map<K, T, C, A> const& v);
    template <class K, class T, class C, class A>
    std::size_t hash_value(std::multimap<K, T, C, A> const& v);
    template <class T>
    std::size_t hash_value(std::complex<T> const&);
    template <class A, class B>
    std::size_t hash_value(std::pair<A, B> const& v)
    {
        std::size_t seed = 0;
        hash_combine(seed, v.first);
        hash_combine(seed, v.second);
        return seed;
    }
    template <class T, class A>
    std::size_t hash_value(std::vector<T, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }
    template <class T, class A>
    std::size_t hash_value(std::list<T, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }
    template <class T, class A>
    std::size_t hash_value(std::deque<T, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }
    template <class K, class C, class A>
    std::size_t hash_value(std::set<K, C, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }
    template <class K, class C, class A>
    std::size_t hash_value(std::multiset<K, C, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }
    template <class K, class T, class C, class A>
    std::size_t hash_value(std::map<K, T, C, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }
    template <class K, class T, class C, class A>
    std::size_t hash_value(std::multimap<K, T, C, A> const& v)
    {
        return hash_range(v.begin(), v.end());
    }
    template <class T>
    std::size_t hash_value(std::complex<T> const& v)
    {
        boost::hash<T> hasher;
        std::size_t seed = hasher(v.imag());
        seed ^= hasher(v.real()) + (seed<<6) + (seed>>2);
        return seed;
    }
    template <class T> struct hash
        : std::unary_function<T, std::size_t>
    {
        std::size_t operator()(T const& val) const
        {
            return hash_value(val);
        }
    };
}
namespace boost { namespace unordered_detail {
    template <class Alloc, class T>
    struct rebind_wrap
    {
        typedef typename
            Alloc::template rebind<T>::other
            type;
    };
    template <class Allocator>
    struct allocator_array_constructor
    {
        typedef typename Allocator::pointer pointer;
        Allocator& alloc_;
        pointer ptr_;
        pointer constructed_;
        std::size_t length_;
        allocator_array_constructor(Allocator& a)
            : alloc_(a), ptr_(), constructed_(), length_(0)
        {
            constructed_ = pointer();
            ptr_ = pointer();
        }
        ~allocator_array_constructor() {
            if (ptr_) {
                for(pointer p = ptr_; p != constructed_; ++p)
                    alloc_.destroy(p);
                alloc_.deallocate(ptr_, length_);
            }
        }
        template <class V>
        void construct(V const& v, std::size_t l)
        {
            (__builtin_expect(!(!ptr_), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/unordered/detail/allocator_helpers.hpp", 81, "!ptr_") : (void)0);
            length_ = l;
            ptr_ = alloc_.allocate(length_);
            pointer end = ptr_ + static_cast<std::ptrdiff_t>(length_);
            for(constructed_ = ptr_; constructed_ != end; ++constructed_)
                alloc_.construct(constructed_, v);
        }
        pointer get() const
        {
            return ptr_;
        }
        pointer release()
        {
            pointer p(ptr_);
            ptr_ = pointer();
            return p;
        }
    private:
        allocator_array_constructor(allocator_array_constructor const&);
        allocator_array_constructor& operator=(
            allocator_array_constructor const&);
    };
}}
       
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
}
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__));
}
namespace boost {
namespace detail {
template <typename T>
struct empty_helper_t1 : public T
{
    empty_helper_t1();
    int i[256];
private:
   empty_helper_t1(const empty_helper_t1&);
   empty_helper_t1& operator=(const empty_helper_t1&);
};
struct empty_helper_t2 { int i[256]; };
template <typename T, bool is_a_class = false>
struct empty_helper
{
    static const bool value = false;
};
template <typename T>
struct empty_helper<T, true>
{
    static const bool value = (sizeof(empty_helper_t1<T>) == sizeof(empty_helper_t2));
};
template <typename T>
struct is_empty_impl
{
    typedef typename remove_cv<T>::type cvt;
    static const bool value = ( ::boost::type_traits::ice_or< ::boost::detail::empty_helper<cvt,::boost::is_class<T>::value>::value , false >::value );
};
template<> struct is_empty_impl< void > { public: static const bool value = (false); };
template<> struct is_empty_impl< void const > { public: static const bool value = (false); };
template<> struct is_empty_impl< void volatile > { public: static const bool value = (false); };
template<> struct is_empty_impl< void const volatile > { public: static const bool value = (false); };
}
template< typename T > struct is_empty : public ::boost::integral_constant<bool,::boost::detail::is_empty_impl<T>::value> { public: };
}
namespace boost
{
template <class T1, class T2>
class compressed_pair;
namespace details
{
   template <class T1, class T2, bool IsSame, bool FirstEmpty, bool SecondEmpty>
   struct compressed_pair_switch;
   template <class T1, class T2>
   struct compressed_pair_switch<T1, T2, false, false, false>
      {static const int value = 0;};
   template <class T1, class T2>
   struct compressed_pair_switch<T1, T2, false, true, true>
      {static const int value = 3;};
   template <class T1, class T2>
   struct compressed_pair_switch<T1, T2, false, true, false>
      {static const int value = 1;};
   template <class T1, class T2>
   struct compressed_pair_switch<T1, T2, false, false, true>
      {static const int value = 2;};
   template <class T1, class T2>
   struct compressed_pair_switch<T1, T2, true, true, true>
      {static const int value = 4;};
   template <class T1, class T2>
   struct compressed_pair_switch<T1, T2, true, false, false>
      {static const int value = 5;};
   template <class T1, class T2, int Version> class compressed_pair_imp;
   using std::swap;
   template <typename T>
   inline void cp_swap(T& t1, T& t2)
   {
      swap(t1, t2);
   }
   template <class T1, class T2>
   class compressed_pair_imp<T1, T2, 0>
   {
   public:
      typedef T1 first_type;
      typedef T2 second_type;
      typedef typename call_traits<first_type>::param_type first_param_type;
      typedef typename call_traits<second_type>::param_type second_param_type;
      typedef typename call_traits<first_type>::reference first_reference;
      typedef typename call_traits<second_type>::reference second_reference;
      typedef typename call_traits<first_type>::const_reference first_const_reference;
      typedef typename call_traits<second_type>::const_reference second_const_reference;
      compressed_pair_imp() {}
      compressed_pair_imp(first_param_type x, second_param_type y)
         : first_(x), second_(y) {}
      compressed_pair_imp(first_param_type x)
         : first_(x) {}
      compressed_pair_imp(second_param_type y)
         : second_(y) {}
      first_reference first() {return first_;}
      first_const_reference first() const {return first_;}
      second_reference second() {return second_;}
      second_const_reference second() const {return second_;}
      void swap(::boost::compressed_pair<T1, T2>& y)
      {
         cp_swap(first_, y.first());
         cp_swap(second_, y.second());
      }
   private:
      first_type first_;
      second_type second_;
   };
   template <class T1, class T2>
   class compressed_pair_imp<T1, T2, 1>
      : protected ::boost::remove_cv<T1>::type
   {
   public:
      typedef T1 first_type;
      typedef T2 second_type;
      typedef typename call_traits<first_type>::param_type first_param_type;
      typedef typename call_traits<second_type>::param_type second_param_type;
      typedef typename call_traits<first_type>::reference first_reference;
      typedef typename call_traits<second_type>::reference second_reference;
      typedef typename call_traits<first_type>::const_reference first_const_reference;
      typedef typename call_traits<second_type>::const_reference second_const_reference;
      compressed_pair_imp() {}
      compressed_pair_imp(first_param_type x, second_param_type y)
         : first_type(x), second_(y) {}
      compressed_pair_imp(first_param_type x)
         : first_type(x) {}
      compressed_pair_imp(second_param_type y)
         : second_(y) {}
      first_reference first() {return *this;}
      first_const_reference first() const {return *this;}
      second_reference second() {return second_;}
      second_const_reference second() const {return second_;}
      void swap(::boost::compressed_pair<T1,T2>& y)
      {
         cp_swap(second_, y.second());
      }
   private:
      second_type second_;
   };
   template <class T1, class T2>
   class compressed_pair_imp<T1, T2, 2>
      : protected ::boost::remove_cv<T2>::type
   {
   public:
      typedef T1 first_type;
      typedef T2 second_type;
      typedef typename call_traits<first_type>::param_type first_param_type;
      typedef typename call_traits<second_type>::param_type second_param_type;
      typedef typename call_traits<first_type>::reference first_reference;
      typedef typename call_traits<second_type>::reference second_reference;
      typedef typename call_traits<first_type>::const_reference first_const_reference;
      typedef typename call_traits<second_type>::const_reference second_const_reference;
      compressed_pair_imp() {}
      compressed_pair_imp(first_param_type x, second_param_type y)
         : second_type(y), first_(x) {}
      compressed_pair_imp(first_param_type x)
         : first_(x) {}
      compressed_pair_imp(second_param_type y)
         : second_type(y) {}
      first_reference first() {return first_;}
      first_const_reference first() const {return first_;}
      second_reference second() {return *this;}
      second_const_reference second() const {return *this;}
      void swap(::boost::compressed_pair<T1,T2>& y)
      {
         cp_swap(first_, y.first());
      }
   private:
      first_type first_;
   };
   template <class T1, class T2>
   class compressed_pair_imp<T1, T2, 3>
      : protected ::boost::remove_cv<T1>::type,
        protected ::boost::remove_cv<T2>::type
   {
   public:
      typedef T1 first_type;
      typedef T2 second_type;
      typedef typename call_traits<first_type>::param_type first_param_type;
      typedef typename call_traits<second_type>::param_type second_param_type;
      typedef typename call_traits<first_type>::reference first_reference;
      typedef typename call_traits<second_type>::reference second_reference;
      typedef typename call_traits<first_type>::const_reference first_const_reference;
      typedef typename call_traits<second_type>::const_reference second_const_reference;
      compressed_pair_imp() {}
      compressed_pair_imp(first_param_type x, second_param_type y)
         : first_type(x), second_type(y) {}
      compressed_pair_imp(first_param_type x)
         : first_type(x) {}
      compressed_pair_imp(second_param_type y)
         : second_type(y) {}
      first_reference first() {return *this;}
      first_const_reference first() const {return *this;}
      second_reference second() {return *this;}
      second_const_reference second() const {return *this;}
      void swap(::boost::compressed_pair<T1,T2>&) {}
   };
   template <class T1, class T2>
   class compressed_pair_imp<T1, T2, 4>
      : protected ::boost::remove_cv<T1>::type
   {
   public:
      typedef T1 first_type;
      typedef T2 second_type;
      typedef typename call_traits<first_type>::param_type first_param_type;
      typedef typename call_traits<second_type>::param_type second_param_type;
      typedef typename call_traits<first_type>::reference first_reference;
      typedef typename call_traits<second_type>::reference second_reference;
      typedef typename call_traits<first_type>::const_reference first_const_reference;
      typedef typename call_traits<second_type>::const_reference second_const_reference;
      compressed_pair_imp() {}
      compressed_pair_imp(first_param_type x, second_param_type y)
         : first_type(x), m_second(y) {}
      compressed_pair_imp(first_param_type x)
         : first_type(x), m_second(x) {}
      first_reference first() {return *this;}
      first_const_reference first() const {return *this;}
      second_reference second() {return m_second;}
      second_const_reference second() const {return m_second;}
      void swap(::boost::compressed_pair<T1,T2>&) {}
   private:
      T2 m_second;
   };
   template <class T1, class T2>
   class compressed_pair_imp<T1, T2, 5>
   {
   public:
      typedef T1 first_type;
      typedef T2 second_type;
      typedef typename call_traits<first_type>::param_type first_param_type;
      typedef typename call_traits<second_type>::param_type second_param_type;
      typedef typename call_traits<first_type>::reference first_reference;
      typedef typename call_traits<second_type>::reference second_reference;
      typedef typename call_traits<first_type>::const_reference first_const_reference;
      typedef typename call_traits<second_type>::const_reference second_const_reference;
      compressed_pair_imp() {}
      compressed_pair_imp(first_param_type x, second_param_type y)
         : first_(x), second_(y) {}
      compressed_pair_imp(first_param_type x)
         : first_(x), second_(x) {}
      first_reference first() {return first_;}
      first_const_reference first() const {return first_;}
      second_reference second() {return second_;}
      second_const_reference second() const {return second_;}
      void swap(::boost::compressed_pair<T1, T2>& y)
      {
         cp_swap(first_, y.first());
         cp_swap(second_, y.second());
      }
   private:
      first_type first_;
      second_type second_;
   };
}
template <class T1, class T2>
class compressed_pair
   : private ::boost::details::compressed_pair_imp<T1, T2,
             ::boost::details::compressed_pair_switch<
                    T1,
                    T2,
                    ::boost::is_same<typename remove_cv<T1>::type, typename remove_cv<T2>::type>::value,
                    ::boost::is_empty<T1>::value,
                    ::boost::is_empty<T2>::value>::value>
{
private:
   typedef details::compressed_pair_imp<T1, T2,
             ::boost::details::compressed_pair_switch<
                    T1,
                    T2,
                    ::boost::is_same<typename remove_cv<T1>::type, typename remove_cv<T2>::type>::value,
                    ::boost::is_empty<T1>::value,
                    ::boost::is_empty<T2>::value>::value> base;
public:
   typedef T1 first_type;
   typedef T2 second_type;
   typedef typename call_traits<first_type>::param_type first_param_type;
   typedef typename call_traits<second_type>::param_type second_param_type;
   typedef typename call_traits<first_type>::reference first_reference;
   typedef typename call_traits<second_type>::reference second_reference;
   typedef typename call_traits<first_type>::const_reference first_const_reference;
   typedef typename call_traits<second_type>::const_reference second_const_reference;
            compressed_pair() : base() {}
            compressed_pair(first_param_type x, second_param_type y) : base(x, y) {}
   explicit compressed_pair(first_param_type x) : base(x) {}
   explicit compressed_pair(second_param_type y) : base(y) {}
   first_reference first() {return base::first();}
   first_const_reference first() const {return base::first();}
   second_reference second() {return base::second();}
   second_const_reference second() const {return base::second();}
   void swap(compressed_pair& y) { base::swap(y); }
};
template <class T>
class compressed_pair<T, T>
   : private details::compressed_pair_imp<T, T,
             ::boost::details::compressed_pair_switch<
                    T,
                    T,
                    ::boost::is_same<typename remove_cv<T>::type, typename remove_cv<T>::type>::value,
                    ::boost::is_empty<T>::value,
                    ::boost::is_empty<T>::value>::value>
{
private:
   typedef details::compressed_pair_imp<T, T,
             ::boost::details::compressed_pair_switch<
                    T,
                    T,
                    ::boost::is_same<typename remove_cv<T>::type, typename remove_cv<T>::type>::value,
                    ::boost::is_empty<T>::value,
                    ::boost::is_empty<T>::value>::value> base;
public:
   typedef T first_type;
   typedef T second_type;
   typedef typename call_traits<first_type>::param_type first_param_type;
   typedef typename call_traits<second_type>::param_type second_param_type;
   typedef typename call_traits<first_type>::reference first_reference;
   typedef typename call_traits<second_type>::reference second_reference;
   typedef typename call_traits<first_type>::const_reference first_const_reference;
   typedef typename call_traits<second_type>::const_reference second_const_reference;
            compressed_pair() : base() {}
            compressed_pair(first_param_type x, second_param_type y) : base(x, y) {}
   explicit
      compressed_pair(first_param_type x) : base(x) {}
   first_reference first() {return base::first();}
   first_const_reference first() const {return base::first();}
   second_reference second() {return base::second();}
   second_const_reference second() const {return base::second();}
   void swap(::boost::compressed_pair<T,T>& y) { base::swap(y); }
};
template <class T1, class T2>
inline
void
swap(compressed_pair<T1, T2>& x, compressed_pair<T1, T2>& y)
{
   x.swap(y);
}
}
       
namespace boost {
namespace detail { namespace aligned_storage {
static const std::size_t alignment_of_max_align = ::boost::alignment_of<max_align>::value;
template <
      std::size_t size_
    , std::size_t alignment_
>
struct aligned_storage_imp
{
    union data_t
    {
        char buf[size_];
        typename mpl::eval_if_c<
              alignment_ == std::size_t(-1)
            , mpl::identity<detail::max_align>
            , type_with_alignment<alignment_>
            >::type align_;
    } data_;
    void* address() const { return const_cast<aligned_storage_imp*>(this); }
};
template< std::size_t alignment_ >
struct aligned_storage_imp<0u,alignment_>
{
    void* address() const { return 0; }
};
}}
template <
      std::size_t size_
    , std::size_t alignment_ = std::size_t(-1)
>
class aligned_storage :
   private
   detail::aligned_storage::aligned_storage_imp<size_, alignment_>
{
public:
    typedef detail::aligned_storage::aligned_storage_imp<size_, alignment_> type;
    static const std::size_t size = size_;
    static const std::size_t alignment = ( alignment_ == std::size_t(-1) ? ::boost::detail::aligned_storage::alignment_of_max_align : alignment_ );
private:
    aligned_storage(const aligned_storage&);
    aligned_storage& operator=(const aligned_storage&);
public:
    aligned_storage()
    {
    }
    ~aligned_storage()
    {
    }
public:
    void* address()
    {
        return static_cast<type*>(this)->address();
    }
    const void* address() const
    {
        return static_cast<const type*>(this)->address();
    }
};
template <std::size_t size_, std::size_t alignment_>
struct is_pod<boost::detail::aligned_storage::aligned_storage_imp<size_,alignment_> >
   : public ::boost::integral_constant<bool,true>
{
   
};
}
namespace boost { namespace unordered_detail {
    static const float minimum_max_load_factor = 1e-3f;
    static const std::size_t default_bucket_count = 11;
    struct move_tag {};
    template <class T> class hash_unique_table;
    template <class T> class hash_equivalent_table;
    template <class Alloc, class Grouped>
    class hash_node_constructor;
    template <class ValueType>
    struct set_extractor;
    template <class Key, class ValueType>
    struct map_extractor;
    struct no_key;
    template <class T>
    inline void destroy(T* x) {
        x->~T();
    }
    template <class A>
    class hash_bucket
    {
        hash_bucket& operator=(hash_bucket const&);
    public:
        typedef hash_bucket<A> bucket;
        typedef typename
            boost::unordered_detail::rebind_wrap<A, bucket>::type
            bucket_allocator;
        typedef typename bucket_allocator::pointer bucket_ptr;
        typedef bucket_ptr node_ptr;
        node_ptr next_;
        hash_bucket() : next_() {}
    };
    template <class A>
    struct ungrouped_node_base : hash_bucket<A> {
        typedef hash_bucket<A> bucket;
        typedef typename bucket::bucket_ptr bucket_ptr;
        typedef typename bucket::node_ptr node_ptr;
        ungrouped_node_base() : bucket() {}
        static inline node_ptr& next_group(node_ptr ptr);
        static inline std::size_t group_count(node_ptr ptr);
        static inline void add_to_bucket(node_ptr n, bucket& b);
        static inline void add_after_node(node_ptr n, node_ptr position);
        static void unlink_node(bucket& b, node_ptr n);
        static void unlink_nodes(bucket& b, node_ptr begin, node_ptr end);
        static void unlink_nodes(bucket& b, node_ptr end);
    };
    template <class A>
    struct grouped_node_base : hash_bucket<A>
    {
        typedef hash_bucket<A> bucket;
        typedef typename bucket::bucket_ptr bucket_ptr;
        typedef typename bucket::node_ptr node_ptr;
        node_ptr group_prev_;
        grouped_node_base() : bucket(), group_prev_() {}
        static inline node_ptr& next_group(node_ptr ptr);
        static inline node_ptr first_in_group(node_ptr n);
        static inline std::size_t group_count(node_ptr ptr);
        static inline void add_to_bucket(node_ptr n, bucket& b);
        static inline void add_after_node(node_ptr n, node_ptr position);
        static void unlink_node(bucket& b, node_ptr n);
        static void unlink_nodes(bucket& b, node_ptr begin, node_ptr end);
        static void unlink_nodes(bucket& b, node_ptr end);
    private:
        static inline node_ptr split_group(node_ptr split);
        static inline grouped_node_base& get(node_ptr ptr) {
            return static_cast<grouped_node_base&>(*ptr);
        }
    };
    struct ungrouped
    {
        template <class A>
        struct base {
            typedef ungrouped_node_base<A> type;
        };
    };
    struct grouped
    {
        template <class A>
        struct base {
            typedef grouped_node_base<A> type;
        };
    };
    template <class ValueType>
    struct value_base
    {
        typedef ValueType value_type;
        typename boost::aligned_storage<
            sizeof(value_type),
            ::boost::alignment_of<value_type>::value>::type data_;
        void* address() {
            return this;
        }
        value_type& value() {
            return *(ValueType*) this;
        }
        value_type* value_ptr() {
            return (ValueType*) this;
        }
    private:
        value_base& operator=(value_base const&);
    };
    template <class A, class G>
    class hash_node :
        public G::template base<A>::type,
        public value_base<typename A::value_type>
    {
    public:
        typedef typename A::value_type value_type;
        typedef typename hash_bucket<A>::node_ptr node_ptr;
        static value_type& get_value(node_ptr p) {
            return static_cast<hash_node&>(*p).value();
        }
        static value_type* get_value_ptr(node_ptr p) {
            return static_cast<hash_node&>(*p).value_ptr();
        }
    private:
        hash_node& operator=(hash_node const&);
    };
    template <class A, class G>
    class hash_iterator_base
    {
    public:
        typedef A value_allocator;
        typedef hash_bucket<A> bucket;
        typedef hash_node<A, G> node;
        typedef typename A::value_type value_type;
        typedef typename bucket::bucket_ptr bucket_ptr;
        typedef typename bucket::node_ptr node_ptr;
        bucket_ptr bucket_;
        node_ptr node_;
        hash_iterator_base() : bucket_(), node_() {}
        explicit hash_iterator_base(bucket_ptr b)
          : bucket_(b),
            node_(b ? b->next_ : node_ptr()) {}
        hash_iterator_base(bucket_ptr b, node_ptr n)
          : bucket_(b),
            node_(n) {}
        bool operator==(hash_iterator_base const& x) const {
            return node_ == x.node_; }
        bool operator!=(hash_iterator_base const& x) const {
            return node_ != x.node_; }
        value_type& operator*() const {
            return node::get_value(node_);
        }
        void increment_bucket(node_ptr n) {
            while(!n) {
                ++bucket_;
                n = bucket_->next_;
            }
            node_ = bucket_ == n ? node_ptr() : n;
        }
        void increment() {
            increment_bucket(node_->next_);
        }
    };
    template <class A, class G>
    class hash_buckets
    {
        hash_buckets(hash_buckets const&);
        hash_buckets& operator=(hash_buckets const&);
    public:
        typedef A value_allocator;
        typedef hash_bucket<A> bucket;
        typedef hash_iterator_base<A, G> iterator_base;
        typedef typename A::value_type value_type;
        typedef typename iterator_base::node node;
        typedef typename bucket::bucket_allocator
            bucket_allocator;
        typedef typename bucket::bucket_ptr bucket_ptr;
        typedef typename bucket::node_ptr node_ptr;
        typedef typename rebind_wrap<value_allocator, node>::type
            node_allocator;
        typedef typename node_allocator::pointer real_node_ptr;
        bucket_ptr buckets_;
        std::size_t bucket_count_;
        boost::compressed_pair<bucket_allocator, node_allocator> allocators_;
        bucket_allocator const& bucket_alloc() const {
            return allocators_.first(); }
        node_allocator const& node_alloc() const {
            return allocators_.second(); }
        bucket_allocator& bucket_alloc() {
            return allocators_.first(); }
        node_allocator& node_alloc() {
            return allocators_.second(); }
        std::size_t max_bucket_count() const;
        hash_buckets(node_allocator const& a, std::size_t n);
        void create_buckets();
        ~hash_buckets();
        void swap(hash_buckets& other);
        void move(hash_buckets& other);
        bucket_ptr get_bucket(std::size_t n) const;
        bucket_ptr bucket_ptr_from_hash(std::size_t hashed) const;
        std::size_t bucket_size(std::size_t index) const;
        node_ptr bucket_begin(std::size_t n) const;
        void delete_node(node_ptr);
        void delete_buckets();
        void clear_bucket(bucket_ptr);
        std::size_t delete_nodes(node_ptr begin, node_ptr end);
        std::size_t delete_to_bucket_end(node_ptr begin);
    };
    template <class H, class P> class set_hash_functions;
    template <class H, class P>
    class hash_buffered_functions
    {
        friend class set_hash_functions<H, P>;
        hash_buffered_functions& operator=(hash_buffered_functions const&);
        typedef boost::compressed_pair<H, P> function_pair;
        typedef typename boost::aligned_storage<
            sizeof(function_pair),
            ::boost::alignment_of<function_pair>::value>::type aligned_function;
        bool current_;
        aligned_function funcs_[2];
        function_pair const& current() const {
            return *static_cast<function_pair const*>(
                static_cast<void const*>(&funcs_[current_]));
        }
        void construct(bool which, H const& hf, P const& eq)
        {
            new((void*) &funcs_[which]) function_pair(hf, eq);
        }
        void construct(bool which, function_pair const& f)
        {
            new((void*) &funcs_[which]) function_pair(f);
        }
        void destroy(bool which)
        {
            boost::unordered_detail::destroy((function_pair*)(&funcs_[which]));
        }
    public:
        hash_buffered_functions(H const& hf, P const& eq)
            : current_(false)
        {
            construct(current_, hf, eq);
        }
        hash_buffered_functions(hash_buffered_functions const& bf)
            : current_(false)
        {
            construct(current_, bf.current());
        }
        ~hash_buffered_functions() {
            destroy(current_);
        }
        H const& hash_function() const {
            return current().first();
        }
        P const& key_eq() const {
            return current().second();
        }
    };
    template <class H, class P>
    class set_hash_functions
    {
        set_hash_functions(set_hash_functions const&);
        set_hash_functions& operator=(set_hash_functions const&);
        typedef hash_buffered_functions<H, P> buffered_functions;
        buffered_functions& buffered_functions_;
        bool tmp_functions_;
    public:
        set_hash_functions(buffered_functions& f, H const& h, P const& p)
          : buffered_functions_(f),
            tmp_functions_(!f.current_)
        {
            f.construct(tmp_functions_, h, p);
        }
        set_hash_functions(buffered_functions& f,
            buffered_functions const& other)
          : buffered_functions_(f),
            tmp_functions_(!f.current_)
        {
            f.construct(tmp_functions_, other.current());
        }
        ~set_hash_functions()
        {
            buffered_functions_.destroy(tmp_functions_);
        }
        void commit()
        {
            buffered_functions_.current_ = tmp_functions_;
            tmp_functions_ = !tmp_functions_;
        }
    };
    template <class T>
    class hash_table : public T::buckets, public T::buffered_functions
    {
        hash_table(hash_table const&);
    public:
        typedef typename T::hasher hasher;
        typedef typename T::key_equal key_equal;
        typedef typename T::value_allocator value_allocator;
        typedef typename T::key_type key_type;
        typedef typename T::value_type value_type;
        typedef typename T::buffered_functions base;
        typedef typename T::buckets buckets;
        typedef typename T::extractor extractor;
        typedef typename T::node_constructor node_constructor;
        typedef typename T::node node;
        typedef typename T::bucket bucket;
        typedef typename T::node_ptr node_ptr;
        typedef typename T::bucket_ptr bucket_ptr;
        typedef typename T::iterator_base iterator_base;
        typedef typename T::node_allocator node_allocator;
        typedef typename T::iterator_pair iterator_pair;
        std::size_t size_;
        float mlf_;
        bucket_ptr cached_begin_bucket_;
        std::size_t max_load_;
        key_type const& get_key(value_type const& v) const {
            return extractor::extract(v);
        }
        key_type const& get_key_from_ptr(node_ptr n) const {
            return extractor::extract(node::get_value(n));
        }
        bool equal(key_type const& k, value_type const& v) const;
        template <class Key, class Pred>
        node_ptr find_iterator(bucket_ptr bucket, Key const& k,
            Pred const&) const;
        node_ptr find_iterator(bucket_ptr bucket, key_type const& k) const;
        node_ptr find_iterator(key_type const& k) const;
        node_ptr* find_for_erase(bucket_ptr bucket, key_type const& k) const;
        std::size_t max_size() const;
        std::size_t bucket_index(key_type const& k) const;
        void max_load_factor(float z);
        std::size_t min_buckets_for_size(std::size_t n) const;
        std::size_t calculate_max_load();
        hash_table(std::size_t n, hasher const& hf, key_equal const& eq,
            node_allocator const& a);
        hash_table(hash_table const& x, node_allocator const& a);
        hash_table(hash_table& x, move_tag m);
        hash_table(hash_table& x, node_allocator const& a, move_tag m);
        ~hash_table() {}
        hash_table& operator=(hash_table const&);
        iterator_base begin() const {
            return this->size_ ?
                iterator_base(this->cached_begin_bucket_) :
                iterator_base();
        }
        iterator_base end() const {
            return iterator_base();
        }
        void swap(hash_table& x);
        void fast_swap(hash_table& other);
        void slow_swap(hash_table& other);
        void partial_swap(hash_table& other);
        void move(hash_table& x);
        void create_for_insert(std::size_t n);
        bool reserve_for_insert(std::size_t n);
        void rehash(std::size_t n);
        void rehash_impl(std::size_t n);
        void move_buckets_to(buckets& dst);
        void copy_buckets_to(buckets& dst) const;
        std::size_t count(key_type const& k) const;
        iterator_base find(key_type const& k) const;
        template <class Key, class Hash, class Pred>
        iterator_base find(Key const& k, Hash const& h, Pred const& eq) const;
        value_type& at(key_type const& k) const;
        iterator_pair equal_range(key_type const& k) const;
        void clear();
        std::size_t erase_key(key_type const& k);
        iterator_base erase_return_iterator(iterator_base r);
        void erase(iterator_base r);
        std::size_t erase_group(node_ptr* it, bucket_ptr bucket);
        iterator_base erase_range(iterator_base r1, iterator_base r2);
        void init_buckets();
        void recompute_begin_bucket(bucket_ptr b);
        void recompute_begin_bucket(bucket_ptr b1, bucket_ptr b2);
        float load_factor() const;
        iterator_base emplace_empty_impl_with_node(
            node_constructor&, std::size_t);
    };
    class iterator_access
    {
    public:
        template <class Iterator>
        static typename Iterator::base const&
            get(Iterator const& it)
        {
            return it.base_;
        }
    };
    template <class A, class G> class hash_iterator;
    template <class A, class G> class hash_const_iterator;
    template <class A, class G> class hash_local_iterator;
    template <class A, class G> class hash_const_local_iterator;
    template <class A, class G>
    class hash_local_iterator
        : public boost::iterator <
            std::forward_iterator_tag,
            typename A::value_type,
            std::ptrdiff_t,
            typename A::pointer,
            typename A::reference>
    {
    public:
        typedef typename A::value_type value_type;
    private:
        typedef hash_buckets<A, G> buckets;
        typedef typename buckets::node_ptr node_ptr;
        typedef typename buckets::node node;
        typedef hash_const_local_iterator<A, G> const_local_iterator;
        friend class hash_const_local_iterator<A, G>;
        node_ptr ptr_;
    public:
        hash_local_iterator() : ptr_() {}
        explicit hash_local_iterator(node_ptr x) : ptr_(x) {}
        typename A::reference operator*() const {
            return node::get_value(ptr_);
        }
        value_type* operator->() const {
            return node::get_value_ptr(ptr_);
        }
        hash_local_iterator& operator++() {
            ptr_ = ptr_->next_; return *this;
        }
        hash_local_iterator operator++(int) {
            hash_local_iterator tmp(ptr_); ptr_ = ptr_->next_; return tmp; }
        bool operator==(hash_local_iterator x) const {
            return ptr_ == x.ptr_;
        }
        bool operator==(const_local_iterator x) const {
            return ptr_ == x.ptr_;
        }
        bool operator!=(hash_local_iterator x) const {
            return ptr_ != x.ptr_;
        }
        bool operator!=(const_local_iterator x) const {
            return ptr_ != x.ptr_;
        }
    };
    template <class A, class G>
    class hash_const_local_iterator
        : public boost::iterator <
            std::forward_iterator_tag,
            typename A::value_type,
            std::ptrdiff_t,
            typename A::const_pointer,
            typename A::const_reference >
    {
    public:
        typedef typename A::value_type value_type;
    private:
        typedef hash_buckets<A, G> buckets;
        typedef typename buckets::node_ptr ptr;
        typedef typename buckets::node node;
        typedef hash_local_iterator<A, G> local_iterator;
        friend class hash_local_iterator<A, G>;
        ptr ptr_;
    public:
        hash_const_local_iterator() : ptr_() {}
        explicit hash_const_local_iterator(ptr x) : ptr_(x) {}
        hash_const_local_iterator(local_iterator x) : ptr_(x.ptr_) {}
        typename A::const_reference
            operator*() const {
            return node::get_value(ptr_);
        }
        value_type const* operator->() const {
            return node::get_value_ptr(ptr_);
        }
        hash_const_local_iterator& operator++() {
            ptr_ = ptr_->next_; return *this;
        }
        hash_const_local_iterator operator++(int) {
            hash_const_local_iterator tmp(ptr_); ptr_ = ptr_->next_; return tmp;
        }
        bool operator==(local_iterator x) const {
            return ptr_ == x.ptr_;
        }
        bool operator==(hash_const_local_iterator x) const {
            return ptr_ == x.ptr_;
        }
        bool operator!=(local_iterator x) const {
            return ptr_ != x.ptr_;
        }
        bool operator!=(hash_const_local_iterator x) const {
            return ptr_ != x.ptr_;
        }
    };
    template <class A, class G>
    class hash_iterator
        : public boost::iterator <
            std::forward_iterator_tag,
            typename A::value_type,
            std::ptrdiff_t,
            typename A::pointer,
            typename A::reference >
    {
    public:
        typedef typename A::value_type value_type;
    private:
        typedef hash_buckets<A, G> buckets;
        typedef typename buckets::node node;
        typedef typename buckets::iterator_base base;
        typedef hash_const_iterator<A, G> const_iterator;
        friend class hash_const_iterator<A, G>;
        base base_;
    public:
        hash_iterator() : base_() {}
        explicit hash_iterator(base const& x) : base_(x) {}
        typename A::reference operator*() const {
            return *base_;
        }
        value_type* operator->() const {
            return &*base_;
        }
        hash_iterator& operator++() {
            base_.increment(); return *this;
        }
        hash_iterator operator++(int) {
            hash_iterator tmp(base_); base_.increment(); return tmp;
        }
        bool operator==(hash_iterator const& x) const {
            return base_ == x.base_;
        }
        bool operator==(const_iterator const& x) const {
            return base_ == x.base_;
        }
        bool operator!=(hash_iterator const& x) const {
            return base_ != x.base_;
        }
        bool operator!=(const_iterator const& x) const {
            return base_ != x.base_;
        }
    };
    template <class A, class G>
    class hash_const_iterator
        : public boost::iterator <
            std::forward_iterator_tag,
            typename A::value_type,
            std::ptrdiff_t,
            typename A::const_pointer,
            typename A::const_reference >
    {
    public:
        typedef typename A::value_type value_type;
    private:
        typedef hash_buckets<A, G> buckets;
        typedef typename buckets::node node;
        typedef typename buckets::iterator_base base;
        typedef hash_iterator<A, G> iterator;
        friend class hash_iterator<A, G>;
        friend class iterator_access;
        base base_;
    public:
        hash_const_iterator() : base_() {}
        explicit hash_const_iterator(base const& x) : base_(x) {}
        hash_const_iterator(iterator const& x) : base_(x.base_) {}
        typename A::const_reference operator*() const {
            return *base_;
        }
        value_type const* operator->() const {
            return &*base_;
        }
        hash_const_iterator& operator++() {
            base_.increment(); return *this;
        }
        hash_const_iterator operator++(int) {
            hash_const_iterator tmp(base_); base_.increment(); return tmp;
        }
        bool operator==(iterator const& x) const {
            return base_ == x.base_;
        }
        bool operator==(hash_const_iterator const& x) const {
            return base_ == x.base_;
        }
        bool operator!=(iterator const& x) const {
            return base_ != x.base_;
        }
        bool operator!=(hash_const_iterator const& x) const {
            return base_ != x.base_;
        }
    };
    template <class K, class V, class H, class P, class A, class E, class G>
    struct types
    {
    public:
        typedef K key_type;
        typedef V value_type;
        typedef H hasher;
        typedef P key_equal;
        typedef A value_allocator;
        typedef E extractor;
        typedef G group_type;
        typedef hash_node_constructor<value_allocator, group_type>
            node_constructor;
        typedef hash_buckets<value_allocator, group_type> buckets;
        typedef hash_buffered_functions<hasher, key_equal> buffered_functions;
        typedef typename buckets::node node;
        typedef typename buckets::bucket bucket;
        typedef typename buckets::node_ptr node_ptr;
        typedef typename buckets::bucket_ptr bucket_ptr;
        typedef typename buckets::iterator_base iterator_base;
        typedef typename buckets::node_allocator node_allocator;
        typedef std::pair<iterator_base, iterator_base> iterator_pair;
    };
}}
namespace boost { namespace unordered_detail {
    template <class A>
    inline typename ungrouped_node_base<A>::node_ptr&
        ungrouped_node_base<A>::next_group(node_ptr ptr)
    {
        return ptr->next_;
    }
    template <class A>
    inline std::size_t ungrouped_node_base<A>::group_count(node_ptr)
    {
        return 1;
    }
    template <class A>
    inline void ungrouped_node_base<A>::add_to_bucket(node_ptr n, bucket& b)
    {
        n->next_ = b.next_;
        b.next_ = n;
    }
    template <class A>
    inline void ungrouped_node_base<A>::add_after_node(node_ptr n,
        node_ptr position)
    {
        n->next_ = position->next_;
        position->next_ = position;
    }
    template <class A>
    inline void ungrouped_node_base<A>::unlink_nodes(bucket& b,
        node_ptr begin, node_ptr end)
    {
        node_ptr* pos = &b.next_;
        while(*pos != begin) pos = &(*pos)->next_;
        *pos = end;
    }
    template <class A>
    inline void ungrouped_node_base<A>::unlink_nodes(bucket& b, node_ptr end)
    {
        b.next_ = end;
    }
    template <class A>
    inline void ungrouped_node_base<A>::unlink_node(bucket& b, node_ptr n)
    {
        unlink_nodes(b, n, n->next_);
    }
    template <class A>
    inline typename grouped_node_base<A>::node_ptr&
        grouped_node_base<A>::next_group(node_ptr ptr)
    {
        return get(ptr).group_prev_->next_;
    }
    template <class A>
    inline typename grouped_node_base<A>::node_ptr
        grouped_node_base<A>::first_in_group(node_ptr ptr)
    {
        while(next_group(ptr) == ptr)
            ptr = get(ptr).group_prev_;
        return ptr;
    }
    template <class A>
    inline std::size_t grouped_node_base<A>::group_count(node_ptr ptr)
    {
        node_ptr start = ptr;
        std::size_t size = 0;
        do {
            ++size;
            ptr = get(ptr).group_prev_;
        } while(ptr != start);
        return size;
    }
    template <class A>
    inline void grouped_node_base<A>::add_to_bucket(node_ptr n, bucket& b)
    {
        n->next_ = b.next_;
        get(n).group_prev_ = n;
        b.next_ = n;
    }
    template <class A>
    inline void grouped_node_base<A>::add_after_node(node_ptr n, node_ptr pos)
    {
        n->next_ = next_group(pos);
        get(n).group_prev_ = get(pos).group_prev_;
        next_group(pos) = n;
        get(pos).group_prev_ = n;
    }
    template <class A>
    inline typename grouped_node_base<A>::node_ptr
        grouped_node_base<A>::split_group(node_ptr split)
    {
        node_ptr first = first_in_group(split);
        if(first == split) return split;
        node_ptr last = get(first).group_prev_;
        get(first).group_prev_ = get(split).group_prev_;
        get(split).group_prev_ = last;
        return first;
    }
    template <class A>
    void grouped_node_base<A>::unlink_node(bucket& b, node_ptr n)
    {
        node_ptr next = n->next_;
        node_ptr* pos = &next_group(n);
        if(*pos != n) {
            pos = &b.next_;
            while(*pos != n) pos = &next_group(*pos);
            if(next &&
                get(next).group_prev_ == n)
            {
                get(next).group_prev_ = get(n).group_prev_;
            }
        }
        else if(next &&
            get(next).group_prev_ == n)
        {
            get(next).group_prev_ = get(n).group_prev_;
        }
        else {
            node_ptr x = get(n).group_prev_;
            while(get(x).group_prev_ != n) {
                x = get(x).group_prev_;
            }
            get(x).group_prev_ = get(n).group_prev_;
        }
        *pos = next;
    }
    template <class A>
    void grouped_node_base<A>::unlink_nodes(bucket& b,
        node_ptr begin, node_ptr end)
    {
        node_ptr* pos = &next_group(begin);
        if(*pos != begin) {
            pos = &b.next_;
            while(*pos != begin) pos = &next_group(*pos);
            if(end) split_group(end);
        }
        else {
            node_ptr group1 = split_group(begin);
            if(end) {
                node_ptr group2 = split_group(end);
                if(begin == group2) {
                    node_ptr end1 = get(group1).group_prev_;
                    node_ptr end2 = get(group2).group_prev_;
                    get(group1).group_prev_ = end2;
                    get(group2).group_prev_ = end1;
                }
            }
        }
        *pos = end;
    }
    template <class A>
    void grouped_node_base<A>::unlink_nodes(bucket& b, node_ptr end)
    {
        split_group(end);
        b.next_ = end;
    }
}}
       
namespace boost { namespace unordered_detail {
    inline std::size_t double_to_size_t(double f)
    {
        return f >= static_cast<double>(
            (std::numeric_limits<std::size_t>::max)()) ?
            (std::numeric_limits<std::size_t>::max)() :
            static_cast<std::size_t>(f);
    }
    template<class T> struct prime_list_template
    {
        static std::size_t const value[];
        static std::ptrdiff_t const length;
    };
    template<class T>
    std::size_t const prime_list_template<T>::value[] = {
        5ul, 11ul, 17ul, 29ul, 37ul, 53ul, 67ul, 79ul, 97ul, 131ul, 193ul, 257ul, 389ul, 521ul, 769ul, 1031ul, 1543ul, 2053ul, 3079ul, 6151ul, 12289ul, 24593ul, 49157ul, 98317ul, 196613ul, 393241ul, 786433ul, 1572869ul, 3145739ul, 6291469ul, 12582917ul, 25165843ul, 50331653ul, 100663319ul, 201326611ul, 402653189ul, 805306457ul, 1610612741ul, 3221225473ul, 4294967291ul
    };
    template<class T>
    std::ptrdiff_t const prime_list_template<T>::length
        = 40;
    typedef prime_list_template<std::size_t> prime_list;
    inline std::size_t next_prime(std::size_t num) {
        std::size_t const* const prime_list_begin = prime_list::value;
        std::size_t const* const prime_list_end = prime_list_begin +
            prime_list::length;
        std::size_t const* bound =
            std::lower_bound(prime_list_begin, prime_list_end, num);
        if(bound == prime_list_end)
            bound--;
        return *bound;
    }
    inline std::size_t prev_prime(std::size_t num) {
        std::size_t const* const prime_list_begin = prime_list::value;
        std::size_t const* const prime_list_end = prime_list_begin +
            prime_list::length;
        std::size_t const* bound =
            std::upper_bound(prime_list_begin,prime_list_end, num);
        if(bound != prime_list_begin)
            bound--;
        return *bound;
    }
    template <class Dst1, class Dst2, class Src1, class Src2>
    inline std::pair<Dst1, Dst2> pair_cast(std::pair<Src1, Src2> const& x)
    {
        return std::pair<Dst1, Dst2>(Dst1(x.first), Dst2(x.second));
    }
    using ::std::distance;
    template <class I>
    inline std::size_t insert_size(I i, I j, boost::forward_traversal_tag)
    {
        return std::distance(i, j);
    }
    template <class I>
    inline std::size_t insert_size(I, I, boost::incrementable_traversal_tag)
    {
        return 1;
    }
    template <class I>
    inline std::size_t insert_size(I i, I j)
    {
        typename boost::iterator_traversal<I>::type
            iterator_traversal_tag;
        return insert_size(i, j, iterator_traversal_tag);
    }
    template <class I>
    inline std::size_t initial_size(I i, I j,
        std::size_t num_buckets = boost::unordered_detail::default_bucket_count)
    {
        return (std::max)(static_cast<std::size_t>(insert_size(i, j)) + 1,
            num_buckets);
    }
    template <class T, class... Args>
    inline void construct_impl(T*, void* address, Args&&... args)
    {
        new(address) T(std::forward<Args>(args)...);
    }
    template <class Alloc, class Grouped>
    class hash_node_constructor
    {
        typedef hash_buckets<Alloc, Grouped> buckets;
        typedef typename buckets::node node;
        typedef typename buckets::real_node_ptr real_node_ptr;
        typedef typename buckets::value_type value_type;
        buckets& buckets_;
        real_node_ptr node_;
        bool node_constructed_;
        bool value_constructed_;
    public:
        hash_node_constructor(buckets& m) :
            buckets_(m),
            node_(),
            node_constructed_(false),
            value_constructed_(false)
        {
        }
        ~hash_node_constructor();
        void construct_preamble();
        template <class... Args>
        void construct(Args&&... args)
        {
            construct_preamble();
            construct_impl((value_type*) 0, node_->address(),
                std::forward<Args>(args)...);
            value_constructed_ = true;
        }
        template <class K, class M>
        void construct_pair(K const& k, M*)
        {
            construct_preamble();
            new(node_->address()) value_type(k, M());
            value_constructed_ = true;
        }
        value_type& value() const
        {
            (__builtin_expect(!(node_), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/unordered/detail/util.hpp", 274, "node_") : (void)0);
            return node_->value();
        }
        typename buckets::node_ptr release()
        {
            real_node_ptr p = node_;
            node_ = real_node_ptr();
            return buckets_.bucket_alloc().address(*p);
        }
    private:
        hash_node_constructor(hash_node_constructor const&);
        hash_node_constructor& operator=(hash_node_constructor const&);
    };
    template <class Alloc, class Grouped>
    inline hash_node_constructor<Alloc, Grouped>::~hash_node_constructor()
    {
        if (node_) {
            if (value_constructed_) {
                boost::unordered_detail::destroy(node_->value_ptr());
            }
            if (node_constructed_)
                buckets_.node_alloc().destroy(node_);
            buckets_.node_alloc().deallocate(node_, 1);
        }
    }
    template <class Alloc, class Grouped>
    inline void hash_node_constructor<Alloc, Grouped>::construct_preamble()
    {
        if(!node_) {
            node_constructed_ = false;
            value_constructed_ = false;
            node_ = buckets_.node_alloc().allocate(1);
            buckets_.node_alloc().construct(node_, node());
            node_constructed_ = true;
        }
        else {
            (__builtin_expect(!(node_constructed_ && value_constructed_), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/unordered/detail/util.hpp", 324, "node_constructed_ && value_constructed_") : (void)0);
            boost::unordered_detail::destroy(node_->value_ptr());
            value_constructed_ = false;
        }
    }
}}
namespace boost { namespace unordered_detail {
    template <class A, class G>
    inline std::size_t hash_buckets<A, G>::max_bucket_count() const {
        return prev_prime(this->bucket_alloc().max_size() - 1);
    }
    template <class A, class G>
    inline typename hash_buckets<A, G>::bucket_ptr
        hash_buckets<A, G>::get_bucket(std::size_t num) const
    {
        return buckets_ + static_cast<std::ptrdiff_t>(num);
    }
    template <class A, class G>
    inline typename hash_buckets<A, G>::bucket_ptr
        hash_buckets<A, G>::bucket_ptr_from_hash(std::size_t hashed) const
    {
        return get_bucket(hashed % bucket_count_);
    }
    template <class A, class G>
    std::size_t hash_buckets<A, G>::bucket_size(std::size_t index) const
    {
        if(!buckets_) return 0;
        bucket_ptr ptr = get_bucket(index)->next_;
        std::size_t count = 0;
        while(ptr) {
            ++count;
            ptr = ptr->next_;
        }
        return count;
    }
    template <class A, class G>
    inline typename hash_buckets<A, G>::node_ptr
        hash_buckets<A, G>::bucket_begin(std::size_t num) const
    {
        return buckets_ ? get_bucket(num)->next_ : node_ptr();
    }
    template <class A, class G>
    inline void hash_buckets<A, G>::delete_node(node_ptr b)
    {
        node* raw_ptr = static_cast<node*>(&*b);
        boost::unordered_detail::destroy(raw_ptr->value_ptr());
        real_node_ptr n(node_alloc().address(*raw_ptr));
        node_alloc().destroy(n);
        node_alloc().deallocate(n, 1);
    }
    template <class A, class G>
    inline void hash_buckets<A, G>::clear_bucket(bucket_ptr b)
    {
        node_ptr node_it = b->next_;
        b->next_ = node_ptr();
        while(node_it) {
            node_ptr node_to_delete = node_it;
            node_it = node_it->next_;
            delete_node(node_to_delete);
        }
    }
    template <class A, class G>
    inline void hash_buckets<A, G>::delete_buckets()
    {
        bucket_ptr end = this->get_bucket(this->bucket_count_);
        for(bucket_ptr begin = this->buckets_; begin != end; ++begin) {
            clear_bucket(begin);
        }
        ++end;
        for(bucket_ptr begin = this->buckets_; begin != end; ++begin) {
            bucket_alloc().destroy(begin);
        }
        bucket_alloc().deallocate(this->buckets_, this->bucket_count_ + 1);
        this->buckets_ = bucket_ptr();
    }
    template <class A, class G>
    inline std::size_t hash_buckets<A, G>::delete_nodes(
        node_ptr begin, node_ptr end)
    {
        std::size_t count = 0;
        while(begin != end) {
            node_ptr n = begin;
            begin = begin->next_;
            delete_node(n);
            ++count;
        }
        return count;
    }
    template <class A, class G>
    inline hash_buckets<A, G>::hash_buckets(
        node_allocator const& a, std::size_t bucket_count)
      : buckets_(),
        bucket_count_(bucket_count),
        allocators_(a,a)
    {
    }
    template <class A, class G>
    inline hash_buckets<A, G>::~hash_buckets()
    {
        if(this->buckets_) { this->delete_buckets(); }
    }
    template <class A, class G>
    inline void hash_buckets<A, G>::create_buckets()
    {
        allocator_array_constructor<bucket_allocator>
            constructor(bucket_alloc());
        constructor.construct(bucket(), this->bucket_count_ + 1);
        bucket_ptr sentinel = constructor.get() +
            static_cast<std::ptrdiff_t>(this->bucket_count_);
        sentinel->next_ = sentinel;
        this->buckets_ = constructor.release();
    }
    template <class A, class G>
    inline void hash_buckets<A, G>::move(hash_buckets& other)
    {
        (__builtin_expect(!(node_alloc() == other.node_alloc()), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/unordered/detail/buckets.hpp", 166, "node_alloc() == other.node_alloc()") : (void)0);
        if(this->buckets_) { this->delete_buckets(); }
        this->buckets_ = other.buckets_;
        this->bucket_count_ = other.bucket_count_;
        other.buckets_ = bucket_ptr();
        other.bucket_count_ = 0;
    }
    template <class A, class G>
    inline void hash_buckets<A, G>::swap(hash_buckets<A, G>& other)
    {
        (__builtin_expect(!(node_alloc() == other.node_alloc()), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/unordered/detail/buckets.hpp", 177, "node_alloc() == other.node_alloc()") : (void)0);
        std::swap(buckets_, other.buckets_);
        std::swap(bucket_count_, other.bucket_count_);
    }
}}
namespace boost { namespace unordered_detail {
    template <class T>
    inline bool hash_table<T>::equal(
        key_type const& k, value_type const& v) const
    {
        return this->key_eq()(k, get_key(v));
    }
    template <class T>
    template <class Key, class Pred>
    inline typename T::node_ptr
        hash_table<T>::find_iterator(bucket_ptr bucket, Key const& k,
            Pred const& eq) const
    {
        node_ptr it = bucket->next_;
        while (it &&
            !eq(k, get_key(node::get_value(it))))
        {
            it = node::next_group(it);
        }
        return it;
    }
    template <class T>
    inline typename T::node_ptr
        hash_table<T>::find_iterator(
            bucket_ptr bucket, key_type const& k) const
    {
        node_ptr it = bucket->next_;
        while (it &&
            !equal(k, node::get_value(it)))
        {
            it = node::next_group(it);
        }
        return it;
    }
    template <class T>
    inline typename T::node_ptr
        hash_table<T>::find_iterator(key_type const& k) const
    {
        return find_iterator(this->get_bucket(this->bucket_index(k)), k);
    }
    template <class T>
    inline typename T::node_ptr*
        hash_table<T>::find_for_erase(
            bucket_ptr bucket, key_type const& k) const
    {
        node_ptr* it = &bucket->next_;
        while(*it &&
            !equal(k, node::get_value(*it)))
        {
            it = &node::next_group(*it);
        }
        return it;
    }
    template <class T>
    std::size_t hash_table<T>::max_size() const
    {
        using namespace std;
        return double_to_size_t(ceil(
                (double) this->mlf_ * this->max_bucket_count())) - 1;
    }
    template <class T>
    inline std::size_t hash_table<T>::bucket_index(
        key_type const& k) const
    {
        return this->hash_function()(k) % this->bucket_count_;
    }
    template <class T>
    inline std::size_t hash_table<T>::calculate_max_load()
    {
        using namespace std;
        return double_to_size_t(ceil((double) mlf_ * this->bucket_count_));
    }
    template <class T>
    void hash_table<T>::max_load_factor(float z)
    {
        (__builtin_expect(!(z > 0), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/unordered/detail/table.hpp", 128, "z > 0") : (void)0);
        mlf_ = (std::max)(z, minimum_max_load_factor);
        this->max_load_ = this->calculate_max_load();
    }
    template <class T>
    inline std::size_t hash_table<T>::min_buckets_for_size(
        std::size_t size) const
    {
        (__builtin_expect(!(this->mlf_ != 0), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/unordered/detail/table.hpp", 138, "this->mlf_ != 0") : (void)0);
        using namespace std;
        return next_prime(double_to_size_t(floor(size / (double) mlf_)) + 1);
    }
    template <class T>
    inline void hash_table<T>::init_buckets()
    {
        if (this->size_) {
            this->cached_begin_bucket_ = this->buckets_;
            while (!this->cached_begin_bucket_->next_)
                ++this->cached_begin_bucket_;
        } else {
            this->cached_begin_bucket_ = this->get_bucket(this->bucket_count_);
        }
        this->max_load_ = calculate_max_load();
    }
    template <class T>
    inline void hash_table<T>::recompute_begin_bucket(bucket_ptr b)
    {
        (__builtin_expect(!(!(b < this->cached_begin_bucket_)), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/unordered/detail/table.hpp", 177, "!(b < this->cached_begin_bucket_)") : (void)0);
        if(b == this->cached_begin_bucket_)
        {
            if (this->size_ != 0) {
                while (!this->cached_begin_bucket_->next_)
                    ++this->cached_begin_bucket_;
            } else {
                this->cached_begin_bucket_ =
                    this->get_bucket(this->bucket_count_);
            }
        }
    }
    template <class T>
    inline void hash_table<T>::recompute_begin_bucket(
        bucket_ptr b1, bucket_ptr b2)
    {
        (__builtin_expect(!(!(b1 < this->cached_begin_bucket_) && !(b2 < b1)), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/unordered/detail/table.hpp", 199, "!(b1 < this->cached_begin_bucket_) && !(b2 < b1)") : (void)0);
        (__builtin_expect(!(b2->next_), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/unordered/detail/table.hpp", 200, "b2->next_") : (void)0);
        if(b1 == this->cached_begin_bucket_ && !b1->next_)
            this->cached_begin_bucket_ = b2;
    }
    template <class T>
    inline float hash_table<T>::load_factor() const
    {
        (__builtin_expect(!(this->bucket_count_ != 0), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/unordered/detail/table.hpp", 210, "this->bucket_count_ != 0") : (void)0);
        return static_cast<float>(this->size_)
            / static_cast<float>(this->bucket_count_);
    }
    template <class T>
    hash_table<T>::hash_table(std::size_t num_buckets,
        hasher const& hf, key_equal const& eq, node_allocator const& a)
      : buckets(a, next_prime(num_buckets)),
        base(hf, eq),
        size_(),
        mlf_(1.0f),
        cached_begin_bucket_(),
        max_load_(0)
    {
    }
    template <class T>
    hash_table<T>::hash_table(hash_table const& x,
        node_allocator const& a)
      : buckets(a, x.min_buckets_for_size(x.size_)),
        base(x),
        size_(x.size_),
        mlf_(x.mlf_),
        cached_begin_bucket_(),
        max_load_(0)
    {
        if(x.size_) {
            x.copy_buckets_to(*this);
            this->init_buckets();
        }
    }
    template <class T>
    hash_table<T>::hash_table(hash_table& x, move_tag)
      : buckets(x.node_alloc(), x.bucket_count_),
        base(x),
        size_(0),
        mlf_(1.0f),
        cached_begin_bucket_(),
        max_load_(0)
    {
        this->partial_swap(x);
    }
    template <class T>
    hash_table<T>::hash_table(hash_table& x,
        node_allocator const& a, move_tag)
      : buckets(a, x.bucket_count_),
        base(x),
        size_(0),
        mlf_(x.mlf_),
        cached_begin_bucket_(),
        max_load_(0)
    {
        if(a == x.node_alloc()) {
            this->partial_swap(x);
        }
        else if(x.size_) {
            x.copy_buckets_to(*this);
            this->size_ = x.size_;
            this->init_buckets();
        }
    }
    template <class T>
    hash_table<T>& hash_table<T>::operator=(
        hash_table const& x)
    {
        hash_table tmp(x, this->node_alloc());
        this->fast_swap(tmp);
        return *this;
    }
    template <class T>
    inline void hash_table<T>::partial_swap(hash_table& x)
    {
        this->buckets::swap(x);
        std::swap(this->size_, x.size_);
        std::swap(this->mlf_, x.mlf_);
        std::swap(this->cached_begin_bucket_, x.cached_begin_bucket_);
        std::swap(this->max_load_, x.max_load_);
    }
    template <class T>
    inline void hash_table<T>::fast_swap(hash_table& x)
    {
        {
            set_hash_functions<hasher, key_equal> op1(*this, x);
            set_hash_functions<hasher, key_equal> op2(x, *this);
            op1.commit();
            op2.commit();
        }
        this->buckets::swap(x);
        std::swap(this->size_, x.size_);
        std::swap(this->mlf_, x.mlf_);
        std::swap(this->cached_begin_bucket_, x.cached_begin_bucket_);
        std::swap(this->max_load_, x.max_load_);
    }
    template <class T>
    inline void hash_table<T>::slow_swap(hash_table& x)
    {
        if(this == &x) return;
        {
            set_hash_functions<hasher, key_equal> op1(*this, x);
            set_hash_functions<hasher, key_equal> op2(x, *this);
            buckets b1(this->node_alloc(), x.min_buckets_for_size(x.size_));
            if(x.size_) x.copy_buckets_to(b1);
            buckets b2(x.node_alloc(), this->min_buckets_for_size(this->size_));
            if(this->size_) copy_buckets_to(b2);
            b1.swap(*this);
            b2.swap(x);
            op1.commit();
            op2.commit();
        }
        std::swap(this->size_, x.size_);
        if(this->buckets_) this->init_buckets();
        if(x.buckets_) x.init_buckets();
    }
    template <class T>
    void hash_table<T>::swap(hash_table& x)
    {
        if(this->node_alloc() == x.node_alloc()) {
            if(this != &x) this->fast_swap(x);
        }
        else {
            this->slow_swap(x);
        }
    }
    template <class T>
    void hash_table<T>::move(hash_table& x)
    {
        set_hash_functions<hasher, key_equal> new_func_this(*this, x);
        if(this->node_alloc() == x.node_alloc()) {
            this->buckets::move(x);
            this->size_ = x.size_;
            this->cached_begin_bucket_ = x.cached_begin_bucket_;
            this->max_load_ = x.max_load_;
            x.size_ = 0;
        }
        else {
            buckets b(this->node_alloc(), x.min_buckets_for_size(x.size_));
            if(x.size_) x.copy_buckets_to(b);
            this->size_ = x.size_;
            b.swap(*this);
            this->init_buckets();
        }
        this->mlf_ = x.mlf_;
        new_func_this.commit();
    }
    template <class T>
    inline void hash_table<T>::create_for_insert(std::size_t size)
    {
        this->bucket_count_ = (std::max)(this->bucket_count_,
            this->min_buckets_for_size(size));
        this->create_buckets();
        this->init_buckets();
    }
    template <class T>
    inline bool hash_table<T>::reserve_for_insert(std::size_t size)
    {
        if(size >= max_load_) {
            std::size_t num_buckets
                = this->min_buckets_for_size((std::max)(size,
                    this->size_ + (this->size_ >> 1)));
            if(num_buckets != this->bucket_count_) {
                rehash_impl(num_buckets);
                return true;
            }
        }
        return false;
    }
    template <class T>
    inline void hash_table<T>::rehash(std::size_t min_buckets)
    {
        using namespace std;
        if(!this->size_) {
            if(this->buckets_) this->delete_buckets();
            this->bucket_count_ = next_prime(min_buckets);
        }
        else {
            min_buckets = next_prime((std::max)(min_buckets,
                    double_to_size_t(floor(this->size_ / (double) mlf_)) + 1));
            if(min_buckets != this->bucket_count_) rehash_impl(min_buckets);
        }
    }
    template <class T>
    void hash_table<T>
        ::rehash_impl(std::size_t num_buckets)
    {
        hasher const& hf = this->hash_function();
        std::size_t size = this->size_;
        bucket_ptr end = this->get_bucket(this->bucket_count_);
        buckets dst(this->node_alloc(), num_buckets);
        dst.create_buckets();
        buckets src(this->node_alloc(), this->bucket_count_);
        src.swap(*this);
        this->size_ = 0;
        for(bucket_ptr bucket = this->cached_begin_bucket_;
            bucket != end; ++bucket)
        {
            node_ptr group = bucket->next_;
            while(group) {
                bucket_ptr dst_bucket = dst.bucket_ptr_from_hash(
                    hf(get_key_from_ptr(group)));
                node_ptr& next_group = node::next_group(group);
                bucket->next_ = next_group;
                next_group = dst_bucket->next_;
                dst_bucket->next_ = group;
                group = bucket->next_;
            }
        }
        this->size_ = size;
        dst.swap(*this);
        this->init_buckets();
    }
    template <class T>
    void hash_table<T>
        ::copy_buckets_to(buckets& dst) const
    {
        (__builtin_expect(!(this->buckets_ && !dst.buckets_), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/unordered/detail/table.hpp", 525, "this->buckets_ && !dst.buckets_") : (void)0);
        hasher const& hf = this->hash_function();
        bucket_ptr end = this->get_bucket(this->bucket_count_);
        node_constructor a(dst);
        dst.create_buckets();
        for(bucket_ptr i = this->cached_begin_bucket_; i != end; ++i) {
            for(node_ptr it = i->next_; it;) {
                bucket_ptr dst_bucket = dst.bucket_ptr_from_hash(
                    hf(get_key_from_ptr(it)));
                node_ptr group_end = node::next_group(it);
                a.construct(node::get_value(it));
                node_ptr n = a.release();
                node::add_to_bucket(n, *dst_bucket);
                for(it = it->next_; it != group_end; it = it->next_) {
                    a.construct(node::get_value(it));
                    node::add_after_node(a.release(), n);
                }
            }
        }
    }
    template <class T>
    std::size_t hash_table<T>::count(key_type const& k) const
    {
        if(!this->size_) return 0;
        node_ptr it = find_iterator(k);
        return it ? node::group_count(it) : 0;
    }
    template <class T>
    typename T::iterator_base
        hash_table<T>::find(key_type const& k) const
    {
        if(!this->size_) return this->end();
        bucket_ptr bucket = this->get_bucket(this->bucket_index(k));
        node_ptr it = find_iterator(bucket, k);
        if (it)
            return iterator_base(bucket, it);
        else
            return this->end();
    }
    template <class T>
    template <class Key, class Hash, class Pred>
    typename T::iterator_base hash_table<T>::find(Key const& k,
        Hash const& h, Pred const& eq) const
    {
        if(!this->size_) return this->end();
        bucket_ptr bucket = this->get_bucket(h(k) % this->bucket_count_);
        node_ptr it = find_iterator(bucket, k, eq);
        if (it)
            return iterator_base(bucket, it);
        else
            return this->end();
    }
    template <class T>
    typename T::value_type&
        hash_table<T>::at(key_type const& k) const
    {
        if(!this->size_)
            boost::throw_exception(std::out_of_range("Unable to find key in unordered_map."));
        bucket_ptr bucket = this->get_bucket(this->bucket_index(k));
        node_ptr it = find_iterator(bucket, k);
        if (!it)
            boost::throw_exception(std::out_of_range("Unable to find key in unordered_map."));
        return node::get_value(it);
    }
    template <class T>
    typename T::iterator_pair
        hash_table<T>::equal_range(key_type const& k) const
    {
        if(!this->size_)
            return iterator_pair(this->end(), this->end());
        bucket_ptr bucket = this->get_bucket(this->bucket_index(k));
        node_ptr it = find_iterator(bucket, k);
        if (it) {
            iterator_base first(iterator_base(bucket, it));
            iterator_base second(first);
            second.increment_bucket(node::next_group(second.node_));
            return iterator_pair(first, second);
        }
        else {
            return iterator_pair(this->end(), this->end());
        }
    }
    template <class T>
    void hash_table<T>::clear()
    {
        if(!this->size_) return;
        bucket_ptr end = this->get_bucket(this->bucket_count_);
        for(bucket_ptr begin = this->buckets_; begin != end; ++begin) {
            this->clear_bucket(begin);
        }
        this->size_ = 0;
        this->cached_begin_bucket_ = end;
    }
    template <class T>
    inline std::size_t hash_table<T>::erase_group(
        node_ptr* it, bucket_ptr bucket)
    {
        node_ptr pos = *it;
        node_ptr end = node::next_group(pos);
        *it = end;
        std::size_t count = this->delete_nodes(pos, end);
        this->size_ -= count;
        this->recompute_begin_bucket(bucket);
        return count;
    }
    template <class T>
    std::size_t hash_table<T>::erase_key(key_type const& k)
    {
        if(!this->size_) return 0;
        bucket_ptr bucket = this->get_bucket(this->bucket_index(k));
        node_ptr* it = this->find_for_erase(bucket, k);
        return *it ? this->erase_group(it, bucket) : 0;
    }
    template <class T>
    void hash_table<T>::erase(iterator_base r)
    {
        (__builtin_expect(!(r.node_), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/unordered/detail/table.hpp", 692, "r.node_") : (void)0);
        --this->size_;
        node::unlink_node(*r.bucket_, r.node_);
        this->delete_node(r.node_);
        this->recompute_begin_bucket(r.bucket_);
    }
    template <class T>
    typename T::iterator_base
        hash_table<T>::erase_return_iterator(iterator_base r)
    {
        (__builtin_expect(!(r.node_), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/unordered/detail/table.hpp", 704, "r.node_") : (void)0);
        iterator_base next = r;
        next.increment();
        --this->size_;
        node::unlink_node(*r.bucket_, r.node_);
        this->delete_node(r.node_);
        this->recompute_begin_bucket(r.bucket_, next.bucket_);
        return next;
    }
    template <class T>
    typename T::iterator_base
        hash_table<T>::erase_range(
            iterator_base r1, iterator_base r2)
    {
        if(r1 != r2)
        {
            (__builtin_expect(!(r1.node_), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/unordered/detail/table.hpp", 722, "r1.node_") : (void)0);
            if (r1.bucket_ == r2.bucket_) {
                node::unlink_nodes(*r1.bucket_, r1.node_, r2.node_);
                this->size_ -= this->delete_nodes(r1.node_, r2.node_);
                 (__builtin_expect(!(r1.bucket_->next_), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/unordered/detail/table.hpp", 730, "r1.bucket_->next_") : (void)0);
            }
            else {
                bucket_ptr end_bucket = r2.node_ ?
                    r2.bucket_ : this->get_bucket(this->bucket_count_);
                (__builtin_expect(!(r1.bucket_ < end_bucket), 0) ? __assert_rtn(__FUNCTION__, "/usr/local/include/boost/unordered/detail/table.hpp", 735, "r1.bucket_ < end_bucket") : (void)0);
                node::unlink_nodes(*r1.bucket_, r1.node_, node_ptr());
                this->size_ -= this->delete_nodes(r1.node_, node_ptr());
                bucket_ptr i = r1.bucket_;
                for(++i; i != end_bucket; ++i) {
                    this->size_ -= this->delete_nodes(i->next_, node_ptr());
                    i->next_ = node_ptr();
                }
                if(r2.node_) {
                    node_ptr first = r2.bucket_->next_;
                    node::unlink_nodes(*r2.bucket_, r2.node_);
                    this->size_ -= this->delete_nodes(first, r2.node_);
                }
                this->recompute_begin_bucket(r1.bucket_, end_bucket);
            }
        }
        return r2;
    }
    template <class T>
    typename hash_table<T>::iterator_base
        hash_table<T>::emplace_empty_impl_with_node(
            node_constructor& a, std::size_t size)
    {
        key_type const& k = get_key(a.value());
        std::size_t hash_value = this->hash_function()(k);
        if(this->buckets_) this->reserve_for_insert(size);
        else this->create_for_insert(size);
        bucket_ptr bucket = this->bucket_ptr_from_hash(hash_value);
        node_ptr n = a.release();
        node::add_to_bucket(n, *bucket);
        ++this->size_;
        this->cached_begin_bucket_ = bucket;
        return iterator_base(bucket, n);
    }
}}
namespace boost {
namespace unordered_detail {
    struct no_key {
        no_key() {}
        template <class T> no_key(T const&) {}
    };
    template <class ValueType>
    struct set_extractor
    {
        typedef ValueType value_type;
        typedef ValueType key_type;
        static key_type const& extract(key_type const& v)
        {
            return v;
        }
        static no_key extract()
        {
            return no_key();
        }
        template <class... Args>
        static no_key extract(Args const&...)
        {
            return no_key();
        }
        static bool compare_mapped(value_type const&, value_type const&)
        {
            return true;
        }
    };
    template <class Key, class ValueType>
    struct map_extractor
    {
        typedef ValueType value_type;
        typedef typename boost::remove_const<Key>::type key_type;
        static key_type const& extract(value_type const& v)
        {
            return v.first;
        }
        static key_type const& extract(key_type const& v)
        {
            return v;
        }
        template <class Second>
        static key_type const& extract(std::pair<key_type, Second> const& v)
        {
            return v.first;
        }
        template <class Second>
        static key_type const& extract(
            std::pair<key_type const, Second> const& v)
        {
            return v.first;
        }
        template <class Arg1, class... Args>
        static key_type const& extract(key_type const& k,
            Arg1 const&, Args const&...)
        {
            return k;
        }
        template <class... Args>
        static no_key extract(Args const&...)
        {
            return no_key();
        }
        static bool compare_mapped(value_type const& x, value_type const& y)
        {
            return x.second == y.second;
        }
    };
}}
namespace boost { namespace unordered_detail {
    template <class T>
    class hash_equivalent_table : public T::table
    {
    public:
        typedef typename T::hasher hasher;
        typedef typename T::key_equal key_equal;
        typedef typename T::value_allocator value_allocator;
        typedef typename T::key_type key_type;
        typedef typename T::value_type value_type;
        typedef typename T::table table;
        typedef typename T::node_constructor node_constructor;
        typedef typename T::node node;
        typedef typename T::node_ptr node_ptr;
        typedef typename T::bucket_ptr bucket_ptr;
        typedef typename T::iterator_base iterator_base;
        typedef typename T::extractor extractor;
        hash_equivalent_table(std::size_t n,
            hasher const& hf, key_equal const& eq, value_allocator const& a)
          : table(n, hf, eq, a) {}
        hash_equivalent_table(hash_equivalent_table const& x)
          : table(x, x.node_alloc()) {}
        hash_equivalent_table(hash_equivalent_table const& x,
            value_allocator const& a)
          : table(x, a) {}
        hash_equivalent_table(hash_equivalent_table& x, move_tag m)
          : table(x, m) {}
        hash_equivalent_table(hash_equivalent_table& x,
            value_allocator const& a, move_tag m)
          : table(x, a, m) {}
        ~hash_equivalent_table() {}
        iterator_base emplace_impl(node_constructor& a);
        void emplace_impl_no_rehash(node_constructor& a);
        bool equals(hash_equivalent_table const&) const;
        inline node_ptr add_node(node_constructor& a,
            bucket_ptr bucket, node_ptr pos);
        template <class... Args>
        iterator_base emplace(Args&&... args);
        template <class I>
        void insert_for_range(I i, I j, forward_traversal_tag);
        template <class I>
        void insert_for_range(I i, I j, boost::incrementable_traversal_tag);
        template <class I>
        void insert_range(I i, I j);
    };
    template <class H, class P, class A>
    struct multiset : public types<
        typename A::value_type,
        typename A::value_type,
        H, P, A,
        set_extractor<typename A::value_type>,
        grouped>
    {
        typedef hash_equivalent_table<multiset<H, P, A> > impl;
        typedef hash_table<multiset<H, P, A> > table;
    };
    template <class K, class H, class P, class A>
    struct multimap : public types<
        K, typename A::value_type,
        H, P, A,
        map_extractor<K, typename A::value_type>,
        grouped>
    {
        typedef hash_equivalent_table<multimap<K, H, P, A> > impl;
        typedef hash_table<multimap<K, H, P, A> > table;
    };
    template <class T>
    bool hash_equivalent_table<T>
        ::equals(hash_equivalent_table<T> const& other) const
    {
        if(this->size_ != other.size_) return false;
        if(!this->size_) return true;
        bucket_ptr end = this->get_bucket(this->bucket_count_);
        for(bucket_ptr i = this->cached_begin_bucket_; i != end; ++i)
        {
            node_ptr it1 = i->next_;
            while(it1)
            {
                node_ptr it2 = other.find_iterator(this->get_key_from_ptr(it1));
                if(!it2) return false;
                node_ptr end1 = node::next_group(it1);
                node_ptr end2 = node::next_group(it2);
                do {
                    if(!extractor::compare_mapped(
                        node::get_value(it1), node::get_value(it2)))
                        return false;
                    it1 = it1->next_;
                    it2 = it2->next_;
                } while(it1 != end1 && it2 != end2);
                if(it1 != end1 || it2 != end2) return false;
            }
        }
        return true;
    }
    template <class T>
    inline typename hash_equivalent_table<T>::node_ptr
        hash_equivalent_table<T>
            ::add_node(node_constructor& a, bucket_ptr bucket, node_ptr pos)
    {
        node_ptr n = a.release();
        if(pos) {
            node::add_after_node(n, pos);
        }
        else {
            node::add_to_bucket(n, *bucket);
            if(bucket < this->cached_begin_bucket_)
                this->cached_begin_bucket_ = bucket;
        }
        ++this->size_;
        return n;
    }
    template <class T>
    inline typename
        hash_equivalent_table<T>::iterator_base
        hash_equivalent_table<T>::emplace_impl(node_constructor& a)
    {
        key_type const& k = this->get_key(a.value());
        std::size_t hash_value = this->hash_function()(k);
        if(!this->size_) {
            return this->emplace_empty_impl_with_node(a, 1);
        }
        else {
            bucket_ptr bucket = this->bucket_ptr_from_hash(hash_value);
            node_ptr position = this->find_iterator(bucket, k);
            if(this->reserve_for_insert(this->size_ + 1))
                bucket = this->bucket_ptr_from_hash(hash_value);
            return iterator_base(bucket, add_node(a, bucket, position));
        }
    }
    template <class T>
    inline void hash_equivalent_table<T>
            ::emplace_impl_no_rehash(node_constructor& a)
    {
        key_type const& k = this->get_key(a.value());
        bucket_ptr bucket = this->get_bucket(this->bucket_index(k));
        add_node(a, bucket, this->find_iterator(bucket, k));
    }
    template <class T>
    template <class... Args>
    typename hash_equivalent_table<T>::iterator_base
        hash_equivalent_table<T>
            ::emplace(Args&&... args)
    {
        node_constructor a(*this);
        a.construct(std::forward<Args>(args)...);
        return emplace_impl(a);
    }
    template <class T>
    template <class I>
    inline void hash_equivalent_table<T>
        ::insert_for_range(I i, I j, forward_traversal_tag)
    {
        if(i == j) return;
        std::size_t distance = unordered_detail::distance(i, j);
        if(distance == 1) {
            emplace(*i);
        }
        else {
            node_constructor a(*this);
            if(this->size_) {
                this->reserve_for_insert(this->size_ + distance);
            }
            else {
                a.construct(*i++);
                this->emplace_empty_impl_with_node(a, distance);
            }
            for (; i != j; ++i) {
                a.construct(*i);
                emplace_impl_no_rehash(a);
            }
        }
    }
    template <class T>
    template <class I>
    inline void hash_equivalent_table<T>
        ::insert_for_range(I i, I j, boost::incrementable_traversal_tag)
    {
        node_constructor a(*this);
        for (; i != j; ++i) {
            a.construct(*i);
            emplace_impl(a);
        }
    }
    template <class T>
    template <class I>
    void hash_equivalent_table<T>::insert_range(I i, I j)
    {
        typename boost::iterator_traversal<I>::type
            iterator_traversal_tag;
        insert_for_range(i, j, iterator_traversal_tag);
    }
}}
namespace boost { namespace unordered_detail {
    template <class T>
    class hash_unique_table : public T::table
    {
    public:
        typedef typename T::hasher hasher;
        typedef typename T::key_equal key_equal;
        typedef typename T::value_allocator value_allocator;
        typedef typename T::key_type key_type;
        typedef typename T::value_type value_type;
        typedef typename T::table table;
        typedef typename T::node_constructor node_constructor;
        typedef typename T::node node;
        typedef typename T::node_ptr node_ptr;
        typedef typename T::bucket_ptr bucket_ptr;
        typedef typename T::iterator_base iterator_base;
        typedef typename T::extractor extractor;
        typedef std::pair<iterator_base, bool> emplace_return;
        hash_unique_table(std::size_t n, hasher const& hf, key_equal const& eq,
            value_allocator const& a)
          : table(n, hf, eq, a) {}
        hash_unique_table(hash_unique_table const& x)
          : table(x, x.node_alloc()) {}
        hash_unique_table(hash_unique_table const& x, value_allocator const& a)
          : table(x, a) {}
        hash_unique_table(hash_unique_table& x, move_tag m)
          : table(x, m) {}
        hash_unique_table(hash_unique_table& x, value_allocator const& a,
            move_tag m)
          : table(x, a, m) {}
        ~hash_unique_table() {}
        emplace_return emplace_impl_with_node(node_constructor& a);
        value_type& operator[](key_type const& k);
        bool equals(hash_unique_table const&) const;
        node_ptr add_node(node_constructor& a, bucket_ptr bucket);
        template<class... Args>
        emplace_return emplace(Args&&... args);
        template<class... Args>
        emplace_return emplace_impl(key_type const& k, Args&&... args);
        template<class... Args>
        emplace_return emplace_impl(no_key, Args&&... args);
        template<class... Args>
        emplace_return emplace_empty_impl(Args&&... args);
        template <class InputIt>
        void insert_range(InputIt i, InputIt j);
        template <class InputIt>
        void insert_range_impl(key_type const&, InputIt i, InputIt j);
        template <class InputIt>
        void insert_range_impl2(node_constructor&, key_type const&, InputIt i, InputIt j);
        template <class InputIt>
        void insert_range_impl(no_key, InputIt i, InputIt j);
    };
    template <class H, class P, class A>
    struct set : public types<
        typename A::value_type,
        typename A::value_type,
        H, P, A,
        set_extractor<typename A::value_type>,
        ungrouped>
    {
        typedef hash_unique_table<set<H, P, A> > impl;
        typedef hash_table<set<H, P, A> > table;
    };
    template <class K, class H, class P, class A>
    struct map : public types<
        K, typename A::value_type,
        H, P, A,
        map_extractor<K, typename A::value_type>,
        ungrouped>
    {
        typedef hash_unique_table<map<K, H, P, A> > impl;
        typedef hash_table<map<K, H, P, A> > table;
    };
    template <class T>
    bool hash_unique_table<T>
        ::equals(hash_unique_table<T> const& other) const
    {
        if(this->size_ != other.size_) return false;
        if(!this->size_) return true;
        bucket_ptr end = this->get_bucket(this->bucket_count_);
        for(bucket_ptr i = this->cached_begin_bucket_; i != end; ++i)
        {
            node_ptr it1 = i->next_;
            while(it1)
            {
                node_ptr it2 = other.find_iterator(this->get_key_from_ptr(it1));
                if(!it2) return false;
                if(!extractor::compare_mapped(
                    node::get_value(it1), node::get_value(it2)))
                    return false;
                it1 = it1->next_;
            }
        }
        return true;
    }
    template <class T>
    inline typename hash_unique_table<T>::node_ptr
        hash_unique_table<T>::add_node(node_constructor& a,
            bucket_ptr bucket)
    {
        node_ptr n = a.release();
        node::add_to_bucket(n, *bucket);
        ++this->size_;
        if(bucket < this->cached_begin_bucket_)
            this->cached_begin_bucket_ = bucket;
        return n;
    }
    template <class T>
    typename hash_unique_table<T>::value_type&
        hash_unique_table<T>::operator[](key_type const& k)
    {
        typedef typename value_type::second_type mapped_type;
        std::size_t hash_value = this->hash_function()(k);
        bucket_ptr bucket = this->bucket_ptr_from_hash(hash_value);
        if(!this->buckets_) {
            node_constructor a(*this);
            a.construct_pair(k, (mapped_type*) 0);
            return *this->emplace_empty_impl_with_node(a, 1);
        }
        node_ptr pos = this->find_iterator(bucket, k);
        if (pos) {
            return node::get_value(pos);
        }
        else {
            node_constructor a(*this);
            a.construct_pair(k, (mapped_type*) 0);
            if(this->reserve_for_insert(this->size_ + 1))
                bucket = this->bucket_ptr_from_hash(hash_value);
            return node::get_value(add_node(a, bucket));
        }
    }
    template <class T>
    inline typename hash_unique_table<T>::emplace_return
    hash_unique_table<T>::emplace_impl_with_node(node_constructor& a)
    {
        key_type const& k = this->get_key(a.value());
        std::size_t hash_value = this->hash_function()(k);
        bucket_ptr bucket = this->bucket_ptr_from_hash(hash_value);
        node_ptr pos = this->find_iterator(bucket, k);
        if (pos) {
            return emplace_return(iterator_base(bucket, pos), false);
        } else {
            if(this->reserve_for_insert(this->size_ + 1))
                bucket = this->bucket_ptr_from_hash(hash_value);
            return emplace_return(
                iterator_base(bucket, add_node(a, bucket)),
                true);
        }
    }
    template <class T>
    template<class... Args>
    inline typename hash_unique_table<T>::emplace_return
        hash_unique_table<T>::emplace_impl(key_type const& k,
            Args&&... args)
    {
        std::size_t hash_value = this->hash_function()(k);
        bucket_ptr bucket = this->bucket_ptr_from_hash(hash_value);
        node_ptr pos = this->find_iterator(bucket, k);
        if (pos) {
            return emplace_return(iterator_base(bucket, pos), false);
        } else {
            node_constructor a(*this);
            a.construct(std::forward<Args>(args)...);
            if(this->reserve_for_insert(this->size_ + 1))
                bucket = this->bucket_ptr_from_hash(hash_value);
            return emplace_return(
                iterator_base(bucket, add_node(a, bucket)),
                true);
        }
    }
    template <class T>
    template<class... Args>
    inline typename hash_unique_table<T>::emplace_return
        hash_unique_table<T>::emplace_impl(no_key, Args&&... args)
    {
        node_constructor a(*this);
        a.construct(std::forward<Args>(args)...);
        return emplace_impl_with_node(a);
    }
    template <class T>
    template<class... Args>
    inline typename hash_unique_table<T>::emplace_return
        hash_unique_table<T>::emplace_empty_impl(Args&&... args)
    {
        node_constructor a(*this);
        a.construct(std::forward<Args>(args)...);
        return emplace_return(this->emplace_empty_impl_with_node(a, 1), true);
    }
    template <class T>
    template<class... Args>
    typename hash_unique_table<T>::emplace_return
        hash_unique_table<T>::emplace(Args&&... args)
    {
        return this->size_ ?
            emplace_impl(
                extractor::extract(std::forward<Args>(args)...),
                std::forward<Args>(args)...) :
            emplace_empty_impl(std::forward<Args>(args)...);
    }
    template <class T>
    template <class InputIt>
    inline void hash_unique_table<T>::insert_range_impl2(
        node_constructor& a, key_type const& k, InputIt i, InputIt j)
    {
        std::size_t hash_value = this->hash_function()(k);
        bucket_ptr bucket = this->bucket_ptr_from_hash(hash_value);
        node_ptr pos = this->find_iterator(bucket, k);
        if (!pos) {
            a.construct(*i);
            if(this->size_ + 1 >= this->max_load_) {
                this->reserve_for_insert(this->size_ + insert_size(i, j));
                bucket = this->bucket_ptr_from_hash(hash_value);
            }
            add_node(a, bucket);
        }
    }
    template <class T>
    template <class InputIt>
    inline void hash_unique_table<T>::insert_range_impl(
        key_type const&, InputIt i, InputIt j)
    {
        node_constructor a(*this);
        if(!this->size_) {
            a.construct(*i);
            this->emplace_empty_impl_with_node(a, 1);
            ++i;
            if(i == j) return;
        }
        do {
            insert_range_impl2(a, extractor::extract(*i), i, j);
        } while(++i != j);
    }
    template <class T>
    template <class InputIt>
    inline void hash_unique_table<T>::insert_range_impl(
        no_key, InputIt i, InputIt j)
    {
        node_constructor a(*this);
        if(!this->size_) {
            a.construct(*i);
            this->emplace_empty_impl_with_node(a, 1);
            ++i;
            if(i == j) return;
        }
        do {
            a.construct(*i);
            emplace_impl_with_node(a);
        } while(++i != j);
    }
    template <class T>
    template <class InputIt>
    void hash_unique_table<T>::insert_range(InputIt i, InputIt j)
    {
        if(i != j)
            return insert_range_impl(extractor::extract(*i), i, j);
    }
}}
namespace boost
{
    template <class K, class T, class H, class P, class A>
    class unordered_map
    {
    public:
        typedef K key_type;
        typedef std::pair<const K, T> value_type;
        typedef T mapped_type;
        typedef H hasher;
        typedef P key_equal;
        typedef A allocator_type;
    private:
        typedef typename
            boost::unordered_detail::rebind_wrap<
                allocator_type, value_type>::type
            value_allocator;
        typedef boost::unordered_detail::map<K, H, P,
            value_allocator> types;
        typedef typename types::impl table;
        typedef typename types::iterator_base iterator_base;
    public:
        typedef typename
            value_allocator::pointer pointer;
        typedef typename
            value_allocator::const_pointer const_pointer;
        typedef typename
            value_allocator::reference reference;
        typedef typename
            value_allocator::const_reference const_reference;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef boost::unordered_detail::hash_const_local_iterator<
            value_allocator, boost::unordered_detail::ungrouped>
                const_local_iterator;
        typedef boost::unordered_detail::hash_local_iterator<
            value_allocator, boost::unordered_detail::ungrouped>
                local_iterator;
        typedef boost::unordered_detail::hash_const_iterator<
            value_allocator, boost::unordered_detail::ungrouped>
                const_iterator;
        typedef boost::unordered_detail::hash_iterator<
            value_allocator, boost::unordered_detail::ungrouped>
                iterator;
    private:
        table table_;
        typename types::iterator_base const&
            get(const_iterator const& it)
        {
            return boost::unordered_detail::iterator_access::get(it);
        }
    public:
        explicit unordered_map(
                size_type n = boost::unordered_detail::default_bucket_count,
                const hasher &hf = hasher(),
                const key_equal &eql = key_equal(),
                const allocator_type &a = allocator_type())
          : table_(n, hf, eql, a)
        {
        }
        explicit unordered_map(allocator_type const& a)
          : table_(boost::unordered_detail::default_bucket_count,
                hasher(), key_equal(), a)
        {
        }
        unordered_map(unordered_map const& other, allocator_type const& a)
          : table_(other.table_, a)
        {
        }
        template <class InputIt>
        unordered_map(InputIt f, InputIt l)
          : table_(boost::unordered_detail::initial_size(f, l),
                hasher(), key_equal(), allocator_type())
        {
            table_.insert_range(f, l);
        }
        template <class InputIt>
        unordered_map(InputIt f, InputIt l,
                size_type n,
                const hasher &hf = hasher(),
                const key_equal &eql = key_equal())
          : table_(boost::unordered_detail::initial_size(f, l, n),
                hf, eql, allocator_type())
        {
            table_.insert_range(f, l);
        }
        template <class InputIt>
        unordered_map(InputIt f, InputIt l,
                size_type n,
                const hasher &hf,
                const key_equal &eql,
                const allocator_type &a)
          : table_(boost::unordered_detail::initial_size(f, l, n), hf, eql, a)
        {
            table_.insert_range(f, l);
        }
        ~unordered_map() {}
        unordered_map(unordered_map const& other)
          : table_(other.table_)
        {
        }
        unordered_map(unordered_map&& other)
          : table_(other.table_, boost::unordered_detail::move_tag())
        {
        }
        unordered_map(unordered_map&& other, allocator_type const& a)
          : table_(other.table_, a, boost::unordered_detail::move_tag())
        {
        }
        unordered_map& operator=(unordered_map const& x)
        {
            table_ = x.table_;
            return *this;
        }
        unordered_map& operator=(unordered_map&& x)
        {
            table_.move(x.table_);
            return *this;
        }
        unordered_map(std::initializer_list<value_type> list,
                size_type n = boost::unordered_detail::default_bucket_count,
                const hasher &hf = hasher(),
                const key_equal &eql = key_equal(),
                const allocator_type &a = allocator_type())
          : table_(boost::unordered_detail::initial_size(
                    list.begin(), list.end(), n),
                hf, eql, a)
        {
            table_.insert_range(list.begin(), list.end());
        }
        unordered_map& operator=(std::initializer_list<value_type> list)
        {
            table_.clear();
            table_.insert_range(list.begin(), list.end());
            return *this;
        }
        allocator_type get_allocator() const
        {
            return table_.node_alloc();
        }
        bool empty() const
        {
            return table_.size_ == 0;
        }
        size_type size() const
        {
            return table_.size_;
        }
        size_type max_size() const
        {
            return table_.max_size();
        }
        iterator begin()
        {
            return iterator(table_.begin());
        }
        const_iterator begin() const
        {
            return const_iterator(table_.begin());
        }
        iterator end()
        {
            return iterator(table_.end());
        }
        const_iterator end() const
        {
            return const_iterator(table_.end());
        }
        const_iterator cbegin() const
        {
            return const_iterator(table_.begin());
        }
        const_iterator cend() const
        {
            return const_iterator(table_.end());
        }
        template <class... Args>
        std::pair<iterator, bool> emplace(Args&&... args)
        {
            return boost::unordered_detail::pair_cast<iterator, bool>(
                table_.emplace(std::forward<Args>(args)...));
        }
        template <class... Args>
        iterator emplace_hint(const_iterator, Args&&... args)
        {
            return iterator(table_.emplace(std::forward<Args>(args)...).first);
        }
        std::pair<iterator, bool> insert(const value_type& obj)
        {
            return boost::unordered_detail::pair_cast<iterator, bool>(
                    table_.emplace(obj));
        }
        iterator insert(const_iterator, const value_type& obj)
        {
            return iterator(table_.emplace(obj).first);
        }
        template <class InputIt>
            void insert(InputIt first, InputIt last)
        {
            table_.insert_range(first, last);
        }
        void insert(std::initializer_list<value_type> list)
        {
            table_.insert_range(list.begin(), list.end());
        }
        iterator erase(const_iterator position)
        {
            return iterator(table_.erase_return_iterator(get(position)));
        }
        size_type erase(const key_type& k)
        {
            return table_.erase_key(k);
        }
        iterator erase(const_iterator first, const_iterator last)
        {
            return iterator(table_.erase_range(get(first), get(last)));
        }
        void quick_erase(const_iterator position)
        {
            table_.erase(get(position));
        }
        void erase_return_void(const_iterator position)
        {
            table_.erase(get(position));
        }
        void clear()
        {
            table_.clear();
        }
        void swap(unordered_map& other)
        {
            table_.swap(other.table_);
        }
        hasher hash_function() const
        {
            return table_.hash_function();
        }
        key_equal key_eq() const
        {
            return table_.key_eq();
        }
        mapped_type& operator[](const key_type &k)
        {
            return table_[k].second;
        }
        mapped_type& at(const key_type& k)
        {
            return table_.at(k).second;
        }
        mapped_type const& at(const key_type& k) const
        {
            return table_.at(k).second;
        }
        iterator find(const key_type& k)
        {
            return iterator(table_.find(k));
        }
        const_iterator find(const key_type& k) const
        {
            return const_iterator(table_.find(k));
        }
        template <class CompatibleKey, class CompatibleHash,
            class CompatiblePredicate>
        iterator find(
            CompatibleKey const& k,
            CompatibleHash const& hash,
            CompatiblePredicate const& eq)
        {
            return iterator(table_.find(k, hash, eq));
        }
        template <class CompatibleKey, class CompatibleHash,
            class CompatiblePredicate>
        const_iterator find(
            CompatibleKey const& k,
            CompatibleHash const& hash,
            CompatiblePredicate const& eq) const
        {
            return iterator(table_.find(k, hash, eq));
        }
        size_type count(const key_type& k) const
        {
            return table_.count(k);
        }
        std::pair<iterator, iterator>
            equal_range(const key_type& k)
        {
            return boost::unordered_detail::pair_cast<
                iterator, iterator>(
                    table_.equal_range(k));
        }
        std::pair<const_iterator, const_iterator>
            equal_range(const key_type& k) const
        {
            return boost::unordered_detail::pair_cast<
                const_iterator, const_iterator>(
                    table_.equal_range(k));
        }
        size_type bucket_count() const
        {
            return table_.bucket_count_;
        }
        size_type max_bucket_count() const
        {
            return table_.max_bucket_count();
        }
        size_type bucket_size(size_type n) const
        {
            return table_.bucket_size(n);
        }
        size_type bucket(const key_type& k) const
        {
            return table_.bucket_index(k);
        }
        local_iterator begin(size_type n)
        {
            return local_iterator(table_.bucket_begin(n));
        }
        const_local_iterator begin(size_type n) const
        {
            return const_local_iterator(table_.bucket_begin(n));
        }
        local_iterator end(size_type)
        {
            return local_iterator();
        }
        const_local_iterator end(size_type) const
        {
            return const_local_iterator();
        }
        const_local_iterator cbegin(size_type n) const
        {
            return const_local_iterator(table_.bucket_begin(n));
        }
        const_local_iterator cend(size_type) const
        {
            return const_local_iterator();
        }
        float load_factor() const
        {
            return table_.load_factor();
        }
        float max_load_factor() const
        {
            return table_.mlf_;
        }
        void max_load_factor(float m)
        {
            table_.max_load_factor(m);
        }
        void rehash(size_type n)
        {
            table_.rehash(n);
        }
        friend bool operator==<K, T, H, P, A>(
            unordered_map const&, unordered_map const&);
        friend bool operator!=<K, T, H, P, A>(
            unordered_map const&, unordered_map const&);
    };
    template <class K, class T, class H, class P, class A>
    inline bool operator==(unordered_map<K, T, H, P, A> const& m1,
        unordered_map<K, T, H, P, A> const& m2)
    {
        return m1.table_.equals(m2.table_);
    }
    template <class K, class T, class H, class P, class A>
    inline bool operator!=(unordered_map<K, T, H, P, A> const& m1,
        unordered_map<K, T, H, P, A> const& m2)
    {
        return !m1.table_.equals(m2.table_);
    }
    template <class K, class T, class H, class P, class A>
    inline void swap(unordered_map<K, T, H, P, A> &m1,
            unordered_map<K, T, H, P, A> &m2)
    {
        m1.swap(m2);
    }
    template <class K, class T, class H, class P, class A>
    class unordered_multimap
    {
    public:
        typedef K key_type;
        typedef std::pair<const K, T> value_type;
        typedef T mapped_type;
        typedef H hasher;
        typedef P key_equal;
        typedef A allocator_type;
    private:
        typedef typename
            boost::unordered_detail::rebind_wrap<
                allocator_type, value_type>::type
            value_allocator;
        typedef boost::unordered_detail::multimap<K, H, P,
            value_allocator> types;
        typedef typename types::impl table;
        typedef typename types::iterator_base iterator_base;
    public:
        typedef typename
            value_allocator::pointer pointer;
        typedef typename
            value_allocator::const_pointer const_pointer;
        typedef typename
            value_allocator::reference reference;
        typedef typename
            value_allocator::const_reference const_reference;
        typedef std::size_t size_type;
        typedef std::ptrdiff_t difference_type;
        typedef boost::unordered_detail::hash_const_local_iterator<
            value_allocator, boost::unordered_detail::grouped>
                const_local_iterator;
        typedef boost::unordered_detail::hash_local_iterator<
            value_allocator, boost::unordered_detail::grouped>
                local_iterator;
        typedef boost::unordered_detail::hash_const_iterator<
            value_allocator, boost::unordered_detail::grouped>
                const_iterator;
        typedef boost::unordered_detail::hash_iterator<
            value_allocator, boost::unordered_detail::grouped>
                iterator;
    private:
        table table_;
        typename types::iterator_base const&
            get(const_iterator const& it)
        {
            return boost::unordered_detail::iterator_access::get(it);
        }
    public:
        explicit unordered_multimap(
                size_type n = boost::unordered_detail::default_bucket_count,
                const hasher &hf = hasher(),
                const key_equal &eql = key_equal(),
                const allocator_type &a = allocator_type())
          : table_(n, hf, eql, a)
        {
        }
        explicit unordered_multimap(allocator_type const& a)
          : table_(boost::unordered_detail::default_bucket_count,
                hasher(), key_equal(), a)
        {
        }
        unordered_multimap(unordered_multimap const& other,
            allocator_type const& a)
          : table_(other.table_, a)
        {
        }
        template <class InputIt>
        unordered_multimap(InputIt f, InputIt l)
          : table_(boost::unordered_detail::initial_size(f, l),
                hasher(), key_equal(), allocator_type())
        {
            table_.insert_range(f, l);
        }
        template <class InputIt>
        unordered_multimap(InputIt f, InputIt l,
                size_type n,
                const hasher &hf = hasher(),
                const key_equal &eql = key_equal())
          : table_(boost::unordered_detail::initial_size(f, l, n),
                hf, eql, allocator_type())
        {
            table_.insert_range(f, l);
        }
        template <class InputIt>
        unordered_multimap(InputIt f, InputIt l,
                size_type n,
                const hasher &hf,
                const key_equal &eql,
                const allocator_type &a)
          : table_(boost::unordered_detail::initial_size(f, l, n), hf, eql, a)
        {
            table_.insert_range(f, l);
        }
        ~unordered_multimap() {}
        unordered_multimap(unordered_multimap const& other)
          : table_(other.table_)
        {
        }
        unordered_multimap(unordered_multimap&& other)
          : table_(other.table_, boost::unordered_detail::move_tag())
        {
        }
        unordered_multimap(unordered_multimap&& other, allocator_type const& a)
          : table_(other.table_, a, boost::unordered_detail::move_tag())
        {
        }
        unordered_multimap& operator=(unordered_multimap const& x)
        {
            table_ = x.table_;
            return *this;
        }
        unordered_multimap& operator=(unordered_multimap&& x)
        {
            table_.move(x.table_);
            return *this;
        }
        unordered_multimap(std::initializer_list<value_type> list,
                size_type n = boost::unordered_detail::default_bucket_count,
                const hasher &hf = hasher(),
                const key_equal &eql = key_equal(),
                const allocator_type &a = allocator_type())
          : table_(boost::unordered_detail::initial_size(
                    list.begin(), list.end(), n),
                hf, eql, a)
        {
            table_.insert_range(list.begin(), list.end());
        }
        unordered_multimap& operator=(std::initializer_list<value_type> list)
        {
            table_.clear();
            table_.insert_range(list.begin(), list.end());
            return *this;
        }
        allocator_type get_allocator() const
        {
            return table_.node_alloc();
        }
        bool empty() const
        {
            return table_.size_ == 0;
        }
        size_type size() const
        {
            return table_.size_;
        }
        size_type max_size() const
        {
            return table_.max_size();
        }
        iterator begin()
        {
            return iterator(table_.begin());
        }
        const_iterator begin() const
        {
            return const_iterator(table_.begin());
        }
        iterator end()
        {
            return iterator(table_.end());
        }
        const_iterator end() const
        {
            return const_iterator(table_.end());
        }
        const_iterator cbegin() const
        {
            return const_iterator(table_.begin());
        }
        const_iterator cend() const
        {
            return const_iterator(table_.end());
        }
        template <class... Args>
        iterator emplace(Args&&... args)
        {
            return iterator(table_.emplace(std::forward<Args>(args)...));
        }
        template <class... Args>
        iterator emplace_hint(const_iterator, Args&&... args)
        {
            return iterator(table_.emplace(std::forward<Args>(args)...));
        }
        iterator insert(const value_type& obj)
        {
            return iterator(table_.emplace(obj));
        }
        iterator insert(const_iterator, const value_type& obj)
        {
            return iterator(table_.emplace(obj));
        }
        template <class InputIt>
            void insert(InputIt first, InputIt last)
        {
            table_.insert_range(first, last);
        }
        void insert(std::initializer_list<value_type> list)
        {
            table_.insert_range(list.begin(), list.end());
        }
        iterator erase(const_iterator position)
        {
            return iterator(table_.erase_return_iterator(get(position)));
        }
        size_type erase(const key_type& k)
        {
            return table_.erase_key(k);
        }
        iterator erase(const_iterator first, const_iterator last)
        {
            return iterator(table_.erase_range(get(first), get(last)));
        }
        void quick_erase(const_iterator position)
        {
            table_.erase(get(position));
        }
        void erase_return_void(const_iterator position)
        {
            table_.erase(get(position));
        }
        void clear()
        {
            table_.clear();
        }
        void swap(unordered_multimap& other)
        {
            table_.swap(other.table_);
        }
        hasher hash_function() const
        {
            return table_.hash_function();
        }
        key_equal key_eq() const
        {
            return table_.key_eq();
        }
        iterator find(const key_type& k)
        {
            return iterator(table_.find(k));
        }
        const_iterator find(const key_type& k) const
        {
            return const_iterator(table_.find(k));
        }
        template <class CompatibleKey, class CompatibleHash,
            class CompatiblePredicate>
        iterator find(
            CompatibleKey const& k,
            CompatibleHash const& hash,
            CompatiblePredicate const& eq)
        {
            return iterator(table_.find(k, hash, eq));
        }
        template <class CompatibleKey, class CompatibleHash,
            class CompatiblePredicate>
        const_iterator find(
            CompatibleKey const& k,
            CompatibleHash const& hash,
            CompatiblePredicate const& eq) const
        {
            return iterator(table_.find(k, hash, eq));
        }
        size_type count(const key_type& k) const
        {
            return table_.count(k);
        }
        std::pair<iterator, iterator>
            equal_range(const key_type& k)
        {
            return boost::unordered_detail::pair_cast<
                iterator, iterator>(
                    table_.equal_range(k));
        }
        std::pair<const_iterator, const_iterator>
            equal_range(const key_type& k) const
        {
            return boost::unordered_detail::pair_cast<
                const_iterator, const_iterator>(
                    table_.equal_range(k));
        }
        size_type bucket_count() const
        {
            return table_.bucket_count_;
        }
        size_type max_bucket_count() const
        {
            return table_.max_bucket_count();
        }
        size_type bucket_size(size_type n) const
        {
            return table_.bucket_size(n);
        }
        size_type bucket(const key_type& k) const
        {
            return table_.bucket_index(k);
        }
        local_iterator begin(size_type n)
        {
            return local_iterator(table_.bucket_begin(n));
        }
        const_local_iterator begin(size_type n) const
        {
            return const_local_iterator(table_.bucket_begin(n));
        }
        local_iterator end(size_type)
        {
            return local_iterator();
        }
        const_local_iterator end(size_type) const
        {
            return const_local_iterator();
        }
        const_local_iterator cbegin(size_type n) const
        {
            return const_local_iterator(table_.bucket_begin(n));
        }
        const_local_iterator cend(size_type) const
        {
            return const_local_iterator();
        }
        float load_factor() const
        {
            return table_.load_factor();
        }
        float max_load_factor() const
        {
            return table_.mlf_;
        }
        void max_load_factor(float m)
        {
            table_.max_load_factor(m);
        }
        void rehash(size_type n)
        {
            table_.rehash(n);
        }
        friend bool operator==<K, T, H, P, A>(
            unordered_multimap const&, unordered_multimap const&);
        friend bool operator!=<K, T, H, P, A>(
            unordered_multimap const&, unordered_multimap const&);
    };
    template <class K, class T, class H, class P, class A>
    inline bool operator==(unordered_multimap<K, T, H, P, A> const& m1,
        unordered_multimap<K, T, H, P, A> const& m2)
    {
        return m1.table_.equals(m2.table_);
    }
    template <class K, class T, class H, class P, class A>
    inline bool operator!=(unordered_multimap<K, T, H, P, A> const& m1,
        unordered_multimap<K, T, H, P, A> const& m2)
    {
        return !m1.table_.equals(m2.table_);
    }
    template <class K, class T, class H, class P, class A>
    inline void swap(unordered_multimap<K, T, H, P, A> &m1,
            unordered_multimap<K, T, H, P, A> &m2)
    {
        m1.swap(m2);
    }
}
       
namespace boost {
namespace detail {
namespace atomic {
template<typename T>
class fallback_atomic {
public:
    fallback_atomic(void) {}
    explicit fallback_atomic(const T &t) {memcpy(&i, &t, sizeof(T));}
    void store(const T &t, memory_order order=memory_order_seq_cst) volatile
    {
        detail::spinlock_pool<0>::scoped_lock guard(const_cast<T*>(&i));
        memcpy((void*)&i, &t, sizeof(T));
    }
    T load(memory_order =memory_order_seq_cst) volatile const
    {
        detail::spinlock_pool<0>::scoped_lock guard(const_cast<T*>(&i));
        T tmp;
        memcpy(&tmp, (T*)&i, sizeof(T));
        return tmp;
    }
    bool compare_exchange_strong(
        T &expected,
        T desired,
        memory_order ,
        memory_order ) volatile
    {
        detail::spinlock_pool<0>::scoped_lock guard(const_cast<T*>(&i));
        if (memcmp((void*)&i, &expected, sizeof(T))==0) {
            memcpy((void*)&i, &desired, sizeof(T));
            return true;
        } else {
            memcpy(&expected, (void*)&i, sizeof(T));
            return false;
        }
    }
    bool compare_exchange_weak(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        return compare_exchange_strong(expected, desired, success_order, failure_order);
    }
    T exchange(T replacement, memory_order =memory_order_seq_cst) volatile
    {
        detail::spinlock_pool<0>::scoped_lock guard(const_cast<T*>(&i));
        T tmp;
        memcpy(&tmp, (void*)&i, sizeof(T));
        memcpy((void*)&i, &replacement, sizeof(T));
        return tmp;
    }
    bool is_lock_free(void) const volatile {return false;}
protected:
    T i;
    typedef T integral_type;
};
}
}
}
namespace boost {
namespace detail {
namespace atomic {
template<typename T> struct is_integral_type {typedef void test;};
template<> struct is_integral_type<char> {typedef int test;};
template<> struct is_integral_type<unsigned char> {typedef int test;};
template<> struct is_integral_type<signed char> {typedef int test;};
template<> struct is_integral_type<unsigned short> {typedef int test;};
template<> struct is_integral_type<signed short> {typedef int test;};
template<> struct is_integral_type<unsigned int> {typedef int test;};
template<> struct is_integral_type<signed int> {typedef int test;};
template<> struct is_integral_type<unsigned long> {typedef int test;};
template<> struct is_integral_type<long> {typedef int test;};
template<> struct is_integral_type<boost::ulong_long_type> {typedef int test;};
template<> struct is_integral_type<boost::long_long_type> {typedef int test;};
}
}
}
namespace boost {
namespace detail {
namespace atomic {
template<typename Base>
class build_exchange : public Base {
public:
    typedef typename Base::integral_type integral_type;
    using Base::load;
    using Base::compare_exchange_weak;
    bool compare_exchange_strong(
        integral_type &expected,
        integral_type desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        integral_type expected_save=expected;
        while(true) {
            if (compare_exchange_weak(expected, desired, success_order, failure_order)) return true;
            if (expected_save!=expected) return false;
            expected=expected_save;
        }
    }
    integral_type exchange(integral_type replacement, memory_order order=memory_order_seq_cst) volatile
    {
        integral_type o=load(memory_order_relaxed);
        do {} while(!compare_exchange_weak(o, replacement, order, memory_order_relaxed));
        return o;
    }
    build_exchange() {}
    explicit build_exchange(integral_type i) : Base(i) {}
};
template<typename Base>
class build_const_fetch_add : public Base {
public:
    typedef typename Base::integral_type integral_type;
    integral_type fetch_add(
        integral_type c,
        memory_order order=memory_order_seq_cst) volatile
    {
        if (__builtin_constant_p(c)) {
            switch(c) {
                case -1: return fetch_dec(order);
                case 1: return fetch_inc(order);
            }
        }
        return fetch_add_var(c, order);
    }
    build_const_fetch_add() {}
    explicit build_const_fetch_add(integral_type i) : Base(i) {}
protected:
    using Base::fetch_add_var;
    using Base::fetch_inc;
    using Base::fetch_dec;
};
template<typename Base>
class build_fetch_add : public Base {
public:
    typedef typename Base::integral_type integral_type;
    using Base::compare_exchange_weak;
    integral_type fetch_add(
        integral_type c, memory_order order=memory_order_seq_cst) volatile
    {
        integral_type o=Base::load(memory_order_relaxed), n;
        do {n=o+c;} while(!compare_exchange_weak(o, n, order, memory_order_relaxed));
        return o;
    }
    build_fetch_add() {}
    explicit build_fetch_add(integral_type i) : Base(i) {}
};
template<typename Base>
class build_arithmeticops : public Base {
public:
    typedef typename Base::integral_type integral_type;
    using Base::fetch_add;
    integral_type fetch_sub(
        integral_type c,
        memory_order order=memory_order_seq_cst) volatile
    {
        return fetch_add(-c, order);
    }
    build_arithmeticops() {}
    explicit build_arithmeticops(integral_type i) : Base(i) {}
};
template<typename Base>
class build_logicops : public Base {
public:
    typedef typename Base::integral_type integral_type;
    using Base::compare_exchange_weak;
    using Base::load;
    integral_type fetch_and(integral_type c, memory_order order=memory_order_seq_cst) volatile
    {
        integral_type o=load(memory_order_relaxed), n;
        do {n=o&c;} while(!compare_exchange_weak(o, n, order, memory_order_relaxed));
        return o;
    }
    integral_type fetch_or(integral_type c, memory_order order=memory_order_seq_cst) volatile
    {
        integral_type o=load(memory_order_relaxed), n;
        do {n=o|c;} while(!compare_exchange_weak(o, n, order, memory_order_relaxed));
        return o;
    }
    integral_type fetch_xor(integral_type c, memory_order order=memory_order_seq_cst) volatile
    {
        integral_type o=load(memory_order_relaxed), n;
        do {n=o^c;} while(!compare_exchange_weak(o, n, order, memory_order_relaxed));
        return o;
    }
    build_logicops() {}
    build_logicops(integral_type i) : Base(i) {}
};
template<typename Base>
class build_atomic_from_minimal : public build_logicops< build_arithmeticops< build_fetch_add< build_exchange<Base> > > > {
public:
    typedef build_logicops< build_arithmeticops< build_fetch_add< build_exchange<Base> > > > super;
    typedef typename super::integral_type integral_type;
    build_atomic_from_minimal(void) {}
    build_atomic_from_minimal(typename super::integral_type i) : super(i) {}
};
template<typename Base>
class build_atomic_from_typical : public build_logicops< build_arithmeticops< build_const_fetch_add<Base> > > {
public:
    typedef build_logicops< build_arithmeticops< build_const_fetch_add<Base> > > super;
    typedef typename super::integral_type integral_type;
    build_atomic_from_typical(void) {}
    build_atomic_from_typical(typename super::integral_type i) : super(i) {}
};
template<typename Base>
class build_atomic_from_add : public build_logicops< build_arithmeticops<Base> > {
public:
    typedef build_logicops< build_arithmeticops<Base> > super;
    typedef typename super::integral_type integral_type;
    build_atomic_from_add(void) {}
    build_atomic_from_add(typename super::integral_type i) : super(i) {}
};
template<typename Base>
class build_atomic_from_exchange : public build_logicops< build_arithmeticops< build_fetch_add<Base> > > {
public:
    typedef build_logicops< build_arithmeticops< build_fetch_add<Base> > > super;
    typedef typename super::integral_type integral_type;
    build_atomic_from_exchange(void) {}
    build_atomic_from_exchange(typename super::integral_type i) : super(i) {}
};
template<typename Base, typename Type>
class build_base_from_larger_type {
public:
    typedef Type integral_type;
    build_base_from_larger_type() {}
    build_base_from_larger_type(integral_type t) {store(t, memory_order_relaxed);}
    integral_type load(memory_order order=memory_order_seq_cst) const volatile
    {
        larger_integral_type v=get_base().load(order);
        return extract(v);
    }
    bool compare_exchange_weak(integral_type &expected,
        integral_type desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        larger_integral_type expected_;
        larger_integral_type desired_;
        expected_=get_base().load(memory_order_relaxed);
        expected_=insert(expected_, expected);
        desired_=insert(expected_, desired);
        bool success=get_base().compare_exchange_weak(expected_, desired_, success_order, failure_order);
        expected=extract(expected_);
        return success;
    }
    void store(integral_type v,
        memory_order order=memory_order_seq_cst) volatile
    {
        larger_integral_type expected, desired;
        expected=get_base().load(memory_order_relaxed);
        do {
            desired=insert(expected, v);
        } while(!get_base().compare_exchange_weak(expected, desired, order, memory_order_relaxed));
    }
    bool is_lock_free(void)
    {
        return get_base().is_lock_free();
    }
private:
    typedef typename Base::integral_type larger_integral_type;
    const Base &get_base(void) const volatile
    {
        intptr_t address=(intptr_t)this;
        address&=~(sizeof(larger_integral_type)-1);
        return *reinterpret_cast<const Base *>(address);
    }
    Base &get_base(void) volatile
    {
        intptr_t address=(intptr_t)this;
        address&=~(sizeof(larger_integral_type)-1);
        return *reinterpret_cast<Base *>(address);
    }
    unsigned int get_offset(void) const volatile
    {
        intptr_t address=(intptr_t)this;
        address&=(sizeof(larger_integral_type)-1);
        return address;
    }
    unsigned int get_shift(void) const volatile
    {
        return get_offset()*8;
    }
    integral_type extract(larger_integral_type v) const volatile
    {
        return v>>get_shift();
    }
    larger_integral_type insert(larger_integral_type target, integral_type source) const volatile
    {
        larger_integral_type tmp=source;
        larger_integral_type mask=(larger_integral_type)-1;
        mask=~(mask<<(8*sizeof(integral_type)));
        mask=mask<<get_shift();
        tmp=tmp<<get_shift();
        tmp=(tmp & mask) | (target & ~mask);
        return tmp;
    }
    integral_type i;
};
template<typename Base, typename Type>
class build_atomic_from_larger_type : public build_atomic_from_minimal< build_base_from_larger_type<Base, Type> > {
public:
    typedef build_atomic_from_minimal< build_base_from_larger_type<Base, Type> > super;
    typedef Type integral_type;
    build_atomic_from_larger_type() {}
    build_atomic_from_larger_type(integral_type v) : super(v) {}
};
}
}
}
namespace boost {
namespace detail {
namespace atomic {
static inline memory_order calculate_failure_order(memory_order order)
{
    switch(order) {
        case memory_order_acq_rel: return memory_order_acquire;
        case memory_order_release: return memory_order_relaxed;
        default: return order;
    }
}
template<typename T, unsigned short Size=sizeof(T)>
class platform_atomic : public fallback_atomic<T> {
public:
    typedef fallback_atomic<T> super;
    explicit platform_atomic(T v) : super(v) {}
    platform_atomic() {}
protected:
    typedef typename super::integral_type integral_type;
};
template<typename T, unsigned short Size=sizeof(T)>
class platform_atomic_integral : public build_atomic_from_exchange<fallback_atomic<T> > {
public:
    typedef build_atomic_from_exchange<fallback_atomic<T> > super;
    explicit platform_atomic_integral(T v) : super(v) {}
    platform_atomic_integral() {}
protected:
    typedef typename super::integral_type integral_type;
};
template<typename T>
static inline void platform_atomic_thread_fence(T order)
{
    platform_atomic<int> a;
    a.exchange(0, order);
}
template<typename T, unsigned short Size=sizeof(T), typename Int=typename is_integral_type<T>::test>
class internal_atomic;
template<typename T, unsigned short Size>
class internal_atomic<T, Size, void> : private detail::atomic::platform_atomic<T> {
public:
    typedef detail::atomic::platform_atomic<T> super;
    internal_atomic() {}
    explicit internal_atomic(T v) : super(v) {}
    operator T(void) const volatile {return load();}
    T operator=(T v) volatile {store(v); return v;}
    using super::is_lock_free;
    using super::load;
    using super::store;
    using super::exchange;
    bool compare_exchange_strong(
        T &expected,
        T desired,
        memory_order order=memory_order_seq_cst) volatile
    {
        return super::compare_exchange_strong(expected, desired, order, calculate_failure_order(order));
    }
    bool compare_exchange_weak(
        T &expected,
        T desired,
        memory_order order=memory_order_seq_cst) volatile
    {
        return super::compare_exchange_strong(expected, desired, order, calculate_failure_order(order));
    }
    bool compare_exchange_strong(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        return super::compare_exchange_strong(expected, desired, success_order, failure_order);
    }
    bool compare_exchange_weak(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        return super::compare_exchange_strong(expected, desired, success_order, failure_order);
    }
private:
    internal_atomic(const internal_atomic &);
    void operator=(const internal_atomic &);
};
template<typename T, unsigned short Size>
class internal_atomic<T, Size, int> : private detail::atomic::platform_atomic_integral<T> {
public:
    typedef detail::atomic::platform_atomic_integral<T> super;
    typedef typename super::integral_type integral_type;
    internal_atomic() {}
    explicit internal_atomic(T v) : super(v) {}
    using super::is_lock_free;
    using super::load;
    using super::store;
    using super::exchange;
    using super::fetch_add;
    using super::fetch_sub;
    using super::fetch_and;
    using super::fetch_or;
    using super::fetch_xor;
    operator integral_type(void) const volatile {return load();}
    integral_type operator=(integral_type v) volatile {store(v); return v;}
    integral_type operator&=(integral_type c) volatile {return fetch_and(c)&c;}
    integral_type operator|=(integral_type c) volatile {return fetch_or(c)|c;}
    integral_type operator^=(integral_type c) volatile {return fetch_xor(c)^c;}
    integral_type operator+=(integral_type c) volatile {return fetch_add(c)+c;}
    integral_type operator-=(integral_type c) volatile {return fetch_sub(c)-c;}
    integral_type operator++(void) volatile {return fetch_add(1)+1;}
    integral_type operator++(int) volatile {return fetch_add(1);}
    integral_type operator--(void) volatile {return fetch_sub(1)-1;}
    integral_type operator--(int) volatile {return fetch_sub(1);}
    bool compare_exchange_strong(
        integral_type &expected,
        integral_type desired,
        memory_order order=memory_order_seq_cst) volatile
    {
        return super::compare_exchange_strong(expected, desired, order, calculate_failure_order(order));
    }
    bool compare_exchange_weak(
        integral_type &expected,
        integral_type desired,
        memory_order order=memory_order_seq_cst) volatile
    {
        return super::compare_exchange_strong(expected, desired, order, calculate_failure_order(order));
    }
    bool compare_exchange_strong(
        integral_type &expected,
        integral_type desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        return super::compare_exchange_strong(expected, desired, success_order, failure_order);
    }
    bool compare_exchange_weak(
        integral_type &expected,
        integral_type desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        return super::compare_exchange_strong(expected, desired, success_order, failure_order);
    }
private:
    internal_atomic(const internal_atomic &);
    void operator=(const internal_atomic &);
};
}
}
}
namespace boost {
namespace detail {
namespace atomic {
static inline void fence_before(memory_order order)
{
    switch(order) {
        case memory_order_consume:
        case memory_order_release:
        case memory_order_acq_rel:
        case memory_order_seq_cst:
            __asm__ __volatile__ ("" ::: "memory");
        default:;
    }
}
static inline void fence_after(memory_order order)
{
    switch(order) {
        case memory_order_acquire:
        case memory_order_acq_rel:
        case memory_order_seq_cst:
            __asm__ __volatile__ ("" ::: "memory");
        default:;
    }
}
static inline void full_fence(void)
{
            __asm__ __volatile__("mfence" ::: "memory");
}
static inline void fence_after_load(memory_order order)
{
    switch(order) {
        case memory_order_seq_cst:
            full_fence();
        case memory_order_acquire:
        case memory_order_acq_rel:
            __asm__ __volatile__ ("" ::: "memory");
        default:;
    }
}
template<>
inline void platform_atomic_thread_fence(memory_order order)
{
    switch(order) {
        case memory_order_seq_cst:
            full_fence();
        case memory_order_acquire:
        case memory_order_consume:
        case memory_order_acq_rel:
        case memory_order_release:
            __asm__ __volatile__ ("" ::: "memory");
        default:;
    }
}
template<typename T>
class atomic_x86_8 {
public:
    explicit atomic_x86_8(T v) : i(v) {}
    atomic_x86_8() {}
    T load(memory_order order=memory_order_seq_cst) const volatile
    {
        T v=*reinterpret_cast<volatile const T *>(&i);
        fence_after_load(order);
        return v;
    }
    void store(T v, memory_order order=memory_order_seq_cst) volatile
    {
        if (order!=memory_order_seq_cst) {
            fence_before(order);
            *reinterpret_cast<volatile T *>(&i)=v;
        } else {
            exchange(v);
        }
    }
    bool compare_exchange_strong(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        fence_before(success_order);
        T prev=expected;
        __asm__ __volatile__("lock; cmpxchgb %1, %2\n" : "=a" (prev) : "q" (desired), "m" (i), "a" (expected) : "memory");
        bool success=(prev==expected);
        if (success) fence_after(success_order);
        else fence_after(failure_order);
        expected=prev;
        return success;
    }
    bool compare_exchange_weak(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        return compare_exchange_strong(expected, desired, success_order, failure_order);
    }
    T exchange(T r, memory_order order=memory_order_seq_cst) volatile
    {
        __asm__ __volatile__("xchgb %0, %1\n" : "=q" (r) : "m"(i), "0" (r) : "memory");
        return r;
    }
    T fetch_add(T c, memory_order order=memory_order_seq_cst) volatile
    {
        __asm__ __volatile__("lock; xaddb %0, %1" : "+q" (c), "+m" (i) :: "memory");
        return c;
    }
    bool is_lock_free(void) const volatile {return true;}
protected:
    typedef T integral_type;
private:
    T i;
};
template<typename T>
class platform_atomic_integral<T, 1> : public build_atomic_from_add<atomic_x86_8<T> > {
public:
    typedef build_atomic_from_add<atomic_x86_8<T> > super;
    explicit platform_atomic_integral(T v) : super(v) {}
    platform_atomic_integral(void) {}
};
template<typename T>
class atomic_x86_16 {
public:
    explicit atomic_x86_16(T v) : i(v) {}
    atomic_x86_16() {}
    T load(memory_order order=memory_order_seq_cst) const volatile
    {
        T v=*reinterpret_cast<volatile const T *>(&i);
        fence_after_load(order);
        return v;
    }
    void store(T v, memory_order order=memory_order_seq_cst) volatile
    {
        if (order!=memory_order_seq_cst) {
            fence_before(order);
            *reinterpret_cast<volatile T *>(&i)=v;
        } else {
            exchange(v);
        }
    }
    bool compare_exchange_strong(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        fence_before(success_order);
        T prev=expected;
        __asm__ __volatile__("lock; cmpxchgw %1, %2\n" : "=a" (prev) : "q" (desired), "m" (i), "a" (expected) : "memory");
        bool success=(prev==expected);
        if (success) fence_after(success_order);
        else fence_after(failure_order);
        expected=prev;
        return success;
    }
    bool compare_exchange_weak(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        return compare_exchange_strong(expected, desired, success_order, failure_order);
    }
    T exchange(T r, memory_order order=memory_order_seq_cst) volatile
    {
        __asm__ __volatile__("xchgw %0, %1\n" : "=r" (r) : "m"(i), "0" (r) : "memory");
        return r;
    }
    T fetch_add(T c, memory_order order=memory_order_seq_cst) volatile
    {
        __asm__ __volatile__("lock; xaddw %0, %1" : "+r" (c), "+m" (i) :: "memory");
        return c;
    }
    bool is_lock_free(void) const volatile {return true;}
protected:
    typedef T integral_type;
private:
    T i;
};
template<typename T>
class platform_atomic_integral<T, 2> : public build_atomic_from_add<atomic_x86_16<T> > {
public:
    typedef build_atomic_from_add<atomic_x86_16<T> > super;
    explicit platform_atomic_integral(T v) : super(v) {}
    platform_atomic_integral(void) {}
};
template<typename T>
class atomic_x86_32 {
public:
    explicit atomic_x86_32(T v) : i(v) {}
    atomic_x86_32() {}
    T load(memory_order order=memory_order_seq_cst) const volatile
    {
        T v=*reinterpret_cast<volatile const T *>(&i);
        fence_after_load(order);
        return v;
    }
    void store(T v, memory_order order=memory_order_seq_cst) volatile
    {
        if (order!=memory_order_seq_cst) {
            fence_before(order);
            *reinterpret_cast<volatile T *>(&i)=v;
        } else {
            exchange(v);
        }
    }
    bool compare_exchange_strong(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        fence_before(success_order);
        T prev=expected;
        __asm__ __volatile__("lock; cmpxchgl %1, %2\n" : "=a" (prev) : "q" (desired), "m" (i), "a" (expected) : "memory");
        bool success=(prev==expected);
        if (success) fence_after(success_order);
        else fence_after(failure_order);
        expected=prev;
        return success;
    }
    bool compare_exchange_weak(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        return compare_exchange_strong(expected, desired, success_order, failure_order);
    }
    T exchange(T r, memory_order order=memory_order_seq_cst) volatile
    {
        __asm__ __volatile__("xchgl %0, %1\n" : "=r" (r) : "m"(i), "0" (r) : "memory");
        return r;
    }
    T fetch_add(T c, memory_order order=memory_order_seq_cst) volatile
    {
        __asm__ __volatile__("lock; xaddl %0, %1" : "+r" (c), "+m" (i) :: "memory");
        return c;
    }
    bool is_lock_free(void) const volatile {return true;}
protected:
    typedef T integral_type;
private:
    T i;
};
template<typename T>
class platform_atomic_integral<T, 4> : public build_atomic_from_add<atomic_x86_32<T> > {
public:
    typedef build_atomic_from_add<atomic_x86_32<T> > super;
    explicit platform_atomic_integral(T v) : super(v) {}
    platform_atomic_integral(void) {}
};
template<typename T>
class atomic_x86_64 {
public:
    explicit atomic_x86_64(T v) : i(v) {}
    atomic_x86_64() {}
    T load(memory_order order=memory_order_seq_cst) const volatile
    {
        T v=*reinterpret_cast<volatile const T *>(&i);
        fence_after_load(order);
        return v;
    }
    void store(T v, memory_order order=memory_order_seq_cst) volatile
    {
        if (order!=memory_order_seq_cst) {
            fence_before(order);
            *reinterpret_cast<volatile T *>(&i)=v;
        } else {
            exchange(v);
        }
    }
    bool compare_exchange_strong(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        fence_before(success_order);
        T prev=expected;
        __asm__ __volatile__("lock; cmpxchgq %1, %2\n" : "=a" (prev) : "q" (desired), "m" (i), "a" (expected) : "memory");
        bool success=(prev==expected);
        if (success) fence_after(success_order);
        else fence_after(failure_order);
        expected=prev;
        return success;
    }
    bool compare_exchange_weak(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        return compare_exchange_strong(expected, desired, success_order, failure_order);
    }
    T exchange(T r, memory_order order=memory_order_seq_cst) volatile
    {
        __asm__ __volatile__("xchgq %0, %1\n" : "=r" (r) : "m"(i), "0" (r) : "memory");
        return r;
    }
    T fetch_add(T c, memory_order order=memory_order_seq_cst) volatile
    {
        __asm__ __volatile__("lock; xaddq %0, %1" : "+r" (c), "+m" (i) :: "memory");
        return c;
    }
    bool is_lock_free(void) const volatile {return true;}
protected:
    typedef T integral_type;
private:
    T i;
} __attribute__((aligned(8)));
template<typename T>
class platform_atomic_integral<T, 8> : public build_atomic_from_add<atomic_x86_64<T> >{
public:
    typedef build_atomic_from_add<atomic_x86_64<T> > super;
    explicit platform_atomic_integral(T v) : super(v) {}
    platform_atomic_integral(void) {}
};
}
}
}
namespace boost { namespace detail { namespace atomic {
template<typename T>
class platform_atomic<T, 1> : private platform_atomic_integral<boost::uint8_t> {
public:
    typedef platform_atomic_integral<boost::uint8_t> super;
    platform_atomic() {}
    explicit platform_atomic(T t) : super(to_integral(t))
    {
    }
    void store(T t, memory_order order=memory_order_seq_cst) volatile
    {
        super::store(to_integral(t), order);
    }
    T load(memory_order order=memory_order_seq_cst) volatile const
    {
        return from_integral(super::load(order));
    }
    bool compare_exchange_strong(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        boost::uint8_t _expected, _desired;
        _expected=to_integral(expected);
        _desired=to_integral(desired);
        bool success=super::compare_exchange_strong(_expected, _desired, success_order, failure_order);
        expected=from_integral(_expected);
        return success;
    }
    bool compare_exchange_weak(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        boost::uint8_t _expected, _desired;
        _expected=to_integral(expected);
        _desired=to_integral(desired);
        bool success=super::compare_exchange_weak(_expected, _desired, success_order, failure_order);
        expected=from_integral(_expected);
        return success;
    }
    T exchange(T replacement, memory_order order=memory_order_seq_cst) volatile
    {
        return from_integral(super::exchange(to_integral(replacement), order));
    }
    operator T(void) const volatile {return load();}
    T operator=(T v) volatile {store(v); return v;}
    using super::is_lock_free;
protected:
    static inline boost::uint8_t to_integral(T &t)
    {
        boost::uint8_t tmp;
        memcpy(&tmp, &t, sizeof(t));
        return tmp;
    }
    static inline T from_integral(boost::uint8_t t)
    {
        T tmp;
        memcpy(&tmp, &t, sizeof(t));
        return tmp;
    }
};
template<typename T>
class platform_atomic<T, 2> : private platform_atomic_integral<boost::uint16_t> {
public:
    typedef platform_atomic_integral<boost::uint16_t> super;
    platform_atomic() {}
    explicit platform_atomic(T t) : super(to_integral(t))
    {
    }
    void store(T t, memory_order order=memory_order_seq_cst) volatile
    {
        super::store(to_integral(t), order);
    }
    T load(memory_order order=memory_order_seq_cst) volatile const
    {
        return from_integral(super::load(order));
    }
    bool compare_exchange_strong(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        boost::uint16_t _expected, _desired;
        _expected=to_integral(expected);
        _desired=to_integral(desired);
        bool success=super::compare_exchange_strong(_expected, _desired, success_order, failure_order);
        expected=from_integral(_expected);
        return success;
    }
    bool compare_exchange_weak(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        boost::uint16_t _expected, _desired;
        _expected=to_integral(expected);
        _desired=to_integral(desired);
        bool success=super::compare_exchange_weak(_expected, _desired, success_order, failure_order);
        expected=from_integral(_expected);
        return success;
    }
    T exchange(T replacement, memory_order order=memory_order_seq_cst) volatile
    {
        return from_integral(super::exchange(to_integral(replacement), order));
    }
    operator T(void) const volatile {return load();}
    T operator=(T v) volatile {store(v); return v;}
    using super::is_lock_free;
protected:
    static inline boost::uint16_t to_integral(T &t)
    {
        boost::uint16_t tmp;
        memcpy(&tmp, &t, sizeof(t));
        return tmp;
    }
    static inline T from_integral(boost::uint16_t t)
    {
        T tmp;
        memcpy(&tmp, &t, sizeof(t));
        return tmp;
    }
};
template<typename T>
class platform_atomic<T, 4> : private platform_atomic_integral<boost::uint32_t> {
public:
    typedef platform_atomic_integral<boost::uint32_t> super;
    platform_atomic() {}
    explicit platform_atomic(T t) : super(to_integral(t))
    {
    }
    void store(T t, memory_order order=memory_order_seq_cst) volatile
    {
        super::store(to_integral(t), order);
    }
    T load(memory_order order=memory_order_seq_cst) volatile const
    {
        return from_integral(super::load(order));
    }
    bool compare_exchange_strong(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        boost::uint32_t _expected, _desired;
        _expected=to_integral(expected);
        _desired=to_integral(desired);
        bool success=super::compare_exchange_strong(_expected, _desired, success_order, failure_order);
        expected=from_integral(_expected);
        return success;
    }
    bool compare_exchange_weak(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        boost::uint32_t _expected, _desired;
        _expected=to_integral(expected);
        _desired=to_integral(desired);
        bool success=super::compare_exchange_weak(_expected, _desired, success_order, failure_order);
        expected=from_integral(_expected);
        return success;
    }
    T exchange(T replacement, memory_order order=memory_order_seq_cst) volatile
    {
        return from_integral(super::exchange(to_integral(replacement), order));
    }
    operator T(void) const volatile {return load();}
    T operator=(T v) volatile {store(v); return v;}
    using super::is_lock_free;
protected:
    static inline boost::uint32_t to_integral(T &t)
    {
        boost::uint32_t tmp;
        memcpy(&tmp, &t, sizeof(t));
        return tmp;
    }
    static inline T from_integral(boost::uint32_t t)
    {
        T tmp;
        memcpy(&tmp, &t, sizeof(t));
        return tmp;
    }
};
template<typename T>
class platform_atomic<T, 8> : private platform_atomic_integral<boost::uint64_t> {
public:
    typedef platform_atomic_integral<boost::uint64_t> super;
    platform_atomic() {}
    explicit platform_atomic(T t) : super(to_integral(t))
    {
    }
    void store(T t, memory_order order=memory_order_seq_cst) volatile
    {
        super::store(to_integral(t), order);
    }
    T load(memory_order order=memory_order_seq_cst) volatile const
    {
        return from_integral(super::load(order));
    }
    bool compare_exchange_strong(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        boost::uint64_t _expected, _desired;
        _expected=to_integral(expected);
        _desired=to_integral(desired);
        bool success=super::compare_exchange_strong(_expected, _desired, success_order, failure_order);
        expected=from_integral(_expected);
        return success;
    }
    bool compare_exchange_weak(
        T &expected,
        T desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        boost::uint64_t _expected, _desired;
        _expected=to_integral(expected);
        _desired=to_integral(desired);
        bool success=super::compare_exchange_weak(_expected, _desired, success_order, failure_order);
        expected=from_integral(_expected);
        return success;
    }
    T exchange(T replacement, memory_order order=memory_order_seq_cst) volatile
    {
        return from_integral(super::exchange(to_integral(replacement), order));
    }
    operator T(void) const volatile {return load();}
    T operator=(T v) volatile {store(v); return v;}
    using super::is_lock_free;
protected:
    static inline boost::uint64_t to_integral(T &t)
    {
        boost::uint64_t tmp;
        memcpy(&tmp, &t, sizeof(t));
        return tmp;
    }
    static inline T from_integral(boost::uint64_t t)
    {
        T tmp;
        memcpy(&tmp, &t, sizeof(t));
        return tmp;
    }
};
} } }
namespace boost {
template<typename T>
class atomic : public detail::atomic::internal_atomic<T> {
public:
    typedef detail::atomic::internal_atomic<T> super;
    atomic() {}
    explicit atomic(T v) : super(v) {}
private:
    atomic(const atomic &);
    void operator=(const atomic &);
};
template<>
class atomic<bool> : private detail::atomic::internal_atomic<bool> {
public:
    typedef detail::atomic::internal_atomic<bool> super;
    atomic() {}
    explicit atomic(bool v) : super(v) {}
    using super::load;
    using super::store;
    using super::compare_exchange_strong;
    using super::compare_exchange_weak;
    using super::exchange;
    using super::is_lock_free;
    operator bool(void) const volatile {return load();}
    bool operator=(bool v) volatile {store(v); return v;}
private:
    atomic(const atomic &);
    void operator=(const atomic &);
};
template<>
class atomic<void *> : private detail::atomic::internal_atomic<void *, sizeof(void *), int> {
public:
    typedef detail::atomic::internal_atomic<void *, sizeof(void *), int> super;
    atomic() {}
    explicit atomic(void * p) : super(p) {}
    using super::load;
    using super::store;
    using super::compare_exchange_strong;
    using super::compare_exchange_weak;
    using super::exchange;
    using super::is_lock_free;
    operator void *(void) const volatile {return load();}
    void * operator=(void * v) volatile {store(v); return v;}
private:
    atomic(const atomic &);
    void * operator=(const atomic &);
};
template<typename T>
class atomic<T *> : private detail::atomic::internal_atomic<intptr_t> {
public:
    typedef detail::atomic::internal_atomic<intptr_t> super;
    atomic() {}
    explicit atomic(T * p) : super((intptr_t)p) {}
    T *load(memory_order order=memory_order_seq_cst) const volatile
    {
        return (T*)super::load(order);
    }
    void store(T *v, memory_order order=memory_order_seq_cst) volatile
    {
        super::store((intptr_t)v, order);
    }
    bool compare_exchange_strong(
        T * &expected,
        T * desired,
        memory_order order=memory_order_seq_cst) volatile
    {
        return compare_exchange_strong(expected, desired, order, detail::atomic::calculate_failure_order(order));
    }
    bool compare_exchange_weak(
        T * &expected,
        T *desired,
        memory_order order=memory_order_seq_cst) volatile
    {
        return compare_exchange_weak(expected, desired, order, detail::atomic::calculate_failure_order(order));
    }
    bool compare_exchange_weak(
        T * &expected,
        T *desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        intptr_t expected_=(intptr_t)expected, desired_=(intptr_t)desired;
        bool success=super::compare_exchange_weak(expected_, desired_, success_order, failure_order);
        expected=(T*)expected_;
        return success;
    }
    bool compare_exchange_strong(
        T * &expected,
        T *desired,
        memory_order success_order,
        memory_order failure_order) volatile
    {
        intptr_t expected_=(intptr_t)expected, desired_=(intptr_t)desired;
        bool success=super::compare_exchange_strong(expected_, desired_, success_order, failure_order);
        expected=(T*)expected_;
        return success;
    }
    T *exchange(T * replacement, memory_order order=memory_order_seq_cst) volatile
    {
        return (T*)super::exchange((intptr_t)replacement, order);
    }
    using super::is_lock_free;
    operator T *(void) const volatile {return load();}
    T * operator=(T * v) volatile {store(v); return v;}
    T * fetch_add(ptrdiff_t diff, memory_order order=memory_order_seq_cst) volatile
    {
        return (T*)super::fetch_add(diff*sizeof(T), order);
    }
    T * fetch_sub(ptrdiff_t diff, memory_order order=memory_order_seq_cst) volatile
    {
        return (T*)super::fetch_sub(diff*sizeof(T), order);
    }
    T *operator++(void) volatile {return fetch_add(1)+1;}
    T *operator++(int) volatile {return fetch_add(1);}
    T *operator--(void) volatile {return fetch_sub(1)-1;}
    T *operator--(int) volatile {return fetch_sub(1);}
private:
    atomic(const atomic &);
    T * operator=(const atomic &);
};
class atomic_flag : private atomic<int> {
public:
    typedef atomic<int> super;
    using super::is_lock_free;
    atomic_flag(bool initial_state) : super(initial_state?1:0) {}
    atomic_flag() {}
    bool test_and_set(memory_order order=memory_order_seq_cst)
    {
        return super::exchange(1, order) ? true : false;
    }
    void clear(memory_order order=memory_order_seq_cst)
    {
        super::store(0, order);
    }
};
typedef atomic<char> atomic_char;
typedef atomic<unsigned char> atomic_uchar;
typedef atomic<signed char> atomic_schar;
typedef atomic<boost::uint8_t> atomic_uint8_t;
typedef atomic<boost::int8_t> atomic_int8_t;
typedef atomic<unsigned short> atomic_ushort;
typedef atomic<short> atomic_short;
typedef atomic<boost::uint16_t> atomic_uint16_t;
typedef atomic<boost::int16_t> atomic_int16_t;
typedef atomic<unsigned int> atomic_uint;
typedef atomic<int> atomic_int;
typedef atomic<boost::uint32_t> atomic_uint32_t;
typedef atomic<boost::int32_t> atomic_int32_t;
typedef atomic<unsigned long> atomic_ulong;
typedef atomic<long> atomic_long;
typedef atomic<boost::uint64_t> atomic_uint64_t;
typedef atomic<boost::int64_t> atomic_int64_t;
typedef atomic<boost::ulong_long_type> atomic_ullong;
typedef atomic<boost::long_long_type> atomic_llong;
typedef atomic<void*> atomic_address;
typedef atomic<bool> atomic_bool;
static inline void atomic_thread_fence(memory_order order)
{
    detail::atomic::platform_atomic_thread_fence<memory_order>(order);
}
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  struct _List_node_base
  {
    _List_node_base* _M_next;
    _List_node_base* _M_prev;
    static void
    swap(_List_node_base& __x, _List_node_base& __y) throw ();
    void
    _M_transfer(_List_node_base * const __first,
  _List_node_base * const __last) throw ();
    void
    _M_reverse() throw ();
    void
    _M_hook(_List_node_base * const __position) throw ();
    void
    _M_unhook() throw ();
  };
  template<typename _Tp>
    struct _List_node : public _List_node_base
    {
      _Tp _M_data;
      template<typename... _Args>
        _List_node(_Args&&... __args)
 : _List_node_base(), _M_data(std::forward<_Args>(__args)...) { }
    };
  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;
      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
      _List_iterator()
      : _M_node() { }
      explicit
      _List_iterator(_List_node_base* __x)
      : _M_node(__x) { }
      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }
      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }
      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }
      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }
      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }
      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }
      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }
      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }
      _List_node_base* _M_node;
    };
  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;
      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
      _List_const_iterator()
      : _M_node() { }
      explicit
      _List_const_iterator(const _List_node_base* __x)
      : _M_node(__x) { }
      _List_const_iterator(const iterator& __x)
      : _M_node(__x._M_node) { }
      reference
      operator*() const
      { return static_cast<_Node*>(_M_node)->_M_data; }
      pointer
      operator->() const
      { return &static_cast<_Node*>(_M_node)->_M_data; }
      _Self&
      operator++()
      {
 _M_node = _M_node->_M_next;
 return *this;
      }
      _Self
      operator++(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }
      _Self&
      operator--()
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }
      _Self
      operator--(int)
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }
      bool
      operator==(const _Self& __x) const
      { return _M_node == __x._M_node; }
      bool
      operator!=(const _Self& __x) const
      { return _M_node != __x._M_node; }
      const _List_node_base* _M_node;
    };
  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y)
    { return __x._M_node == __y._M_node; }
  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y)
    { return __x._M_node != __y._M_node; }
  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
        _Node_alloc_type;
      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;
      struct _List_impl
      : public _Node_alloc_type
      {
 _List_node_base _M_node;
 _List_impl()
 : _Node_alloc_type(), _M_node()
 { }
 _List_impl(const _Node_alloc_type& __a)
 : _Node_alloc_type(__a), _M_node()
 { }
      };
      _List_impl _M_impl;
      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_alloc_type::allocate(1); }
      void
      _M_put_node(_List_node<_Tp>* __p)
      { _M_impl._Node_alloc_type::deallocate(__p, 1); }
  public:
      typedef _Alloc allocator_type;
      _Node_alloc_type&
      _M_get_Node_allocator()
      { return *static_cast<_Node_alloc_type*>(&this->_M_impl); }
      const _Node_alloc_type&
      _M_get_Node_allocator() const
      { return *static_cast<const _Node_alloc_type*>(&this->_M_impl); }
      _Tp_alloc_type
      _M_get_Tp_allocator() const
      { return _Tp_alloc_type(_M_get_Node_allocator()); }
      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Node_allocator()); }
      _List_base()
      : _M_impl()
      { _M_init(); }
      _List_base(const allocator_type& __a)
      : _M_impl(__a)
      { _M_init(); }
      _List_base(_List_base&& __x)
      : _M_impl(__x._M_get_Node_allocator())
      {
 _M_init();
 _List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node);
      }
      ~_List_base()
      { _M_clear(); }
      void
      _M_clear();
      void
      _M_init()
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
      }
    };
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {
      typedef typename _Alloc::value_type _Alloc_value_type;
     
     
      typedef _List_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;
    protected:
      typedef _List_node<_Tp> _Node;
      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Tp_allocator;
      using _Base::_M_get_Node_allocator;
      template<typename... _Args>
        _Node*
        _M_create_node(_Args&&... __args)
 {
   _Node* __p = this->_M_get_node();
   try
     {
       _M_get_Node_allocator().construct(__p,
      std::forward<_Args>(__args)...);
     }
   catch(...)
     {
       _M_put_node(__p);
       throw;
     }
   return __p;
 }
    public:
      list()
      : _Base() { }
      explicit
      list(const allocator_type& __a)
      : _Base(__a) { }
      explicit
      list(size_type __n, const value_type& __value = value_type(),
    const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_fill_initialize(__n, __value); }
      list(const list& __x)
      : _Base(__x._M_get_Node_allocator())
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }
      list(list&& __x)
      : _Base(std::forward<_Base>(__x)) { }
      list(initializer_list<value_type> __l,
           const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_initialize_dispatch(__l.begin(), __l.end(), __false_type()); }
      template<typename _InputIterator>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
        : _Base(__a)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }
      list&
      operator=(const list& __x);
      list&
      operator=(list&& __x)
      {
 this->clear();
 this->swap(__x);
 return *this;
      }
      list&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }
      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }
      iterator
      begin()
      { return iterator(this->_M_impl._M_node._M_next); }
      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_node._M_next); }
      iterator
      end()
      { return iterator(&this->_M_impl._M_node); }
      const_iterator
      end() const
      { return const_iterator(&this->_M_impl._M_node); }
      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }
      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }
      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }
      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
      const_iterator
      cbegin() const
      { return const_iterator(this->_M_impl._M_node._M_next); }
      const_iterator
      cend() const
      { return const_iterator(&this->_M_impl._M_node); }
      const_reverse_iterator
      crbegin() const
      { return const_reverse_iterator(end()); }
      const_reverse_iterator
      crend() const
      { return const_reverse_iterator(begin()); }
      bool
      empty() const
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }
      size_type
      size() const
      { return std::distance(begin(), end()); }
      size_type
      max_size() const
      { return _M_get_Node_allocator().max_size(); }
      void
      resize(size_type __new_size, value_type __x = value_type());
      reference
      front()
      { return *begin(); }
      const_reference
      front() const
      { return *begin(); }
      reference
      back()
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
      const_reference
      back() const
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }
      void
      push_front(value_type&& __x)
      { this->_M_insert(begin(), std::move(__x)); }
      template<typename... _Args>
        void
        emplace_front(_Args&&... __args)
        { this->_M_insert(begin(), std::forward<_Args>(__args)...); }
      void
      pop_front()
      { this->_M_erase(begin()); }
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }
      void
      push_back(value_type&& __x)
      { this->_M_insert(end(), std::move(__x)); }
      template<typename... _Args>
        void
        emplace_back(_Args&&... __args)
        { this->_M_insert(end(), std::forward<_Args>(__args)...); }
      void
      pop_back()
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
      template<typename... _Args>
        iterator
        emplace(iterator __position, _Args&&... __args);
      iterator
      insert(iterator __position, const value_type& __x);
      iterator
      insert(iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
      void
      insert(iterator __p, initializer_list<value_type> __l)
      { this->insert(__p, __l.begin(), __l.end()); }
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      {
 list __tmp(__n, __x, _M_get_Node_allocator());
 splice(__position, __tmp);
      }
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   list __tmp(__first, __last, _M_get_Node_allocator());
   splice(__position, __tmp);
 }
      iterator
      erase(iterator __position);
      iterator
      erase(iterator __first, iterator __last)
      {
 while (__first != __last)
   __first = erase(__first);
 return __last;
      }
      void
      swap(list& __x)
      {
 _List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node);
 std::__alloc_swap<typename _Base::_Node_alloc_type>::
   _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());
      }
      void
      clear()
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
      void
      splice(iterator __position, list&& __x)
      {
 if (!__x.empty())
   {
     _M_check_equal_allocators(__x);
     this->_M_transfer(__position, __x.begin(), __x.end());
   }
      }
      void
      splice(iterator __position, list& __x)
      { splice(__position, std::move(__x)); }
      void
      splice(iterator __position, list&& __x, iterator __i)
      {
 iterator __j = __i;
 ++__j;
 if (__position == __i || __position == __j)
   return;
 if (this != &__x)
   _M_check_equal_allocators(__x);
 this->_M_transfer(__position, __i, __j);
      }
      void
      splice(iterator __position, list& __x, iterator __i)
      { splice(__position, std::move(__x), __i); }
      void
      splice(iterator __position, list&& __x, iterator __first,
      iterator __last)
      {
 if (__first != __last)
   {
     if (this != &__x)
       _M_check_equal_allocators(__x);
     this->_M_transfer(__position, __first, __last);
   }
      }
      void
      splice(iterator __position, list& __x, iterator __first, iterator __last)
      { splice(__position, std::move(__x), __first, __last); }
      void
      remove(const _Tp& __value);
      template<typename _Predicate>
        void
        remove_if(_Predicate);
      void
      unique();
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
      void
      merge(list&& __x);
      void
      merge(list& __x)
      { merge(std::move(__x)); }
      template<typename _StrictWeakOrdering>
        void
        merge(list&&, _StrictWeakOrdering);
      template<typename _StrictWeakOrdering>
        void
        merge(list& __x, _StrictWeakOrdering __comp)
        { merge(std::move(__x), __comp); }
      void
      reverse()
      { this->_M_impl._M_node._M_reverse(); }
      void
      sort();
      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);
    protected:
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        { _M_fill_initialize(static_cast<size_type>(__n), __x); }
      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }
      void
      _M_fill_initialize(size_type __n, const value_type& __x)
      {
 for (; __n > 0; --__n)
   push_back(__x);
      }
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }
      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);
      void
      _M_fill_assign(size_type __n, const value_type& __val);
      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->_M_transfer(__first._M_node, __last._M_node); }
     template<typename... _Args>
       void
       _M_insert(iterator __position, _Args&&... __args)
       {
  _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
  __tmp->_M_hook(__position._M_node);
       }
      void
      _M_erase(iterator __position)
      {
        __position._M_node->_M_unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);
        _M_get_Node_allocator().destroy(__n);
        _M_put_node(__n);
      }
      void
      _M_check_equal_allocators(list& __x)
      {
 if (std::__alloc_neq<typename _Base::_Node_alloc_type>::
     _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))
   __throw_runtime_error(("list::_M_check_equal_allocators"));
      }
    };
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {
      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();
      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }
  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }
  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear()
    {
      typedef _List_node<_Tp> _Node;
      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);
      while (__cur != &this->_M_impl._M_node)
 {
   _Node* __tmp = __cur;
   __cur = static_cast<_Node*>(__cur->_M_next);
   _M_get_Node_allocator().destroy(__tmp);
   _M_put_node(__tmp);
 }
    }
  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename list<_Tp, _Alloc>::iterator
      list<_Tp, _Alloc>::
      emplace(iterator __position, _Args&&... __args)
      {
 _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
 __tmp->_M_hook(__position._M_node);
 return iterator(__tmp);
      }
  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->_M_hook(__position._M_node);
      return iterator(__tmp);
    }
  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    erase(iterator __position)
    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position);
      return __ret;
    }
  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, value_type __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }
  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   const_iterator __first2 = __x.begin();
   const_iterator __last2 = __x.end();
   for (; __first1 != __last1 && __first2 != __last2;
        ++__first1, ++__first2)
     *__first1 = *__first2;
   if (__first2 == __last2)
     erase(__first1, __last1);
   else
     insert(__last1, __first2, __last2);
 }
      return *this;
    }
  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }
  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }
  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      iterator __extra = __last;
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     {
       if (&*__first != &__value)
  _M_erase(__first);
       else
  __extra = __first;
     }
   __first = __next;
 }
      if (__extra != __last)
 _M_erase(__extra);
    }
  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }
  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    merge(list&& __x)
    {
      if (this != &__x)
 {
   _M_check_equal_allocators(__x);
   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);
 }
    }
  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      merge(list&& __x, _StrictWeakOrdering __comp)
      {
 if (this != &__x)
   {
     _M_check_equal_allocators(__x);
     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);
   }
      }
  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {
      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;
        do
   {
     __carry.splice(__carry.begin(), *this, begin());
     for(__counter = &__tmp[0];
  __counter != __fill && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );
        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }
  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }
  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }
  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {
 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = &__tmp[0];
     list * __counter;
     do
       {
  __carry.splice(__carry.begin(), *this, begin());
  for(__counter = &__tmp[0];
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );
     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1), __comp);
     swap(*(__fill - 1));
   }
      }
}
       
namespace std __attribute__ ((__visibility__ ("default"))) {
  template<typename _Key, typename _Compare = std::less<_Key>,
    typename _Alloc = std::allocator<_Key> >
    class set
    {
      typedef typename _Alloc::value_type _Alloc_value_type;
     
     
     
    public:
      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;
    private:
      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;
      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;
      _Rep_type _M_t;
    public:
      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      set()
      : _M_t() { }
      explicit
      set(const _Compare& __comp,
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
      template<typename _InputIterator>
        set(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_unique(__first, __last); }
      template<typename _InputIterator>
        set(_InputIterator __first, _InputIterator __last,
     const _Compare& __comp,
     const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_unique(__first, __last); }
      set(const set& __x)
      : _M_t(__x._M_t) { }
      set(set&& __x)
      : _M_t(std::forward<_Rep_type>(__x._M_t)) { }
      set(initializer_list<value_type> __l,
   const _Compare& __comp = _Compare(),
   const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a)
      { _M_t._M_insert_unique(__l.begin(), __l.end()); }
      set&
      operator=(const set& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
      set&
      operator=(set&& __x)
      {
 this->clear();
 this->swap(__x);
       return *this;
      }
      set&
      operator=(initializer_list<value_type> __l)
      {
 this->clear();
 this->insert(__l.begin(), __l.end());
 return *this;
      }
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }
      value_compare
      value_comp() const
      { return _M_t.key_comp(); }
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }
      iterator
      begin() const
      { return _M_t.begin(); }
      iterator
      end() const
      { return _M_t.end(); }
      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }
      reverse_iterator
      rend() const
      { return _M_t.rend(); }
      iterator
      cbegin() const
      { return _M_t.begin(); }
      iterator
      cend() const
      { return _M_t.end(); }
      reverse_iterator
      crbegin() const
      { return _M_t.rbegin(); }
      reverse_iterator
      crend() const
      { return _M_t.rend(); }
      bool
      empty() const
      { return _M_t.empty(); }
      size_type
      size() const
      { return _M_t.size(); }
      size_type
      max_size() const
      { return _M_t.max_size(); }
      void
      swap(set& __x)
      { _M_t.swap(__x._M_t); }
      std::pair<iterator, bool>
      insert(const value_type& __x)
      {
 std::pair<typename _Rep_type::iterator, bool> __p =
   _M_t._M_insert_unique(__x);
 return std::pair<iterator, bool>(__p.first, __p.second);
      }
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_unique_(__position, __x); }
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_unique(__first, __last); }
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
      iterator
      erase(iterator __first, iterator __last)
      { return _M_t.erase(__first, __last); }
      void
      clear()
      { _M_t.clear(); }
      size_type
      count(const key_type& __x) const
      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }
      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
    };
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const set<_Key, _Compare, _Alloc>& __x,
       const set<_Key, _Compare, _Alloc>& __y)
    { return __y < __x; }
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const set<_Key, _Compare, _Alloc>& __x,
        const set<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }
  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
}
namespace std __attribute__ ((__visibility__ ("default"))) {
  template <typename _Key, typename _Compare = std::less<_Key>,
     typename _Alloc = std::allocator<_Key> >
    class multiset
    {
      typedef typename _Alloc::value_type _Alloc_value_type;
     
     
     
    public:
      typedef _Key key_type;
      typedef _Key value_type;
      typedef _Compare key_compare;
      typedef _Compare value_compare;
      typedef _Alloc allocator_type;
    private:
      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;
      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
         key_compare, _Key_alloc_type> _Rep_type;
      _Rep_type _M_t;
    public:
      typedef typename _Key_alloc_type::pointer pointer;
      typedef typename _Key_alloc_type::const_pointer const_pointer;
      typedef typename _Key_alloc_type::reference reference;
      typedef typename _Key_alloc_type::const_reference const_reference;
      typedef typename _Rep_type::const_iterator iterator;
      typedef typename _Rep_type::const_iterator const_iterator;
      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
      typedef typename _Rep_type::size_type size_type;
      typedef typename _Rep_type::difference_type difference_type;
      multiset()
      : _M_t() { }
      explicit
      multiset(const _Compare& __comp,
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a) { }
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last)
 : _M_t()
        { _M_t._M_insert_equal(__first, __last); }
      template<typename _InputIterator>
        multiset(_InputIterator __first, _InputIterator __last,
   const _Compare& __comp,
   const allocator_type& __a = allocator_type())
 : _M_t(__comp, __a)
        { _M_t._M_insert_equal(__first, __last); }
      multiset(const multiset& __x)
      : _M_t(__x._M_t) { }
      multiset(multiset&& __x)
      : _M_t(std::forward<_Rep_type>(__x._M_t)) { }
      multiset(initializer_list<value_type> __l,
        const _Compare& __comp = _Compare(),
        const allocator_type& __a = allocator_type())
      : _M_t(__comp, __a)
      { _M_t._M_insert_equal(__l.begin(), __l.end()); }
      multiset&
      operator=(const multiset& __x)
      {
 _M_t = __x._M_t;
 return *this;
      }
      multiset&
      operator=(multiset&& __x)
      {
 this->clear();
 this->swap(__x);
 return *this;
      }
      multiset&
      operator=(initializer_list<value_type> __l)
      {
 this->clear();
 this->insert(__l.begin(), __l.end());
 return *this;
      }
      key_compare
      key_comp() const
      { return _M_t.key_comp(); }
      value_compare
      value_comp() const
      { return _M_t.key_comp(); }
      allocator_type
      get_allocator() const
      { return _M_t.get_allocator(); }
      iterator
      begin() const
      { return _M_t.begin(); }
      iterator
      end() const
      { return _M_t.end(); }
      reverse_iterator
      rbegin() const
      { return _M_t.rbegin(); }
      reverse_iterator
      rend() const
      { return _M_t.rend(); }
      iterator
      cbegin() const
      { return _M_t.begin(); }
      iterator
      cend() const
      { return _M_t.end(); }
      reverse_iterator
      crbegin() const
      { return _M_t.rbegin(); }
      reverse_iterator
      crend() const
      { return _M_t.rend(); }
      bool
      empty() const
      { return _M_t.empty(); }
      size_type
      size() const
      { return _M_t.size(); }
      size_type
      max_size() const
      { return _M_t.max_size(); }
      void
      swap(multiset& __x)
      { _M_t.swap(__x._M_t); }
      iterator
      insert(const value_type& __x)
      { return _M_t._M_insert_equal(__x); }
      iterator
      insert(iterator __position, const value_type& __x)
      { return _M_t._M_insert_equal_(__position, __x); }
      template<typename _InputIterator>
        void
        insert(_InputIterator __first, _InputIterator __last)
        { _M_t._M_insert_equal(__first, __last); }
      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }
      iterator
      erase(iterator __position)
      { return _M_t.erase(__position); }
      size_type
      erase(const key_type& __x)
      { return _M_t.erase(__x); }
      iterator
      erase(iterator __first, iterator __last)
      { return _M_t.erase(__first, __last); }
      void
      clear()
      { _M_t.clear(); }
      size_type
      count(const key_type& __x) const
      { return _M_t.count(__x); }
      iterator
      find(const key_type& __x)
      { return _M_t.find(__x); }
      const_iterator
      find(const key_type& __x) const
      { return _M_t.find(__x); }
      iterator
      lower_bound(const key_type& __x)
      { return _M_t.lower_bound(__x); }
      const_iterator
      lower_bound(const key_type& __x) const
      { return _M_t.lower_bound(__x); }
      iterator
      upper_bound(const key_type& __x)
      { return _M_t.upper_bound(__x); }
      const_iterator
      upper_bound(const key_type& __x) const
      { return _M_t.upper_bound(__x); }
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_t.equal_range(__x); }
      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_t.equal_range(__x); }
      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator==(const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);
      template<typename _K1, typename _C1, typename _A1>
        friend bool
        operator< (const multiset<_K1, _C1, _A1>&,
     const multiset<_K1, _C1, _A1>&);
    };
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator==(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t == __y._M_t; }
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<(const multiset<_Key, _Compare, _Alloc>& __x,
       const multiset<_Key, _Compare, _Alloc>& __y)
    { return __x._M_t < __y._M_t; }
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator!=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x == __y); }
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>(const multiset<_Key,_Compare,_Alloc>& __x,
       const multiset<_Key,_Compare,_Alloc>& __y)
    { return __y < __x; }
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator<=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__y < __x); }
  template<typename _Key, typename _Compare, typename _Alloc>
    inline bool
    operator>=(const multiset<_Key, _Compare, _Alloc>& __x,
        const multiset<_Key, _Compare, _Alloc>& __y)
    { return !(__x < __y); }
  template<typename _Key, typename _Compare, typename _Alloc>
    inline void
    swap(multiset<_Key, _Compare, _Alloc>& __x,
  multiset<_Key, _Compare, _Alloc>& __y)
    { __x.swap(__y); }
}
namespace boost { namespace mpl {
template< typename Tag > struct begin_impl;
template< typename Tag > struct end_impl;
template< typename Sequence > struct begin;
template< typename Sequence > struct end;
}}
namespace boost { namespace fusion
{
    namespace detail
    {
        struct from_sequence_convertible_type
        {};
    }
    template <typename Sequence>
    struct sequence_base
    {
        Sequence const&
        derived() const
        {
            return static_cast<Sequence const&>(*this);
        }
        Sequence&
        derived()
        {
            return static_cast<Sequence&>(*this);
        }
        operator detail::from_sequence_convertible_type()const
        {
            return detail::from_sequence_convertible_type();
        }
    };
    struct fusion_sequence_tag;
}}
namespace boost { namespace mpl
{
    template<> struct begin_impl< boost::fusion::fusion_sequence_tag >;
}}
namespace boost { namespace fusion { namespace detail
{
    template <typename T>
    struct ref_result
    {
        typedef typename add_reference<typename T::type>::type type;
    };
    template <typename T>
    struct cref_result
    {
        typedef typename
            add_reference<
                typename add_const<typename T::type>::type
            >::type
        type;
    };
    template <typename T>
    struct call_param
    {
        typedef T const& type;
    };
    template <typename T>
    struct call_param<T &>
    {
        typedef T& type;
    };
    template <typename T>
    struct call_param<T const>
    {
        typedef T const& type;
    };
    template <typename T>
    struct call_param<T volatile>
    {
        typedef T const& type;
    };
    template <typename T>
    struct call_param<T const volatile>
    {
        typedef T const& type;
    };
}}}
namespace boost { namespace fusion
{
    namespace traits
    {
        template<typename T, typename Active = void>
        struct tag_of;
    }
}}
namespace boost { namespace mpl {
struct nested_begin_end_tag;
struct non_sequence_tag;
template< typename Sequence > struct sequence_tag;
}}
namespace boost { namespace mpl { namespace aux {
template< typename T, typename fallback_ = boost::mpl::bool_<true> > struct has_begin { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::begin>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
}}}
namespace boost { namespace mpl {
namespace aux {
template< typename Sequence >
struct begin_type
{
    typedef typename Sequence::begin type;
};
template< typename Sequence >
struct end_type
{
    typedef typename Sequence::end type;
};
}
template< typename Tag >
struct begin_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename eval_if<aux::has_begin<Sequence, true_>,
                                 aux::begin_type<Sequence>, void_>::type type;
    };
};
template< typename Tag >
struct end_impl
{
    template< typename Sequence > struct apply
    {
        typedef typename eval_if<aux::has_begin<Sequence, true_>,
                                 aux::end_type<Sequence>, void_>::type type;
    };
};
template<> struct begin_impl<nested_begin_end_tag> { template< typename Sequence > struct apply { typedef typename Sequence::begin type; }; };
template<> struct end_impl<nested_begin_end_tag> { template< typename Sequence > struct apply { typedef typename Sequence::end type; }; };
template<> struct begin_impl<non_sequence_tag> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct end_impl<non_sequence_tag> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct begin_impl<na> { template< typename Sequence > struct apply { typedef void_ type; }; };
template<> struct end_impl<na> { template< typename Sequence > struct apply { typedef void_ type; }; };


}}
namespace boost { namespace mpl {
namespace aux {
template< bool has_tag_, bool has_begin_ >
struct sequence_tag_impl
{
    template< typename Sequence > struct result2_;
};
template<> struct sequence_tag_impl<true,true> { template< typename Sequence > struct result2_ { typedef typename Sequence::tag type; }; };
template<> struct sequence_tag_impl<true,false> { template< typename Sequence > struct result2_ { typedef typename Sequence::tag type; }; };
template<> struct sequence_tag_impl<false,true> { template< typename Sequence > struct result2_ { typedef nested_begin_end_tag type; }; };
template<> struct sequence_tag_impl<false,false> { template< typename Sequence > struct result2_ { typedef non_sequence_tag type; }; };
}
template<
      typename Sequence = na
    >
struct sequence_tag
    : aux::sequence_tag_impl<
          ::boost::mpl::aux::has_tag<Sequence>::value
        , ::boost::mpl::aux::has_begin<Sequence>::value
        >::template result2_<Sequence>
{
};
template<> struct sequence_tag< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : sequence_tag< T1 > { }; }; template< typename Tag > struct lambda< sequence_tag< na > , Tag , int_<-1> > { typedef false_ is_le; typedef sequence_tag< na > result_; typedef sequence_tag< na > type; }; namespace aux { template< typename T1 > struct template_arity< sequence_tag< T1 > > : int_<1> { }; template<> struct template_arity< sequence_tag< na > > : int_<-1> { }; }
}}
namespace boost { namespace mpl {
template<
      typename Sequence = na
    >
struct begin
{
    typedef typename sequence_tag<Sequence>::type tag_;
    typedef typename begin_impl< tag_ >
        ::template apply< Sequence >::type type;
   
};
template<
      typename Sequence = na
    >
struct end
{
    typedef typename sequence_tag<Sequence>::type tag_;
    typedef typename end_impl< tag_ >
        ::template apply< Sequence >::type type;
   
};
template<> struct begin< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : begin< T1 > { }; }; template< typename Tag > struct lambda< begin< na > , Tag , int_<-1> > { typedef false_ is_le; typedef begin< na > result_; typedef begin< na > type; }; namespace aux { template< typename T1 > struct template_arity< begin< T1 > > : int_<1> { }; template<> struct template_arity< begin< na > > : int_<-1> { }; }
template<> struct end< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : end< T1 > { }; }; template< typename Tag > struct lambda< end< na > , Tag , int_<-1> > { typedef false_ is_le; typedef end< na > result_; typedef end< na > type; }; namespace aux { template< typename T1 > struct template_arity< end< T1 > > : int_<1> { }; template<> struct template_arity< end< na > > : int_<-1> { }; }
}}
namespace boost { namespace mpl {
template<
      typename T = na
    >
struct is_sequence
    : not_< is_same< typename begin<T>::type, void_ > >
{
   
};
template<> struct is_sequence< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : is_sequence< T1 > { }; }; template< typename Tag > struct lambda< is_sequence< na > , Tag , int_<-1> > { typedef false_ is_le; typedef is_sequence< na > result_; typedef is_sequence< na > type; }; namespace aux { template< typename T1 > struct template_arity< is_sequence< T1 > > : int_<1> { }; template<> struct template_arity< is_sequence< na > > : int_<-1> { }; }
}}
namespace boost { namespace fusion { namespace detail
{
    template <typename T>
    struct is_mpl_sequence
        : mpl::and_<
            mpl::not_<is_convertible<T, from_sequence_convertible_type> >
          , mpl::is_sequence<T> >
    {};
}}}
namespace boost
{
    template <typename T, std::size_t N>
    class array;
    namespace tuples
    {
        struct null_type;
        template <
            class T0, class T1, class T2, class T3, class T4,
            class T5, class T6, class T7, class T8, class T9
        >
        class tuple;
        template <class Head, class Tail>
        struct cons;
    }
}
namespace boost { namespace fusion
{
    struct non_fusion_tag;
    struct mpl_sequence_tag;
    namespace detail
    {
        template< typename T, typename fallback_ = boost::mpl::bool_<false> > struct has_fusion_tag { struct gcc_3_2_wknd { template< typename U > static boost::mpl::aux::yes_tag test( boost::mpl::aux::type_wrapper<U> const volatile* , boost::mpl::aux::type_wrapper<typename U::fusion_tag>* = 0 ); static boost::mpl::aux::no_tag test(...); }; typedef boost::mpl::aux::type_wrapper<T> t_; static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == sizeof(boost::mpl::aux::yes_tag); typedef boost::mpl::bool_<value> type; };
    }
    namespace traits
    {
        template <typename Sequence, typename Active>
        struct tag_of
          : mpl::if_< fusion::detail::is_mpl_sequence<Sequence>,
              mpl::identity<mpl_sequence_tag>,
              mpl::identity<non_fusion_tag> >::type
        {};
        template <typename Sequence>
        struct tag_of<Sequence, typename boost::enable_if<detail::has_fusion_tag<Sequence> >::type>
        {
            typedef typename Sequence::fusion_tag type;
        };
    }
    namespace detail
    {
        template<typename T>
        struct tag_of
            : traits::tag_of<typename remove_const<T>::type>
        {};
    }
}}
namespace boost { namespace fusion
{
    struct iterator_facade_tag;
    struct boost_array_iterator_tag;
    struct mpl_iterator_tag;
    struct std_pair_iterator_tag;
    namespace extension
    {
        template <typename Tag>
        struct next_impl
        {
            template <typename Iterator>
            struct apply {};
        };
        template <>
        struct next_impl<iterator_facade_tag>
        {
            template <typename Iterator>
            struct apply : Iterator::template next<Iterator> {};
        };
        template <>
        struct next_impl<boost_array_iterator_tag>;
        template <>
        struct next_impl<mpl_iterator_tag>;
        template <>
        struct next_impl<std_pair_iterator_tag>;
    }
    namespace result_of
    {
        template <typename Iterator>
        struct next
            : extension::next_impl<typename detail::tag_of<Iterator>::type>::
                template apply<Iterator>
        {};
    }
    template <typename Iterator>
    typename result_of::next<Iterator>::type const
    next(Iterator const& i)
    {
        return result_of::next<Iterator>::call(i);
    }
}}
namespace boost { namespace fusion
{
    struct iterator_root {};
    template <typename Iterator>
    struct iterator_base : iterator_root
    {
        Iterator const&
        cast() const
        {
            return static_cast<Iterator const&>(*this);
        }
        Iterator&
        cast()
        {
            return static_cast<Iterator&>(*this);
        }
    };
}}
namespace boost { namespace fusion
{
    struct iterator_facade_tag;
    struct boost_array_iterator_tag;
    struct mpl_iterator_tag;
    struct std_pair_iterator_tag;
    namespace extension
    {
        template <typename Tag>
        struct deref_impl
        {
            template <typename Iterator>
            struct apply {};
        };
        template <>
        struct deref_impl<iterator_facade_tag>
        {
            template <typename Iterator>
            struct apply : Iterator::template deref<Iterator> {};
       };
        template <>
        struct deref_impl<boost_array_iterator_tag>;
        template <>
        struct deref_impl<mpl_iterator_tag>;
        template <>
        struct deref_impl<std_pair_iterator_tag>;
    }
    namespace result_of
    {
        template <typename Iterator>
        struct deref
            : extension::deref_impl<typename detail::tag_of<Iterator>::type>::
                template apply<Iterator>
        {};
    }
    template <typename Iterator>
    typename result_of::deref<Iterator>::type
    deref(Iterator const& i)
    {
        typedef result_of::deref<Iterator> deref_meta;
        return deref_meta::call(i);
    }
    template <typename Iterator>
    typename result_of::deref<Iterator>::type
    operator*(iterator_base<Iterator> const& i)
    {
        return fusion::deref(i.cast());
    }
}}
namespace boost { namespace fusion
{
    struct non_fusion_tag;
    struct boost_tuple_tag;
    struct boost_array_tag;
    struct mpl_sequence_tag;
    struct std_pair_tag;
    namespace extension
    {
        template <typename T>
        struct is_sequence_impl
        {
            template <typename Sequence>
            struct apply
              : is_convertible<Sequence, detail::from_sequence_convertible_type>
            {};
        };
        template <>
        struct is_sequence_impl<non_fusion_tag>
        {
            template <typename T>
            struct apply : mpl::false_ {};
        };
        template <>
        struct is_sequence_impl<boost_tuple_tag>;
        template <>
        struct is_sequence_impl<boost_array_tag>;
        template <>
        struct is_sequence_impl<mpl_sequence_tag>;
        template <>
        struct is_sequence_impl<std_pair_tag>;
    }
    namespace traits
    {
        template <typename T>
        struct is_sequence
          : extension::is_sequence_impl<
                typename fusion::detail::tag_of<T>::type
            >::template apply<T>
        {};
        template <typename Sequence, typename Enable = void>
        struct is_native_fusion_sequence
          : is_convertible<Sequence, detail::from_sequence_convertible_type>
        {};
    }
}}
namespace boost { namespace fusion
{
    struct sequence_facade_tag;
    struct boost_tuple_tag;
    struct boost_array_tag;
    struct mpl_sequence_tag;
    struct std_pair_tag;
    namespace extension
    {
        template <typename Tag>
        struct begin_impl
        {
            template <typename Sequence>
            struct apply;
        };
        template <>
        struct begin_impl<sequence_facade_tag>
        {
            template <typename Sequence>
            struct apply : Sequence::template begin<Sequence> {};
        };
        template <>
        struct begin_impl<boost_tuple_tag>;
        template <>
        struct begin_impl<boost_array_tag>;
        template <>
        struct begin_impl<mpl_sequence_tag>;
        template <>
        struct begin_impl<std_pair_tag>;
    }
    namespace result_of
    {
        template <typename Sequence>
        struct begin
            : extension::begin_impl<typename detail::tag_of<Sequence>::type>::
                template apply<Sequence>
        {};
    }
    template <typename Sequence>
    inline typename
        lazy_enable_if<
            traits::is_sequence<Sequence>
          , result_of::begin<Sequence>
        >::type const
    begin(Sequence& seq)
    {
        return result_of::begin<Sequence>::call(seq);
    }
    template <typename Sequence>
    inline typename
        lazy_enable_if<
            traits::is_sequence<Sequence>
          , result_of::begin<Sequence const>
        >::type const
    begin(Sequence const& seq)
    {
        return result_of::begin<Sequence const>::call(seq);
    }
}}
namespace boost { namespace mpl {
template< typename Tag > struct at_impl;
template< typename Sequence, typename N > struct at;
}}
namespace boost { namespace mpl {

template< typename Tag > struct advance_impl;
template< typename Iterator, typename N > struct advance;
}}
namespace boost { namespace mpl {
template< typename Tag > struct negate_impl;
template< typename T > struct negate_tag
{
    typedef typename T::tag type;
};
template<
      typename N = na
    >
struct negate
    : negate_impl<
          typename negate_tag<N>::type
        >::template apply<N>::type
{
   
};
template<> struct negate< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : negate< T1 > { }; }; template< typename Tag > struct lambda< negate< na > , Tag , int_<-1> > { typedef false_ is_le; typedef negate< na > result_; typedef negate< na > type; }; namespace aux { template< typename T1 > struct template_arity< negate< T1 > > : int_<1> { }; template<> struct template_arity< negate< na > > : int_<-1> { }; }
template<>
struct negate_impl<integral_c_tag>
{
    template< typename N > struct apply
        : integral_c< typename N::value_type, (-N::value) >
    {
    };
};
}}
namespace mpl_ {
template< long N > struct long_;
}
namespace boost { namespace mpl { using ::mpl_::long_; } }
namespace mpl_ {
template< long N >
struct long_
{
    static const long value = N;
    typedef long_ type;
    typedef long value_type;
    typedef integral_c_tag tag;
    typedef mpl_::long_< static_cast<long>((value + 1)) > next;
    typedef mpl_::long_< static_cast<long>((value - 1)) > prior;
    operator long() const { return static_cast<long>(this->value); }
};
template< long N >
long const mpl_::long_< N >::value;
}
namespace boost { namespace mpl { namespace aux {
template< long N > struct advance_forward;
template<>
struct advance_forward<0>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef iter0 type;
    };
};
template<>
struct advance_forward<1>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef iter1 type;
    };
};
template<>
struct advance_forward<2>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef typename next<iter1>::type iter2;
        typedef iter2 type;
    };
};
template<>
struct advance_forward<3>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef typename next<iter1>::type iter2;
        typedef typename next<iter2>::type iter3;
        typedef iter3 type;
    };
};
template<>
struct advance_forward<4>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename next<iter0>::type iter1;
        typedef typename next<iter1>::type iter2;
        typedef typename next<iter2>::type iter3;
        typedef typename next<iter3>::type iter4;
        typedef iter4 type;
    };
};
template< long N >
struct advance_forward
{
    template< typename Iterator > struct apply
    {
        typedef typename apply_wrap1<
              advance_forward<4>
            , Iterator
            >::type chunk_result_;
        typedef typename apply_wrap1<
              advance_forward<(
                (N - 4) < 0
                    ? 0
                    : N - 4
                    )>
            , chunk_result_
            >::type type;
    };
};
}}}
namespace boost { namespace mpl { namespace aux {
template< long N > struct advance_backward;
template<>
struct advance_backward<0>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef iter0 type;
    };
};
template<>
struct advance_backward<1>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef iter1 type;
    };
};
template<>
struct advance_backward<2>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef typename prior<iter1>::type iter2;
        typedef iter2 type;
    };
};
template<>
struct advance_backward<3>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef typename prior<iter1>::type iter2;
        typedef typename prior<iter2>::type iter3;
        typedef iter3 type;
    };
};
template<>
struct advance_backward<4>
{
    template< typename Iterator > struct apply
    {
        typedef Iterator iter0;
        typedef typename prior<iter0>::type iter1;
        typedef typename prior<iter1>::type iter2;
        typedef typename prior<iter2>::type iter3;
        typedef typename prior<iter3>::type iter4;
        typedef iter4 type;
    };
};
template< long N >
struct advance_backward
{
    template< typename Iterator > struct apply
    {
        typedef typename apply_wrap1<
              advance_backward<4>
            , Iterator
            >::type chunk_result_;
        typedef typename apply_wrap1<
              advance_backward<(
                (N - 4) < 0
                    ? 0
                    : N - 4
                    )>
            , chunk_result_
            >::type type;
    };
};
}}}
namespace boost { namespace mpl {
template< typename Tag >
struct advance_impl
{
    template< typename Iterator, typename N > struct apply
    {
        typedef typename less< N,long_<0> >::type backward_;
        typedef typename if_< backward_, negate<N>, N >::type offset_;
        typedef typename if_<
              backward_
            , aux::advance_backward< offset_::value >
            , aux::advance_forward< offset_::value >
            >::type f_;
        typedef typename apply_wrap1<f_,Iterator>::type type;
    };
};
template<
      typename Iterator = na
    , typename N = na
    >
struct advance
    : advance_impl< typename tag<Iterator>::type >
        ::template apply<Iterator,N>
{
};
template<
      typename Iterator
    , long N
    >
struct advance_c
    : advance_impl< typename tag<Iterator>::type >
        ::template apply<Iterator,long_<N> >
{
};
template<> struct advance< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : advance< T1 , T2 > { }; }; template< typename Tag > struct lambda< advance< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef advance< na , na > result_; typedef advance< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< advance< T1 , T2 > > : int_<2> { }; template<> struct template_arity< advance< na , na > > : int_<-1> { }; }
}}
namespace boost { namespace mpl { namespace aux {
template< typename T > struct msvc_type
{
    typedef typename T::type type;
};
template<> struct msvc_type<int>
{
    typedef int type;
};
}}}
namespace boost { namespace mpl {
template<
      typename Iterator = na
    >
struct deref
{
    typedef typename Iterator::type type;
   
};
template<> struct deref< na > { template< typename T1 , typename T2 =na , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : deref< T1 > { }; }; template< typename Tag > struct lambda< deref< na > , Tag , int_<-1> > { typedef false_ is_le; typedef deref< na > result_; typedef deref< na > type; }; namespace aux { template< typename T1 > struct template_arity< deref< T1 > > : int_<1> { }; template<> struct template_arity< deref< na > > : int_<-1> { }; }
}}
namespace boost { namespace mpl {
template< typename Tag >
struct at_impl
{
    template< typename Sequence, typename N > struct apply
    {
        typedef typename advance<
              typename begin<Sequence>::type
            , N
            >::type iter_;
        typedef typename deref<iter_>::type type;
    };
};
 template<> struct at_impl<non_sequence_tag> {};
}}
namespace boost { namespace mpl {
template<
      typename Sequence = na
    , typename N = na
    >
struct at
    : at_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,N >
{
   
};
template<
      typename Sequence
    , long N
    >
struct at_c
    : at_impl< typename sequence_tag<Sequence>::type >
        ::template apply< Sequence,mpl::long_<N> >
{
};
template<> struct at< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : at< T1 , T2 > { }; }; template< typename Tag > struct lambda< at< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef at< na , na > result_; typedef at< na , na > type; }; namespace aux { template< typename T1 , typename T2 > struct template_arity< at< T1 , T2 > > : int_<2> { }; template<> struct template_arity< at< na , na > > : int_<-1> { }; }
}}
namespace boost { namespace fusion
{
    struct vector_tag;
    namespace extension
    {
        template <typename Tag>
        struct at_impl;
        template <>
        struct at_impl<vector_tag>
        {
            template <typename Sequence, typename N>
            struct apply
            {
                typedef mpl::at<typename Sequence::types, N> element;
                typedef typename detail::ref_result<element>::type type;
                static type
                call(Sequence& v)
                {
                    return v.at_impl(N());
                }
            };
            template <typename Sequence, typename N>
            struct apply <Sequence const, N>
            {
                typedef mpl::at<typename Sequence::types, N> element;
                typedef typename detail::cref_result<element>::type type;
                static type
                call(Sequence const& v)
                {
                    return v.at_impl(N());
                }
            };
        };
    }
}}
namespace boost { namespace fusion
{
    struct vector_tag;
    namespace extension
    {
        template <typename Tag>
        struct value_at_impl;
        template <>
        struct value_at_impl<vector_tag>
        {
            template <typename Sequence, typename N>
            struct apply
            {
                typedef typename mpl::at<typename Sequence::types, N>::type type;
            };
        };
    }
}}
namespace boost { namespace fusion
{
    struct vector_iterator_tag;
    namespace extension
    {
        template <typename Tag>
        struct deref_impl;
        template <>
        struct deref_impl<vector_iterator_tag>
        {
            template <typename Iterator>
            struct apply
            {
                typedef typename Iterator::vector vector;
                typedef typename Iterator::index index;
                typedef typename mpl::at<
                    typename vector::types, index>
                element;
                typedef typename
                    mpl::eval_if<
                        is_const<vector>
                      , fusion::detail::cref_result<element>
                      , fusion::detail::ref_result<element>
                    >::type
                type;
                static type
                call(Iterator const& i)
                {
                    return i.vec.at_impl(index());
                }
            };
        };
    }
}}
namespace boost { namespace fusion
{
    struct vector_iterator_tag;
    namespace extension
    {
        template <typename Tag>
        struct value_of_impl;
        template <>
        struct value_of_impl<vector_iterator_tag>
        {
            template <typename Iterator>
            struct apply
            {
                typedef typename Iterator::vector vector;
                typedef typename Iterator::index index;
                typedef typename mpl::at<
                    typename vector::types, index>::type
                type;
            };
        };
    }
}}
namespace boost { namespace fusion
{
    struct vector_iterator_tag;
    template <typename Vector, int N>
    struct vector_iterator;
    namespace extension
    {
        template <typename Tag>
        struct next_impl;
        template <>
        struct next_impl<vector_iterator_tag>
        {
            template <typename Iterator>
            struct apply
            {
                typedef typename Iterator::vector vector;
                typedef typename Iterator::index index;
                typedef vector_iterator<vector, index::value+1> type;
                static type
                call(Iterator const& i)
                {
                    return type(i.vec);
                }
            };
        };
    }
}}
namespace boost { namespace fusion
{
    struct vector_iterator_tag;
    template <typename Vector, int N>
    struct vector_iterator;
    namespace extension
    {
        template <typename Tag>
        struct prior_impl;
        template <>
        struct prior_impl<vector_iterator_tag>
        {
            template <typename Iterator>
            struct apply
            {
                typedef typename Iterator::vector vector;
                typedef typename Iterator::index index;
                typedef vector_iterator<vector, index::value-1> type;
                static type
                call(Iterator const& i)
                {
                    return type(i.vec);
                }
            };
        };
    }
}}
namespace boost { namespace fusion
{
    struct vector_iterator_tag;
    namespace extension
    {
        template <typename Tag>
        struct equal_to_impl;
        template <>
        struct equal_to_impl<vector_iterator_tag>
        {
            template <typename I1, typename I2>
            struct apply
                : is_same<
                    typename I1::identity
                  , typename I2::identity
                >
            {
            };
        };
    }
}}
namespace boost { namespace mpl {
template<
      typename Tag1
    , typename Tag2
    >
struct minus_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )
        , aux::cast2nd_impl< minus_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< minus_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};
template<> struct minus_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};
template< typename Tag > struct minus_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};
template< typename Tag > struct minus_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};
template< typename T > struct minus_tag
{
    typedef typename T::tag type;
};
template<
      typename N1 = na
    , typename N2 = na
    , typename N3 = na, typename N4 = na, typename N5 = na
    >
struct minus
    : minus< minus< minus< minus< N1,N2 >, N3>, N4>, N5>
{
   
};
template<
      typename N1, typename N2, typename N3, typename N4
    >
struct minus< N1,N2,N3,N4,na >
    : minus< minus< minus< N1,N2 >, N3>, N4>
{
   
};
template<
      typename N1, typename N2, typename N3
    >
struct minus< N1,N2,N3,na,na >
    : minus< minus< N1,N2 >, N3>
{
   
};
template<
      typename N1, typename N2
    >
struct minus< N1,N2,na,na,na >
    : minus_impl<
          typename minus_tag<N1>::type
        , typename minus_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   
};
template<> struct minus< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : minus< T1 , T2 > { }; }; template< typename Tag > struct lambda< minus< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef minus< na , na > result_; typedef minus< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< minus< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< minus< na , na > > : int_<-1> { }; }
}}
namespace boost { namespace mpl {
template<>
struct minus_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply
        : integral_c<
              typename aux::largest_int<
                  typename N1::value_type
                , typename N2::value_type
                >::type
            , ( N1::value
                  - N2::value
                )
            >
    {
    };
};
}}
namespace boost { namespace fusion
{
    struct vector_iterator_tag;
    namespace extension
    {
        template <typename Tag>
        struct distance_impl;
        template <>
        struct distance_impl<vector_iterator_tag>
        {
            template <typename First, typename Last>
            struct apply : mpl::minus<typename Last::index, typename First::index>
            {
                static typename mpl::minus<
                    typename Last::index, typename First::index>::type
                call(First const&, Last const&)
                {
                    typedef typename mpl::minus<
                        typename Last::index, typename First::index>::type
                    result;
                    return result();
                }
            };
        };
    }
}}
namespace boost { namespace fusion
{
    struct vector_iterator_tag;
    template <typename Vector, int N>
    struct vector_iterator;
    namespace extension
    {
        template <typename Tag>
        struct advance_impl;
        template <>
        struct advance_impl<vector_iterator_tag>
        {
            template <typename Iterator, typename N>
            struct apply
            {
                typedef typename Iterator::index index;
                typedef typename Iterator::vector vector;
                typedef vector_iterator<vector, index::value+N::value> type;
                static type
                call(Iterator const& i)
                {
                    return type(i.vec);
                }
            };
        };
    }
}}
namespace boost { namespace fusion
{
    struct vector_iterator_tag;
    struct random_access_traversal_tag;
    template <typename Vector, int N>
    struct vector_iterator_identity;
    template <typename Vector, int N>
    struct vector_iterator : iterator_base<vector_iterator<Vector, N> >
    {
        typedef mpl::int_<N> index;
        typedef Vector vector;
        typedef vector_iterator_tag fusion_tag;
        typedef random_access_traversal_tag category;
        typedef vector_iterator_identity<
            typename add_const<Vector>::type, N> identity;
        vector_iterator(Vector& in_vec)
            : vec(in_vec) {}
        Vector& vec;
    private:
        vector_iterator& operator= (vector_iterator const&);
    };
}}
namespace boost { namespace fusion
{
    struct vector_tag;
    namespace extension
    {
        template <typename Tag>
        struct begin_impl;
        template <>
        struct begin_impl<vector_tag>
        {
            template <typename Sequence>
            struct apply
            {
                typedef vector_iterator<Sequence, 0> type;
                static type
                call(Sequence& v)
                {
                    return type(v);
                }
            };
        };
    }
}}
namespace boost { namespace fusion
{
    struct vector_tag;
    namespace extension
    {
        template <typename Tag>
        struct end_impl;
        template <>
        struct end_impl<vector_tag>
        {
            template <typename Sequence>
            struct apply
            {
                typedef typename Sequence::size size;
                typedef vector_iterator<Sequence, size::value> type;
                static type
                call(Sequence& v)
                {
                    return type(v);
                }
            };
        };
    }
}}
namespace boost { namespace mpl { namespace aux {
struct v_iter_tag;
struct vector_tag;
}}}
namespace boost { namespace mpl {
template< typename Vector, long n_ >
struct v_at_impl
{
    typedef long_< (Vector::lower_bound_::value + n_) > index_;
    typedef __typeof__( Vector::item_(index_()) ) type;
};
template< typename Vector, long n_ >
struct v_at
    : aux::wrapped_type< typename v_at_impl<Vector,n_>::type >
{
};
template<>
struct at_impl< aux::vector_tag >
{
    template< typename Vector, typename N > struct apply
        : v_at<
              Vector
            , N::value
            >
    {
    };
};
}}
namespace boost { namespace mpl {
template< typename Tag > struct front_impl;
template< typename Sequence > struct front;
}}
namespace boost { namespace mpl {
template<>
struct front_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : v_at<Vector,0>
    {
    };
};
}}
namespace boost { namespace mpl {
template< typename Tag > struct push_front_impl;
template< typename Sequence, typename T > struct push_front;
}}
namespace boost { namespace mpl {
template<
      typename T
    , typename Base
    , int at_front = 0
    >
struct v_item
    : Base
{
    typedef typename Base::upper_bound_ index_;
    typedef typename next<index_>::type upper_bound_;
    typedef typename next<typename Base::size>::type size;
    typedef Base base;
    typedef v_item type;
    static aux::type_wrapper<T> item_(index_);
    using Base::item_;
};
template<
      typename T
    , typename Base
    >
struct v_item<T,Base,1>
    : Base
{
    typedef typename prior<typename Base::lower_bound_>::type index_;
    typedef index_ lower_bound_;
    typedef typename next<typename Base::size>::type size;
    typedef Base base;
    typedef v_item type;
    static aux::type_wrapper<T> item_(index_);
    using Base::item_;
};
template<
      typename Base
    , int at_front
    >
struct v_mask
    : Base
{
    typedef typename prior<typename Base::upper_bound_>::type index_;
    typedef index_ upper_bound_;
    typedef typename prior<typename Base::size>::type size;
    typedef Base base;
    typedef v_mask type;
    static aux::type_wrapper<void_> item_(index_);
    using Base::item_;
};
template<
      typename Base
    >
struct v_mask<Base,1>
    : Base
{
    typedef typename Base::lower_bound_ index_;
    typedef typename next<index_>::type lower_bound_;
    typedef typename prior<typename Base::size>::type size;
    typedef Base base;
    typedef v_mask type;
    static aux::type_wrapper<void_> item_(index_);
    using Base::item_;
};
}}
namespace boost { namespace mpl {
template<>
struct push_front_impl< aux::vector_tag >
{
    template< typename Vector, typename T > struct apply
    {
        typedef v_item<T,Vector,1> type;
    };
};
}}
namespace boost { namespace mpl {
template< typename Tag > struct pop_front_impl;
template< typename Sequence > struct pop_front;
}}
namespace boost { namespace mpl {
template<>
struct pop_front_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_mask<Vector,1> type;
    };
};
}}
namespace boost { namespace mpl {
template< typename Tag > struct push_back_impl;
template< typename Sequence, typename T > struct push_back;
}}
namespace boost { namespace mpl {
template<>
struct push_back_impl< aux::vector_tag >
{
    template< typename Vector, typename T > struct apply
    {
        typedef v_item<T,Vector,0> type;
    };
};
}}
namespace boost { namespace mpl {
template< typename Tag > struct pop_back_impl;
template< typename Sequence > struct pop_back;
}}
namespace boost { namespace mpl {
template<>
struct pop_back_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_mask<Vector,0> type;
    };
};
}}
namespace boost { namespace mpl {
template< typename Tag > struct back_impl;
template< typename Sequence > struct back;
}}
namespace boost { namespace mpl {
template<>
struct back_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : v_at<
              Vector
            , prior<typename Vector::size>::type::value
            >
    {
    };
};
}}
namespace boost { namespace mpl {
template< typename Tag > struct clear_impl;
template< typename Sequence > struct clear;
}}
namespace boost { namespace mpl {
struct forward_iterator_tag : int_<0> { typedef forward_iterator_tag type; };
struct bidirectional_iterator_tag : int_<1> { typedef bidirectional_iterator_tag type; };
struct random_access_iterator_tag : int_<2> { typedef random_access_iterator_tag type; };
}}
namespace boost { namespace mpl {
template<
      typename Tag1
    , typename Tag2
    >
struct plus_impl
    : if_c<
          ( Tag1::value
              > Tag2::value
            )
        , aux::cast2nd_impl< plus_impl< Tag1,Tag1 >,Tag1, Tag2 >
        , aux::cast1st_impl< plus_impl< Tag2,Tag2 >,Tag1, Tag2 >
        >::type
{
};
template<> struct plus_impl< na,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};
template< typename Tag > struct plus_impl< na,Tag >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};
template< typename Tag > struct plus_impl< Tag,na >
{
    template< typename U1, typename U2 > struct apply
    {
        typedef apply type;
        static const int value = 0;
    };
};
template< typename T > struct plus_tag
{
    typedef typename T::tag type;
};
template<
      typename N1 = na
    , typename N2 = na
    , typename N3 = na, typename N4 = na, typename N5 = na
    >
struct plus
    : plus< plus< plus< plus< N1,N2 >, N3>, N4>, N5>
{
   
};
template<
      typename N1, typename N2, typename N3, typename N4
    >
struct plus< N1,N2,N3,N4,na >
    : plus< plus< plus< N1,N2 >, N3>, N4>
{
   
};
template<
      typename N1, typename N2, typename N3
    >
struct plus< N1,N2,N3,na,na >
    : plus< plus< N1,N2 >, N3>
{
   
};
template<
      typename N1, typename N2
    >
struct plus< N1,N2,na,na,na >
    : plus_impl<
          typename plus_tag<N1>::type
        , typename plus_tag<N2>::type
        >::template apply< N1,N2 >::type
{
   
};
template<> struct plus< na , na > { template< typename T1 , typename T2 , typename T3 =na , typename T4 =na , typename T5 =na > struct apply : plus< T1 , T2 > { }; }; template< typename Tag > struct lambda< plus< na , na > , Tag , int_<-1> > { typedef false_ is_le; typedef plus< na , na > result_; typedef plus< na , na > type; }; namespace aux { template< typename T1 , typename T2 , typename T3 , typename T4 , typename T5 > struct template_arity< plus< T1 , T2 , T3 , T4 , T5 > > : int_<5> { }; template<> struct template_arity< plus< na , na > > : int_<-1> { }; }
}}
namespace boost { namespace mpl {
template<>
struct plus_impl< integral_c_tag,integral_c_tag >
{
    template< typename N1, typename N2 > struct apply
        : integral_c<
              typename aux::largest_int<
                  typename N1::value_type
                , typename N2::value_type
                >::type
            , ( N1::value
                  + N2::value
                )
            >
    {
    };
};
}}
namespace boost { namespace mpl {

template< typename Tag > struct distance_impl;
template< typename First, typename Last > struct distance;
}}
namespace boost { namespace mpl {
template<
      typename Vector
    , long n_
    >
struct v_iter
{
    typedef aux::v_iter_tag tag;
    typedef random_access_iterator_tag category;
    typedef typename v_at<Vector,n_>::type type;
    typedef Vector vector_;
    typedef mpl::long_<n_> pos;
};
template<
      typename Vector
    , long n_
    >
struct next< v_iter<Vector,n_> >
{
    typedef v_iter<Vector,(n_ + 1)> type;
};
template<
      typename Vector
    , long n_
    >
struct prior< v_iter<Vector,n_> >
{
    typedef v_iter<Vector,(n_ - 1)> type;
};
template<
      typename Vector
    , long n_
    , typename Distance
    >
struct advance< v_iter<Vector,n_>,Distance>
{
    typedef v_iter<
          Vector
        , (n_ + Distance::value)
        > type;
};
template<
      typename Vector
    , long n_
    , long m_
    >
struct distance< v_iter<Vector,n_>, v_iter<Vector,m_> >
    : mpl::long_<(m_ - n_)>
{
};
}}
namespace boost { namespace mpl {
template< typename Dummy = na > struct vector0;
template<> struct vector0<na>
{
    typedef aux::vector_tag tag;
    typedef vector0 type;
    typedef long_<32768> lower_bound_;
    typedef lower_bound_ upper_bound_;
    typedef long_<0> size;
    static aux::type_wrapper<void_> item_(...);
};
}}
namespace boost { namespace mpl {
template<>
struct clear_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef vector0<> type;
    };
};
}}
namespace boost { namespace mpl {
template< typename Tag > struct O1_size_impl;
template< typename Sequence > struct O1_size;
}}
namespace boost { namespace mpl {
template<>
struct O1_size_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : Vector::size
    {
    };
};
}}
namespace boost { namespace mpl {
template< typename Tag > struct size_impl;
template< typename Sequence > struct size;
}}
namespace boost { namespace mpl {
template<>
struct size_impl< aux::vector_tag >
    : O1_size_impl< aux::vector_tag >
{
};
}}
namespace boost { namespace mpl {
template< typename Tag > struct empty_impl;
template< typename Sequence > struct empty;
}}
namespace boost { namespace mpl {
template<>
struct empty_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
        : is_same<
              typename Vector::lower_bound_
            , typename Vector::upper_bound_
            >
    {
    };
};
}}
namespace boost { namespace mpl {
template<>
struct begin_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_iter<Vector,0> type;
    };
};
template<>
struct end_impl< aux::vector_tag >
{
    template< typename Vector > struct apply
    {
        typedef v_iter<Vector,Vector::size::value> type;
    };
};
}}
namespace boost { namespace mpl {
template<
      typename T0
    >
struct vector1
    : v_item<
          T0
        , vector0< >
        >
{
    typedef vector1 type;
};
template<
      typename T0, typename T1
    >
struct vector2
    : v_item<
          T1
        , vector1<T0>
        >
{
    typedef vector2 type;
};
template<
      typename T0, typename T1, typename T2
    >
struct vector3
    : v_item<
          T2
        , vector2< T0,T1 >
        >
{
    typedef vector3 type;
};
template<
      typename T0, typename T1, typename T2, typename T3
    >
struct vector4
    : v_item<
          T3
        , vector3< T0,T1,T2 >
        >
{
    typedef vector4 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    >
struct vector5
    : v_item<
          T4
        , vector4< T0,T1,T2,T3 >
        >
{
    typedef vector5 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5
    >
struct vector6
    : v_item<
          T5
        , vector5< T0,T1,T2,T3,T4 >
        >
{
    typedef vector6 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6
    >
struct vector7
    : v_item<
          T6
        , vector6< T0,T1,T2,T3,T4,T5 >
        >
{
    typedef vector7 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7
    >
struct vector8
    : v_item<
          T7
        , vector7< T0,T1,T2,T3,T4,T5,T6 >
        >
{
    typedef vector8 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8
    >
struct vector9
    : v_item<
          T8
        , vector8< T0,T1,T2,T3,T4,T5,T6,T7 >
        >
{
    typedef vector9 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    >
struct vector10
    : v_item<
          T9
        , vector9< T0,T1,T2,T3,T4,T5,T6,T7,T8 >
        >
{
    typedef vector10 type;
};
}}
namespace boost { namespace fusion
{
    struct vector_tag;
    struct fusion_sequence_tag;
    struct random_access_traversal_tag;
    template <typename Dummy = void>
    struct vector0 : sequence_base<vector0<Dummy> >
    {
        typedef mpl::vector0<> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<0> size;
        vector0() {}
        template<typename Sequence>
        vector0(Sequence const& )
        {}
    };
    template < typename T0>
    struct vector_data1
    {
        vector_data1()
            : m0() {}
        vector_data1(
            typename detail::call_param<T0 >::type _0)
            : m0(_0) {}
        vector_data1(
            vector_data1 const& other)
            : m0(other.m0) {}
        vector_data1&
        operator=(vector_data1 const& vec)
        {
            this->m0 = vec.m0;
            return *this;
        }
        template <typename Sequence>
        static vector_data1
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
           
            return vector_data1( *i0);
        }
        T0 m0;
    };
    template < typename T0>
    struct vector1
      : vector_data1< T0>
      , sequence_base<vector1< T0> >
    {
        typedef vector1< T0> this_type;
        typedef vector_data1< T0> base_type;
        typedef mpl::vector1< T0> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<1> size;
        vector1() {}
        explicit
        vector1(
            typename detail::call_param<T0 >::type _0)
            : base_type( _0) {}
        template < typename U0>
        vector1(
            vector1< U0> const& vec)
            : base_type( vec.m0) {}
        template <typename Sequence>
        vector1(
            Sequence const& seq
          , typename disable_if<is_convertible<Sequence, T0> >::type* = 0
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0>
        vector1&
        operator=(vector1< U0> const& vec)
        {
            this->m0 = vec.m0;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
           
            this->m0 = *i0;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1>
    struct vector_data2
    {
        vector_data2()
            : m0() , m1() {}
        vector_data2(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1)
            : m0(_0) , m1(_1) {}
        vector_data2(
            vector_data2 const& other)
            : m0(other.m0) , m1(other.m1) {}
        vector_data2&
        operator=(vector_data2 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1;
            return *this;
        }
        template <typename Sequence>
        static vector_data2
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0);
            return vector_data2( *i0 , *i1);
        }
        T0 m0; T1 m1;
    };
    template < typename T0 , typename T1>
    struct vector2
      : vector_data2< T0 , T1>
      , sequence_base<vector2< T0 , T1> >
    {
        typedef vector2< T0 , T1> this_type;
        typedef vector_data2< T0 , T1> base_type;
        typedef mpl::vector2< T0 , T1> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<2> size;
        vector2() {}
        vector2(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1)
            : base_type( _0 , _1) {}
        template < typename U0 , typename U1>
        vector2(
            vector2< U0 , U1> const& vec)
            : base_type( vec.m0 , vec.m1) {}
        template <typename Sequence>
        vector2(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1>
        vector2&
        operator=(vector2< U0 , U1> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0);
            this->m0 = *i0; this->m1 = *i1;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2>
    struct vector_data3
    {
        vector_data3()
            : m0() , m1() , m2() {}
        vector_data3(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2)
            : m0(_0) , m1(_1) , m2(_2) {}
        vector_data3(
            vector_data3 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) {}
        vector_data3&
        operator=(vector_data3 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2;
            return *this;
        }
        template <typename Sequence>
        static vector_data3
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1);
            return vector_data3( *i0 , *i1 , *i2);
        }
        T0 m0; T1 m1; T2 m2;
    };
    template < typename T0 , typename T1 , typename T2>
    struct vector3
      : vector_data3< T0 , T1 , T2>
      , sequence_base<vector3< T0 , T1 , T2> >
    {
        typedef vector3< T0 , T1 , T2> this_type;
        typedef vector_data3< T0 , T1 , T2> base_type;
        typedef mpl::vector3< T0 , T1 , T2> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<3> size;
        vector3() {}
        vector3(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2)
            : base_type( _0 , _1 , _2) {}
        template < typename U0 , typename U1 , typename U2>
        vector3(
            vector3< U0 , U1 , U2> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2) {}
        template <typename Sequence>
        vector3(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2>
        vector3&
        operator=(vector3< U0 , U1 , U2> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3>
    struct vector_data4
    {
        vector_data4()
            : m0() , m1() , m2() , m3() {}
        vector_data4(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) {}
        vector_data4(
            vector_data4 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) {}
        vector_data4&
        operator=(vector_data4 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3;
            return *this;
        }
        template <typename Sequence>
        static vector_data4
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2);
            return vector_data4( *i0 , *i1 , *i2 , *i3);
        }
        T0 m0; T1 m1; T2 m2; T3 m3;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3>
    struct vector4
      : vector_data4< T0 , T1 , T2 , T3>
      , sequence_base<vector4< T0 , T1 , T2 , T3> >
    {
        typedef vector4< T0 , T1 , T2 , T3> this_type;
        typedef vector_data4< T0 , T1 , T2 , T3> base_type;
        typedef mpl::vector4< T0 , T1 , T2 , T3> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<4> size;
        vector4() {}
        vector4(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3)
            : base_type( _0 , _1 , _2 , _3) {}
        template < typename U0 , typename U1 , typename U2 , typename U3>
        vector4(
            vector4< U0 , U1 , U2 , U3> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3) {}
        template <typename Sequence>
        vector4(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3>
        vector4&
        operator=(vector4< U0 , U1 , U2 , U3> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
    struct vector_data5
    {
        vector_data5()
            : m0() , m1() , m2() , m3() , m4() {}
        vector_data5(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) {}
        vector_data5(
            vector_data5 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) {}
        vector_data5&
        operator=(vector_data5 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4;
            return *this;
        }
        template <typename Sequence>
        static vector_data5
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3);
            return vector_data5( *i0 , *i1 , *i2 , *i3 , *i4);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
    struct vector5
      : vector_data5< T0 , T1 , T2 , T3 , T4>
      , sequence_base<vector5< T0 , T1 , T2 , T3 , T4> >
    {
        typedef vector5< T0 , T1 , T2 , T3 , T4> this_type;
        typedef vector_data5< T0 , T1 , T2 , T3 , T4> base_type;
        typedef mpl::vector5< T0 , T1 , T2 , T3 , T4> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<5> size;
        vector5() {}
        vector5(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4)
            : base_type( _0 , _1 , _2 , _3 , _4) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4>
        vector5(
            vector5< U0 , U1 , U2 , U3 , U4> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4) {}
        template <typename Sequence>
        vector5(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4>
        vector5&
        operator=(vector5< U0 , U1 , U2 , U3 , U4> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
    struct vector_data6
    {
        vector_data6()
            : m0() , m1() , m2() , m3() , m4() , m5() {}
        vector_data6(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) {}
        vector_data6(
            vector_data6 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) {}
        vector_data6&
        operator=(vector_data6 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5;
            return *this;
        }
        template <typename Sequence>
        static vector_data6
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4);
            return vector_data6( *i0 , *i1 , *i2 , *i3 , *i4 , *i5);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
    struct vector6
      : vector_data6< T0 , T1 , T2 , T3 , T4 , T5>
      , sequence_base<vector6< T0 , T1 , T2 , T3 , T4 , T5> >
    {
        typedef vector6< T0 , T1 , T2 , T3 , T4 , T5> this_type;
        typedef vector_data6< T0 , T1 , T2 , T3 , T4 , T5> base_type;
        typedef mpl::vector6< T0 , T1 , T2 , T3 , T4 , T5> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<6> size;
        vector6() {}
        vector6(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5>
        vector6(
            vector6< U0 , U1 , U2 , U3 , U4 , U5> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5) {}
        template <typename Sequence>
        vector6(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5>
        vector6&
        operator=(vector6< U0 , U1 , U2 , U3 , U4 , U5> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
    struct vector_data7
    {
        vector_data7()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() {}
        vector_data7(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) {}
        vector_data7(
            vector_data7 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) {}
        vector_data7&
        operator=(vector_data7 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6;
            return *this;
        }
        template <typename Sequence>
        static vector_data7
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5);
            return vector_data7( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
    struct vector7
      : vector_data7< T0 , T1 , T2 , T3 , T4 , T5 , T6>
      , sequence_base<vector7< T0 , T1 , T2 , T3 , T4 , T5 , T6> >
    {
        typedef vector7< T0 , T1 , T2 , T3 , T4 , T5 , T6> this_type;
        typedef vector_data7< T0 , T1 , T2 , T3 , T4 , T5 , T6> base_type;
        typedef mpl::vector7< T0 , T1 , T2 , T3 , T4 , T5 , T6> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<7> size;
        vector7() {}
        vector7(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6>
        vector7(
            vector7< U0 , U1 , U2 , U3 , U4 , U5 , U6> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6) {}
        template <typename Sequence>
        vector7(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6>
        vector7&
        operator=(vector7< U0 , U1 , U2 , U3 , U4 , U5 , U6> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
    struct vector_data8
    {
        vector_data8()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() {}
        vector_data8(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) {}
        vector_data8(
            vector_data8 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) {}
        vector_data8&
        operator=(vector_data8 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7;
            return *this;
        }
        template <typename Sequence>
        static vector_data8
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6);
            return vector_data8( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
    struct vector8
      : vector_data8< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>
      , sequence_base<vector8< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7> >
    {
        typedef vector8< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7> this_type;
        typedef vector_data8< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7> base_type;
        typedef mpl::vector8< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<8> size;
        vector8() {}
        vector8(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7>
        vector8(
            vector8< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7) {}
        template <typename Sequence>
        vector8(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7>
        vector8&
        operator=(vector8< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
    struct vector_data9
    {
        vector_data9()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() {}
        vector_data9(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) {}
        vector_data9(
            vector_data9 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) {}
        vector_data9&
        operator=(vector_data9 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8;
            return *this;
        }
        template <typename Sequence>
        static vector_data9
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7);
            return vector_data9( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
    struct vector9
      : vector_data9< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>
      , sequence_base<vector9< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8> >
    {
        typedef vector9< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8> this_type;
        typedef vector_data9< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8> base_type;
        typedef mpl::vector9< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<9> size;
        vector9() {}
        vector9(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8>
        vector9(
            vector9< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8) {}
        template <typename Sequence>
        vector9(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8>
        vector9&
        operator=(vector9< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
    struct vector_data10
    {
        vector_data10()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() {}
        vector_data10(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) {}
        vector_data10(
            vector_data10 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) {}
        vector_data10&
        operator=(vector_data10 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9;
            return *this;
        }
        template <typename Sequence>
        static vector_data10
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8);
            return vector_data10( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
    struct vector10
      : vector_data10< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>
      , sequence_base<vector10< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9> >
    {
        typedef vector10< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9> this_type;
        typedef vector_data10< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9> base_type;
        typedef mpl::vector10< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<10> size;
        vector10() {}
        vector10(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9>
        vector10(
            vector10< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9) {}
        template <typename Sequence>
        vector10(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9>
        vector10&
        operator=(vector10< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
}}
namespace boost { namespace mpl {
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10
    >
struct vector11
    : v_item<
          T10
        , vector10< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9 >
        >
{
    typedef vector11 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11
    >
struct vector12
    : v_item<
          T11
        , vector11< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10 >
        >
{
    typedef vector12 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12
    >
struct vector13
    : v_item<
          T12
        , vector12< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11 >
        >
{
    typedef vector13 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13
    >
struct vector14
    : v_item<
          T13
        , vector13< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12 >
        >
{
    typedef vector14 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    >
struct vector15
    : v_item<
          T14
        , vector14< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13 >
        >
{
    typedef vector15 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15
    >
struct vector16
    : v_item<
          T15
        , vector15< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14 >
        >
{
    typedef vector16 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16
    >
struct vector17
    : v_item<
          T16
        , vector16< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15 >
        >
{
    typedef vector17 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17
    >
struct vector18
    : v_item<
          T17
        , vector17< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16 >
        >
{
    typedef vector18 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18
    >
struct vector19
    : v_item<
          T18
        , vector18< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17 >
        >
{
    typedef vector19 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    >
struct vector20
    : v_item<
          T19
        , vector19< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18 >
        >
{
    typedef vector20 type;
};
}}
namespace boost { namespace fusion
{
    struct vector_tag;
    struct fusion_sequence_tag;
    struct random_access_traversal_tag;
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10>
    struct vector_data11
    {
        vector_data11()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() {}
        vector_data11(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) {}
        vector_data11(
            vector_data11 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) {}
        vector_data11&
        operator=(vector_data11 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10;
            return *this;
        }
        template <typename Sequence>
        static vector_data11
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9);
            return vector_data11( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10>
    struct vector11
      : vector_data11< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10>
      , sequence_base<vector11< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10> >
    {
        typedef vector11< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10> this_type;
        typedef vector_data11< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10> base_type;
        typedef mpl::vector11< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<11> size;
        vector11() {}
        vector11(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10>
        vector11(
            vector11< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10) {}
        template <typename Sequence>
        vector11(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10>
        vector11&
        operator=(vector11< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11>
    struct vector_data12
    {
        vector_data12()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() {}
        vector_data12(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) {}
        vector_data12(
            vector_data12 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) {}
        vector_data12&
        operator=(vector_data12 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11;
            return *this;
        }
        template <typename Sequence>
        static vector_data12
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10);
            return vector_data12( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11>
    struct vector12
      : vector_data12< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11>
      , sequence_base<vector12< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11> >
    {
        typedef vector12< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11> this_type;
        typedef vector_data12< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11> base_type;
        typedef mpl::vector12< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<12> size;
        vector12() {}
        vector12(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11>
        vector12(
            vector12< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11) {}
        template <typename Sequence>
        vector12(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11>
        vector12&
        operator=(vector12< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12>
    struct vector_data13
    {
        vector_data13()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() {}
        vector_data13(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) {}
        vector_data13(
            vector_data13 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) {}
        vector_data13&
        operator=(vector_data13 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12;
            return *this;
        }
        template <typename Sequence>
        static vector_data13
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11);
            return vector_data13( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12>
    struct vector13
      : vector_data13< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12>
      , sequence_base<vector13< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12> >
    {
        typedef vector13< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12> this_type;
        typedef vector_data13< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12> base_type;
        typedef mpl::vector13< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<13> size;
        vector13() {}
        vector13(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12>
        vector13(
            vector13< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12) {}
        template <typename Sequence>
        vector13(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12>
        vector13&
        operator=(vector13< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13>
    struct vector_data14
    {
        vector_data14()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() {}
        vector_data14(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) {}
        vector_data14(
            vector_data14 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) {}
        vector_data14&
        operator=(vector_data14 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13;
            return *this;
        }
        template <typename Sequence>
        static vector_data14
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12);
            return vector_data14( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13>
    struct vector14
      : vector_data14< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13>
      , sequence_base<vector14< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13> >
    {
        typedef vector14< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13> this_type;
        typedef vector_data14< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13> base_type;
        typedef mpl::vector14< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<14> size;
        vector14() {}
        vector14(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13>
        vector14(
            vector14< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13) {}
        template <typename Sequence>
        vector14(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13>
        vector14&
        operator=(vector14< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14>
    struct vector_data15
    {
        vector_data15()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() {}
        vector_data15(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) {}
        vector_data15(
            vector_data15 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) {}
        vector_data15&
        operator=(vector_data15 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14;
            return *this;
        }
        template <typename Sequence>
        static vector_data15
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13);
            return vector_data15( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14>
    struct vector15
      : vector_data15< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14>
      , sequence_base<vector15< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14> >
    {
        typedef vector15< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14> this_type;
        typedef vector_data15< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14> base_type;
        typedef mpl::vector15< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<15> size;
        vector15() {}
        vector15(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14>
        vector15(
            vector15< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14) {}
        template <typename Sequence>
        vector15(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14>
        vector15&
        operator=(vector15< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15>
    struct vector_data16
    {
        vector_data16()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() {}
        vector_data16(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) {}
        vector_data16(
            vector_data16 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) {}
        vector_data16&
        operator=(vector_data16 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15;
            return *this;
        }
        template <typename Sequence>
        static vector_data16
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14);
            return vector_data16( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15>
    struct vector16
      : vector_data16< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15>
      , sequence_base<vector16< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15> >
    {
        typedef vector16< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15> this_type;
        typedef vector_data16< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15> base_type;
        typedef mpl::vector16< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<16> size;
        vector16() {}
        vector16(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15>
        vector16(
            vector16< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15) {}
        template <typename Sequence>
        vector16(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15>
        vector16&
        operator=(vector16< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16>
    struct vector_data17
    {
        vector_data17()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() {}
        vector_data17(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) {}
        vector_data17(
            vector_data17 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) {}
        vector_data17&
        operator=(vector_data17 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16;
            return *this;
        }
        template <typename Sequence>
        static vector_data17
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15);
            return vector_data17( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16>
    struct vector17
      : vector_data17< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16>
      , sequence_base<vector17< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16> >
    {
        typedef vector17< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16> this_type;
        typedef vector_data17< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16> base_type;
        typedef mpl::vector17< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<17> size;
        vector17() {}
        vector17(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16>
        vector17(
            vector17< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16) {}
        template <typename Sequence>
        vector17(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16>
        vector17&
        operator=(vector17< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17>
    struct vector_data18
    {
        vector_data18()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() {}
        vector_data18(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) {}
        vector_data18(
            vector_data18 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) {}
        vector_data18&
        operator=(vector_data18 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17;
            return *this;
        }
        template <typename Sequence>
        static vector_data18
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16);
            return vector_data18( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17>
    struct vector18
      : vector_data18< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17>
      , sequence_base<vector18< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17> >
    {
        typedef vector18< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17> this_type;
        typedef vector_data18< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17> base_type;
        typedef mpl::vector18< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<18> size;
        vector18() {}
        vector18(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17>
        vector18(
            vector18< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17) {}
        template <typename Sequence>
        vector18(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17>
        vector18&
        operator=(vector18< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18>
    struct vector_data19
    {
        vector_data19()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() {}
        vector_data19(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) {}
        vector_data19(
            vector_data19 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) {}
        vector_data19&
        operator=(vector_data19 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18;
            return *this;
        }
        template <typename Sequence>
        static vector_data19
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17);
            return vector_data19( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18>
    struct vector19
      : vector_data19< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18>
      , sequence_base<vector19< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18> >
    {
        typedef vector19< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18> this_type;
        typedef vector_data19< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18> base_type;
        typedef mpl::vector19< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<19> size;
        vector19() {}
        vector19(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18>
        vector19(
            vector19< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18) {}
        template <typename Sequence>
        vector19(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18>
        vector19&
        operator=(vector19< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19>
    struct vector_data20
    {
        vector_data20()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() {}
        vector_data20(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) {}
        vector_data20(
            vector_data20 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) {}
        vector_data20&
        operator=(vector_data20 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19;
            return *this;
        }
        template <typename Sequence>
        static vector_data20
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18);
            return vector_data20( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19>
    struct vector20
      : vector_data20< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19>
      , sequence_base<vector20< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19> >
    {
        typedef vector20< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19> this_type;
        typedef vector_data20< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19> base_type;
        typedef mpl::vector20< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<20> size;
        vector20() {}
        vector20(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19>
        vector20(
            vector20< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19) {}
        template <typename Sequence>
        vector20(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19>
        vector20&
        operator=(vector20< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
}}
namespace boost { namespace mpl {
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20
    >
struct vector21
    : v_item<
          T20
        , vector20< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19 >
        >
{
    typedef vector21 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21
    >
struct vector22
    : v_item<
          T21
        , vector21< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20 >
        >
{
    typedef vector22 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22
    >
struct vector23
    : v_item<
          T22
        , vector22< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21 >
        >
{
    typedef vector23 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23
    >
struct vector24
    : v_item<
          T23
        , vector23< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22 >
        >
{
    typedef vector24 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    >
struct vector25
    : v_item<
          T24
        , vector24< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23 >
        >
{
    typedef vector25 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25
    >
struct vector26
    : v_item<
          T25
        , vector25< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24 >
        >
{
    typedef vector26 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26
    >
struct vector27
    : v_item<
          T26
        , vector26< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25 >
        >
{
    typedef vector27 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27
    >
struct vector28
    : v_item<
          T27
        , vector27< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26 >
        >
{
    typedef vector28 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28
    >
struct vector29
    : v_item<
          T28
        , vector28< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27 >
        >
{
    typedef vector29 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    >
struct vector30
    : v_item<
          T29
        , vector29< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28 >
        >
{
    typedef vector30 type;
};
}}
namespace boost { namespace fusion
{
    struct vector_tag;
    struct fusion_sequence_tag;
    struct random_access_traversal_tag;
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20>
    struct vector_data21
    {
        vector_data21()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() {}
        vector_data21(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) {}
        vector_data21(
            vector_data21 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) {}
        vector_data21&
        operator=(vector_data21 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20;
            return *this;
        }
        template <typename Sequence>
        static vector_data21
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19);
            return vector_data21( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20>
    struct vector21
      : vector_data21< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20>
      , sequence_base<vector21< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20> >
    {
        typedef vector21< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20> this_type;
        typedef vector_data21< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20> base_type;
        typedef mpl::vector21< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<21> size;
        vector21() {}
        vector21(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20>
        vector21(
            vector21< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20) {}
        template <typename Sequence>
        vector21(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20>
        vector21&
        operator=(vector21< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21>
    struct vector_data22
    {
        vector_data22()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() {}
        vector_data22(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) {}
        vector_data22(
            vector_data22 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) {}
        vector_data22&
        operator=(vector_data22 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21;
            return *this;
        }
        template <typename Sequence>
        static vector_data22
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20);
            return vector_data22( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21>
    struct vector22
      : vector_data22< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21>
      , sequence_base<vector22< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21> >
    {
        typedef vector22< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21> this_type;
        typedef vector_data22< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21> base_type;
        typedef mpl::vector22< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<22> size;
        vector22() {}
        vector22(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21>
        vector22(
            vector22< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21) {}
        template <typename Sequence>
        vector22(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21>
        vector22&
        operator=(vector22< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22>
    struct vector_data23
    {
        vector_data23()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() {}
        vector_data23(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) {}
        vector_data23(
            vector_data23 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) {}
        vector_data23&
        operator=(vector_data23 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22;
            return *this;
        }
        template <typename Sequence>
        static vector_data23
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21);
            return vector_data23( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22>
    struct vector23
      : vector_data23< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22>
      , sequence_base<vector23< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22> >
    {
        typedef vector23< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22> this_type;
        typedef vector_data23< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22> base_type;
        typedef mpl::vector23< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<23> size;
        vector23() {}
        vector23(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22>
        vector23(
            vector23< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22) {}
        template <typename Sequence>
        vector23(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22>
        vector23&
        operator=(vector23< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23>
    struct vector_data24
    {
        vector_data24()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() {}
        vector_data24(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) {}
        vector_data24(
            vector_data24 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) {}
        vector_data24&
        operator=(vector_data24 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23;
            return *this;
        }
        template <typename Sequence>
        static vector_data24
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22);
            return vector_data24( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23>
    struct vector24
      : vector_data24< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23>
      , sequence_base<vector24< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23> >
    {
        typedef vector24< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23> this_type;
        typedef vector_data24< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23> base_type;
        typedef mpl::vector24< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<24> size;
        vector24() {}
        vector24(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23>
        vector24(
            vector24< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23) {}
        template <typename Sequence>
        vector24(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23>
        vector24&
        operator=(vector24< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24>
    struct vector_data25
    {
        vector_data25()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() {}
        vector_data25(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) {}
        vector_data25(
            vector_data25 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) {}
        vector_data25&
        operator=(vector_data25 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24;
            return *this;
        }
        template <typename Sequence>
        static vector_data25
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23);
            return vector_data25( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24>
    struct vector25
      : vector_data25< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24>
      , sequence_base<vector25< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24> >
    {
        typedef vector25< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24> this_type;
        typedef vector_data25< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24> base_type;
        typedef mpl::vector25< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<25> size;
        vector25() {}
        vector25(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24>
        vector25(
            vector25< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24) {}
        template <typename Sequence>
        vector25(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24>
        vector25&
        operator=(vector25< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25>
    struct vector_data26
    {
        vector_data26()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() {}
        vector_data26(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) {}
        vector_data26(
            vector_data26 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) {}
        vector_data26&
        operator=(vector_data26 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25;
            return *this;
        }
        template <typename Sequence>
        static vector_data26
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24);
            return vector_data26( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25>
    struct vector26
      : vector_data26< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25>
      , sequence_base<vector26< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25> >
    {
        typedef vector26< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25> this_type;
        typedef vector_data26< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25> base_type;
        typedef mpl::vector26< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<26> size;
        vector26() {}
        vector26(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25>
        vector26(
            vector26< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25) {}
        template <typename Sequence>
        vector26(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25>
        vector26&
        operator=(vector26< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26>
    struct vector_data27
    {
        vector_data27()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() {}
        vector_data27(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) {}
        vector_data27(
            vector_data27 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) {}
        vector_data27&
        operator=(vector_data27 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26;
            return *this;
        }
        template <typename Sequence>
        static vector_data27
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25);
            return vector_data27( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26>
    struct vector27
      : vector_data27< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26>
      , sequence_base<vector27< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26> >
    {
        typedef vector27< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26> this_type;
        typedef vector_data27< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26> base_type;
        typedef mpl::vector27< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<27> size;
        vector27() {}
        vector27(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26>
        vector27(
            vector27< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26) {}
        template <typename Sequence>
        vector27(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26>
        vector27&
        operator=(vector27< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27>
    struct vector_data28
    {
        vector_data28()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() {}
        vector_data28(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) {}
        vector_data28(
            vector_data28 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) {}
        vector_data28&
        operator=(vector_data28 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27;
            return *this;
        }
        template <typename Sequence>
        static vector_data28
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26);
            return vector_data28( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27>
    struct vector28
      : vector_data28< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27>
      , sequence_base<vector28< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27> >
    {
        typedef vector28< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27> this_type;
        typedef vector_data28< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27> base_type;
        typedef mpl::vector28< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<28> size;
        vector28() {}
        vector28(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27>
        vector28(
            vector28< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27) {}
        template <typename Sequence>
        vector28(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27>
        vector28&
        operator=(vector28< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28>
    struct vector_data29
    {
        vector_data29()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() {}
        vector_data29(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) {}
        vector_data29(
            vector_data29 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) {}
        vector_data29&
        operator=(vector_data29 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28;
            return *this;
        }
        template <typename Sequence>
        static vector_data29
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27);
            return vector_data29( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28>
    struct vector29
      : vector_data29< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28>
      , sequence_base<vector29< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28> >
    {
        typedef vector29< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28> this_type;
        typedef vector_data29< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28> base_type;
        typedef mpl::vector29< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<29> size;
        vector29() {}
        vector29(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28>
        vector29(
            vector29< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28) {}
        template <typename Sequence>
        vector29(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28>
        vector29&
        operator=(vector29< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29>
    struct vector_data30
    {
        vector_data30()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() {}
        vector_data30(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) {}
        vector_data30(
            vector_data30 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) {}
        vector_data30&
        operator=(vector_data30 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29;
            return *this;
        }
        template <typename Sequence>
        static vector_data30
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28);
            return vector_data30( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29>
    struct vector30
      : vector_data30< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29>
      , sequence_base<vector30< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29> >
    {
        typedef vector30< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29> this_type;
        typedef vector_data30< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29> base_type;
        typedef mpl::vector30< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<30> size;
        vector30() {}
        vector30(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29>
        vector30(
            vector30< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29) {}
        template <typename Sequence>
        vector30(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29>
        vector30&
        operator=(vector30< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
}}
namespace boost { namespace mpl {
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30
    >
struct vector31
    : v_item<
          T30
        , vector30< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29 >
        >
{
    typedef vector31 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31
    >
struct vector32
    : v_item<
          T31
        , vector31< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30 >
        >
{
    typedef vector32 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32
    >
struct vector33
    : v_item<
          T32
        , vector32< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31 >
        >
{
    typedef vector33 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32, typename T33
    >
struct vector34
    : v_item<
          T33
        , vector33< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32 >
        >
{
    typedef vector34 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32, typename T33, typename T34
    >
struct vector35
    : v_item<
          T34
        , vector34< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33 >
        >
{
    typedef vector35 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32, typename T33, typename T34
    , typename T35
    >
struct vector36
    : v_item<
          T35
        , vector35< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34 >
        >
{
    typedef vector36 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32, typename T33, typename T34
    , typename T35, typename T36
    >
struct vector37
    : v_item<
          T36
        , vector36< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35 >
        >
{
    typedef vector37 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32, typename T33, typename T34
    , typename T35, typename T36, typename T37
    >
struct vector38
    : v_item<
          T37
        , vector37< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36 >
        >
{
    typedef vector38 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32, typename T33, typename T34
    , typename T35, typename T36, typename T37, typename T38
    >
struct vector39
    : v_item<
          T38
        , vector38< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37 >
        >
{
    typedef vector39 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32, typename T33, typename T34
    , typename T35, typename T36, typename T37, typename T38, typename T39
    >
struct vector40
    : v_item<
          T39
        , vector39< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38 >
        >
{
    typedef vector40 type;
};
}}
namespace boost { namespace fusion
{
    struct vector_tag;
    struct fusion_sequence_tag;
    struct random_access_traversal_tag;
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30>
    struct vector_data31
    {
        vector_data31()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() {}
        vector_data31(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) {}
        vector_data31(
            vector_data31 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) {}
        vector_data31&
        operator=(vector_data31 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30;
            return *this;
        }
        template <typename Sequence>
        static vector_data31
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29);
            return vector_data31( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30>
    struct vector31
      : vector_data31< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30>
      , sequence_base<vector31< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30> >
    {
        typedef vector31< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30> this_type;
        typedef vector_data31< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30> base_type;
        typedef mpl::vector31< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<31> size;
        vector31() {}
        vector31(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30>
        vector31(
            vector31< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30) {}
        template <typename Sequence>
        vector31(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30>
        vector31&
        operator=(vector31< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31>
    struct vector_data32
    {
        vector_data32()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() {}
        vector_data32(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) {}
        vector_data32(
            vector_data32 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) {}
        vector_data32&
        operator=(vector_data32 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31;
            return *this;
        }
        template <typename Sequence>
        static vector_data32
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30);
            return vector_data32( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31>
    struct vector32
      : vector_data32< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31>
      , sequence_base<vector32< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31> >
    {
        typedef vector32< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31> this_type;
        typedef vector_data32< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31> base_type;
        typedef mpl::vector32< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<32> size;
        vector32() {}
        vector32(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31>
        vector32(
            vector32< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31) {}
        template <typename Sequence>
        vector32(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31>
        vector32&
        operator=(vector32< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32>
    struct vector_data33
    {
        vector_data33()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() {}
        vector_data33(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) {}
        vector_data33(
            vector_data33 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) {}
        vector_data33&
        operator=(vector_data33 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32;
            return *this;
        }
        template <typename Sequence>
        static vector_data33
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31);
            return vector_data33( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32>
    struct vector33
      : vector_data33< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32>
      , sequence_base<vector33< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32> >
    {
        typedef vector33< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32> this_type;
        typedef vector_data33< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32> base_type;
        typedef mpl::vector33< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<33> size;
        vector33() {}
        vector33(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32>
        vector33(
            vector33< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32) {}
        template <typename Sequence>
        vector33(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32>
        vector33&
        operator=(vector33< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33>
    struct vector_data34
    {
        vector_data34()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() , m33() {}
        vector_data34(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) , m33(_33) {}
        vector_data34(
            vector_data34 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) , m33(other.m33) {}
        vector_data34&
        operator=(vector_data34 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33;
            return *this;
        }
        template <typename Sequence>
        static vector_data34
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32);
            return vector_data34( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32 , *i33);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32; T33 m33;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33>
    struct vector34
      : vector_data34< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33>
      , sequence_base<vector34< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33> >
    {
        typedef vector34< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33> this_type;
        typedef vector_data34< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33> base_type;
        typedef mpl::vector34< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<34> size;
        vector34() {}
        vector34(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32 , _33) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33>
        vector34(
            vector34< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32 , vec.m33) {}
        template <typename Sequence>
        vector34(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33>
        vector34&
        operator=(vector34< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32; this->m33 = *i33;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; } typename add_reference<T33>::type at_impl(mpl::int_<33>) { return this->m33; } typename add_reference<typename add_const<T33>::type>::type at_impl(mpl::int_<33>) const { return this->m33; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34>
    struct vector_data35
    {
        vector_data35()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() , m33() , m34() {}
        vector_data35(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) , m33(_33) , m34(_34) {}
        vector_data35(
            vector_data35 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) , m33(other.m33) , m34(other.m34) {}
        vector_data35&
        operator=(vector_data35 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34;
            return *this;
        }
        template <typename Sequence>
        static vector_data35
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33);
            return vector_data35( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32 , *i33 , *i34);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32; T33 m33; T34 m34;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34>
    struct vector35
      : vector_data35< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34>
      , sequence_base<vector35< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34> >
    {
        typedef vector35< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34> this_type;
        typedef vector_data35< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34> base_type;
        typedef mpl::vector35< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<35> size;
        vector35() {}
        vector35(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32 , _33 , _34) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34>
        vector35(
            vector35< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32 , vec.m33 , vec.m34) {}
        template <typename Sequence>
        vector35(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34>
        vector35&
        operator=(vector35< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32; this->m33 = *i33; this->m34 = *i34;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; } typename add_reference<T33>::type at_impl(mpl::int_<33>) { return this->m33; } typename add_reference<typename add_const<T33>::type>::type at_impl(mpl::int_<33>) const { return this->m33; } typename add_reference<T34>::type at_impl(mpl::int_<34>) { return this->m34; } typename add_reference<typename add_const<T34>::type>::type at_impl(mpl::int_<34>) const { return this->m34; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35>
    struct vector_data36
    {
        vector_data36()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() , m33() , m34() , m35() {}
        vector_data36(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) , m33(_33) , m34(_34) , m35(_35) {}
        vector_data36(
            vector_data36 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) , m33(other.m33) , m34(other.m34) , m35(other.m35) {}
        vector_data36&
        operator=(vector_data36 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35;
            return *this;
        }
        template <typename Sequence>
        static vector_data36
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34);
            return vector_data36( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32 , *i33 , *i34 , *i35);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32; T33 m33; T34 m34; T35 m35;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35>
    struct vector36
      : vector_data36< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35>
      , sequence_base<vector36< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35> >
    {
        typedef vector36< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35> this_type;
        typedef vector_data36< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35> base_type;
        typedef mpl::vector36< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<36> size;
        vector36() {}
        vector36(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32 , _33 , _34 , _35) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35>
        vector36(
            vector36< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32 , vec.m33 , vec.m34 , vec.m35) {}
        template <typename Sequence>
        vector36(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35>
        vector36&
        operator=(vector36< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32; this->m33 = *i33; this->m34 = *i34; this->m35 = *i35;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; } typename add_reference<T33>::type at_impl(mpl::int_<33>) { return this->m33; } typename add_reference<typename add_const<T33>::type>::type at_impl(mpl::int_<33>) const { return this->m33; } typename add_reference<T34>::type at_impl(mpl::int_<34>) { return this->m34; } typename add_reference<typename add_const<T34>::type>::type at_impl(mpl::int_<34>) const { return this->m34; } typename add_reference<T35>::type at_impl(mpl::int_<35>) { return this->m35; } typename add_reference<typename add_const<T35>::type>::type at_impl(mpl::int_<35>) const { return this->m35; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36>
    struct vector_data37
    {
        vector_data37()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() , m33() , m34() , m35() , m36() {}
        vector_data37(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) , m33(_33) , m34(_34) , m35(_35) , m36(_36) {}
        vector_data37(
            vector_data37 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) , m33(other.m33) , m34(other.m34) , m35(other.m35) , m36(other.m36) {}
        vector_data37&
        operator=(vector_data37 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36;
            return *this;
        }
        template <typename Sequence>
        static vector_data37
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35);
            return vector_data37( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32 , *i33 , *i34 , *i35 , *i36);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32; T33 m33; T34 m34; T35 m35; T36 m36;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36>
    struct vector37
      : vector_data37< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36>
      , sequence_base<vector37< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36> >
    {
        typedef vector37< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36> this_type;
        typedef vector_data37< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36> base_type;
        typedef mpl::vector37< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<37> size;
        vector37() {}
        vector37(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32 , _33 , _34 , _35 , _36) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36>
        vector37(
            vector37< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32 , vec.m33 , vec.m34 , vec.m35 , vec.m36) {}
        template <typename Sequence>
        vector37(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36>
        vector37&
        operator=(vector37< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32; this->m33 = *i33; this->m34 = *i34; this->m35 = *i35; this->m36 = *i36;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; } typename add_reference<T33>::type at_impl(mpl::int_<33>) { return this->m33; } typename add_reference<typename add_const<T33>::type>::type at_impl(mpl::int_<33>) const { return this->m33; } typename add_reference<T34>::type at_impl(mpl::int_<34>) { return this->m34; } typename add_reference<typename add_const<T34>::type>::type at_impl(mpl::int_<34>) const { return this->m34; } typename add_reference<T35>::type at_impl(mpl::int_<35>) { return this->m35; } typename add_reference<typename add_const<T35>::type>::type at_impl(mpl::int_<35>) const { return this->m35; } typename add_reference<T36>::type at_impl(mpl::int_<36>) { return this->m36; } typename add_reference<typename add_const<T36>::type>::type at_impl(mpl::int_<36>) const { return this->m36; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37>
    struct vector_data38
    {
        vector_data38()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() , m33() , m34() , m35() , m36() , m37() {}
        vector_data38(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) , m33(_33) , m34(_34) , m35(_35) , m36(_36) , m37(_37) {}
        vector_data38(
            vector_data38 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) , m33(other.m33) , m34(other.m34) , m35(other.m35) , m36(other.m36) , m37(other.m37) {}
        vector_data38&
        operator=(vector_data38 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37;
            return *this;
        }
        template <typename Sequence>
        static vector_data38
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36);
            return vector_data38( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32 , *i33 , *i34 , *i35 , *i36 , *i37);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32; T33 m33; T34 m34; T35 m35; T36 m36; T37 m37;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37>
    struct vector38
      : vector_data38< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37>
      , sequence_base<vector38< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37> >
    {
        typedef vector38< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37> this_type;
        typedef vector_data38< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37> base_type;
        typedef mpl::vector38< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<38> size;
        vector38() {}
        vector38(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32 , _33 , _34 , _35 , _36 , _37) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37>
        vector38(
            vector38< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32 , vec.m33 , vec.m34 , vec.m35 , vec.m36 , vec.m37) {}
        template <typename Sequence>
        vector38(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37>
        vector38&
        operator=(vector38< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32; this->m33 = *i33; this->m34 = *i34; this->m35 = *i35; this->m36 = *i36; this->m37 = *i37;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; } typename add_reference<T33>::type at_impl(mpl::int_<33>) { return this->m33; } typename add_reference<typename add_const<T33>::type>::type at_impl(mpl::int_<33>) const { return this->m33; } typename add_reference<T34>::type at_impl(mpl::int_<34>) { return this->m34; } typename add_reference<typename add_const<T34>::type>::type at_impl(mpl::int_<34>) const { return this->m34; } typename add_reference<T35>::type at_impl(mpl::int_<35>) { return this->m35; } typename add_reference<typename add_const<T35>::type>::type at_impl(mpl::int_<35>) const { return this->m35; } typename add_reference<T36>::type at_impl(mpl::int_<36>) { return this->m36; } typename add_reference<typename add_const<T36>::type>::type at_impl(mpl::int_<36>) const { return this->m36; } typename add_reference<T37>::type at_impl(mpl::int_<37>) { return this->m37; } typename add_reference<typename add_const<T37>::type>::type at_impl(mpl::int_<37>) const { return this->m37; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38>
    struct vector_data39
    {
        vector_data39()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() , m33() , m34() , m35() , m36() , m37() , m38() {}
        vector_data39(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) , m33(_33) , m34(_34) , m35(_35) , m36(_36) , m37(_37) , m38(_38) {}
        vector_data39(
            vector_data39 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) , m33(other.m33) , m34(other.m34) , m35(other.m35) , m36(other.m36) , m37(other.m37) , m38(other.m38) {}
        vector_data39&
        operator=(vector_data39 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38;
            return *this;
        }
        template <typename Sequence>
        static vector_data39
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37);
            return vector_data39( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32 , *i33 , *i34 , *i35 , *i36 , *i37 , *i38);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32; T33 m33; T34 m34; T35 m35; T36 m36; T37 m37; T38 m38;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38>
    struct vector39
      : vector_data39< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38>
      , sequence_base<vector39< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38> >
    {
        typedef vector39< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38> this_type;
        typedef vector_data39< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38> base_type;
        typedef mpl::vector39< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<39> size;
        vector39() {}
        vector39(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32 , _33 , _34 , _35 , _36 , _37 , _38) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38>
        vector39(
            vector39< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32 , vec.m33 , vec.m34 , vec.m35 , vec.m36 , vec.m37 , vec.m38) {}
        template <typename Sequence>
        vector39(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38>
        vector39&
        operator=(vector39< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32; this->m33 = *i33; this->m34 = *i34; this->m35 = *i35; this->m36 = *i36; this->m37 = *i37; this->m38 = *i38;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; } typename add_reference<T33>::type at_impl(mpl::int_<33>) { return this->m33; } typename add_reference<typename add_const<T33>::type>::type at_impl(mpl::int_<33>) const { return this->m33; } typename add_reference<T34>::type at_impl(mpl::int_<34>) { return this->m34; } typename add_reference<typename add_const<T34>::type>::type at_impl(mpl::int_<34>) const { return this->m34; } typename add_reference<T35>::type at_impl(mpl::int_<35>) { return this->m35; } typename add_reference<typename add_const<T35>::type>::type at_impl(mpl::int_<35>) const { return this->m35; } typename add_reference<T36>::type at_impl(mpl::int_<36>) { return this->m36; } typename add_reference<typename add_const<T36>::type>::type at_impl(mpl::int_<36>) const { return this->m36; } typename add_reference<T37>::type at_impl(mpl::int_<37>) { return this->m37; } typename add_reference<typename add_const<T37>::type>::type at_impl(mpl::int_<37>) const { return this->m37; } typename add_reference<T38>::type at_impl(mpl::int_<38>) { return this->m38; } typename add_reference<typename add_const<T38>::type>::type at_impl(mpl::int_<38>) const { return this->m38; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39>
    struct vector_data40
    {
        vector_data40()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() , m33() , m34() , m35() , m36() , m37() , m38() , m39() {}
        vector_data40(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) , m33(_33) , m34(_34) , m35(_35) , m36(_36) , m37(_37) , m38(_38) , m39(_39) {}
        vector_data40(
            vector_data40 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) , m33(other.m33) , m34(other.m34) , m35(other.m35) , m36(other.m36) , m37(other.m37) , m38(other.m38) , m39(other.m39) {}
        vector_data40&
        operator=(vector_data40 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39;
            return *this;
        }
        template <typename Sequence>
        static vector_data40
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38);
            return vector_data40( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32 , *i33 , *i34 , *i35 , *i36 , *i37 , *i38 , *i39);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32; T33 m33; T34 m34; T35 m35; T36 m36; T37 m37; T38 m38; T39 m39;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39>
    struct vector40
      : vector_data40< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39>
      , sequence_base<vector40< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39> >
    {
        typedef vector40< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39> this_type;
        typedef vector_data40< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39> base_type;
        typedef mpl::vector40< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<40> size;
        vector40() {}
        vector40(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32 , _33 , _34 , _35 , _36 , _37 , _38 , _39) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39>
        vector40(
            vector40< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32 , vec.m33 , vec.m34 , vec.m35 , vec.m36 , vec.m37 , vec.m38 , vec.m39) {}
        template <typename Sequence>
        vector40(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39>
        vector40&
        operator=(vector40< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32; this->m33 = *i33; this->m34 = *i34; this->m35 = *i35; this->m36 = *i36; this->m37 = *i37; this->m38 = *i38; this->m39 = *i39;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; } typename add_reference<T33>::type at_impl(mpl::int_<33>) { return this->m33; } typename add_reference<typename add_const<T33>::type>::type at_impl(mpl::int_<33>) const { return this->m33; } typename add_reference<T34>::type at_impl(mpl::int_<34>) { return this->m34; } typename add_reference<typename add_const<T34>::type>::type at_impl(mpl::int_<34>) const { return this->m34; } typename add_reference<T35>::type at_impl(mpl::int_<35>) { return this->m35; } typename add_reference<typename add_const<T35>::type>::type at_impl(mpl::int_<35>) const { return this->m35; } typename add_reference<T36>::type at_impl(mpl::int_<36>) { return this->m36; } typename add_reference<typename add_const<T36>::type>::type at_impl(mpl::int_<36>) const { return this->m36; } typename add_reference<T37>::type at_impl(mpl::int_<37>) { return this->m37; } typename add_reference<typename add_const<T37>::type>::type at_impl(mpl::int_<37>) const { return this->m37; } typename add_reference<T38>::type at_impl(mpl::int_<38>) { return this->m38; } typename add_reference<typename add_const<T38>::type>::type at_impl(mpl::int_<38>) const { return this->m38; } typename add_reference<T39>::type at_impl(mpl::int_<39>) { return this->m39; } typename add_reference<typename add_const<T39>::type>::type at_impl(mpl::int_<39>) const { return this->m39; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
}}
namespace boost { namespace mpl {
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32, typename T33, typename T34
    , typename T35, typename T36, typename T37, typename T38, typename T39
    , typename T40
    >
struct vector41
    : v_item<
          T40
        , vector40< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39 >
        >
{
    typedef vector41 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32, typename T33, typename T34
    , typename T35, typename T36, typename T37, typename T38, typename T39
    , typename T40, typename T41
    >
struct vector42
    : v_item<
          T41
        , vector41< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40 >
        >
{
    typedef vector42 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32, typename T33, typename T34
    , typename T35, typename T36, typename T37, typename T38, typename T39
    , typename T40, typename T41, typename T42
    >
struct vector43
    : v_item<
          T42
        , vector42< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41 >
        >
{
    typedef vector43 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32, typename T33, typename T34
    , typename T35, typename T36, typename T37, typename T38, typename T39
    , typename T40, typename T41, typename T42, typename T43
    >
struct vector44
    : v_item<
          T43
        , vector43< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42 >
        >
{
    typedef vector44 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32, typename T33, typename T34
    , typename T35, typename T36, typename T37, typename T38, typename T39
    , typename T40, typename T41, typename T42, typename T43, typename T44
    >
struct vector45
    : v_item<
          T44
        , vector44< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43 >
        >
{
    typedef vector45 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32, typename T33, typename T34
    , typename T35, typename T36, typename T37, typename T38, typename T39
    , typename T40, typename T41, typename T42, typename T43, typename T44
    , typename T45
    >
struct vector46
    : v_item<
          T45
        , vector45< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44 >
        >
{
    typedef vector46 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32, typename T33, typename T34
    , typename T35, typename T36, typename T37, typename T38, typename T39
    , typename T40, typename T41, typename T42, typename T43, typename T44
    , typename T45, typename T46
    >
struct vector47
    : v_item<
          T46
        , vector46< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45 >
        >
{
    typedef vector47 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32, typename T33, typename T34
    , typename T35, typename T36, typename T37, typename T38, typename T39
    , typename T40, typename T41, typename T42, typename T43, typename T44
    , typename T45, typename T46, typename T47
    >
struct vector48
    : v_item<
          T47
        , vector47< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46 >
        >
{
    typedef vector48 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32, typename T33, typename T34
    , typename T35, typename T36, typename T37, typename T38, typename T39
    , typename T40, typename T41, typename T42, typename T43, typename T44
    , typename T45, typename T46, typename T47, typename T48
    >
struct vector49
    : v_item<
          T48
        , vector48< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47 >
        >
{
    typedef vector49 type;
};
template<
      typename T0, typename T1, typename T2, typename T3, typename T4
    , typename T5, typename T6, typename T7, typename T8, typename T9
    , typename T10, typename T11, typename T12, typename T13, typename T14
    , typename T15, typename T16, typename T17, typename T18, typename T19
    , typename T20, typename T21, typename T22, typename T23, typename T24
    , typename T25, typename T26, typename T27, typename T28, typename T29
    , typename T30, typename T31, typename T32, typename T33, typename T34
    , typename T35, typename T36, typename T37, typename T38, typename T39
    , typename T40, typename T41, typename T42, typename T43, typename T44
    , typename T45, typename T46, typename T47, typename T48, typename T49
    >
struct vector50
    : v_item<
          T49
        , vector49< T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,T40,T41,T42,T43,T44,T45,T46,T47,T48 >
        >
{
    typedef vector50 type;
};
}}
namespace boost { namespace fusion
{
    struct vector_tag;
    struct fusion_sequence_tag;
    struct random_access_traversal_tag;
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40>
    struct vector_data41
    {
        vector_data41()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() , m33() , m34() , m35() , m36() , m37() , m38() , m39() , m40() {}
        vector_data41(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) , m33(_33) , m34(_34) , m35(_35) , m36(_36) , m37(_37) , m38(_38) , m39(_39) , m40(_40) {}
        vector_data41(
            vector_data41 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) , m33(other.m33) , m34(other.m34) , m35(other.m35) , m36(other.m36) , m37(other.m37) , m38(other.m38) , m39(other.m39) , m40(other.m40) {}
        vector_data41&
        operator=(vector_data41 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40;
            return *this;
        }
        template <typename Sequence>
        static vector_data41
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39);
            return vector_data41( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32 , *i33 , *i34 , *i35 , *i36 , *i37 , *i38 , *i39 , *i40);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32; T33 m33; T34 m34; T35 m35; T36 m36; T37 m37; T38 m38; T39 m39; T40 m40;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40>
    struct vector41
      : vector_data41< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40>
      , sequence_base<vector41< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40> >
    {
        typedef vector41< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40> this_type;
        typedef vector_data41< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40> base_type;
        typedef mpl::vector41< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<41> size;
        vector41() {}
        vector41(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32 , _33 , _34 , _35 , _36 , _37 , _38 , _39 , _40) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40>
        vector41(
            vector41< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32 , vec.m33 , vec.m34 , vec.m35 , vec.m36 , vec.m37 , vec.m38 , vec.m39 , vec.m40) {}
        template <typename Sequence>
        vector41(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40>
        vector41&
        operator=(vector41< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32; this->m33 = *i33; this->m34 = *i34; this->m35 = *i35; this->m36 = *i36; this->m37 = *i37; this->m38 = *i38; this->m39 = *i39; this->m40 = *i40;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; } typename add_reference<T33>::type at_impl(mpl::int_<33>) { return this->m33; } typename add_reference<typename add_const<T33>::type>::type at_impl(mpl::int_<33>) const { return this->m33; } typename add_reference<T34>::type at_impl(mpl::int_<34>) { return this->m34; } typename add_reference<typename add_const<T34>::type>::type at_impl(mpl::int_<34>) const { return this->m34; } typename add_reference<T35>::type at_impl(mpl::int_<35>) { return this->m35; } typename add_reference<typename add_const<T35>::type>::type at_impl(mpl::int_<35>) const { return this->m35; } typename add_reference<T36>::type at_impl(mpl::int_<36>) { return this->m36; } typename add_reference<typename add_const<T36>::type>::type at_impl(mpl::int_<36>) const { return this->m36; } typename add_reference<T37>::type at_impl(mpl::int_<37>) { return this->m37; } typename add_reference<typename add_const<T37>::type>::type at_impl(mpl::int_<37>) const { return this->m37; } typename add_reference<T38>::type at_impl(mpl::int_<38>) { return this->m38; } typename add_reference<typename add_const<T38>::type>::type at_impl(mpl::int_<38>) const { return this->m38; } typename add_reference<T39>::type at_impl(mpl::int_<39>) { return this->m39; } typename add_reference<typename add_const<T39>::type>::type at_impl(mpl::int_<39>) const { return this->m39; } typename add_reference<T40>::type at_impl(mpl::int_<40>) { return this->m40; } typename add_reference<typename add_const<T40>::type>::type at_impl(mpl::int_<40>) const { return this->m40; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41>
    struct vector_data42
    {
        vector_data42()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() , m33() , m34() , m35() , m36() , m37() , m38() , m39() , m40() , m41() {}
        vector_data42(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) , m33(_33) , m34(_34) , m35(_35) , m36(_36) , m37(_37) , m38(_38) , m39(_39) , m40(_40) , m41(_41) {}
        vector_data42(
            vector_data42 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) , m33(other.m33) , m34(other.m34) , m35(other.m35) , m36(other.m36) , m37(other.m37) , m38(other.m38) , m39(other.m39) , m40(other.m40) , m41(other.m41) {}
        vector_data42&
        operator=(vector_data42 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41;
            return *this;
        }
        template <typename Sequence>
        static vector_data42
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40);
            return vector_data42( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32 , *i33 , *i34 , *i35 , *i36 , *i37 , *i38 , *i39 , *i40 , *i41);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32; T33 m33; T34 m34; T35 m35; T36 m36; T37 m37; T38 m38; T39 m39; T40 m40; T41 m41;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41>
    struct vector42
      : vector_data42< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41>
      , sequence_base<vector42< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41> >
    {
        typedef vector42< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41> this_type;
        typedef vector_data42< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41> base_type;
        typedef mpl::vector42< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<42> size;
        vector42() {}
        vector42(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32 , _33 , _34 , _35 , _36 , _37 , _38 , _39 , _40 , _41) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41>
        vector42(
            vector42< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32 , vec.m33 , vec.m34 , vec.m35 , vec.m36 , vec.m37 , vec.m38 , vec.m39 , vec.m40 , vec.m41) {}
        template <typename Sequence>
        vector42(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41>
        vector42&
        operator=(vector42< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32; this->m33 = *i33; this->m34 = *i34; this->m35 = *i35; this->m36 = *i36; this->m37 = *i37; this->m38 = *i38; this->m39 = *i39; this->m40 = *i40; this->m41 = *i41;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; } typename add_reference<T33>::type at_impl(mpl::int_<33>) { return this->m33; } typename add_reference<typename add_const<T33>::type>::type at_impl(mpl::int_<33>) const { return this->m33; } typename add_reference<T34>::type at_impl(mpl::int_<34>) { return this->m34; } typename add_reference<typename add_const<T34>::type>::type at_impl(mpl::int_<34>) const { return this->m34; } typename add_reference<T35>::type at_impl(mpl::int_<35>) { return this->m35; } typename add_reference<typename add_const<T35>::type>::type at_impl(mpl::int_<35>) const { return this->m35; } typename add_reference<T36>::type at_impl(mpl::int_<36>) { return this->m36; } typename add_reference<typename add_const<T36>::type>::type at_impl(mpl::int_<36>) const { return this->m36; } typename add_reference<T37>::type at_impl(mpl::int_<37>) { return this->m37; } typename add_reference<typename add_const<T37>::type>::type at_impl(mpl::int_<37>) const { return this->m37; } typename add_reference<T38>::type at_impl(mpl::int_<38>) { return this->m38; } typename add_reference<typename add_const<T38>::type>::type at_impl(mpl::int_<38>) const { return this->m38; } typename add_reference<T39>::type at_impl(mpl::int_<39>) { return this->m39; } typename add_reference<typename add_const<T39>::type>::type at_impl(mpl::int_<39>) const { return this->m39; } typename add_reference<T40>::type at_impl(mpl::int_<40>) { return this->m40; } typename add_reference<typename add_const<T40>::type>::type at_impl(mpl::int_<40>) const { return this->m40; } typename add_reference<T41>::type at_impl(mpl::int_<41>) { return this->m41; } typename add_reference<typename add_const<T41>::type>::type at_impl(mpl::int_<41>) const { return this->m41; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41 , typename T42>
    struct vector_data43
    {
        vector_data43()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() , m33() , m34() , m35() , m36() , m37() , m38() , m39() , m40() , m41() , m42() {}
        vector_data43(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41 , typename detail::call_param<T42 >::type _42)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) , m33(_33) , m34(_34) , m35(_35) , m36(_36) , m37(_37) , m38(_38) , m39(_39) , m40(_40) , m41(_41) , m42(_42) {}
        vector_data43(
            vector_data43 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) , m33(other.m33) , m34(other.m34) , m35(other.m35) , m36(other.m36) , m37(other.m37) , m38(other.m38) , m39(other.m39) , m40(other.m40) , m41(other.m41) , m42(other.m42) {}
        vector_data43&
        operator=(vector_data43 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41; this->m42 = vec.m42;
            return *this;
        }
        template <typename Sequence>
        static vector_data43
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40); typedef typename result_of::next< I41>::type I42; I42 i42 = fusion::next(i41);
            return vector_data43( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32 , *i33 , *i34 , *i35 , *i36 , *i37 , *i38 , *i39 , *i40 , *i41 , *i42);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32; T33 m33; T34 m34; T35 m35; T36 m36; T37 m37; T38 m38; T39 m39; T40 m40; T41 m41; T42 m42;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41 , typename T42>
    struct vector43
      : vector_data43< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42>
      , sequence_base<vector43< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42> >
    {
        typedef vector43< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42> this_type;
        typedef vector_data43< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42> base_type;
        typedef mpl::vector43< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<43> size;
        vector43() {}
        vector43(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41 , typename detail::call_param<T42 >::type _42)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32 , _33 , _34 , _35 , _36 , _37 , _38 , _39 , _40 , _41 , _42) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41 , typename U42>
        vector43(
            vector43< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41 , U42> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32 , vec.m33 , vec.m34 , vec.m35 , vec.m36 , vec.m37 , vec.m38 , vec.m39 , vec.m40 , vec.m41 , vec.m42) {}
        template <typename Sequence>
        vector43(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41 , typename U42>
        vector43&
        operator=(vector43< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41 , U42> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41; this->m42 = vec.m42;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40); typedef typename result_of::next< I41>::type I42; I42 i42 = fusion::next(i41);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32; this->m33 = *i33; this->m34 = *i34; this->m35 = *i35; this->m36 = *i36; this->m37 = *i37; this->m38 = *i38; this->m39 = *i39; this->m40 = *i40; this->m41 = *i41; this->m42 = *i42;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; } typename add_reference<T33>::type at_impl(mpl::int_<33>) { return this->m33; } typename add_reference<typename add_const<T33>::type>::type at_impl(mpl::int_<33>) const { return this->m33; } typename add_reference<T34>::type at_impl(mpl::int_<34>) { return this->m34; } typename add_reference<typename add_const<T34>::type>::type at_impl(mpl::int_<34>) const { return this->m34; } typename add_reference<T35>::type at_impl(mpl::int_<35>) { return this->m35; } typename add_reference<typename add_const<T35>::type>::type at_impl(mpl::int_<35>) const { return this->m35; } typename add_reference<T36>::type at_impl(mpl::int_<36>) { return this->m36; } typename add_reference<typename add_const<T36>::type>::type at_impl(mpl::int_<36>) const { return this->m36; } typename add_reference<T37>::type at_impl(mpl::int_<37>) { return this->m37; } typename add_reference<typename add_const<T37>::type>::type at_impl(mpl::int_<37>) const { return this->m37; } typename add_reference<T38>::type at_impl(mpl::int_<38>) { return this->m38; } typename add_reference<typename add_const<T38>::type>::type at_impl(mpl::int_<38>) const { return this->m38; } typename add_reference<T39>::type at_impl(mpl::int_<39>) { return this->m39; } typename add_reference<typename add_const<T39>::type>::type at_impl(mpl::int_<39>) const { return this->m39; } typename add_reference<T40>::type at_impl(mpl::int_<40>) { return this->m40; } typename add_reference<typename add_const<T40>::type>::type at_impl(mpl::int_<40>) const { return this->m40; } typename add_reference<T41>::type at_impl(mpl::int_<41>) { return this->m41; } typename add_reference<typename add_const<T41>::type>::type at_impl(mpl::int_<41>) const { return this->m41; } typename add_reference<T42>::type at_impl(mpl::int_<42>) { return this->m42; } typename add_reference<typename add_const<T42>::type>::type at_impl(mpl::int_<42>) const { return this->m42; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41 , typename T42 , typename T43>
    struct vector_data44
    {
        vector_data44()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() , m33() , m34() , m35() , m36() , m37() , m38() , m39() , m40() , m41() , m42() , m43() {}
        vector_data44(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41 , typename detail::call_param<T42 >::type _42 , typename detail::call_param<T43 >::type _43)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) , m33(_33) , m34(_34) , m35(_35) , m36(_36) , m37(_37) , m38(_38) , m39(_39) , m40(_40) , m41(_41) , m42(_42) , m43(_43) {}
        vector_data44(
            vector_data44 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) , m33(other.m33) , m34(other.m34) , m35(other.m35) , m36(other.m36) , m37(other.m37) , m38(other.m38) , m39(other.m39) , m40(other.m40) , m41(other.m41) , m42(other.m42) , m43(other.m43) {}
        vector_data44&
        operator=(vector_data44 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41; this->m42 = vec.m42; this->m43 = vec.m43;
            return *this;
        }
        template <typename Sequence>
        static vector_data44
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40); typedef typename result_of::next< I41>::type I42; I42 i42 = fusion::next(i41); typedef typename result_of::next< I42>::type I43; I43 i43 = fusion::next(i42);
            return vector_data44( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32 , *i33 , *i34 , *i35 , *i36 , *i37 , *i38 , *i39 , *i40 , *i41 , *i42 , *i43);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32; T33 m33; T34 m34; T35 m35; T36 m36; T37 m37; T38 m38; T39 m39; T40 m40; T41 m41; T42 m42; T43 m43;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41 , typename T42 , typename T43>
    struct vector44
      : vector_data44< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43>
      , sequence_base<vector44< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43> >
    {
        typedef vector44< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43> this_type;
        typedef vector_data44< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43> base_type;
        typedef mpl::vector44< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<44> size;
        vector44() {}
        vector44(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41 , typename detail::call_param<T42 >::type _42 , typename detail::call_param<T43 >::type _43)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32 , _33 , _34 , _35 , _36 , _37 , _38 , _39 , _40 , _41 , _42 , _43) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41 , typename U42 , typename U43>
        vector44(
            vector44< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41 , U42 , U43> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32 , vec.m33 , vec.m34 , vec.m35 , vec.m36 , vec.m37 , vec.m38 , vec.m39 , vec.m40 , vec.m41 , vec.m42 , vec.m43) {}
        template <typename Sequence>
        vector44(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41 , typename U42 , typename U43>
        vector44&
        operator=(vector44< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41 , U42 , U43> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41; this->m42 = vec.m42; this->m43 = vec.m43;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40); typedef typename result_of::next< I41>::type I42; I42 i42 = fusion::next(i41); typedef typename result_of::next< I42>::type I43; I43 i43 = fusion::next(i42);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32; this->m33 = *i33; this->m34 = *i34; this->m35 = *i35; this->m36 = *i36; this->m37 = *i37; this->m38 = *i38; this->m39 = *i39; this->m40 = *i40; this->m41 = *i41; this->m42 = *i42; this->m43 = *i43;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; } typename add_reference<T33>::type at_impl(mpl::int_<33>) { return this->m33; } typename add_reference<typename add_const<T33>::type>::type at_impl(mpl::int_<33>) const { return this->m33; } typename add_reference<T34>::type at_impl(mpl::int_<34>) { return this->m34; } typename add_reference<typename add_const<T34>::type>::type at_impl(mpl::int_<34>) const { return this->m34; } typename add_reference<T35>::type at_impl(mpl::int_<35>) { return this->m35; } typename add_reference<typename add_const<T35>::type>::type at_impl(mpl::int_<35>) const { return this->m35; } typename add_reference<T36>::type at_impl(mpl::int_<36>) { return this->m36; } typename add_reference<typename add_const<T36>::type>::type at_impl(mpl::int_<36>) const { return this->m36; } typename add_reference<T37>::type at_impl(mpl::int_<37>) { return this->m37; } typename add_reference<typename add_const<T37>::type>::type at_impl(mpl::int_<37>) const { return this->m37; } typename add_reference<T38>::type at_impl(mpl::int_<38>) { return this->m38; } typename add_reference<typename add_const<T38>::type>::type at_impl(mpl::int_<38>) const { return this->m38; } typename add_reference<T39>::type at_impl(mpl::int_<39>) { return this->m39; } typename add_reference<typename add_const<T39>::type>::type at_impl(mpl::int_<39>) const { return this->m39; } typename add_reference<T40>::type at_impl(mpl::int_<40>) { return this->m40; } typename add_reference<typename add_const<T40>::type>::type at_impl(mpl::int_<40>) const { return this->m40; } typename add_reference<T41>::type at_impl(mpl::int_<41>) { return this->m41; } typename add_reference<typename add_const<T41>::type>::type at_impl(mpl::int_<41>) const { return this->m41; } typename add_reference<T42>::type at_impl(mpl::int_<42>) { return this->m42; } typename add_reference<typename add_const<T42>::type>::type at_impl(mpl::int_<42>) const { return this->m42; } typename add_reference<T43>::type at_impl(mpl::int_<43>) { return this->m43; } typename add_reference<typename add_const<T43>::type>::type at_impl(mpl::int_<43>) const { return this->m43; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41 , typename T42 , typename T43 , typename T44>
    struct vector_data45
    {
        vector_data45()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() , m33() , m34() , m35() , m36() , m37() , m38() , m39() , m40() , m41() , m42() , m43() , m44() {}
        vector_data45(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41 , typename detail::call_param<T42 >::type _42 , typename detail::call_param<T43 >::type _43 , typename detail::call_param<T44 >::type _44)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) , m33(_33) , m34(_34) , m35(_35) , m36(_36) , m37(_37) , m38(_38) , m39(_39) , m40(_40) , m41(_41) , m42(_42) , m43(_43) , m44(_44) {}
        vector_data45(
            vector_data45 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) , m33(other.m33) , m34(other.m34) , m35(other.m35) , m36(other.m36) , m37(other.m37) , m38(other.m38) , m39(other.m39) , m40(other.m40) , m41(other.m41) , m42(other.m42) , m43(other.m43) , m44(other.m44) {}
        vector_data45&
        operator=(vector_data45 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41; this->m42 = vec.m42; this->m43 = vec.m43; this->m44 = vec.m44;
            return *this;
        }
        template <typename Sequence>
        static vector_data45
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40); typedef typename result_of::next< I41>::type I42; I42 i42 = fusion::next(i41); typedef typename result_of::next< I42>::type I43; I43 i43 = fusion::next(i42); typedef typename result_of::next< I43>::type I44; I44 i44 = fusion::next(i43);
            return vector_data45( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32 , *i33 , *i34 , *i35 , *i36 , *i37 , *i38 , *i39 , *i40 , *i41 , *i42 , *i43 , *i44);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32; T33 m33; T34 m34; T35 m35; T36 m36; T37 m37; T38 m38; T39 m39; T40 m40; T41 m41; T42 m42; T43 m43; T44 m44;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41 , typename T42 , typename T43 , typename T44>
    struct vector45
      : vector_data45< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44>
      , sequence_base<vector45< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44> >
    {
        typedef vector45< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44> this_type;
        typedef vector_data45< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44> base_type;
        typedef mpl::vector45< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<45> size;
        vector45() {}
        vector45(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41 , typename detail::call_param<T42 >::type _42 , typename detail::call_param<T43 >::type _43 , typename detail::call_param<T44 >::type _44)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32 , _33 , _34 , _35 , _36 , _37 , _38 , _39 , _40 , _41 , _42 , _43 , _44) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41 , typename U42 , typename U43 , typename U44>
        vector45(
            vector45< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41 , U42 , U43 , U44> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32 , vec.m33 , vec.m34 , vec.m35 , vec.m36 , vec.m37 , vec.m38 , vec.m39 , vec.m40 , vec.m41 , vec.m42 , vec.m43 , vec.m44) {}
        template <typename Sequence>
        vector45(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41 , typename U42 , typename U43 , typename U44>
        vector45&
        operator=(vector45< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41 , U42 , U43 , U44> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41; this->m42 = vec.m42; this->m43 = vec.m43; this->m44 = vec.m44;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40); typedef typename result_of::next< I41>::type I42; I42 i42 = fusion::next(i41); typedef typename result_of::next< I42>::type I43; I43 i43 = fusion::next(i42); typedef typename result_of::next< I43>::type I44; I44 i44 = fusion::next(i43);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32; this->m33 = *i33; this->m34 = *i34; this->m35 = *i35; this->m36 = *i36; this->m37 = *i37; this->m38 = *i38; this->m39 = *i39; this->m40 = *i40; this->m41 = *i41; this->m42 = *i42; this->m43 = *i43; this->m44 = *i44;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; } typename add_reference<T33>::type at_impl(mpl::int_<33>) { return this->m33; } typename add_reference<typename add_const<T33>::type>::type at_impl(mpl::int_<33>) const { return this->m33; } typename add_reference<T34>::type at_impl(mpl::int_<34>) { return this->m34; } typename add_reference<typename add_const<T34>::type>::type at_impl(mpl::int_<34>) const { return this->m34; } typename add_reference<T35>::type at_impl(mpl::int_<35>) { return this->m35; } typename add_reference<typename add_const<T35>::type>::type at_impl(mpl::int_<35>) const { return this->m35; } typename add_reference<T36>::type at_impl(mpl::int_<36>) { return this->m36; } typename add_reference<typename add_const<T36>::type>::type at_impl(mpl::int_<36>) const { return this->m36; } typename add_reference<T37>::type at_impl(mpl::int_<37>) { return this->m37; } typename add_reference<typename add_const<T37>::type>::type at_impl(mpl::int_<37>) const { return this->m37; } typename add_reference<T38>::type at_impl(mpl::int_<38>) { return this->m38; } typename add_reference<typename add_const<T38>::type>::type at_impl(mpl::int_<38>) const { return this->m38; } typename add_reference<T39>::type at_impl(mpl::int_<39>) { return this->m39; } typename add_reference<typename add_const<T39>::type>::type at_impl(mpl::int_<39>) const { return this->m39; } typename add_reference<T40>::type at_impl(mpl::int_<40>) { return this->m40; } typename add_reference<typename add_const<T40>::type>::type at_impl(mpl::int_<40>) const { return this->m40; } typename add_reference<T41>::type at_impl(mpl::int_<41>) { return this->m41; } typename add_reference<typename add_const<T41>::type>::type at_impl(mpl::int_<41>) const { return this->m41; } typename add_reference<T42>::type at_impl(mpl::int_<42>) { return this->m42; } typename add_reference<typename add_const<T42>::type>::type at_impl(mpl::int_<42>) const { return this->m42; } typename add_reference<T43>::type at_impl(mpl::int_<43>) { return this->m43; } typename add_reference<typename add_const<T43>::type>::type at_impl(mpl::int_<43>) const { return this->m43; } typename add_reference<T44>::type at_impl(mpl::int_<44>) { return this->m44; } typename add_reference<typename add_const<T44>::type>::type at_impl(mpl::int_<44>) const { return this->m44; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41 , typename T42 , typename T43 , typename T44 , typename T45>
    struct vector_data46
    {
        vector_data46()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() , m33() , m34() , m35() , m36() , m37() , m38() , m39() , m40() , m41() , m42() , m43() , m44() , m45() {}
        vector_data46(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41 , typename detail::call_param<T42 >::type _42 , typename detail::call_param<T43 >::type _43 , typename detail::call_param<T44 >::type _44 , typename detail::call_param<T45 >::type _45)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) , m33(_33) , m34(_34) , m35(_35) , m36(_36) , m37(_37) , m38(_38) , m39(_39) , m40(_40) , m41(_41) , m42(_42) , m43(_43) , m44(_44) , m45(_45) {}
        vector_data46(
            vector_data46 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) , m33(other.m33) , m34(other.m34) , m35(other.m35) , m36(other.m36) , m37(other.m37) , m38(other.m38) , m39(other.m39) , m40(other.m40) , m41(other.m41) , m42(other.m42) , m43(other.m43) , m44(other.m44) , m45(other.m45) {}
        vector_data46&
        operator=(vector_data46 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41; this->m42 = vec.m42; this->m43 = vec.m43; this->m44 = vec.m44; this->m45 = vec.m45;
            return *this;
        }
        template <typename Sequence>
        static vector_data46
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40); typedef typename result_of::next< I41>::type I42; I42 i42 = fusion::next(i41); typedef typename result_of::next< I42>::type I43; I43 i43 = fusion::next(i42); typedef typename result_of::next< I43>::type I44; I44 i44 = fusion::next(i43); typedef typename result_of::next< I44>::type I45; I45 i45 = fusion::next(i44);
            return vector_data46( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32 , *i33 , *i34 , *i35 , *i36 , *i37 , *i38 , *i39 , *i40 , *i41 , *i42 , *i43 , *i44 , *i45);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32; T33 m33; T34 m34; T35 m35; T36 m36; T37 m37; T38 m38; T39 m39; T40 m40; T41 m41; T42 m42; T43 m43; T44 m44; T45 m45;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41 , typename T42 , typename T43 , typename T44 , typename T45>
    struct vector46
      : vector_data46< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45>
      , sequence_base<vector46< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45> >
    {
        typedef vector46< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45> this_type;
        typedef vector_data46< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45> base_type;
        typedef mpl::vector46< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<46> size;
        vector46() {}
        vector46(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41 , typename detail::call_param<T42 >::type _42 , typename detail::call_param<T43 >::type _43 , typename detail::call_param<T44 >::type _44 , typename detail::call_param<T45 >::type _45)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32 , _33 , _34 , _35 , _36 , _37 , _38 , _39 , _40 , _41 , _42 , _43 , _44 , _45) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41 , typename U42 , typename U43 , typename U44 , typename U45>
        vector46(
            vector46< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41 , U42 , U43 , U44 , U45> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32 , vec.m33 , vec.m34 , vec.m35 , vec.m36 , vec.m37 , vec.m38 , vec.m39 , vec.m40 , vec.m41 , vec.m42 , vec.m43 , vec.m44 , vec.m45) {}
        template <typename Sequence>
        vector46(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41 , typename U42 , typename U43 , typename U44 , typename U45>
        vector46&
        operator=(vector46< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41 , U42 , U43 , U44 , U45> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41; this->m42 = vec.m42; this->m43 = vec.m43; this->m44 = vec.m44; this->m45 = vec.m45;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40); typedef typename result_of::next< I41>::type I42; I42 i42 = fusion::next(i41); typedef typename result_of::next< I42>::type I43; I43 i43 = fusion::next(i42); typedef typename result_of::next< I43>::type I44; I44 i44 = fusion::next(i43); typedef typename result_of::next< I44>::type I45; I45 i45 = fusion::next(i44);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32; this->m33 = *i33; this->m34 = *i34; this->m35 = *i35; this->m36 = *i36; this->m37 = *i37; this->m38 = *i38; this->m39 = *i39; this->m40 = *i40; this->m41 = *i41; this->m42 = *i42; this->m43 = *i43; this->m44 = *i44; this->m45 = *i45;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; } typename add_reference<T33>::type at_impl(mpl::int_<33>) { return this->m33; } typename add_reference<typename add_const<T33>::type>::type at_impl(mpl::int_<33>) const { return this->m33; } typename add_reference<T34>::type at_impl(mpl::int_<34>) { return this->m34; } typename add_reference<typename add_const<T34>::type>::type at_impl(mpl::int_<34>) const { return this->m34; } typename add_reference<T35>::type at_impl(mpl::int_<35>) { return this->m35; } typename add_reference<typename add_const<T35>::type>::type at_impl(mpl::int_<35>) const { return this->m35; } typename add_reference<T36>::type at_impl(mpl::int_<36>) { return this->m36; } typename add_reference<typename add_const<T36>::type>::type at_impl(mpl::int_<36>) const { return this->m36; } typename add_reference<T37>::type at_impl(mpl::int_<37>) { return this->m37; } typename add_reference<typename add_const<T37>::type>::type at_impl(mpl::int_<37>) const { return this->m37; } typename add_reference<T38>::type at_impl(mpl::int_<38>) { return this->m38; } typename add_reference<typename add_const<T38>::type>::type at_impl(mpl::int_<38>) const { return this->m38; } typename add_reference<T39>::type at_impl(mpl::int_<39>) { return this->m39; } typename add_reference<typename add_const<T39>::type>::type at_impl(mpl::int_<39>) const { return this->m39; } typename add_reference<T40>::type at_impl(mpl::int_<40>) { return this->m40; } typename add_reference<typename add_const<T40>::type>::type at_impl(mpl::int_<40>) const { return this->m40; } typename add_reference<T41>::type at_impl(mpl::int_<41>) { return this->m41; } typename add_reference<typename add_const<T41>::type>::type at_impl(mpl::int_<41>) const { return this->m41; } typename add_reference<T42>::type at_impl(mpl::int_<42>) { return this->m42; } typename add_reference<typename add_const<T42>::type>::type at_impl(mpl::int_<42>) const { return this->m42; } typename add_reference<T43>::type at_impl(mpl::int_<43>) { return this->m43; } typename add_reference<typename add_const<T43>::type>::type at_impl(mpl::int_<43>) const { return this->m43; } typename add_reference<T44>::type at_impl(mpl::int_<44>) { return this->m44; } typename add_reference<typename add_const<T44>::type>::type at_impl(mpl::int_<44>) const { return this->m44; } typename add_reference<T45>::type at_impl(mpl::int_<45>) { return this->m45; } typename add_reference<typename add_const<T45>::type>::type at_impl(mpl::int_<45>) const { return this->m45; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , typename T46>
    struct vector_data47
    {
        vector_data47()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() , m33() , m34() , m35() , m36() , m37() , m38() , m39() , m40() , m41() , m42() , m43() , m44() , m45() , m46() {}
        vector_data47(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41 , typename detail::call_param<T42 >::type _42 , typename detail::call_param<T43 >::type _43 , typename detail::call_param<T44 >::type _44 , typename detail::call_param<T45 >::type _45 , typename detail::call_param<T46 >::type _46)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) , m33(_33) , m34(_34) , m35(_35) , m36(_36) , m37(_37) , m38(_38) , m39(_39) , m40(_40) , m41(_41) , m42(_42) , m43(_43) , m44(_44) , m45(_45) , m46(_46) {}
        vector_data47(
            vector_data47 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) , m33(other.m33) , m34(other.m34) , m35(other.m35) , m36(other.m36) , m37(other.m37) , m38(other.m38) , m39(other.m39) , m40(other.m40) , m41(other.m41) , m42(other.m42) , m43(other.m43) , m44(other.m44) , m45(other.m45) , m46(other.m46) {}
        vector_data47&
        operator=(vector_data47 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41; this->m42 = vec.m42; this->m43 = vec.m43; this->m44 = vec.m44; this->m45 = vec.m45; this->m46 = vec.m46;
            return *this;
        }
        template <typename Sequence>
        static vector_data47
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40); typedef typename result_of::next< I41>::type I42; I42 i42 = fusion::next(i41); typedef typename result_of::next< I42>::type I43; I43 i43 = fusion::next(i42); typedef typename result_of::next< I43>::type I44; I44 i44 = fusion::next(i43); typedef typename result_of::next< I44>::type I45; I45 i45 = fusion::next(i44); typedef typename result_of::next< I45>::type I46; I46 i46 = fusion::next(i45);
            return vector_data47( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32 , *i33 , *i34 , *i35 , *i36 , *i37 , *i38 , *i39 , *i40 , *i41 , *i42 , *i43 , *i44 , *i45 , *i46);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32; T33 m33; T34 m34; T35 m35; T36 m36; T37 m37; T38 m38; T39 m39; T40 m40; T41 m41; T42 m42; T43 m43; T44 m44; T45 m45; T46 m46;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , typename T46>
    struct vector47
      : vector_data47< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46>
      , sequence_base<vector47< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46> >
    {
        typedef vector47< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46> this_type;
        typedef vector_data47< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46> base_type;
        typedef mpl::vector47< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<47> size;
        vector47() {}
        vector47(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41 , typename detail::call_param<T42 >::type _42 , typename detail::call_param<T43 >::type _43 , typename detail::call_param<T44 >::type _44 , typename detail::call_param<T45 >::type _45 , typename detail::call_param<T46 >::type _46)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32 , _33 , _34 , _35 , _36 , _37 , _38 , _39 , _40 , _41 , _42 , _43 , _44 , _45 , _46) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41 , typename U42 , typename U43 , typename U44 , typename U45 , typename U46>
        vector47(
            vector47< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41 , U42 , U43 , U44 , U45 , U46> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32 , vec.m33 , vec.m34 , vec.m35 , vec.m36 , vec.m37 , vec.m38 , vec.m39 , vec.m40 , vec.m41 , vec.m42 , vec.m43 , vec.m44 , vec.m45 , vec.m46) {}
        template <typename Sequence>
        vector47(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41 , typename U42 , typename U43 , typename U44 , typename U45 , typename U46>
        vector47&
        operator=(vector47< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41 , U42 , U43 , U44 , U45 , U46> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41; this->m42 = vec.m42; this->m43 = vec.m43; this->m44 = vec.m44; this->m45 = vec.m45; this->m46 = vec.m46;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40); typedef typename result_of::next< I41>::type I42; I42 i42 = fusion::next(i41); typedef typename result_of::next< I42>::type I43; I43 i43 = fusion::next(i42); typedef typename result_of::next< I43>::type I44; I44 i44 = fusion::next(i43); typedef typename result_of::next< I44>::type I45; I45 i45 = fusion::next(i44); typedef typename result_of::next< I45>::type I46; I46 i46 = fusion::next(i45);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32; this->m33 = *i33; this->m34 = *i34; this->m35 = *i35; this->m36 = *i36; this->m37 = *i37; this->m38 = *i38; this->m39 = *i39; this->m40 = *i40; this->m41 = *i41; this->m42 = *i42; this->m43 = *i43; this->m44 = *i44; this->m45 = *i45; this->m46 = *i46;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; } typename add_reference<T33>::type at_impl(mpl::int_<33>) { return this->m33; } typename add_reference<typename add_const<T33>::type>::type at_impl(mpl::int_<33>) const { return this->m33; } typename add_reference<T34>::type at_impl(mpl::int_<34>) { return this->m34; } typename add_reference<typename add_const<T34>::type>::type at_impl(mpl::int_<34>) const { return this->m34; } typename add_reference<T35>::type at_impl(mpl::int_<35>) { return this->m35; } typename add_reference<typename add_const<T35>::type>::type at_impl(mpl::int_<35>) const { return this->m35; } typename add_reference<T36>::type at_impl(mpl::int_<36>) { return this->m36; } typename add_reference<typename add_const<T36>::type>::type at_impl(mpl::int_<36>) const { return this->m36; } typename add_reference<T37>::type at_impl(mpl::int_<37>) { return this->m37; } typename add_reference<typename add_const<T37>::type>::type at_impl(mpl::int_<37>) const { return this->m37; } typename add_reference<T38>::type at_impl(mpl::int_<38>) { return this->m38; } typename add_reference<typename add_const<T38>::type>::type at_impl(mpl::int_<38>) const { return this->m38; } typename add_reference<T39>::type at_impl(mpl::int_<39>) { return this->m39; } typename add_reference<typename add_const<T39>::type>::type at_impl(mpl::int_<39>) const { return this->m39; } typename add_reference<T40>::type at_impl(mpl::int_<40>) { return this->m40; } typename add_reference<typename add_const<T40>::type>::type at_impl(mpl::int_<40>) const { return this->m40; } typename add_reference<T41>::type at_impl(mpl::int_<41>) { return this->m41; } typename add_reference<typename add_const<T41>::type>::type at_impl(mpl::int_<41>) const { return this->m41; } typename add_reference<T42>::type at_impl(mpl::int_<42>) { return this->m42; } typename add_reference<typename add_const<T42>::type>::type at_impl(mpl::int_<42>) const { return this->m42; } typename add_reference<T43>::type at_impl(mpl::int_<43>) { return this->m43; } typename add_reference<typename add_const<T43>::type>::type at_impl(mpl::int_<43>) const { return this->m43; } typename add_reference<T44>::type at_impl(mpl::int_<44>) { return this->m44; } typename add_reference<typename add_const<T44>::type>::type at_impl(mpl::int_<44>) const { return this->m44; } typename add_reference<T45>::type at_impl(mpl::int_<45>) { return this->m45; } typename add_reference<typename add_const<T45>::type>::type at_impl(mpl::int_<45>) const { return this->m45; } typename add_reference<T46>::type at_impl(mpl::int_<46>) { return this->m46; } typename add_reference<typename add_const<T46>::type>::type at_impl(mpl::int_<46>) const { return this->m46; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , typename T46 , typename T47>
    struct vector_data48
    {
        vector_data48()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() , m33() , m34() , m35() , m36() , m37() , m38() , m39() , m40() , m41() , m42() , m43() , m44() , m45() , m46() , m47() {}
        vector_data48(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41 , typename detail::call_param<T42 >::type _42 , typename detail::call_param<T43 >::type _43 , typename detail::call_param<T44 >::type _44 , typename detail::call_param<T45 >::type _45 , typename detail::call_param<T46 >::type _46 , typename detail::call_param<T47 >::type _47)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) , m33(_33) , m34(_34) , m35(_35) , m36(_36) , m37(_37) , m38(_38) , m39(_39) , m40(_40) , m41(_41) , m42(_42) , m43(_43) , m44(_44) , m45(_45) , m46(_46) , m47(_47) {}
        vector_data48(
            vector_data48 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) , m33(other.m33) , m34(other.m34) , m35(other.m35) , m36(other.m36) , m37(other.m37) , m38(other.m38) , m39(other.m39) , m40(other.m40) , m41(other.m41) , m42(other.m42) , m43(other.m43) , m44(other.m44) , m45(other.m45) , m46(other.m46) , m47(other.m47) {}
        vector_data48&
        operator=(vector_data48 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41; this->m42 = vec.m42; this->m43 = vec.m43; this->m44 = vec.m44; this->m45 = vec.m45; this->m46 = vec.m46; this->m47 = vec.m47;
            return *this;
        }
        template <typename Sequence>
        static vector_data48
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40); typedef typename result_of::next< I41>::type I42; I42 i42 = fusion::next(i41); typedef typename result_of::next< I42>::type I43; I43 i43 = fusion::next(i42); typedef typename result_of::next< I43>::type I44; I44 i44 = fusion::next(i43); typedef typename result_of::next< I44>::type I45; I45 i45 = fusion::next(i44); typedef typename result_of::next< I45>::type I46; I46 i46 = fusion::next(i45); typedef typename result_of::next< I46>::type I47; I47 i47 = fusion::next(i46);
            return vector_data48( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32 , *i33 , *i34 , *i35 , *i36 , *i37 , *i38 , *i39 , *i40 , *i41 , *i42 , *i43 , *i44 , *i45 , *i46 , *i47);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32; T33 m33; T34 m34; T35 m35; T36 m36; T37 m37; T38 m38; T39 m39; T40 m40; T41 m41; T42 m42; T43 m43; T44 m44; T45 m45; T46 m46; T47 m47;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , typename T46 , typename T47>
    struct vector48
      : vector_data48< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47>
      , sequence_base<vector48< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47> >
    {
        typedef vector48< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47> this_type;
        typedef vector_data48< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47> base_type;
        typedef mpl::vector48< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<48> size;
        vector48() {}
        vector48(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41 , typename detail::call_param<T42 >::type _42 , typename detail::call_param<T43 >::type _43 , typename detail::call_param<T44 >::type _44 , typename detail::call_param<T45 >::type _45 , typename detail::call_param<T46 >::type _46 , typename detail::call_param<T47 >::type _47)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32 , _33 , _34 , _35 , _36 , _37 , _38 , _39 , _40 , _41 , _42 , _43 , _44 , _45 , _46 , _47) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41 , typename U42 , typename U43 , typename U44 , typename U45 , typename U46 , typename U47>
        vector48(
            vector48< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41 , U42 , U43 , U44 , U45 , U46 , U47> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32 , vec.m33 , vec.m34 , vec.m35 , vec.m36 , vec.m37 , vec.m38 , vec.m39 , vec.m40 , vec.m41 , vec.m42 , vec.m43 , vec.m44 , vec.m45 , vec.m46 , vec.m47) {}
        template <typename Sequence>
        vector48(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41 , typename U42 , typename U43 , typename U44 , typename U45 , typename U46 , typename U47>
        vector48&
        operator=(vector48< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41 , U42 , U43 , U44 , U45 , U46 , U47> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41; this->m42 = vec.m42; this->m43 = vec.m43; this->m44 = vec.m44; this->m45 = vec.m45; this->m46 = vec.m46; this->m47 = vec.m47;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40); typedef typename result_of::next< I41>::type I42; I42 i42 = fusion::next(i41); typedef typename result_of::next< I42>::type I43; I43 i43 = fusion::next(i42); typedef typename result_of::next< I43>::type I44; I44 i44 = fusion::next(i43); typedef typename result_of::next< I44>::type I45; I45 i45 = fusion::next(i44); typedef typename result_of::next< I45>::type I46; I46 i46 = fusion::next(i45); typedef typename result_of::next< I46>::type I47; I47 i47 = fusion::next(i46);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32; this->m33 = *i33; this->m34 = *i34; this->m35 = *i35; this->m36 = *i36; this->m37 = *i37; this->m38 = *i38; this->m39 = *i39; this->m40 = *i40; this->m41 = *i41; this->m42 = *i42; this->m43 = *i43; this->m44 = *i44; this->m45 = *i45; this->m46 = *i46; this->m47 = *i47;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; } typename add_reference<T33>::type at_impl(mpl::int_<33>) { return this->m33; } typename add_reference<typename add_const<T33>::type>::type at_impl(mpl::int_<33>) const { return this->m33; } typename add_reference<T34>::type at_impl(mpl::int_<34>) { return this->m34; } typename add_reference<typename add_const<T34>::type>::type at_impl(mpl::int_<34>) const { return this->m34; } typename add_reference<T35>::type at_impl(mpl::int_<35>) { return this->m35; } typename add_reference<typename add_const<T35>::type>::type at_impl(mpl::int_<35>) const { return this->m35; } typename add_reference<T36>::type at_impl(mpl::int_<36>) { return this->m36; } typename add_reference<typename add_const<T36>::type>::type at_impl(mpl::int_<36>) const { return this->m36; } typename add_reference<T37>::type at_impl(mpl::int_<37>) { return this->m37; } typename add_reference<typename add_const<T37>::type>::type at_impl(mpl::int_<37>) const { return this->m37; } typename add_reference<T38>::type at_impl(mpl::int_<38>) { return this->m38; } typename add_reference<typename add_const<T38>::type>::type at_impl(mpl::int_<38>) const { return this->m38; } typename add_reference<T39>::type at_impl(mpl::int_<39>) { return this->m39; } typename add_reference<typename add_const<T39>::type>::type at_impl(mpl::int_<39>) const { return this->m39; } typename add_reference<T40>::type at_impl(mpl::int_<40>) { return this->m40; } typename add_reference<typename add_const<T40>::type>::type at_impl(mpl::int_<40>) const { return this->m40; } typename add_reference<T41>::type at_impl(mpl::int_<41>) { return this->m41; } typename add_reference<typename add_const<T41>::type>::type at_impl(mpl::int_<41>) const { return this->m41; } typename add_reference<T42>::type at_impl(mpl::int_<42>) { return this->m42; } typename add_reference<typename add_const<T42>::type>::type at_impl(mpl::int_<42>) const { return this->m42; } typename add_reference<T43>::type at_impl(mpl::int_<43>) { return this->m43; } typename add_reference<typename add_const<T43>::type>::type at_impl(mpl::int_<43>) const { return this->m43; } typename add_reference<T44>::type at_impl(mpl::int_<44>) { return this->m44; } typename add_reference<typename add_const<T44>::type>::type at_impl(mpl::int_<44>) const { return this->m44; } typename add_reference<T45>::type at_impl(mpl::int_<45>) { return this->m45; } typename add_reference<typename add_const<T45>::type>::type at_impl(mpl::int_<45>) const { return this->m45; } typename add_reference<T46>::type at_impl(mpl::int_<46>) { return this->m46; } typename add_reference<typename add_const<T46>::type>::type at_impl(mpl::int_<46>) const { return this->m46; } typename add_reference<T47>::type at_impl(mpl::int_<47>) { return this->m47; } typename add_reference<typename add_const<T47>::type>::type at_impl(mpl::int_<47>) const { return this->m47; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , typename T46 , typename T47 , typename T48>
    struct vector_data49
    {
        vector_data49()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() , m33() , m34() , m35() , m36() , m37() , m38() , m39() , m40() , m41() , m42() , m43() , m44() , m45() , m46() , m47() , m48() {}
        vector_data49(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41 , typename detail::call_param<T42 >::type _42 , typename detail::call_param<T43 >::type _43 , typename detail::call_param<T44 >::type _44 , typename detail::call_param<T45 >::type _45 , typename detail::call_param<T46 >::type _46 , typename detail::call_param<T47 >::type _47 , typename detail::call_param<T48 >::type _48)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) , m33(_33) , m34(_34) , m35(_35) , m36(_36) , m37(_37) , m38(_38) , m39(_39) , m40(_40) , m41(_41) , m42(_42) , m43(_43) , m44(_44) , m45(_45) , m46(_46) , m47(_47) , m48(_48) {}
        vector_data49(
            vector_data49 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) , m33(other.m33) , m34(other.m34) , m35(other.m35) , m36(other.m36) , m37(other.m37) , m38(other.m38) , m39(other.m39) , m40(other.m40) , m41(other.m41) , m42(other.m42) , m43(other.m43) , m44(other.m44) , m45(other.m45) , m46(other.m46) , m47(other.m47) , m48(other.m48) {}
        vector_data49&
        operator=(vector_data49 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41; this->m42 = vec.m42; this->m43 = vec.m43; this->m44 = vec.m44; this->m45 = vec.m45; this->m46 = vec.m46; this->m47 = vec.m47; this->m48 = vec.m48;
            return *this;
        }
        template <typename Sequence>
        static vector_data49
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40); typedef typename result_of::next< I41>::type I42; I42 i42 = fusion::next(i41); typedef typename result_of::next< I42>::type I43; I43 i43 = fusion::next(i42); typedef typename result_of::next< I43>::type I44; I44 i44 = fusion::next(i43); typedef typename result_of::next< I44>::type I45; I45 i45 = fusion::next(i44); typedef typename result_of::next< I45>::type I46; I46 i46 = fusion::next(i45); typedef typename result_of::next< I46>::type I47; I47 i47 = fusion::next(i46); typedef typename result_of::next< I47>::type I48; I48 i48 = fusion::next(i47);
            return vector_data49( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32 , *i33 , *i34 , *i35 , *i36 , *i37 , *i38 , *i39 , *i40 , *i41 , *i42 , *i43 , *i44 , *i45 , *i46 , *i47 , *i48);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32; T33 m33; T34 m34; T35 m35; T36 m36; T37 m37; T38 m38; T39 m39; T40 m40; T41 m41; T42 m42; T43 m43; T44 m44; T45 m45; T46 m46; T47 m47; T48 m48;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , typename T46 , typename T47 , typename T48>
    struct vector49
      : vector_data49< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47 , T48>
      , sequence_base<vector49< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47 , T48> >
    {
        typedef vector49< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47 , T48> this_type;
        typedef vector_data49< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47 , T48> base_type;
        typedef mpl::vector49< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47 , T48> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<49> size;
        vector49() {}
        vector49(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41 , typename detail::call_param<T42 >::type _42 , typename detail::call_param<T43 >::type _43 , typename detail::call_param<T44 >::type _44 , typename detail::call_param<T45 >::type _45 , typename detail::call_param<T46 >::type _46 , typename detail::call_param<T47 >::type _47 , typename detail::call_param<T48 >::type _48)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32 , _33 , _34 , _35 , _36 , _37 , _38 , _39 , _40 , _41 , _42 , _43 , _44 , _45 , _46 , _47 , _48) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41 , typename U42 , typename U43 , typename U44 , typename U45 , typename U46 , typename U47 , typename U48>
        vector49(
            vector49< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41 , U42 , U43 , U44 , U45 , U46 , U47 , U48> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32 , vec.m33 , vec.m34 , vec.m35 , vec.m36 , vec.m37 , vec.m38 , vec.m39 , vec.m40 , vec.m41 , vec.m42 , vec.m43 , vec.m44 , vec.m45 , vec.m46 , vec.m47 , vec.m48) {}
        template <typename Sequence>
        vector49(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41 , typename U42 , typename U43 , typename U44 , typename U45 , typename U46 , typename U47 , typename U48>
        vector49&
        operator=(vector49< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41 , U42 , U43 , U44 , U45 , U46 , U47 , U48> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41; this->m42 = vec.m42; this->m43 = vec.m43; this->m44 = vec.m44; this->m45 = vec.m45; this->m46 = vec.m46; this->m47 = vec.m47; this->m48 = vec.m48;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40); typedef typename result_of::next< I41>::type I42; I42 i42 = fusion::next(i41); typedef typename result_of::next< I42>::type I43; I43 i43 = fusion::next(i42); typedef typename result_of::next< I43>::type I44; I44 i44 = fusion::next(i43); typedef typename result_of::next< I44>::type I45; I45 i45 = fusion::next(i44); typedef typename result_of::next< I45>::type I46; I46 i46 = fusion::next(i45); typedef typename result_of::next< I46>::type I47; I47 i47 = fusion::next(i46); typedef typename result_of::next< I47>::type I48; I48 i48 = fusion::next(i47);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32; this->m33 = *i33; this->m34 = *i34; this->m35 = *i35; this->m36 = *i36; this->m37 = *i37; this->m38 = *i38; this->m39 = *i39; this->m40 = *i40; this->m41 = *i41; this->m42 = *i42; this->m43 = *i43; this->m44 = *i44; this->m45 = *i45; this->m46 = *i46; this->m47 = *i47; this->m48 = *i48;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; } typename add_reference<T33>::type at_impl(mpl::int_<33>) { return this->m33; } typename add_reference<typename add_const<T33>::type>::type at_impl(mpl::int_<33>) const { return this->m33; } typename add_reference<T34>::type at_impl(mpl::int_<34>) { return this->m34; } typename add_reference<typename add_const<T34>::type>::type at_impl(mpl::int_<34>) const { return this->m34; } typename add_reference<T35>::type at_impl(mpl::int_<35>) { return this->m35; } typename add_reference<typename add_const<T35>::type>::type at_impl(mpl::int_<35>) const { return this->m35; } typename add_reference<T36>::type at_impl(mpl::int_<36>) { return this->m36; } typename add_reference<typename add_const<T36>::type>::type at_impl(mpl::int_<36>) const { return this->m36; } typename add_reference<T37>::type at_impl(mpl::int_<37>) { return this->m37; } typename add_reference<typename add_const<T37>::type>::type at_impl(mpl::int_<37>) const { return this->m37; } typename add_reference<T38>::type at_impl(mpl::int_<38>) { return this->m38; } typename add_reference<typename add_const<T38>::type>::type at_impl(mpl::int_<38>) const { return this->m38; } typename add_reference<T39>::type at_impl(mpl::int_<39>) { return this->m39; } typename add_reference<typename add_const<T39>::type>::type at_impl(mpl::int_<39>) const { return this->m39; } typename add_reference<T40>::type at_impl(mpl::int_<40>) { return this->m40; } typename add_reference<typename add_const<T40>::type>::type at_impl(mpl::int_<40>) const { return this->m40; } typename add_reference<T41>::type at_impl(mpl::int_<41>) { return this->m41; } typename add_reference<typename add_const<T41>::type>::type at_impl(mpl::int_<41>) const { return this->m41; } typename add_reference<T42>::type at_impl(mpl::int_<42>) { return this->m42; } typename add_reference<typename add_const<T42>::type>::type at_impl(mpl::int_<42>) const { return this->m42; } typename add_reference<T43>::type at_impl(mpl::int_<43>) { return this->m43; } typename add_reference<typename add_const<T43>::type>::type at_impl(mpl::int_<43>) const { return this->m43; } typename add_reference<T44>::type at_impl(mpl::int_<44>) { return this->m44; } typename add_reference<typename add_const<T44>::type>::type at_impl(mpl::int_<44>) const { return this->m44; } typename add_reference<T45>::type at_impl(mpl::int_<45>) { return this->m45; } typename add_reference<typename add_const<T45>::type>::type at_impl(mpl::int_<45>) const { return this->m45; } typename add_reference<T46>::type at_impl(mpl::int_<46>) { return this->m46; } typename add_reference<typename add_const<T46>::type>::type at_impl(mpl::int_<46>) const { return this->m46; } typename add_reference<T47>::type at_impl(mpl::int_<47>) { return this->m47; } typename add_reference<typename add_const<T47>::type>::type at_impl(mpl::int_<47>) const { return this->m47; } typename add_reference<T48>::type at_impl(mpl::int_<48>) { return this->m48; } typename add_reference<typename add_const<T48>::type>::type at_impl(mpl::int_<48>) const { return this->m48; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , typename T46 , typename T47 , typename T48 , typename T49>
    struct vector_data50
    {
        vector_data50()
            : m0() , m1() , m2() , m3() , m4() , m5() , m6() , m7() , m8() , m9() , m10() , m11() , m12() , m13() , m14() , m15() , m16() , m17() , m18() , m19() , m20() , m21() , m22() , m23() , m24() , m25() , m26() , m27() , m28() , m29() , m30() , m31() , m32() , m33() , m34() , m35() , m36() , m37() , m38() , m39() , m40() , m41() , m42() , m43() , m44() , m45() , m46() , m47() , m48() , m49() {}
        vector_data50(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41 , typename detail::call_param<T42 >::type _42 , typename detail::call_param<T43 >::type _43 , typename detail::call_param<T44 >::type _44 , typename detail::call_param<T45 >::type _45 , typename detail::call_param<T46 >::type _46 , typename detail::call_param<T47 >::type _47 , typename detail::call_param<T48 >::type _48 , typename detail::call_param<T49 >::type _49)
            : m0(_0) , m1(_1) , m2(_2) , m3(_3) , m4(_4) , m5(_5) , m6(_6) , m7(_7) , m8(_8) , m9(_9) , m10(_10) , m11(_11) , m12(_12) , m13(_13) , m14(_14) , m15(_15) , m16(_16) , m17(_17) , m18(_18) , m19(_19) , m20(_20) , m21(_21) , m22(_22) , m23(_23) , m24(_24) , m25(_25) , m26(_26) , m27(_27) , m28(_28) , m29(_29) , m30(_30) , m31(_31) , m32(_32) , m33(_33) , m34(_34) , m35(_35) , m36(_36) , m37(_37) , m38(_38) , m39(_39) , m40(_40) , m41(_41) , m42(_42) , m43(_43) , m44(_44) , m45(_45) , m46(_46) , m47(_47) , m48(_48) , m49(_49) {}
        vector_data50(
            vector_data50 const& other)
            : m0(other.m0) , m1(other.m1) , m2(other.m2) , m3(other.m3) , m4(other.m4) , m5(other.m5) , m6(other.m6) , m7(other.m7) , m8(other.m8) , m9(other.m9) , m10(other.m10) , m11(other.m11) , m12(other.m12) , m13(other.m13) , m14(other.m14) , m15(other.m15) , m16(other.m16) , m17(other.m17) , m18(other.m18) , m19(other.m19) , m20(other.m20) , m21(other.m21) , m22(other.m22) , m23(other.m23) , m24(other.m24) , m25(other.m25) , m26(other.m26) , m27(other.m27) , m28(other.m28) , m29(other.m29) , m30(other.m30) , m31(other.m31) , m32(other.m32) , m33(other.m33) , m34(other.m34) , m35(other.m35) , m36(other.m36) , m37(other.m37) , m38(other.m38) , m39(other.m39) , m40(other.m40) , m41(other.m41) , m42(other.m42) , m43(other.m43) , m44(other.m44) , m45(other.m45) , m46(other.m46) , m47(other.m47) , m48(other.m48) , m49(other.m49) {}
        vector_data50&
        operator=(vector_data50 const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41; this->m42 = vec.m42; this->m43 = vec.m43; this->m44 = vec.m44; this->m45 = vec.m45; this->m46 = vec.m46; this->m47 = vec.m47; this->m48 = vec.m48; this->m49 = vec.m49;
            return *this;
        }
        template <typename Sequence>
        static vector_data50
        init_from_sequence(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40); typedef typename result_of::next< I41>::type I42; I42 i42 = fusion::next(i41); typedef typename result_of::next< I42>::type I43; I43 i43 = fusion::next(i42); typedef typename result_of::next< I43>::type I44; I44 i44 = fusion::next(i43); typedef typename result_of::next< I44>::type I45; I45 i45 = fusion::next(i44); typedef typename result_of::next< I45>::type I46; I46 i46 = fusion::next(i45); typedef typename result_of::next< I46>::type I47; I47 i47 = fusion::next(i46); typedef typename result_of::next< I47>::type I48; I48 i48 = fusion::next(i47); typedef typename result_of::next< I48>::type I49; I49 i49 = fusion::next(i48);
            return vector_data50( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9 , *i10 , *i11 , *i12 , *i13 , *i14 , *i15 , *i16 , *i17 , *i18 , *i19 , *i20 , *i21 , *i22 , *i23 , *i24 , *i25 , *i26 , *i27 , *i28 , *i29 , *i30 , *i31 , *i32 , *i33 , *i34 , *i35 , *i36 , *i37 , *i38 , *i39 , *i40 , *i41 , *i42 , *i43 , *i44 , *i45 , *i46 , *i47 , *i48 , *i49);
        }
        T0 m0; T1 m1; T2 m2; T3 m3; T4 m4; T5 m5; T6 m6; T7 m7; T8 m8; T9 m9; T10 m10; T11 m11; T12 m12; T13 m13; T14 m14; T15 m15; T16 m16; T17 m17; T18 m18; T19 m19; T20 m20; T21 m21; T22 m22; T23 m23; T24 m24; T25 m25; T26 m26; T27 m27; T28 m28; T29 m29; T30 m30; T31 m31; T32 m32; T33 m33; T34 m34; T35 m35; T36 m36; T37 m37; T38 m38; T39 m39; T40 m40; T41 m41; T42 m42; T43 m43; T44 m44; T45 m45; T46 m46; T47 m47; T48 m48; T49 m49;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename T10 , typename T11 , typename T12 , typename T13 , typename T14 , typename T15 , typename T16 , typename T17 , typename T18 , typename T19 , typename T20 , typename T21 , typename T22 , typename T23 , typename T24 , typename T25 , typename T26 , typename T27 , typename T28 , typename T29 , typename T30 , typename T31 , typename T32 , typename T33 , typename T34 , typename T35 , typename T36 , typename T37 , typename T38 , typename T39 , typename T40 , typename T41 , typename T42 , typename T43 , typename T44 , typename T45 , typename T46 , typename T47 , typename T48 , typename T49>
    struct vector50
      : vector_data50< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47 , T48 , T49>
      , sequence_base<vector50< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47 , T48 , T49> >
    {
        typedef vector50< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47 , T48 , T49> this_type;
        typedef vector_data50< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47 , T48 , T49> base_type;
        typedef mpl::vector50< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9 , T10 , T11 , T12 , T13 , T14 , T15 , T16 , T17 , T18 , T19 , T20 , T21 , T22 , T23 , T24 , T25 , T26 , T27 , T28 , T29 , T30 , T31 , T32 , T33 , T34 , T35 , T36 , T37 , T38 , T39 , T40 , T41 , T42 , T43 , T44 , T45 , T46 , T47 , T48 , T49> types;
        typedef vector_tag fusion_tag;
        typedef fusion_sequence_tag tag;
        typedef mpl::false_ is_view;
        typedef random_access_traversal_tag category;
        typedef mpl::int_<50> size;
        vector50() {}
        vector50(
            typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9 , typename detail::call_param<T10 >::type _10 , typename detail::call_param<T11 >::type _11 , typename detail::call_param<T12 >::type _12 , typename detail::call_param<T13 >::type _13 , typename detail::call_param<T14 >::type _14 , typename detail::call_param<T15 >::type _15 , typename detail::call_param<T16 >::type _16 , typename detail::call_param<T17 >::type _17 , typename detail::call_param<T18 >::type _18 , typename detail::call_param<T19 >::type _19 , typename detail::call_param<T20 >::type _20 , typename detail::call_param<T21 >::type _21 , typename detail::call_param<T22 >::type _22 , typename detail::call_param<T23 >::type _23 , typename detail::call_param<T24 >::type _24 , typename detail::call_param<T25 >::type _25 , typename detail::call_param<T26 >::type _26 , typename detail::call_param<T27 >::type _27 , typename detail::call_param<T28 >::type _28 , typename detail::call_param<T29 >::type _29 , typename detail::call_param<T30 >::type _30 , typename detail::call_param<T31 >::type _31 , typename detail::call_param<T32 >::type _32 , typename detail::call_param<T33 >::type _33 , typename detail::call_param<T34 >::type _34 , typename detail::call_param<T35 >::type _35 , typename detail::call_param<T36 >::type _36 , typename detail::call_param<T37 >::type _37 , typename detail::call_param<T38 >::type _38 , typename detail::call_param<T39 >::type _39 , typename detail::call_param<T40 >::type _40 , typename detail::call_param<T41 >::type _41 , typename detail::call_param<T42 >::type _42 , typename detail::call_param<T43 >::type _43 , typename detail::call_param<T44 >::type _44 , typename detail::call_param<T45 >::type _45 , typename detail::call_param<T46 >::type _46 , typename detail::call_param<T47 >::type _47 , typename detail::call_param<T48 >::type _48 , typename detail::call_param<T49 >::type _49)
            : base_type( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9 , _10 , _11 , _12 , _13 , _14 , _15 , _16 , _17 , _18 , _19 , _20 , _21 , _22 , _23 , _24 , _25 , _26 , _27 , _28 , _29 , _30 , _31 , _32 , _33 , _34 , _35 , _36 , _37 , _38 , _39 , _40 , _41 , _42 , _43 , _44 , _45 , _46 , _47 , _48 , _49) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41 , typename U42 , typename U43 , typename U44 , typename U45 , typename U46 , typename U47 , typename U48 , typename U49>
        vector50(
            vector50< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41 , U42 , U43 , U44 , U45 , U46 , U47 , U48 , U49> const& vec)
            : base_type( vec.m0 , vec.m1 , vec.m2 , vec.m3 , vec.m4 , vec.m5 , vec.m6 , vec.m7 , vec.m8 , vec.m9 , vec.m10 , vec.m11 , vec.m12 , vec.m13 , vec.m14 , vec.m15 , vec.m16 , vec.m17 , vec.m18 , vec.m19 , vec.m20 , vec.m21 , vec.m22 , vec.m23 , vec.m24 , vec.m25 , vec.m26 , vec.m27 , vec.m28 , vec.m29 , vec.m30 , vec.m31 , vec.m32 , vec.m33 , vec.m34 , vec.m35 , vec.m36 , vec.m37 , vec.m38 , vec.m39 , vec.m40 , vec.m41 , vec.m42 , vec.m43 , vec.m44 , vec.m45 , vec.m46 , vec.m47 , vec.m48 , vec.m49) {}
        template <typename Sequence>
        vector50(
            Sequence const& seq
            )
            : base_type(base_type::init_from_sequence(seq)) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 , typename U10 , typename U11 , typename U12 , typename U13 , typename U14 , typename U15 , typename U16 , typename U17 , typename U18 , typename U19 , typename U20 , typename U21 , typename U22 , typename U23 , typename U24 , typename U25 , typename U26 , typename U27 , typename U28 , typename U29 , typename U30 , typename U31 , typename U32 , typename U33 , typename U34 , typename U35 , typename U36 , typename U37 , typename U38 , typename U39 , typename U40 , typename U41 , typename U42 , typename U43 , typename U44 , typename U45 , typename U46 , typename U47 , typename U48 , typename U49>
        vector50&
        operator=(vector50< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9 , U10 , U11 , U12 , U13 , U14 , U15 , U16 , U17 , U18 , U19 , U20 , U21 , U22 , U23 , U24 , U25 , U26 , U27 , U28 , U29 , U30 , U31 , U32 , U33 , U34 , U35 , U36 , U37 , U38 , U39 , U40 , U41 , U42 , U43 , U44 , U45 , U46 , U47 , U48 , U49> const& vec)
        {
            this->m0 = vec.m0; this->m1 = vec.m1; this->m2 = vec.m2; this->m3 = vec.m3; this->m4 = vec.m4; this->m5 = vec.m5; this->m6 = vec.m6; this->m7 = vec.m7; this->m8 = vec.m8; this->m9 = vec.m9; this->m10 = vec.m10; this->m11 = vec.m11; this->m12 = vec.m12; this->m13 = vec.m13; this->m14 = vec.m14; this->m15 = vec.m15; this->m16 = vec.m16; this->m17 = vec.m17; this->m18 = vec.m18; this->m19 = vec.m19; this->m20 = vec.m20; this->m21 = vec.m21; this->m22 = vec.m22; this->m23 = vec.m23; this->m24 = vec.m24; this->m25 = vec.m25; this->m26 = vec.m26; this->m27 = vec.m27; this->m28 = vec.m28; this->m29 = vec.m29; this->m30 = vec.m30; this->m31 = vec.m31; this->m32 = vec.m32; this->m33 = vec.m33; this->m34 = vec.m34; this->m35 = vec.m35; this->m36 = vec.m36; this->m37 = vec.m37; this->m38 = vec.m38; this->m39 = vec.m39; this->m40 = vec.m40; this->m41 = vec.m41; this->m42 = vec.m42; this->m43 = vec.m43; this->m44 = vec.m44; this->m45 = vec.m45; this->m46 = vec.m46; this->m47 = vec.m47; this->m48 = vec.m48; this->m49 = vec.m49;
            return *this;
        }
        template <typename Sequence>
        typename disable_if<is_convertible<Sequence, T0>, this_type&>::type
        operator=(Sequence const& seq)
        {
            typedef typename result_of::begin<Sequence const>::type I0;
            I0 i0 = fusion::begin(seq);
            typedef typename result_of::next< I0>::type I1; I1 i1 = fusion::next(i0); typedef typename result_of::next< I1>::type I2; I2 i2 = fusion::next(i1); typedef typename result_of::next< I2>::type I3; I3 i3 = fusion::next(i2); typedef typename result_of::next< I3>::type I4; I4 i4 = fusion::next(i3); typedef typename result_of::next< I4>::type I5; I5 i5 = fusion::next(i4); typedef typename result_of::next< I5>::type I6; I6 i6 = fusion::next(i5); typedef typename result_of::next< I6>::type I7; I7 i7 = fusion::next(i6); typedef typename result_of::next< I7>::type I8; I8 i8 = fusion::next(i7); typedef typename result_of::next< I8>::type I9; I9 i9 = fusion::next(i8); typedef typename result_of::next< I9>::type I10; I10 i10 = fusion::next(i9); typedef typename result_of::next< I10>::type I11; I11 i11 = fusion::next(i10); typedef typename result_of::next< I11>::type I12; I12 i12 = fusion::next(i11); typedef typename result_of::next< I12>::type I13; I13 i13 = fusion::next(i12); typedef typename result_of::next< I13>::type I14; I14 i14 = fusion::next(i13); typedef typename result_of::next< I14>::type I15; I15 i15 = fusion::next(i14); typedef typename result_of::next< I15>::type I16; I16 i16 = fusion::next(i15); typedef typename result_of::next< I16>::type I17; I17 i17 = fusion::next(i16); typedef typename result_of::next< I17>::type I18; I18 i18 = fusion::next(i17); typedef typename result_of::next< I18>::type I19; I19 i19 = fusion::next(i18); typedef typename result_of::next< I19>::type I20; I20 i20 = fusion::next(i19); typedef typename result_of::next< I20>::type I21; I21 i21 = fusion::next(i20); typedef typename result_of::next< I21>::type I22; I22 i22 = fusion::next(i21); typedef typename result_of::next< I22>::type I23; I23 i23 = fusion::next(i22); typedef typename result_of::next< I23>::type I24; I24 i24 = fusion::next(i23); typedef typename result_of::next< I24>::type I25; I25 i25 = fusion::next(i24); typedef typename result_of::next< I25>::type I26; I26 i26 = fusion::next(i25); typedef typename result_of::next< I26>::type I27; I27 i27 = fusion::next(i26); typedef typename result_of::next< I27>::type I28; I28 i28 = fusion::next(i27); typedef typename result_of::next< I28>::type I29; I29 i29 = fusion::next(i28); typedef typename result_of::next< I29>::type I30; I30 i30 = fusion::next(i29); typedef typename result_of::next< I30>::type I31; I31 i31 = fusion::next(i30); typedef typename result_of::next< I31>::type I32; I32 i32 = fusion::next(i31); typedef typename result_of::next< I32>::type I33; I33 i33 = fusion::next(i32); typedef typename result_of::next< I33>::type I34; I34 i34 = fusion::next(i33); typedef typename result_of::next< I34>::type I35; I35 i35 = fusion::next(i34); typedef typename result_of::next< I35>::type I36; I36 i36 = fusion::next(i35); typedef typename result_of::next< I36>::type I37; I37 i37 = fusion::next(i36); typedef typename result_of::next< I37>::type I38; I38 i38 = fusion::next(i37); typedef typename result_of::next< I38>::type I39; I39 i39 = fusion::next(i38); typedef typename result_of::next< I39>::type I40; I40 i40 = fusion::next(i39); typedef typename result_of::next< I40>::type I41; I41 i41 = fusion::next(i40); typedef typename result_of::next< I41>::type I42; I42 i42 = fusion::next(i41); typedef typename result_of::next< I42>::type I43; I43 i43 = fusion::next(i42); typedef typename result_of::next< I43>::type I44; I44 i44 = fusion::next(i43); typedef typename result_of::next< I44>::type I45; I45 i45 = fusion::next(i44); typedef typename result_of::next< I45>::type I46; I46 i46 = fusion::next(i45); typedef typename result_of::next< I46>::type I47; I47 i47 = fusion::next(i46); typedef typename result_of::next< I47>::type I48; I48 i48 = fusion::next(i47); typedef typename result_of::next< I48>::type I49; I49 i49 = fusion::next(i48);
            this->m0 = *i0; this->m1 = *i1; this->m2 = *i2; this->m3 = *i3; this->m4 = *i4; this->m5 = *i5; this->m6 = *i6; this->m7 = *i7; this->m8 = *i8; this->m9 = *i9; this->m10 = *i10; this->m11 = *i11; this->m12 = *i12; this->m13 = *i13; this->m14 = *i14; this->m15 = *i15; this->m16 = *i16; this->m17 = *i17; this->m18 = *i18; this->m19 = *i19; this->m20 = *i20; this->m21 = *i21; this->m22 = *i22; this->m23 = *i23; this->m24 = *i24; this->m25 = *i25; this->m26 = *i26; this->m27 = *i27; this->m28 = *i28; this->m29 = *i29; this->m30 = *i30; this->m31 = *i31; this->m32 = *i32; this->m33 = *i33; this->m34 = *i34; this->m35 = *i35; this->m36 = *i36; this->m37 = *i37; this->m38 = *i38; this->m39 = *i39; this->m40 = *i40; this->m41 = *i41; this->m42 = *i42; this->m43 = *i43; this->m44 = *i44; this->m45 = *i45; this->m46 = *i46; this->m47 = *i47; this->m48 = *i48; this->m49 = *i49;
            return *this;
        }
        typename add_reference<T0>::type at_impl(mpl::int_<0>) { return this->m0; } typename add_reference<typename add_const<T0>::type>::type at_impl(mpl::int_<0>) const { return this->m0; } typename add_reference<T1>::type at_impl(mpl::int_<1>) { return this->m1; } typename add_reference<typename add_const<T1>::type>::type at_impl(mpl::int_<1>) const { return this->m1; } typename add_reference<T2>::type at_impl(mpl::int_<2>) { return this->m2; } typename add_reference<typename add_const<T2>::type>::type at_impl(mpl::int_<2>) const { return this->m2; } typename add_reference<T3>::type at_impl(mpl::int_<3>) { return this->m3; } typename add_reference<typename add_const<T3>::type>::type at_impl(mpl::int_<3>) const { return this->m3; } typename add_reference<T4>::type at_impl(mpl::int_<4>) { return this->m4; } typename add_reference<typename add_const<T4>::type>::type at_impl(mpl::int_<4>) const { return this->m4; } typename add_reference<T5>::type at_impl(mpl::int_<5>) { return this->m5; } typename add_reference<typename add_const<T5>::type>::type at_impl(mpl::int_<5>) const { return this->m5; } typename add_reference<T6>::type at_impl(mpl::int_<6>) { return this->m6; } typename add_reference<typename add_const<T6>::type>::type at_impl(mpl::int_<6>) const { return this->m6; } typename add_reference<T7>::type at_impl(mpl::int_<7>) { return this->m7; } typename add_reference<typename add_const<T7>::type>::type at_impl(mpl::int_<7>) const { return this->m7; } typename add_reference<T8>::type at_impl(mpl::int_<8>) { return this->m8; } typename add_reference<typename add_const<T8>::type>::type at_impl(mpl::int_<8>) const { return this->m8; } typename add_reference<T9>::type at_impl(mpl::int_<9>) { return this->m9; } typename add_reference<typename add_const<T9>::type>::type at_impl(mpl::int_<9>) const { return this->m9; } typename add_reference<T10>::type at_impl(mpl::int_<10>) { return this->m10; } typename add_reference<typename add_const<T10>::type>::type at_impl(mpl::int_<10>) const { return this->m10; } typename add_reference<T11>::type at_impl(mpl::int_<11>) { return this->m11; } typename add_reference<typename add_const<T11>::type>::type at_impl(mpl::int_<11>) const { return this->m11; } typename add_reference<T12>::type at_impl(mpl::int_<12>) { return this->m12; } typename add_reference<typename add_const<T12>::type>::type at_impl(mpl::int_<12>) const { return this->m12; } typename add_reference<T13>::type at_impl(mpl::int_<13>) { return this->m13; } typename add_reference<typename add_const<T13>::type>::type at_impl(mpl::int_<13>) const { return this->m13; } typename add_reference<T14>::type at_impl(mpl::int_<14>) { return this->m14; } typename add_reference<typename add_const<T14>::type>::type at_impl(mpl::int_<14>) const { return this->m14; } typename add_reference<T15>::type at_impl(mpl::int_<15>) { return this->m15; } typename add_reference<typename add_const<T15>::type>::type at_impl(mpl::int_<15>) const { return this->m15; } typename add_reference<T16>::type at_impl(mpl::int_<16>) { return this->m16; } typename add_reference<typename add_const<T16>::type>::type at_impl(mpl::int_<16>) const { return this->m16; } typename add_reference<T17>::type at_impl(mpl::int_<17>) { return this->m17; } typename add_reference<typename add_const<T17>::type>::type at_impl(mpl::int_<17>) const { return this->m17; } typename add_reference<T18>::type at_impl(mpl::int_<18>) { return this->m18; } typename add_reference<typename add_const<T18>::type>::type at_impl(mpl::int_<18>) const { return this->m18; } typename add_reference<T19>::type at_impl(mpl::int_<19>) { return this->m19; } typename add_reference<typename add_const<T19>::type>::type at_impl(mpl::int_<19>) const { return this->m19; } typename add_reference<T20>::type at_impl(mpl::int_<20>) { return this->m20; } typename add_reference<typename add_const<T20>::type>::type at_impl(mpl::int_<20>) const { return this->m20; } typename add_reference<T21>::type at_impl(mpl::int_<21>) { return this->m21; } typename add_reference<typename add_const<T21>::type>::type at_impl(mpl::int_<21>) const { return this->m21; } typename add_reference<T22>::type at_impl(mpl::int_<22>) { return this->m22; } typename add_reference<typename add_const<T22>::type>::type at_impl(mpl::int_<22>) const { return this->m22; } typename add_reference<T23>::type at_impl(mpl::int_<23>) { return this->m23; } typename add_reference<typename add_const<T23>::type>::type at_impl(mpl::int_<23>) const { return this->m23; } typename add_reference<T24>::type at_impl(mpl::int_<24>) { return this->m24; } typename add_reference<typename add_const<T24>::type>::type at_impl(mpl::int_<24>) const { return this->m24; } typename add_reference<T25>::type at_impl(mpl::int_<25>) { return this->m25; } typename add_reference<typename add_const<T25>::type>::type at_impl(mpl::int_<25>) const { return this->m25; } typename add_reference<T26>::type at_impl(mpl::int_<26>) { return this->m26; } typename add_reference<typename add_const<T26>::type>::type at_impl(mpl::int_<26>) const { return this->m26; } typename add_reference<T27>::type at_impl(mpl::int_<27>) { return this->m27; } typename add_reference<typename add_const<T27>::type>::type at_impl(mpl::int_<27>) const { return this->m27; } typename add_reference<T28>::type at_impl(mpl::int_<28>) { return this->m28; } typename add_reference<typename add_const<T28>::type>::type at_impl(mpl::int_<28>) const { return this->m28; } typename add_reference<T29>::type at_impl(mpl::int_<29>) { return this->m29; } typename add_reference<typename add_const<T29>::type>::type at_impl(mpl::int_<29>) const { return this->m29; } typename add_reference<T30>::type at_impl(mpl::int_<30>) { return this->m30; } typename add_reference<typename add_const<T30>::type>::type at_impl(mpl::int_<30>) const { return this->m30; } typename add_reference<T31>::type at_impl(mpl::int_<31>) { return this->m31; } typename add_reference<typename add_const<T31>::type>::type at_impl(mpl::int_<31>) const { return this->m31; } typename add_reference<T32>::type at_impl(mpl::int_<32>) { return this->m32; } typename add_reference<typename add_const<T32>::type>::type at_impl(mpl::int_<32>) const { return this->m32; } typename add_reference<T33>::type at_impl(mpl::int_<33>) { return this->m33; } typename add_reference<typename add_const<T33>::type>::type at_impl(mpl::int_<33>) const { return this->m33; } typename add_reference<T34>::type at_impl(mpl::int_<34>) { return this->m34; } typename add_reference<typename add_const<T34>::type>::type at_impl(mpl::int_<34>) const { return this->m34; } typename add_reference<T35>::type at_impl(mpl::int_<35>) { return this->m35; } typename add_reference<typename add_const<T35>::type>::type at_impl(mpl::int_<35>) const { return this->m35; } typename add_reference<T36>::type at_impl(mpl::int_<36>) { return this->m36; } typename add_reference<typename add_const<T36>::type>::type at_impl(mpl::int_<36>) const { return this->m36; } typename add_reference<T37>::type at_impl(mpl::int_<37>) { return this->m37; } typename add_reference<typename add_const<T37>::type>::type at_impl(mpl::int_<37>) const { return this->m37; } typename add_reference<T38>::type at_impl(mpl::int_<38>) { return this->m38; } typename add_reference<typename add_const<T38>::type>::type at_impl(mpl::int_<38>) const { return this->m38; } typename add_reference<T39>::type at_impl(mpl::int_<39>) { return this->m39; } typename add_reference<typename add_const<T39>::type>::type at_impl(mpl::int_<39>) const { return this->m39; } typename add_reference<T40>::type at_impl(mpl::int_<40>) { return this->m40; } typename add_reference<typename add_const<T40>::type>::type at_impl(mpl::int_<40>) const { return this->m40; } typename add_reference<T41>::type at_impl(mpl::int_<41>) { return this->m41; } typename add_reference<typename add_const<T41>::type>::type at_impl(mpl::int_<41>) const { return this->m41; } typename add_reference<T42>::type at_impl(mpl::int_<42>) { return this->m42; } typename add_reference<typename add_const<T42>::type>::type at_impl(mpl::int_<42>) const { return this->m42; } typename add_reference<T43>::type at_impl(mpl::int_<43>) { return this->m43; } typename add_reference<typename add_const<T43>::type>::type at_impl(mpl::int_<43>) const { return this->m43; } typename add_reference<T44>::type at_impl(mpl::int_<44>) { return this->m44; } typename add_reference<typename add_const<T44>::type>::type at_impl(mpl::int_<44>) const { return this->m44; } typename add_reference<T45>::type at_impl(mpl::int_<45>) { return this->m45; } typename add_reference<typename add_const<T45>::type>::type at_impl(mpl::int_<45>) const { return this->m45; } typename add_reference<T46>::type at_impl(mpl::int_<46>) { return this->m46; } typename add_reference<typename add_const<T46>::type>::type at_impl(mpl::int_<46>) const { return this->m46; } typename add_reference<T47>::type at_impl(mpl::int_<47>) { return this->m47; } typename add_reference<typename add_const<T47>::type>::type at_impl(mpl::int_<47>) const { return this->m47; } typename add_reference<T48>::type at_impl(mpl::int_<48>) { return this->m48; } typename add_reference<typename add_const<T48>::type>::type at_impl(mpl::int_<48>) const { return this->m48; } typename add_reference<T49>::type at_impl(mpl::int_<49>) { return this->m49; } typename add_reference<typename add_const<T49>::type>::type at_impl(mpl::int_<49>) const { return this->m49; }
        template<typename I>
        typename add_reference<typename mpl::at<types, I>::type>::type
        at_impl(I)
        {
            return this->at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<typename add_const<typename mpl::at<types, I>::type>::type>::type
        at_impl(I) const
        {
            return this->at_impl(mpl::int_<I::value>());
        }
    };
}}
namespace boost { namespace fusion
{
    struct void_;
    template <
        typename T0 = void_ , typename T1 = void_ , typename T2 = void_ , typename T3 = void_ , typename T4 = void_ , typename T5 = void_ , typename T6 = void_ , typename T7 = void_ , typename T8 = void_ , typename T9 = void_
    >
    struct vector;
}}
namespace boost { namespace fusion
{
    struct void_;
}}
namespace boost { namespace fusion { namespace detail
{
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
    struct vector_n_chooser
    {
        typedef vector10< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9> type;
    };
    template <>
    struct vector_n_chooser< void_ , void_ , void_ , void_ , void_ , void_ , void_ , void_ , void_ , void_ >
    {
        typedef vector0<> type;
    };
    template < typename T0>
    struct vector_n_chooser<
        T0
        , void_ , void_ , void_ , void_ , void_ , void_ , void_ , void_ , void_ >
    {
        typedef vector1< T0> type;
    };
    template < typename T0 , typename T1>
    struct vector_n_chooser<
        T0 , T1
        , void_ , void_ , void_ , void_ , void_ , void_ , void_ , void_ >
    {
        typedef vector2< T0 , T1> type;
    };
    template < typename T0 , typename T1 , typename T2>
    struct vector_n_chooser<
        T0 , T1 , T2
        , void_ , void_ , void_ , void_ , void_ , void_ , void_ >
    {
        typedef vector3< T0 , T1 , T2> type;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3>
    struct vector_n_chooser<
        T0 , T1 , T2 , T3
        , void_ , void_ , void_ , void_ , void_ , void_ >
    {
        typedef vector4< T0 , T1 , T2 , T3> type;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
    struct vector_n_chooser<
        T0 , T1 , T2 , T3 , T4
        , void_ , void_ , void_ , void_ , void_ >
    {
        typedef vector5< T0 , T1 , T2 , T3 , T4> type;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
    struct vector_n_chooser<
        T0 , T1 , T2 , T3 , T4 , T5
        , void_ , void_ , void_ , void_ >
    {
        typedef vector6< T0 , T1 , T2 , T3 , T4 , T5> type;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
    struct vector_n_chooser<
        T0 , T1 , T2 , T3 , T4 , T5 , T6
        , void_ , void_ , void_ >
    {
        typedef vector7< T0 , T1 , T2 , T3 , T4 , T5 , T6> type;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
    struct vector_n_chooser<
        T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7
        , void_ , void_ >
    {
        typedef vector8< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7> type;
    };
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
    struct vector_n_chooser<
        T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8
        , void_ >
    {
        typedef vector9< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8> type;
    };
}}}
namespace boost { namespace fusion
{
    struct void_;
    struct fusion_sequence_tag;
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
    struct vector
        : sequence_base<vector< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9> >
    {
    private:
        typedef typename detail::vector_n_chooser<
            T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>::type
        vector_n;
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9>
        friend struct vector;
    public:
        typedef typename vector_n::types types;
        typedef typename vector_n::fusion_tag fusion_tag;
        typedef typename vector_n::tag tag;
        typedef typename vector_n::size size;
        typedef typename vector_n::category category;
        typedef typename vector_n::is_view is_view;
        vector()
            : vec() {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9>
        vector(vector< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9> const& rhs)
            : vec(rhs.vec) {}
        vector(vector const& rhs)
            : vec(rhs.vec) {}
        template <typename Sequence>
        vector(Sequence const& rhs)
            : vec(rhs) {}
    explicit
    vector( typename detail::call_param<T0 >::type _0)
        : vec( _0) {}
    vector( typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1)
        : vec( _0 , _1) {}
    vector( typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2)
        : vec( _0 , _1 , _2) {}
    vector( typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3)
        : vec( _0 , _1 , _2 , _3) {}
    vector( typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4)
        : vec( _0 , _1 , _2 , _3 , _4) {}
    vector( typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5)
        : vec( _0 , _1 , _2 , _3 , _4 , _5) {}
    vector( typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6)
        : vec( _0 , _1 , _2 , _3 , _4 , _5 , _6) {}
    vector( typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7)
        : vec( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7) {}
    vector( typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8)
        : vec( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8) {}
    vector( typename detail::call_param<T0 >::type _0 , typename detail::call_param<T1 >::type _1 , typename detail::call_param<T2 >::type _2 , typename detail::call_param<T3 >::type _3 , typename detail::call_param<T4 >::type _4 , typename detail::call_param<T5 >::type _5 , typename detail::call_param<T6 >::type _6 , typename detail::call_param<T7 >::type _7 , typename detail::call_param<T8 >::type _8 , typename detail::call_param<T9 >::type _9)
        : vec( _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9) {}
        template < typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9>
        vector&
        operator=(vector< U0 , U1 , U2 , U3 , U4 , U5 , U6 , U7 , U8 , U9> const& rhs)
        {
            vec = rhs.vec;
            return *this;
        }
        template <typename T>
        vector&
        operator=(T const& rhs)
        {
            vec = rhs;
            return *this;
        }
        template <int N>
        typename add_reference<
            typename mpl::at_c<types, N>::type
        >::type
        at_impl(mpl::int_<N> index)
        {
            return vec.at_impl(index);
        }
        template <int N>
        typename add_reference<
            typename add_const<
                typename mpl::at_c<types, N>::type
            >::type
        >::type
        at_impl(mpl::int_<N> index) const
        {
            return vec.at_impl(index);
        }
        template <typename I>
        typename add_reference<
            typename mpl::at<types, I>::type
        >::type
        at_impl(I )
        {
            return vec.at_impl(mpl::int_<I::value>());
        }
        template<typename I>
        typename add_reference<
            typename add_const<
                typename mpl::at<types, I>::type
            >::type
        >::type
        at_impl(I ) const
        {
            return vec.at_impl(mpl::int_<I::value>());
        }
    private:
        vector_n vec;
    };
}}
namespace boost { namespace fusion
{
    struct iterator_facade_tag;
    struct boost_array_iterator_tag;
    struct mpl_iterator_tag;
    struct std_pair_iterator_tag;
    namespace extension
    {
        template <typename Tag>
        struct value_of_impl
        {
            template <typename Iterator>
            struct apply {};
        };
        template <>
        struct value_of_impl<iterator_facade_tag>
        {
            template <typename Iterator>
            struct apply : Iterator::template value_of<Iterator> {};
        };
        template <>
        struct value_of_impl<boost_array_iterator_tag>;
        template <>
        struct value_of_impl<mpl_iterator_tag>;
        template <>
        struct value_of_impl<std_pair_iterator_tag>;
    }
    namespace result_of
    {
        template <typename Iterator>
        struct value_of
            : extension::value_of_impl<typename detail::tag_of<Iterator>::type>::
                template apply<Iterator>
        {};
    }
}}
namespace boost { namespace fusion { namespace detail
{
    template <int size>
    struct as_vector;
    template <>
    struct as_vector<0>
    {
        template <typename Iterator>
        struct apply
        {
            typedef vector0<> type;
        };
        template <typename Iterator>
        static typename apply<Iterator>::type
        call(Iterator)
        {
            return vector0<>();
        }
    };
    template <>
    struct as_vector<1>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1;
            typedef typename fusion::result_of::value_of<I0>::type T0;
            typedef vector1< T0> type;
        };
        template <typename Iterator>
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
           
            return result( *i0);
        }
    };
    template <>
    struct as_vector<2>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2;
            typedef typename fusion::result_of::value_of<I0>::type T0; typedef typename fusion::result_of::value_of<I1>::type T1;
            typedef vector2< T0 , T1> type;
        };
        template <typename Iterator>
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0);
            return result( *i0 , *i1);
        }
    };
    template <>
    struct as_vector<3>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3;
            typedef typename fusion::result_of::value_of<I0>::type T0; typedef typename fusion::result_of::value_of<I1>::type T1; typedef typename fusion::result_of::value_of<I2>::type T2;
            typedef vector3< T0 , T1 , T2> type;
        };
        template <typename Iterator>
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1);
            return result( *i0 , *i1 , *i2);
        }
    };
    template <>
    struct as_vector<4>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4;
            typedef typename fusion::result_of::value_of<I0>::type T0; typedef typename fusion::result_of::value_of<I1>::type T1; typedef typename fusion::result_of::value_of<I2>::type T2; typedef typename fusion::result_of::value_of<I3>::type T3;
            typedef vector4< T0 , T1 , T2 , T3> type;
        };
        template <typename Iterator>
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2);
            return result( *i0 , *i1 , *i2 , *i3);
        }
    };
    template <>
    struct as_vector<5>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5;
            typedef typename fusion::result_of::value_of<I0>::type T0; typedef typename fusion::result_of::value_of<I1>::type T1; typedef typename fusion::result_of::value_of<I2>::type T2; typedef typename fusion::result_of::value_of<I3>::type T3; typedef typename fusion::result_of::value_of<I4>::type T4;
            typedef vector5< T0 , T1 , T2 , T3 , T4> type;
        };
        template <typename Iterator>
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3);
            return result( *i0 , *i1 , *i2 , *i3 , *i4);
        }
    };
    template <>
    struct as_vector<6>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6;
            typedef typename fusion::result_of::value_of<I0>::type T0; typedef typename fusion::result_of::value_of<I1>::type T1; typedef typename fusion::result_of::value_of<I2>::type T2; typedef typename fusion::result_of::value_of<I3>::type T3; typedef typename fusion::result_of::value_of<I4>::type T4; typedef typename fusion::result_of::value_of<I5>::type T5;
            typedef vector6< T0 , T1 , T2 , T3 , T4 , T5> type;
        };
        template <typename Iterator>
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4);
            return result( *i0 , *i1 , *i2 , *i3 , *i4 , *i5);
        }
    };
    template <>
    struct as_vector<7>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6; typedef typename fusion::result_of::next<I6>::type I7;
            typedef typename fusion::result_of::value_of<I0>::type T0; typedef typename fusion::result_of::value_of<I1>::type T1; typedef typename fusion::result_of::value_of<I2>::type T2; typedef typename fusion::result_of::value_of<I3>::type T3; typedef typename fusion::result_of::value_of<I4>::type T4; typedef typename fusion::result_of::value_of<I5>::type T5; typedef typename fusion::result_of::value_of<I6>::type T6;
            typedef vector7< T0 , T1 , T2 , T3 , T4 , T5 , T6> type;
        };
        template <typename Iterator>
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5);
            return result( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6);
        }
    };
    template <>
    struct as_vector<8>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6; typedef typename fusion::result_of::next<I6>::type I7; typedef typename fusion::result_of::next<I7>::type I8;
            typedef typename fusion::result_of::value_of<I0>::type T0; typedef typename fusion::result_of::value_of<I1>::type T1; typedef typename fusion::result_of::value_of<I2>::type T2; typedef typename fusion::result_of::value_of<I3>::type T3; typedef typename fusion::result_of::value_of<I4>::type T4; typedef typename fusion::result_of::value_of<I5>::type T5; typedef typename fusion::result_of::value_of<I6>::type T6; typedef typename fusion::result_of::value_of<I7>::type T7;
            typedef vector8< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7> type;
        };
        template <typename Iterator>
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5); typename gen::I7 i7 = fusion::next(i6);
            return result( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7);
        }
    };
    template <>
    struct as_vector<9>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6; typedef typename fusion::result_of::next<I6>::type I7; typedef typename fusion::result_of::next<I7>::type I8; typedef typename fusion::result_of::next<I8>::type I9;
            typedef typename fusion::result_of::value_of<I0>::type T0; typedef typename fusion::result_of::value_of<I1>::type T1; typedef typename fusion::result_of::value_of<I2>::type T2; typedef typename fusion::result_of::value_of<I3>::type T3; typedef typename fusion::result_of::value_of<I4>::type T4; typedef typename fusion::result_of::value_of<I5>::type T5; typedef typename fusion::result_of::value_of<I6>::type T6; typedef typename fusion::result_of::value_of<I7>::type T7; typedef typename fusion::result_of::value_of<I8>::type T8;
            typedef vector9< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8> type;
        };
        template <typename Iterator>
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5); typename gen::I7 i7 = fusion::next(i6); typename gen::I8 i8 = fusion::next(i7);
            return result( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8);
        }
    };
    template <>
    struct as_vector<10>
    {
        template <typename I0>
        struct apply
        {
            typedef typename fusion::result_of::next<I0>::type I1; typedef typename fusion::result_of::next<I1>::type I2; typedef typename fusion::result_of::next<I2>::type I3; typedef typename fusion::result_of::next<I3>::type I4; typedef typename fusion::result_of::next<I4>::type I5; typedef typename fusion::result_of::next<I5>::type I6; typedef typename fusion::result_of::next<I6>::type I7; typedef typename fusion::result_of::next<I7>::type I8; typedef typename fusion::result_of::next<I8>::type I9; typedef typename fusion::result_of::next<I9>::type I10;
            typedef typename fusion::result_of::value_of<I0>::type T0; typedef typename fusion::result_of::value_of<I1>::type T1; typedef typename fusion::result_of::value_of<I2>::type T2; typedef typename fusion::result_of::value_of<I3>::type T3; typedef typename fusion::result_of::value_of<I4>::type T4; typedef typename fusion::result_of::value_of<I5>::type T5; typedef typename fusion::result_of::value_of<I6>::type T6; typedef typename fusion::result_of::value_of<I7>::type T7; typedef typename fusion::result_of::value_of<I8>::type T8; typedef typename fusion::result_of::value_of<I9>::type T9;
            typedef vector10< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9> type;
        };
        template <typename Iterator>
        static typename apply<Iterator>::type
        call(Iterator const& i0)
        {
            typedef apply<Iterator> gen;
            typedef typename gen::type result;
            typename gen::I1 i1 = fusion::next(i0); typename gen::I2 i2 = fusion::next(i1); typename gen::I3 i3 = fusion::next(i2); typename gen::I4 i4 = fusion::next(i3); typename gen::I5 i5 = fusion::next(i4); typename gen::I6 i6 = fusion::next(i5); typename gen::I7 i7 = fusion::next(i6); typename gen::I8 i8 = fusion::next(i7); typename gen::I9 i9 = fusion::next(i8);
            return result( *i0 , *i1 , *i2 , *i3 , *i4 , *i5 , *i6 , *i7 , *i8 , *i9);
        }
    };
}}}
namespace boost { namespace fusion
{
    struct sequence_facade_tag;
    struct boost_tuple_tag;
    struct boost_array_tag;
    struct mpl_sequence_tag;
    struct std_pair_tag;
    namespace extension
    {
        template <typename Tag>
        struct size_impl
        {
            template <typename Sequence>
            struct apply : Sequence::size {};
        };
        template <>
        struct size_impl<sequence_facade_tag>
        {
            template <typename Sequence>
            struct apply : Sequence::template size<Sequence> {};
        };
        template <>
        struct size_impl<boost_tuple_tag>;
        template <>
        struct size_impl<boost_array_tag>;
        template <>
        struct size_impl<mpl_sequence_tag>;
        template <>
        struct size_impl<std_pair_tag>;
    }
    namespace result_of
    {
        template <typename Sequence>
        struct size
            : extension::size_impl<typename detail::tag_of<Sequence>::type>::
        template apply<Sequence>
        {
            typedef typename extension::size_impl<typename detail::tag_of<Sequence>::type>::
            template apply<Sequence>::type size_application;
            static const int value = size_application::value;
        };
    }
    template <typename Sequence>
    inline typename result_of::size<Sequence>::type
    size(Sequence const&)
    {
        typedef typename result_of::size<Sequence>::type result;
        return result();
    }
}}
namespace boost { namespace fusion
{
    struct vector_tag;
    namespace extension
    {
        template <typename T>
        struct convert_impl;
        template <>
        struct convert_impl<vector_tag>
        {
            template <typename Sequence>
            struct apply
            {
                typedef typename detail::as_vector<result_of::size<Sequence>::value> gen;
                typedef typename gen::
                    template apply<typename result_of::begin<Sequence>::type>::type
                type;
                static type call(Sequence& seq)
                {
                    return gen::call(fusion::begin(seq));
                }
            };
        };
    }
}}
namespace boost { namespace fusion
{
    namespace result_of
    {
        template <typename Sequence>
        struct as_vector
        {
            typedef typename detail::as_vector<result_of::size<Sequence>::value> gen;
            typedef typename gen::
                template apply<typename result_of::begin<Sequence>::type>::type
            type;
        };
    }
    template <typename Sequence>
    inline typename result_of::as_vector<Sequence>::type
    as_vector(Sequence& seq)
    {
        typedef typename result_of::as_vector<Sequence>::gen gen;
        return gen::call(fusion::begin(seq));
    }
    template <typename Sequence>
    inline typename result_of::as_vector<Sequence const>::type
    as_vector(Sequence const& seq)
    {
        typedef typename result_of::as_vector<Sequence const>::gen gen;
        return gen::call(fusion::begin(seq));
    }
}}
namespace boost { namespace reflect {
    struct void_t{
        friend std::ostream& operator<<(std::ostream& os,const void_t&) {return os;}
        friend std::istream& operator>>(std::istream& is,void_t&) {return is;}
    };
    template<typename R, typename Functor=int>
    struct adapt_void {
        typedef R result_type;
        adapt_void( const Functor _f):f(_f){}
        template<typename Seq>
        result_type operator()( const Seq& seq )const {
            return f(seq);
        }
        template<typename Seq>
        result_type operator()( Seq& seq )const {
            return f(seq);
        }
        Functor f;
    };
    template<typename Functor>
    struct adapt_void<void,Functor> {
        typedef void_t result_type;
        adapt_void( const Functor _f):f(_f){}
        template<typename Seq>
        result_type operator()( const Seq& seq )const {
            f(seq); return result_type();
        }
        template<typename Seq>
        result_type operator()( Seq& seq )const {
            f(seq); return result_type();
        }
        Functor f;
    };
} }
namespace boost { namespace type_of {
    template<typename T>
        typename enable_if<is_function<T>, T&>::type
        ensure_obj(T&);
    template<typename T>
        typename disable_if<is_function<T>, T&>::type
        ensure_obj(const T&);
}}
namespace boost { namespace reflect {
  struct mirror_interface;
  template<typename InterfaceType = void, typename InterfaceDelegate = boost::reflect::mirror_interface>
  class vtable {};
  template<typename InterfaceType>
  struct vtable_reflector {
    template<typename Visitor, typename InterfaceDelegate>
    static void visit( const boost::reflect::vtable<InterfaceType,InterfaceDelegate>* vtbl, const Visitor& v ) {}
  };
  template<typename t>
  class vtable_base{};
} }
namespace boost { namespace reflect {
template<typename T>
struct get_typeinfo {
  enum is_defined_enum{ is_defined = 0 };
  static const char* name() { return typeid(T).name(); }
};
template<typename T>
inline const char* get_typename() {
  return get_typeinfo<typename boost::remove_const<
                      typename boost::remove_reference<
                      typename boost::remove_pointer<T>::type>::type>::type>::name();
}
template<typename TP>
struct get_typeinfo< std::vector<TP> > {
  enum is_defined_enum{ is_defined = get_typeinfo<TP>::is_defined };
  static const char* name()
  {
    static std::string n = "std::vector<" + std::string(get_typename<TP>()) + ">";
    return n.c_str();
  }
};
template<typename TP>
struct get_typeinfo< std::list<TP> > {
  enum is_defined_enum{ is_defined = get_typeinfo<TP>::is_defined };
  static const char* name()
  {
    static std::string n = "std::list<" + std::string(get_typename<TP>()) + ">";
    return n.c_str();
  }
};
template<typename TP, typename TP2>
struct get_typeinfo< std::map<TP,TP2> > {
  enum is_defined_enum{ is_defined = get_typeinfo<TP>::is_defined && get_typeinfo<TP2>::is_defined };
  static const char* name()
  {
    static std::string n = "std::map<" + std::string(get_typename<TP>()) + "," +
                                      std::string(get_typename<TP2>() ) + ">";
    return n.c_str();
  }
};
} }
namespace boost { namespace reflect { template<> struct get_typeinfo<void> { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "void"; } }; } }
namespace boost { namespace reflect { template<> struct get_typeinfo<bool> { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "bool"; } }; } }
namespace boost { namespace reflect { template<> struct get_typeinfo<uint8_t> { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "uint8_t"; } }; } }
namespace boost { namespace reflect { template<> struct get_typeinfo<uint16_t> { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "uint16_t"; } }; } }
namespace boost { namespace reflect { template<> struct get_typeinfo<uint32_t> { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "uint32_t"; } }; } }
namespace boost { namespace reflect { template<> struct get_typeinfo<uint64_t> { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "uint64_t"; } }; } }
namespace boost { namespace reflect { template<> struct get_typeinfo<int8_t> { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "int8_t"; } }; } }
namespace boost { namespace reflect { template<> struct get_typeinfo<int16_t> { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "int16_t"; } }; } }
namespace boost { namespace reflect { template<> struct get_typeinfo<int32_t> { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "int32_t"; } }; } }
namespace boost { namespace reflect { template<> struct get_typeinfo<int64_t> { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "int64_t"; } }; } }
namespace boost { namespace reflect { template<> struct get_typeinfo<double> { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "double"; } }; } }
namespace boost { namespace reflect { template<> struct get_typeinfo<float> { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "float"; } }; } }
namespace boost { namespace reflect { template<> struct get_typeinfo<void_t> { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "void_t"; } }; } }
namespace boost { namespace reflect { template<> struct get_typeinfo<std::string> { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "std::string"; } }; } }
namespace boost { namespace reflect {template<> struct get_typeinfo<std::vector<void_t> > { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "std::vector"; } }; } }
namespace boost { namespace reflect {template<> struct get_typeinfo<std::set<void_t> > { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "std::set"; } }; } }
namespace boost { namespace reflect {template<> struct get_typeinfo<std::list<void_t> > { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "std::list"; } }; } }
namespace boost { namespace reflect {template<> struct get_typeinfo<std::map<void_t,void_t> > { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "std::map"; } }; } }
namespace boost { namespace reflect {template<> struct get_typeinfo<std::pair<void_t,void_t> > { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "std::pair"; } }; } }
namespace boost { namespace reflect {
template<typename Rtn >
struct get_typeinfo<Rtn ()>
{
    static const char* name()
    {
        static std::string* sig = __null;
        if( !sig )
        {
            sig = new std::string( get_typename<Rtn>() );
            *sig += '(';
           
            *sig += ')';
        }
        return sig->c_str();
    }
};
template<typename Rtn , typename A0>
struct get_typeinfo<Rtn ( A0)>
{
    static const char* name()
    {
        static std::string* sig = __null;
        if( !sig )
        {
            sig = new std::string( get_typename<Rtn>() );
            *sig += '(';
            *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A0>::type>::type>() ;
            *sig += ')';
        }
        return sig->c_str();
    }
};
template<typename Rtn , typename A0 , typename A1>
struct get_typeinfo<Rtn ( A0 , A1)>
{
    static const char* name()
    {
        static std::string* sig = __null;
        if( !sig )
        {
            sig = new std::string( get_typename<Rtn>() );
            *sig += '(';
            *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A0>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A1>::type>::type>() ;
            *sig += ')';
        }
        return sig->c_str();
    }
};
template<typename Rtn , typename A0 , typename A1 , typename A2>
struct get_typeinfo<Rtn ( A0 , A1 , A2)>
{
    static const char* name()
    {
        static std::string* sig = __null;
        if( !sig )
        {
            sig = new std::string( get_typename<Rtn>() );
            *sig += '(';
            *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A0>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A1>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A2>::type>::type>() ;
            *sig += ')';
        }
        return sig->c_str();
    }
};
template<typename Rtn , typename A0 , typename A1 , typename A2 , typename A3>
struct get_typeinfo<Rtn ( A0 , A1 , A2 , A3)>
{
    static const char* name()
    {
        static std::string* sig = __null;
        if( !sig )
        {
            sig = new std::string( get_typename<Rtn>() );
            *sig += '(';
            *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A0>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A1>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A2>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A3>::type>::type>() ;
            *sig += ')';
        }
        return sig->c_str();
    }
};
template<typename Rtn , typename A0 , typename A1 , typename A2 , typename A3 , typename A4>
struct get_typeinfo<Rtn ( A0 , A1 , A2 , A3 , A4)>
{
    static const char* name()
    {
        static std::string* sig = __null;
        if( !sig )
        {
            sig = new std::string( get_typename<Rtn>() );
            *sig += '(';
            *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A0>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A1>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A2>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A3>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A4>::type>::type>() ;
            *sig += ')';
        }
        return sig->c_str();
    }
};
template<typename Rtn , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5>
struct get_typeinfo<Rtn ( A0 , A1 , A2 , A3 , A4 , A5)>
{
    static const char* name()
    {
        static std::string* sig = __null;
        if( !sig )
        {
            sig = new std::string( get_typename<Rtn>() );
            *sig += '(';
            *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A0>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A1>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A2>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A3>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A4>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A5>::type>::type>() ;
            *sig += ')';
        }
        return sig->c_str();
    }
};
template<typename Rtn , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6>
struct get_typeinfo<Rtn ( A0 , A1 , A2 , A3 , A4 , A5 , A6)>
{
    static const char* name()
    {
        static std::string* sig = __null;
        if( !sig )
        {
            sig = new std::string( get_typename<Rtn>() );
            *sig += '(';
            *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A0>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A1>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A2>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A3>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A4>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A5>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A6>::type>::type>() ;
            *sig += ')';
        }
        return sig->c_str();
    }
};
template<typename Rtn , typename A0 , typename A1 , typename A2 , typename A3 , typename A4 , typename A5 , typename A6 , typename A7>
struct get_typeinfo<Rtn ( A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7)>
{
    static const char* name()
    {
        static std::string* sig = __null;
        if( !sig )
        {
            sig = new std::string( get_typename<Rtn>() );
            *sig += '(';
            *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A0>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A1>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A2>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A3>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A4>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A5>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A6>::type>::type>() + std::string(","); *sig += get_typename<typename boost::remove_const<typename boost::remove_reference<A7>::type>::type>() ;
            *sig += ')';
        }
        return sig->c_str();
    }
};
} }
namespace boost { namespace reflect {
template<typename T>
struct reflector{
    typedef T type;
    typedef boost::fusion::vector<> base_class_types;
    typedef boost::false_type is_defined;
    template<typename Visitor>
    static inline void visit( const Visitor& ){};
};
} }
namespace boost { namespace reflect {
namespace detail {
  class const_iterator_impl_base;
  class iterator_impl_base;
}
class value_ref;
class value_cref;
class iterator {
  public:
    std::string key()const;
    value_ref value()const;
    iterator( const iterator& i );
    iterator( iterator&& i );
    iterator( detail::iterator_impl_base* p = 0 );
    ~iterator();
    iterator& operator=( const iterator& i );
    iterator& operator++(int);
    iterator& operator++();
    bool operator == ( const iterator& i )const;
    bool operator != ( const iterator& i )const;
  private:
    friend class const_iterator;
    detail::iterator_impl_base* itr;
};
class const_iterator {
  public:
    std::string key()const;
    value_cref value()const;
    const_iterator( detail::const_iterator_impl_base* b = 0 );
    const_iterator( const iterator& i );
    const_iterator( const const_iterator& i );
    const_iterator( const_iterator&& i );
    ~const_iterator();
    const_iterator& operator++(int);
    const_iterator& operator++();
    bool operator == ( const const_iterator& i )const;
    bool operator != ( const const_iterator& i )const;
  private:
    friend class iterator;
    detail::const_iterator_impl_base* itr;
};
} }
namespace boost { namespace reflect { namespace detail {
    class const_iterator_impl_base {
      public:
        virtual ~const_iterator_impl_base(){}
        virtual std::string key()const = 0;
        virtual value_cref const_value()const = 0;
        virtual const_iterator_impl_base* const_clone()const = 0;
        virtual void next() = 0;
        virtual bool equals( const const_iterator_impl_base* other )const = 0;
        virtual const char* type()const = 0;
    };
    class iterator_impl_base : public const_iterator_impl_base {
      public:
        virtual value_ref value()const = 0;
        virtual iterator_impl_base* clone()const = 0;
    };
    template<typename T>
    class const_vector_iterator_impl;
    template<typename T>
    class vector_iterator_impl : public iterator_impl_base {
      public:
        typename std::vector<T>::iterator itr;
        std::vector<T>& vec;
        vector_iterator_impl( std::vector<T>& v, const typename std::vector<T>::iterator i ):vec(v),itr(i){}
        virtual std::string key()const { return boost::lexical_cast<std::string>(itr-vec.begin()); }
        virtual value_ref value()const { return *itr; }
        virtual value_cref const_value()const { return *itr; }
        virtual const_iterator_impl_base* const_clone()const { return new const_vector_iterator_impl<T>(vec,itr); }
        virtual iterator_impl_base* clone()const { return new vector_iterator_impl(vec,itr); }
        virtual void next() { ++itr; }
        virtual bool equals( const const_iterator_impl_base* other )const{
            if( other == 0 )
               return itr == vec.end();
            if( type() == other->type() ) {
                return itr == static_cast<const vector_iterator_impl<T>*>(other)->itr;
            }
        }
        virtual const char* type()const { return get_typename<vector_iterator_impl>(); }
    };
    template<typename T>
    class const_vector_iterator_impl : public const_iterator_impl_base {
      public:
        typename std::vector<T>::const_iterator itr;
        const std::vector<T>& vec;
        const_vector_iterator_impl( const std::vector<T>& v, const typename std::vector<T>::const_iterator& i ):vec(v),itr(i){}
        virtual std::string key()const { return boost::lexical_cast<std::string>(itr-vec.begin()); }
        virtual value_cref const_value()const { return *itr; }
        virtual const_iterator_impl_base* const_clone()const { return new const_vector_iterator_impl(vec,itr); }
        virtual void next() { ++itr; }
        virtual bool equals( const const_iterator_impl_base* other )const{
            if( other == 0 )
               return itr == vec.end();
            if( type() == other->type() ) {
                return itr == static_cast<const vector_iterator_impl<T>*>(other)->itr;
            }
        }
        virtual const char* type()const { return get_typename<const_vector_iterator_impl>(); }
    };
    template<typename K, typename V>
    class const_map_iterator_impl;
    template<typename K,typename V>
    class map_iterator_impl : public iterator_impl_base {
      public:
        typename std::map<K,V>::iterator itr;
        std::map<K,V>& vec;
        map_iterator_impl( std::map<K,V>& v, const typename std::map<K,V>::iterator i ):vec(v),itr(i){}
        virtual std::string key()const { return boost::lexical_cast<std::string>(itr->first); }
        virtual value_ref value()const { return itr->second; }
        virtual value_cref const_value()const { return itr->second; }
        virtual const_iterator_impl_base* const_clone()const { return new const_map_iterator_impl<K,V>(vec,itr); }
        virtual iterator_impl_base* clone()const { return new map_iterator_impl(vec,itr); }
        virtual void next() { ++itr; }
        virtual bool equals( const const_iterator_impl_base* other )const{
            if( other == 0 )
               return itr == vec.end();
            if( type() == other->type() ) {
                return itr == static_cast<const map_iterator_impl<K,V>*>(other)->itr;
            }
        }
        virtual const char* type()const { return get_typename<map_iterator_impl>(); }
    };
    template<typename K, typename V>
    class const_map_iterator_impl : public const_iterator_impl_base {
      public:
        typename std::map<K,V>::const_iterator itr;
        const std::map<K,V>& vec;
        const_map_iterator_impl( const std::map<K,V>& v, const typename std::map<K,V>::const_iterator& i ):vec(v),itr(i){}
        virtual std::string key()const { return boost::lexical_cast<std::string>(itr->first); }
        virtual value_cref const_value()const { return itr->second; }
        virtual const_iterator_impl_base* const_clone()const { return new const_map_iterator_impl(vec,itr); }
        virtual void next() { ++itr; }
        virtual bool equals( const const_iterator_impl_base* other )const{
            if( other == 0 )
               return itr == vec.end();
            if( type() == other->type() ) {
                return itr == static_cast<const map_iterator_impl<K,V>*>(other)->itr;
            }
        }
        virtual const char* type()const { return get_typename<const_map_iterator_impl>(); }
    };
} } }
namespace boost { namespace reflect {
namespace detail { struct get_field_method; }
typedef boost::unordered_map<std::string,detail::get_field_method*> field_map_type;
template<typename T>
value_ref get_field( const std::string& n, T& v );
template<typename T>
value_cref get_field( const std::string& n, const T& v );
namespace detail {
      struct get_field_method {
        public:
            get_field_method( const char* n ):m_name(n){}
            virtual value_ref operator()( void* f )const = 0;
            virtual value_cref operator()( const void* f )const = 0;
            const char* name()const { return m_name; }
        private:
            const char* m_name;
      };
      template<typename T,typename C, T(C::*p)>
      struct get_field_method_impl : get_field_method {
        get_field_method_impl( const char* n ):get_field_method(n){}
        virtual value_ref operator()( void* f )const {
           return value_ref((((C*)f)->*p));
        }
        virtual value_cref operator()( const void* f )const {
           return value_cref(((const C*)f)->*p);
        }
      };
      class get_field_visitor {
        public:
          get_field_visitor( field_map_type& _field_map )
          :field_map(_field_map){}
          template<typename T,typename C, T(C::*p)>
          inline void operator()( const char* name )const {
            static get_field_method_impl<T,C,p> gfm(name);
            field_map[name] = &gfm;
          }
          template<typename T,typename C, typename P1, T(C::*p)(P1)>
          inline void operator()( const char* name )const {
          }
          template<typename T,typename C, typename P1, typename P2, T(C::*p)(P1,P2)>
          inline void operator()( const char* name )const {
          }
          template<typename T,typename C, typename P1, T(C::*p)(P1)const>
          inline void operator()( const char* name )const {
          }
          template<typename T,typename C, typename P1, typename P2, T(C::*p)(P1,P2)const>
          inline void operator()( const char* name )const {
          }
          field_map_type& field_map;
      };
      template<typename T>
      static field_map_type* create_field_map() {
        static boost::atomic<field_map_type*> fm(0);
        field_map_type* n = new field_map_type();
        boost::reflect::reflector<T>::visit( get_field_visitor(*n) );
        delete fm.exchange(n,boost::memory_order_consume);
        return fm;
      }
 }
template<typename T>
const field_map_type& get_field_map() {
  static field_map_type* fm = detail::create_field_map<T>();
  return *fm;
}
template<typename T>
bool has_field( const std::string& n ) {
  field_map_type::const_iterator itr = get_field_map<T>().find(n);
  return itr != get_field_map<T>().end();
}
template<typename T>
value_ref get_field( const std::string& n, T& v ) {
  field_map_type::const_iterator itr = get_field_map<T>().find(n);
  if( itr != get_field_map<T>().end() )
    return (*itr->second)(&v);
  ::boost::exception_detail::throw_exception_(unknown_field() << err_msg(n+": '"+n+"'"),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/get_field.hpp",117);
}
template<typename T>
value_cref get_field( const std::string& n, const T& v ) {
  field_map_type::const_iterator itr = get_field_map<T>().find(n);
  if( itr != get_field_map<T>().end() )
    return (*itr->second)(&v);
  ::boost::exception_detail::throw_exception_(unknown_field() << err_msg(n+": '"+n+"'"),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/get_field.hpp",124);
}
template<typename T>
class iterator_impl;
template<typename T>
class const_iterator_impl : public detail::const_iterator_impl_base {
  public:
    const T& val;
    field_map_type::const_iterator itr;
    const_iterator_impl( const T& _val, const field_map_type::const_iterator& i )
    :val(_val),itr(i){}
    const_iterator_impl( const const_iterator_impl& c )
    :val(c.val),itr(c.itr){}
    virtual std::string key()const { return itr->first; }
    virtual value_ref value()const { ::boost::exception_detail::throw_exception_(bad_value_cast(),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/get_field.hpp",143);}
    virtual value_cref const_value()const { return (*itr->second)(&val); }
    virtual const_iterator_impl_base* const_clone()const { return new const_iterator_impl(val,itr); }
    virtual const char* type()const { return get_typename<iterator_impl<T> >(); }
    virtual void next() { ++itr; }
    virtual bool equals( const const_iterator_impl_base* other )const {
      if( other == 0 )
         return itr == get_field_map<T>().end();
      if( type() == other->type() ) {
          return itr == static_cast<const const_iterator_impl<T>*>(other)->itr;
                &val == &static_cast<const const_iterator_impl<T>*>(other)->val;
      }
    }
};
template<typename T>
class iterator_impl : public detail::iterator_impl_base {
  public:
    T& val;
    field_map_type::const_iterator itr;
    iterator_impl( T& _val, const field_map_type::const_iterator& i )
    :val(_val),itr(i){}
    iterator_impl( const iterator_impl& c )
    :val(c.val),itr(c.itr){}
    virtual std::string key()const { return itr->first; }
    virtual value_ref value()const { return (*itr->second)(&val); }
    virtual value_cref const_value()const { return (*itr->second)(&val); }
    virtual iterator_impl_base* clone()const { return new iterator_impl(val,itr); }
    virtual const_iterator_impl_base* const_clone()const { return new const_iterator_impl<T>(val,itr); }
    virtual const char* type()const { return get_typename<iterator_impl<T> >(); }
    virtual void next() { ++itr; }
    virtual bool equals( const const_iterator_impl_base* other )const {
      if( other == 0 )
         return itr == get_field_map<T>().end();
      if( type() == other->type() ) {
          return itr == static_cast<const iterator_impl<T>*>(other)->itr;
                &val == &static_cast<const iterator_impl<T>*>(other)->val;
      }
    }
};
} }
namespace boost { namespace fusion { namespace traits
{
    template <typename T> struct deduce;
    template <typename T>
    struct deduce
    {
        typedef T type;
    };
    template <typename T>
    struct deduce<T const>
    {
        typedef T type;
    };
    template <typename T>
    struct deduce<T volatile>
    {
        typedef T type;
    };
    template <typename T>
    struct deduce<T const volatile>
    {
        typedef T type;
    };
    template <typename T>
    struct deduce<T &>
    {
        typedef T & type;
    };
    template <typename T>
    struct deduce<T volatile&>
    {
        typedef T volatile& type;
    };
    template <typename T>
    struct deduce<T const&>
    {
        typedef T type;
    };
    template <typename T>
    struct deduce<T const volatile&>
    {
        typedef T type;
    };
    template <typename T>
    struct deduce<reference_wrapper<T> & >
    {
        typedef T& type;
    };
    template <typename T>
    struct deduce<reference_wrapper<T> const & >
    {
        typedef T& type;
    };
    template <typename T, int N>
    struct deduce<T(&)[N]>
    {
        typedef T(&type)[N];
    };
    template <typename T, int N>
    struct deduce<volatile T(&)[N]>
    {
        typedef volatile T(&type)[N];
    };
    template <typename T, int N>
    struct deduce<const T(&)[N]>
    {
        typedef const T(&type)[N];
    };
    template <typename T, int N>
    struct deduce<const volatile T(&)[N]>
    {
        typedef const volatile T(&type)[N];
    };
}}}
namespace boost { namespace fusion
{
    struct sequence_facade_tag;
    struct boost_tuple_tag;
    struct boost_array_tag;
    struct mpl_sequence_tag;
    struct std_pair_tag;
    namespace extension
    {
        template <typename Tag>
        struct end_impl
        {
            template <typename Sequence>
            struct apply;
        };
        template <>
        struct end_impl<sequence_facade_tag>
        {
            template <typename Sequence>
            struct apply : Sequence::template end<Sequence> {};
        };
        template <>
        struct end_impl<boost_tuple_tag>;
        template <>
        struct end_impl<boost_array_tag>;
        template <>
        struct end_impl<mpl_sequence_tag>;
        template <>
        struct end_impl<std_pair_tag>;
    }
    namespace result_of
    {
        template <typename Sequence>
        struct end
            : extension::end_impl<typename detail::tag_of<Sequence>::type>::
                template apply<Sequence>
        {};
    }
    template <typename Sequence>
    inline typename
        lazy_enable_if<
            traits::is_sequence<Sequence>
          , result_of::end<Sequence>
        >::type const
    end(Sequence& seq)
    {
        return result_of::end<Sequence>::call(seq);
    }
    template <typename Sequence>
    inline typename
        lazy_enable_if<
            traits::is_sequence<Sequence>
          , result_of::end<Sequence const>
        >::type const
    end(Sequence const& seq)
    {
        return result_of::end<Sequence const>::call(seq);
    }
}}
namespace boost { namespace fusion
{
    struct iterator_root;
    template <typename T>
    struct is_fusion_iterator : is_base_of<iterator_root, T> {};
}}
namespace boost { namespace fusion
{
    struct iterator_facade_tag;
    struct boost_array_iterator_tag;
    struct mpl_iterator_tag;
    struct std_pair_iterator_tag;
    namespace extension
    {
        template <typename Tag>
        struct equal_to_impl
        {
            template <typename I1, typename I2>
            struct apply
                : is_same<typename add_const<I1>::type, typename add_const<I2>::type>
            {};
        };
        template <>
        struct equal_to_impl<iterator_facade_tag>
        {
            template <typename I1, typename I2>
            struct apply : I1::template equal_to<I1, I2> {};
        };
        template <>
        struct equal_to_impl<boost_array_iterator_tag>;
        template <>
        struct equal_to_impl<mpl_iterator_tag>;
        template <>
        struct equal_to_impl<std_pair_iterator_tag>;
    }
    namespace result_of
    {
        template <typename I1, typename I2>
        struct equal_to
            : extension::equal_to_impl<typename detail::tag_of<I1>::type>::
                template apply<I1, I2>
        {};
    }
    namespace iterator_operators
    {
        template <typename Iter1, typename Iter2>
        inline typename
        enable_if<
            mpl::and_<is_fusion_iterator<Iter1>, is_fusion_iterator<Iter2> >
            , bool
            >::type
        operator==(Iter1 const&, Iter2 const&)
        {
            return result_of::equal_to<Iter1, Iter2>::value;
        }
        template <typename Iter1, typename Iter2>
        inline typename
        enable_if<
            mpl::and_<is_fusion_iterator<Iter1>, is_fusion_iterator<Iter2> >
            , bool
            >::type
        operator!=(Iter1 const&, Iter2 const&)
        {
            return !result_of::equal_to<Iter1, Iter2>::value;
        }
    }
    using iterator_operators::operator==;
    using iterator_operators::operator!=;
}}
namespace boost { namespace fusion { namespace distance_detail
{
    template <typename First, typename Last>
    struct linear_distance;
    template <typename First, typename Last>
    struct next_distance
    {
        typedef typename
            mpl::next<
                typename linear_distance<
                    typename result_of::next<First>::type
                  , Last
                >::type
            >::type
        type;
    };
    template <typename First, typename Last>
    struct linear_distance
        : mpl::eval_if<
            result_of::equal_to<First, Last>
          , mpl::identity<mpl::int_<0> >
          , next_distance<First, Last>
        >::type
    {
        typedef typename
            mpl::eval_if<
                result_of::equal_to<First, Last>
              , mpl::identity<mpl::int_<0> >
              , next_distance<First, Last>
            >::type
        type;
        static type
        call(First const&, Last const&)
        {
            return type();
        }
    };
}}}
namespace boost { namespace fusion { namespace detail
{
    template <typename T>
    struct fusion_category_of
    {
        typedef typename T::category type;
    };
}}}
namespace boost { namespace fusion
{
    struct boost_tuple_tag;
    struct boost_array_tag;
    struct mpl_sequence_tag;
    struct std_pair_tag;
    struct incrementable_traversal_tag {};
    struct single_pass_traversal_tag
        : incrementable_traversal_tag {};
    struct forward_traversal_tag
        : single_pass_traversal_tag {};
    struct bidirectional_traversal_tag
        : forward_traversal_tag {};
    struct random_access_traversal_tag
        : bidirectional_traversal_tag {};
    struct associative_tag {};
    namespace extension
    {
        template<typename Tag>
        struct category_of_impl
        {
            template<typename T>
            struct apply : detail::fusion_category_of<T> {};
        };
        template <>
        struct category_of_impl<boost_tuple_tag>;
        template <>
        struct category_of_impl<boost_array_tag>;
        template <>
        struct category_of_impl<mpl_sequence_tag>;
        template <>
        struct category_of_impl<std_pair_tag>;
    }
    namespace traits
    {
        template <typename T>
        struct category_of
            : extension::category_of_impl<typename fusion::detail::tag_of<T>::type>::
                template apply<T>
        {};
        template <typename T>
        struct is_associative
            : is_base_of<
                associative_tag
              , typename category_of<T>::type>
        {};
        template <typename T>
        struct is_incrementable
            : is_base_of<
                incrementable_traversal_tag
              , typename category_of<T>::type>
        {};
        template <typename T>
        struct is_single_pass
            : is_base_of<
                single_pass_traversal_tag
              , typename category_of<T>::type>
        {};
        template <typename T>
        struct is_forward
            : is_base_of<
                forward_traversal_tag
              , typename category_of<T>::type>
        {};
        template <typename T>
        struct is_bidirectional
            : is_base_of<
                bidirectional_traversal_tag
              , typename category_of<T>::type>
        {};
        template <typename T>
        struct is_random_access
            : is_base_of<
                random_access_traversal_tag
              , typename category_of<T>::type>
        {};
    }
}}
namespace boost { namespace fusion
{
    struct random_access_traversal_tag;
    struct iterator_facade_tag;
    struct boost_array_iterator_tag;
    struct mpl_iterator_tag;
    struct std_pair_iterator_tag;
    namespace extension
    {
        template <typename Tag>
        struct distance_impl
        {
            template <typename First, typename Last>
            struct apply : distance_detail::linear_distance<First, Last>
            {
                enum { mpl_assertion_in_line_38 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (traits::is_random_access<First>))0, 1 ) ) ) };
                enum { mpl_assertion_in_line_39 = sizeof( boost::mpl::assertion_failed<false>( boost::mpl::assert_not_arg( (void (*) (traits::is_random_access<Last>))0, 1 ) ) ) };
            };
        };
        template <>
        struct distance_impl<iterator_facade_tag>
        {
            template <typename First, typename Last>
            struct apply : First::template distance<First, Last> {};
        };
        template <>
        struct distance_impl<boost_array_iterator_tag>;
        template <>
        struct distance_impl<mpl_iterator_tag>;
        template <>
        struct distance_impl<std_pair_iterator_tag>;
    }
    namespace result_of
    {
        template <typename First, typename Last>
        struct distance
          : extension::distance_impl<typename detail::tag_of<First>::type>::
                template apply<First, Last>
        {
            typedef typename extension::distance_impl<typename detail::tag_of<First>::type>::
            template apply<First, Last>::type distance_application;
            static const int value = distance_application::value;
        };
    }
    template <typename First, typename Last>
    inline typename result_of::distance<First, Last>::type
    distance(First const& a, Last const& b)
    {
        return result_of::distance<First, Last>::call(a,b);
    }
}}
namespace boost { namespace fusion {
namespace detail
{
    template <typename First, typename Last, typename F>
    inline void
    for_each_linear(First const&, Last const&, F const&, mpl::true_)
    {
    }
    template <typename First, typename Last, typename F>
    inline void
    for_each_linear(First const& first, Last const& last, F const& f, mpl::false_)
    {
        f(*first);
        detail::for_each_linear(fusion::next(first), last, f,
                                result_of::equal_to<typename result_of::next<First>::type, Last>());
    }
    template <typename Sequence, typename F, typename Tag>
    inline void
    for_each(Sequence& seq, F const& f, Tag)
    {
        detail::for_each_linear(
                                fusion::begin(seq)
                                , fusion::end(seq)
                                , f
                                , result_of::equal_to<
                                typename result_of::begin<Sequence>::type
                                , typename result_of::end<Sequence>::type>());
    }
    template<int N>
    struct for_each_unrolled
    {
        template<typename I0, typename F>
        static void call(I0 const& i0, F const& f)
        {
            f(*i0);
            typedef typename result_of::next<I0>::type I1;
            I1 i1(fusion::next(i0));
            f(*i1);
            typedef typename result_of::next<I1>::type I2;
            I2 i2(fusion::next(i1));
            f(*i2);
            typedef typename result_of::next<I2>::type I3;
            I3 i3(fusion::next(i2));
            f(*i3);
            for_each_unrolled<N-4>::call(fusion::next(i3), f);
        }
    };
    template<>
    struct for_each_unrolled<3>
    {
        template<typename I0, typename F>
        static void call(I0 const& i0, F const& f)
        {
            f(*i0);
            typedef typename result_of::next<I0>::type I1;
            I1 i1(fusion::next(i0));
            f(*i1);
            typedef typename result_of::next<I1>::type I2;
            I2 i2(fusion::next(i1));
            f(*i2);
        }
    };
    template<>
    struct for_each_unrolled<2>
    {
        template<typename I0, typename F>
        static void call(I0 const& i0, F const& f)
        {
            f(*i0);
            typedef typename result_of::next<I0>::type I1;
            I1 i1(fusion::next(i0));
            f(*i1);
        }
    };
    template<>
    struct for_each_unrolled<1>
    {
        template<typename I0, typename F>
        static void call(I0 const& i0, F const& f)
        {
            f(*i0);
        }
    };
    template<>
    struct for_each_unrolled<0>
    {
        template<typename It, typename F>
        static void call(It const&, F const&)
        {
        }
    };
    template <typename Sequence, typename F>
    inline void
    for_each(Sequence& seq, F const& f, random_access_traversal_tag)
    {
        typedef typename result_of::begin<Sequence>::type begin;
        typedef typename result_of::end<Sequence>::type end;
        for_each_unrolled<result_of::distance<begin, end>::type::value>::call(fusion::begin(seq), f);
    }
}}}
namespace boost { namespace fusion {
    namespace result_of
    {
        template <typename Sequence, typename F>
        struct for_each
        {
            typedef void type;
        };
    }
    struct random_access_traversal_tag;
    template <typename Sequence, typename F>
    inline void
    for_each(Sequence& seq, F const& f)
    {
        detail::for_each(seq, f, typename traits::category_of<Sequence>::type());
    }
    template <typename Sequence, typename F>
    inline void
    for_each(Sequence const& seq, F const& f)
    {
        detail::for_each(seq, f, typename traits::category_of<Sequence>::type());
    }
}}
namespace boost { namespace reflect { namespace detail {
  struct place_holder {
      virtual ~place_holder(){}
      virtual const char* type()const { return 0; }
      virtual void* ptr() { return 0; }
      virtual const void* ptr()const { return 0; }
      virtual place_holder* clone( char* place = 0 )const {
        if( place ) return new(place)place_holder();
        return new place_holder();
      }
      virtual value call( const std::vector<value>& params )const { return value(); }
      virtual value call( const std::vector<value>& params ) { return value(); }
      virtual void visit( read_value_visitor&& v )const { v(); }
      virtual void visit( write_value_visitor&& v ) { v(); }
      virtual iterator_impl_base* begin() { return 0; }
      virtual const_iterator_impl_base* begin()const { return 0; }
      virtual size_t size()const { return 0; }
      virtual bool is_array()const { return 0; }
      virtual value copy()const { ::boost::exception_detail::throw_exception_(bad_value_cast(),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/place_holder.hpp",36); }
      virtual value_cref cref()const { ::boost::exception_detail::throw_exception_(bad_value_cast(),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/place_holder.hpp",37); }
      virtual bool has_field( const std::string& f )const { return false; }
      virtual value_ref get_field( const std::string& f ) { ::boost::exception_detail::throw_exception_(bad_value_cast(),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/place_holder.hpp",39); }
      virtual value_cref get_field( const std::string& f )const { ::boost::exception_detail::throw_exception_(bad_value_cast(),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/place_holder.hpp",40); }
      virtual value_ref get_field( uint64_t idx ) { ::boost::exception_detail::throw_exception_(bad_value_cast(),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/place_holder.hpp",41); }
      virtual value_cref get_field( uint64_t idx )const { ::boost::exception_detail::throw_exception_(bad_value_cast(),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/place_holder.hpp",42); }
  };
  template<typename T, bool StackAllocate = true >
  struct place_holder_impl : place_holder {
      place_holder_impl( const T& v ):val(new T(v)){}
      place_holder_impl( T&& v ):val(new T(v)){}
      ~place_holder_impl() { delete val; }
      virtual size_t size()const { return get_field_map<T>().size(); }
      virtual const char* type()const { return get_typename<T>(); }
      virtual void* ptr() { return val; }
      virtual const void* ptr()const { return val; }
      virtual place_holder* clone( char* place = 0 )const {
        if( place ) return new (place) place_holder_impl(*val);
        return new place_holder_impl(*val);
      }
      virtual void visit( read_value_visitor&& v )const { v(*val); }
      virtual void visit( write_value_visitor&& v ) { v(*val); }
      virtual value_cref cref()const { return *val; }
      virtual value copy()const { return *val; }
      virtual bool has_field( const std::string& f )const { return reflect::has_field<T>(f); }
      virtual value_ref get_field( const std::string& f ){
         return reflect::get_field(f,*val);
      }
      virtual value_cref get_field( const std::string& f )const {
         return reflect::get_field(f,*val);
      }
      const T& get_val()const { return *val; }
      T& get_val() { return *val; }
      virtual iterator_impl_base* begin() { return new iterator_impl<T>(get_val(), get_field_map<T>().begin()); }
      virtual const_iterator_impl_base* begin()const { return new const_iterator_impl<T>(get_val(), get_field_map<T>().begin()); }
      T* val;
  };
  template<typename T>
  struct place_holder_impl<T,false> : place_holder {
      place_holder_impl( T&& v ):val(std::forward<T>(v)){}
      place_holder_impl( const T& v ):val(v){}
      virtual size_t size()const { return get_field_map<T>().size(); }
      virtual const char* type()const { return get_typename<T>(); }
      virtual void* ptr() { return &val; }
      virtual const void* ptr()const { return &val; }
      virtual place_holder* clone( char* place = 0 )const {
        if( place ) return new (place) place_holder_impl(val);
        return new place_holder_impl(val);
      }
      virtual void visit( read_value_visitor&& v )const { v(val); }
      virtual void visit( write_value_visitor&& v ) { v(val); }
      virtual value copy()const { return val; }
      virtual bool has_field( const std::string& f )const { return reflect::has_field<T>(f); }
      virtual value_ref get_field( const std::string& f ){
         return reflect::get_field(f,val);
      }
      virtual value_cref get_field( const std::string& f )const {
         return reflect::get_field(f,val);
      }
      virtual iterator_impl_base* begin() { return new iterator_impl<T>(val, get_field_map<T>().begin()); }
      virtual const_iterator_impl_base* begin()const { return new const_iterator_impl<T>(val, get_field_map<T>().begin()); }
      const T& get_val()const { return val; }
      T& get_val() { return val; }
      T val;
  };
  template<typename T>
  struct place_holder_impl<T&> : place_holder {
      place_holder_impl( T& v ):val(v){}
      virtual size_t size()const { return get_field_map<T>().size(); }
      virtual const char* type()const { return get_typename<T>(); }
      virtual void* ptr() { return &val; }
      virtual const void* ptr()const { return &val; }
      virtual place_holder* clone( char* place = 0 )const {
        if( place ) return new (place) place_holder_impl(val);
        return new place_holder_impl(val);
      }
      virtual void visit( read_value_visitor&& v )const { v(val); }
      virtual void visit( write_value_visitor&& v ) { v(val); }
      virtual value_cref cref()const { return val; }
      virtual value copy()const { return val; }
      virtual bool has_field( const std::string& f )const { return reflect::has_field<T>(f); }
      virtual value_ref get_field( const std::string& f ) {
         return reflect::get_field(f,val);
      }
      virtual value_cref get_field( const std::string& f )const{
         return reflect::get_field(f,val);
      }
      virtual iterator_impl_base* begin() { return new iterator_impl<T>(val, get_field_map<T>().begin()); }
      virtual const_iterator_impl_base* begin()const { return new const_iterator_impl<T>(val, get_field_map<T>().begin()); }
      const T& get_val()const { return val; }
      T& get_val() { return val; }
      T& val;
  };
  template<typename T>
  struct place_holder_impl<const T&> : place_holder {
      place_holder_impl( const T& v ):val(v){}
      virtual size_t size()const { return get_field_map<T>().size(); }
      virtual const char* type()const { return get_typename<T>(); }
      virtual void* ptr() { return 0; }
      virtual const void* ptr()const { return &val; }
      virtual place_holder* clone( char* place = 0 )const {
        if( place ) return new (place) place_holder_impl(val);
        return new place_holder_impl(val);
      }
      virtual void visit( read_value_visitor&& v )const { v(val); }
      virtual void visit( write_value_visitor&& v ) { v(); }
      virtual value_cref cref()const { return val; }
      virtual value copy()const { return val; }
      virtual bool has_field( const std::string& f )const { return reflect::has_field<T>(f); }
      virtual value_ref get_field( const std::string& f ) {
         ::boost::exception_detail::throw_exception_(bad_value_cast(),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/place_holder.hpp",170);
      }
      virtual value_cref get_field( const std::string& f )const {
         return reflect::get_field(f,val);
      }
      virtual iterator_impl_base* begin() { ::boost::exception_detail::throw_exception_(bad_value_cast(),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/place_holder.hpp",175); return 0; }
      virtual const_iterator_impl_base* begin()const { return new const_iterator_impl<T>(val, get_field_map<T>().begin()); }
      const T& get_val()const { return val; }
      const T& val;
  };
  template<typename T, class Base >
  struct place_holder_array: public Base {
      place_holder_array(){}
      place_holder_array( T& v ):Base(v){}
      place_holder_array( const T& v ):Base(v){}
      place_holder_array( T&& v ):Base(std::forward<T>(v)){}
      virtual bool is_array()const { return true; }
      virtual size_t size()const { return this->get_val().size(); }
      virtual bool has_field( const std::string& f )const {
        try {
            uint64_t idx = boost::lexical_cast<uint64_t>(f);
            return idx < size();
        } catch ( ... ) { return false; }
      }
      virtual value_ref get_field( const std::string& f ) {
            uint64_t idx = boost::lexical_cast<uint64_t>(f);
            return this->get_val()[idx];
      }
      virtual value_cref get_field( const std::string& f )const{
            uint64_t idx = boost::lexical_cast<uint64_t>(f);
            return this->get_val()[idx];
      }
      virtual value_ref get_field( uint64_t idx ) { return this->get_val()[idx]; }
      virtual value_cref get_field( uint64_t idx )const { return this->get_val()[idx]; }
      virtual iterator_impl_base* begin() { return new vector_iterator_impl<typename T::value_type>( this->get_val(), this->get_val().begin() ); }
      virtual const_iterator_impl_base* begin()const { return new const_vector_iterator_impl<typename T::value_type>( this->get_val(), this->get_val().begin() ); }
  };
  template<typename T, class Base >
  struct place_holder_const_array: public Base {
      place_holder_const_array( const T& v ):Base(v){}
      virtual bool is_array()const { return true; }
      virtual size_t size()const { return this->get_val().size(); }
      virtual bool has_field( const std::string& f )const {
        try {
            uint64_t idx = boost::lexical_cast<uint64_t>(f);
            return idx < size();
        } catch ( ... ) { return false; }
      }
      virtual value_cref get_field( const std::string& f )const{
            uint64_t idx = boost::lexical_cast<uint64_t>(f);
            return this->get_val()[idx];
      }
      virtual value_cref get_field( uint64_t idx )const { return this->get_val()[idx]; }
      virtual iterator_impl_base* begin() { return 0; }
      virtual const_iterator_impl_base* begin()const { return new const_vector_iterator_impl<typename T::value_type>( this->get_val(), this->get_val().begin() ); }
  };
  template<typename K, typename V, class Base>
  struct place_holder_map: public Base {
      place_holder_map( std::map<K,V>& v ):Base(v){}
      place_holder_map( const std::map<K,V>& v ):Base(v){}
      place_holder_map( std::map<K,V>&& v ):Base(std::forward<std::map<K,V> >(v) ){}
      virtual bool is_array()const { return false; }
      virtual size_t size()const { return this->get_val().size(); }
      virtual bool has_field( const std::string& f )const {
        try {
            return this->get_val().find(boost::lexical_cast<K>(f)) != this->get_val().end();
        } catch ( ... ) { return false; }
      }
      virtual value_ref get_field( const std::string& f ) {
         return this->get_val()[boost::lexical_cast<K>(f)];
      }
      virtual value_cref get_field( const std::string& f )const{
         typename std::map<K,V>::const_iterator itr = this->get_val().find(boost::lexical_cast<K>(f));
         if( itr != this->get_val().end() )
           return itr->second;
         ::boost::exception_detail::throw_exception_(bad_value_cast(),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/place_holder.hpp",255);
      }
      virtual iterator_impl_base* begin() { return new map_iterator_impl<K,V>( this->get_val(), this->get_val().begin() ); }
      virtual const_iterator_impl_base* begin()const { return new const_map_iterator_impl<K,V>( this->get_val(), this->get_val().begin() ); }
  };
  template<typename K, typename V, class Base>
  struct place_holder_const_map: public Base {
      place_holder_const_map( const std::map<K,V>& v ):Base(v){}
      virtual bool is_array()const { return false; }
      virtual size_t size()const { return this->get_val().size(); }
      virtual bool has_field( const std::string& f )const {
        try {
            return this->get_val().find(boost::lexical_cast<K>(f)) != this->get_val().end();
        } catch ( ... ) { return false; }
      }
      virtual value_ref get_field( const std::string& f ) {
         ::boost::exception_detail::throw_exception_(bad_value_cast(),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/place_holder.hpp",271);
      }
      virtual value_cref get_field( const std::string& f )const{
         typename std::map<K,V>::const_iterator itr = this->get_val().find(boost::lexical_cast<K>(f));
         if( itr != this->get_val().end() )
           return itr->second;
         ::boost::exception_detail::throw_exception_(bad_value_cast(),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/place_holder.hpp",277);
      }
      virtual iterator_impl_base* begin() { return 0; }
      virtual const_iterator_impl_base* begin()const { return new const_map_iterator_impl<K,V>( this->get_val(), this->get_val().begin() ); }
  };
  template<typename T, bool StackAllocate = true>
  struct select_place_holder { typedef place_holder_impl<T,StackAllocate> type; };
  template<typename T>
  struct select_place_holder<std::vector<T>,false > : public place_holder_array<std::vector<T>, place_holder_impl<std::vector<T>,false > > {
    select_place_holder( const std::vector<T>& v ):place_holder_array<std::vector<T>, place_holder_impl<std::vector<T>,false > >(v){}
    select_place_holder( std::vector<T>&& v ):place_holder_array<std::vector<T>, place_holder_impl<std::vector<T>,false > >(std::forward<std::vector<T> >(v)){}
    typedef select_place_holder type;
  };
  template<typename T>
  struct select_place_holder<std::vector<T>& > : public place_holder_array<std::vector<T>, place_holder_impl<std::vector<T>& > > {
    select_place_holder( std::vector<T>& v ):place_holder_array<std::vector<T>, place_holder_impl<std::vector<T>& > >(v){};
    typedef select_place_holder type;
  };
  template<typename T>
  struct select_place_holder<const std::vector<T>& > : public place_holder_const_array<std::vector<T>, place_holder_impl<const std::vector<T>& > > {
    select_place_holder( const std::vector<T>& v ):place_holder_const_array<std::vector<T>, place_holder_impl<const std::vector<T>& > >(v){};
    typedef select_place_holder type;
  };
  template<typename K,typename V>
  struct select_place_holder<std::map<K,V>,false > : public place_holder_array<std::map<K,V>, place_holder_impl<std::map<K,V>,false > > {
    select_place_holder( const std::map<K,V>& v ):place_holder_map<K,V, place_holder_impl<std::map<K,V>,false > >(v){}
    select_place_holder( std::map<K,V>&& v ):place_holder_map<K,V, place_holder_impl<std::map<K,V>,false > >(std::forward<std::map<K,V> >(v)){}
    typedef select_place_holder type;
  };
  template<typename K,typename V>
  struct select_place_holder<std::map<K,V>& > : public place_holder_map<K,V, place_holder_impl<std::map<K,V>& > > {
    select_place_holder( std::map<K,V>& v ):place_holder_map<K,V, place_holder_impl<std::map<K,V>& > >(v){};
    typedef select_place_holder type;
  };
  template<typename K,typename V>
  struct select_place_holder<const std::map<K,V>& > : public place_holder_const_map<K,V, place_holder_impl<const std::map<K,V>& > > {
    select_place_holder( const std::map<K,V>& v ):place_holder_const_map<K,V, place_holder_impl<const std::map<K,V>& > >(v){};
    typedef select_place_holder type;
  };
  template<typename Seq>
  class sequence_iterator_impl {};
  template<typename Seq>
  class sequence_iterator_impl<Seq&> : public iterator_impl_base {
    public:
      Seq& seq;
      int idx;
      sequence_iterator_impl( int i, Seq& s ):seq(s),idx(i){}
      virtual std::string key()const { return boost::lexical_cast<std::string>(idx); }
      virtual value_ref value()const { return get_value_ref( seq, idx ); }
      virtual value_cref const_value()const { return get_value_ref(seq,idx); }
      virtual const_iterator_impl_base* const_clone()const { return new sequence_iterator_impl<const Seq&>(idx,seq); }
      virtual iterator_impl_base* clone()const { return new sequence_iterator_impl<Seq&>(idx,seq); }
      virtual void next() { ++idx; }
      virtual bool equals( const const_iterator_impl_base* other )const{
          if( other == 0 )
             return idx == boost::fusion::result_of::size<Seq>::value;
          if( type() == other->type() ) {
              return idx == static_cast<const sequence_iterator_impl<const Seq&>*>(other)->idx;
          }
      }
      virtual const char* type()const { return get_typename<sequence_iterator_impl>(); }
  };
  template<typename Seq>
  class sequence_iterator_impl<const Seq&> : public const_iterator_impl_base {
    public:
      const Seq& seq;
      int idx;
      sequence_iterator_impl( int i, const Seq& s ):seq(s),idx(i){}
      virtual std::string key()const { return boost::lexical_cast<std::string>(idx); }
      virtual value_cref const_value()const { return get_value_ref(seq,idx); }
      virtual const_iterator_impl_base* const_clone()const { return new sequence_iterator_impl<const Seq&>(idx,seq); }
      virtual void next() { ++idx; }
      virtual bool equals( const const_iterator_impl_base* other )const{
          if( other == 0 )
             return idx == boost::fusion::result_of::size<Seq>::value;
          if( type() == other->type() ) {
              return idx == static_cast<const sequence_iterator_impl<const Seq&>*>(other)->idx;
          }
      }
      virtual const char* type()const { return get_typename<sequence_iterator_impl>(); }
  };
  template<typename Seq>
  struct get_value_ref_visitor {
    mutable int idx;
    int target;
    mutable char ref[sizeof(value_ref)];
    value_ref result()const {
      if( *((int64_t*)ref) == 0 )
        ::boost::exception_detail::throw_exception_(std::out_of_range( boost::lexical_cast<std::string>(target) ),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/place_holder.hpp",384);
      return *static_cast<value_ref*>((void*)ref);
    }
    get_value_ref_visitor(int t=0):idx(0),target(t){}
    template<typename T>
    inline void operator()( T& v )const {
      if( idx == target ) new(ref)value_ref(v);
      ++idx;
    }
  };
  template<typename Seq>
  struct get_value_ref_visitor<const Seq&> {
    mutable int idx;
    int target;
    mutable char ref[sizeof(value_cref)];
    value_cref& result()const {
      if( *((int64_t*)ref) == 0 )
        ::boost::exception_detail::throw_exception_(std::out_of_range( boost::lexical_cast<std::string>(target) ),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/place_holder.hpp",403);
      return *static_cast<value_cref*>((void*)ref);
    }
    get_value_ref_visitor(int t=0):idx(0),target(t){memset(ref,0,sizeof(ref));}
    template<typename T>
    inline void operator()( const T& v )const {
      if( idx == target ) new(ref)value_cref(v);
      ++idx;
    }
  };
  template<typename Seq>
  value_cref get_value_ref( const Seq& s, int idx ) {
    get_value_ref_visitor<const Seq&> get_idx(idx);
    boost::fusion::for_each( s, get_idx );
    return get_idx.result();
  }
  template<typename Seq>
  value_ref get_value_ref( Seq& s, int idx ) {
    get_value_ref_visitor<Seq&> get_idx(idx);
    boost::fusion::for_each( s, get_idx );
    return get_idx.result();
  }
  template<typename Seq, typename Base>
  struct place_holder_sequence : public Base {
      place_holder_sequence(){}
      place_holder_sequence( Seq v ):Base(v){}
      virtual bool is_array()const { return true; }
      virtual size_t size()const { return boost::fusion::result_of::size<typename boost::fusion::traits::deduce<Seq>::type>::value; }
      virtual bool has_field( const std::string& f )const {
        try {
            uint64_t idx = boost::lexical_cast<uint64_t>(f);
            return idx < size();
        } catch ( ... ) { return false; }
      }
      virtual value_ref get_field( const std::string& f ) {
            uint64_t idx = boost::lexical_cast<uint64_t>(f);
            return get_value_ref( this->get_val(), idx );
      }
      virtual value_cref get_field( const std::string& f )const{
            uint64_t idx = boost::lexical_cast<uint64_t>(f);
            return get_value_ref( this->get_val(), idx );
      }
      virtual value_ref get_field( uint64_t idx ) { return get_value_ref( this->get_val(), idx ); }
      virtual value_cref get_field( uint64_t idx )const { return get_value_ref( this->get_val(), idx ); }
      virtual iterator_impl_base* begin() { return new sequence_iterator_impl<Seq&>( 0,this->get_val()); }
      virtual const_iterator_impl_base* begin()const { return new sequence_iterator_impl<const Seq&>( 0,this->get_val());}
  };
  template<typename Seq, typename Base>
  struct place_holder_sequence<const Seq&,Base> : public Base {
      place_holder_sequence(){}
      place_holder_sequence( const Seq& v ):Base(v){}
      virtual bool is_array()const { return true; }
      virtual size_t size()const { return boost::fusion::result_of::size<typename boost::fusion::traits::deduce<Seq>::type>::value; }
      virtual bool has_field( const std::string& f )const {
        try {
            uint64_t idx = boost::lexical_cast<uint64_t>(f);
            return idx < size();
        } catch ( ... ) { return false; }
      }
      virtual value_cref get_field( const std::string& f )const{
            uint64_t idx = boost::lexical_cast<uint64_t>(f);
            return get_value_ref( this->get_val(), idx );
      }
      virtual value_cref get_field( uint64_t idx )const { return get_value_ref( this->get_val(), idx ); }
      virtual iterator_impl_base* begin() { return 0; }
      virtual const_iterator_impl_base* begin()const { return new sequence_iterator_impl<const Seq&>( 0,this->get_val());}
  };
  template<typename Seq, bool StackAllocate = true>
  struct select_sequence_holder: public place_holder_sequence<Seq, place_holder_impl<Seq,StackAllocate > > {
    select_sequence_holder( const Seq& v ):place_holder_sequence<Seq, place_holder_impl<Seq,StackAllocate > >(v){}
    select_sequence_holder( Seq&& v ):place_holder_sequence<Seq, place_holder_impl<Seq,StackAllocate > >(std::forward<Seq >(v)){}
    typedef select_sequence_holder type;
  };
  template<typename Seq>
  struct select_sequence_holder<Seq& > : public place_holder_sequence<Seq, place_holder_impl<Seq& > > {
    select_sequence_holder( Seq& v ):place_holder_sequence<Seq, place_holder_impl<Seq& > >(v){};
    typedef select_sequence_holder type;
  };
  template<typename Seq>
  struct select_sequence_holder<const Seq& > : public place_holder_sequence<const Seq&, place_holder_impl<const Seq& > > {
    select_sequence_holder( const Seq& v ):place_holder_sequence<const Seq&, place_holder_impl<const Seq& > >(v){};
    typedef select_sequence_holder type;
  };
  template<typename T>
  struct select_holder {
    typedef typename boost::mpl::if_c<
        boost::fusion::traits::is_sequence<typename boost::fusion::traits::deduce<T>::type >::value,
        typename select_sequence_holder<T, sizeof(typename select_sequence_holder<T,true>::type ) <= 3*sizeof(void*)>::type,
        typename select_place_holder <T, sizeof(typename select_place_holder <T,true>::type ) <= 3*sizeof(void*)>::type
        >::type type;
  };
} } }
namespace boost { namespace reflect {
    template<typename T>
    value_cref::value_cref( const T&& t ) {
      static_assert(sizeof(held) >= sizeof( typename detail::select_holder<const T&>::type ), "sizeof(held) >= sizeof( typename detail::select_holder<const T&>::type )");
      new (held) typename detail::select_holder<const T&>::type( std::forward<const T>(t) );
    }
    template<typename T>
    value_cref::value_cref( const T& v ) {
      static_assert(sizeof(held) >= sizeof( typename detail::select_holder<const T&>::type ), "sizeof(held) >= sizeof( typename detail::select_holder<const T&>::type )");
      new (held) typename detail::select_holder<const T&>::type(v);
    }
    value_cref::value_cref( const value& v ) {
        v.get_holder()->cref().get_holder()->clone(held);
    }
    value_cref value_cref::operator[]( const std::string& field )const {
      return get_holder()->get_field( field );
    }
    value_cref::value_cref( const value_cref& c ):value_base(c){}
    value_cref::value_cref( value_cref&& t ) {
      memcpy( held, t.held, sizeof(held) );
      new (t.held) detail::place_holder();
    }
    template<typename T>
    inline const T& value_cref::get()const {
      const T* v = const_ptr<T>();
      if( v ) return *v;
      ::boost::exception_detail::throw_exception_(bad_value_cast(),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/value_cref.ipp",41);
    }
    template<typename T>
    inline const T* value_cref::const_ptr()const {
       if( get_holder()->type() == get_typename<T>() )
         return static_cast<const T*>( get_holder()->ptr() );
       return 0;
    }
} }
namespace boost { namespace reflect {
     value_ref::value_ref( const value_ref& r ):value_base(r){}
     value_ref::value_ref( value_ref&& v ) {
        memcpy( held, v.held, sizeof(held) );
        new (v.held) detail::place_holder();
     }
     value_ref::operator value_cref()const {
        return get_holder()->cref();
     }
     template<typename T>
     value_ref::value_ref( T& v ) {
      static_assert(sizeof(typename detail::select_holder<T&>::type(v)) <= sizeof(held), "sizeof(typename detail::select_holder<T&>::type(v)) <= sizeof(held)");
      new (held) typename detail::select_holder<T&>::type(v);
     }
     template<typename T>
     value_ref& value_ref::operator=( const T& r ) {
         get<T>() = r;
         return *this;
     }
     value_cref value_ref::operator[]( const std::string& field )const {
       return get_holder()->get_field(field);
     }
     value_ref value_ref::operator[]( const std::string& field ) {
       return get_holder()->get_field(field);
     }
} }
namespace boost { namespace reflect {
    value::value( const value_cref& c) {
       *this = c.get_holder()->copy();
    }
    value::value( const value_ref& c) {
       *this = c.get_holder()->copy();
    }
    template<typename T>
    value::value( const T& v ) {
      static_assert(sizeof(held) >= sizeof(typename detail::select_holder<T>::type), "sizeof(held) >= sizeof(typename detail::select_holder<T>::type)");
      new(held) typename detail::select_holder<T>::type(v);
    }
    template<typename T>
    value::value( typename boost::remove_reference<T>::type&& v ) {
      static_assert(sizeof(held) >= sizeof(typename detail::select_holder<T>::type), "sizeof(held) >= sizeof(typename detail::select_holder<T>::type)");
      new(held) typename detail::select_holder<T>::type(std::forward<T>(v));
    }
    value::value( value&& v ) {
      memcpy( held, v.held, sizeof(held) );
      new(v.held) detail::place_holder();
    }
    template<typename T>
    value& value::operator=( const T& v ) {
       if( ptr<T>() ) { *ptr<T>() = v; return *this; }
       get_holder()->~place_holder();
       new(held) typename detail::select_holder<T>::type(v);
       return *this;
    }
    template<typename T>
    value& value::operator=( T&& v ) {
       if( ptr<T>() ) { *ptr<T>() = std::forward<T>(v); }
       else {
           new(held)typename detail::select_holder<T>::type(std::forward<T>(v));
       }
        return *this;
     }
     template<typename T>
     value& value::operator=( value&& v ) {
        memcpy(held,v.held,sizeof(held));
        new (v.held) detail::place_holder();
        return *this;
     }
     template<typename T>
     value& value::operator=( const value& v ) {
       if( this != &v ) {
          get_holder()->~place_holder();
          v.get_holder()->clone( held );
       }
       return *this;
     }
     template<typename T>
     value& value::operator=( const value_ref& v ){
        return *this = v.get_holder()->copy();
     }
     template<typename T>
     value& value::operator=( const value_cref& v ) {
        return *this = v.get_holder()->copy();
     }
     value_cref value::operator[]( const std::string& field )const {
       return get_holder()->get_field(field);
     }
     value_ref value::operator[]( const std::string& field ) {
       return get_holder()->get_field(field);
     }
} }
namespace boost { namespace reflect {
    value_base::value_base() { new (held) detail::place_holder(); }
    value_base::~value_base() { get_holder()->~place_holder(); }
    value_base::value_base(const value_base& copy)
    { copy.get_holder()->clone( held ); }
    bool value_base::is_array()const {
      return get_holder()->is_array();
    }
    size_t value_base::size()const {
      return get_holder()->size();
    }
    iterator value_base::begin() {
      return get_holder()->begin();
    }
    const_iterator value_base::begin()const {
      return get_holder()->begin();
    }
    iterator value_base::end() {
      return iterator();
    }
    const_iterator value_base::end()const {
      return const_iterator();
    }
    inline const detail::place_holder* value_base::get_holder()const {
      return reinterpret_cast<detail::place_holder*>(const_cast<char*>(held));
    }
    inline detail::place_holder* value_base::get_holder(){
      return reinterpret_cast<detail::place_holder*>(held);
    }
    const char* value_base::type()const { return get_holder()->type(); }
    void value_base::visit( read_value_visitor&& v )const {
      get_holder()->visit( std::forward<read_value_visitor>(v) );
    }
    void value_base::visit( write_value_visitor&& v ) {
      get_holder()->visit( std::forward<write_value_visitor>(v) );
    }
    template<typename T>
    T value_base::as()const {
      T val;
      visit( get_visitor<T>(val) );
      return val;
    }
    template<typename T>
    void value_base::set_as( const T&& v ) {
      visit( set_visitor<T>( std::forward<const T>(v) ) );
    }
    bool value_base::operator!()const {
      return get_holder()->type() == 0;
    }
    template<typename T>
    inline const T* value_base::ptr()const {
       if( get_holder()->type() == get_typename<T>() )
         return static_cast<const T*>( get_holder()->ptr() );
       return 0;
    }
    template<typename T>
    inline T* value_base::ptr(){
       if( get_holder()->type() == get_typename<T>() )
         return static_cast<T*>( get_holder()->ptr() );
       return 0;
    }
    bool value_base::has_field( const std::string& field )const{
      return get_holder()->has_field(field);
    }
    template<typename T>
    inline const T& value_base::get()const {
      const T* v = ptr<T>();
      if( v ) return *v;
      ::boost::exception_detail::throw_exception_(bad_value_cast(),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/value_base.ipp",92);
    }
    template<typename T>
    inline T& value_base::get() {
      T* v = ptr<T>();
      if( v ) return *v;
      ::boost::exception_detail::throw_exception_(bad_value_cast(),__PRETTY_FUNCTION__,"../include/boost/reflect/detail/value_base.ipp",99);
    }
      template<typename P1>
      value value_base::operator()(P1 p1)const {
        std::vector<value> params(1); params[0] = p1;
        return get_holder()->call( params );
      }
      template<typename P1>
      value value_base::operator()(P1 p1){
        std::vector<value> params(1); params[0] = p1;
        return get_holder()->call( params );
      }
      template<typename P1, typename P2>
      value value_base::operator()(P1 p1,P2 p2)const{
        std::vector<value> params(2);
        params[0] = p1;
        params[1] = p2;
        return get_holder()->call( params );
      }
      template<typename P1,typename P2>
      value value_base::operator()(P1 p1,P2 p2){
        std::vector<value> params(2);
        params[0] = p1;
        params[1] = p2;
        return get_holder()->call( params );
      }
} }
namespace boost { namespace reflect {
    std::string iterator::key()const { return itr->key(); }
    value_ref iterator::value()const { return itr->value(); }
    iterator::iterator( detail::iterator_impl_base* i )
    :itr(i){}
    iterator::iterator( const iterator& i )
    :itr(i.itr->clone()){}
    iterator::iterator( iterator&& i )
    :itr(i.itr) { i.itr = 0; }
    iterator::~iterator(){ delete itr; }
    iterator& iterator::operator=( const iterator& i ) {
      if( this != &i ) {
        delete itr;
        itr = i.itr->clone();
      }
      return *this;
    }
    iterator& iterator::operator++(int) { itr->next(); return *this; }
    iterator& iterator::operator++() { itr->next(); return *this; }
    bool iterator::operator == ( const iterator& i )const {
      if( itr == i.itr ) return true;
      if( itr == 0 ) return i.itr->equals(itr);
      return itr->equals(i.itr);
    }
    inline const_iterator::const_iterator( const const_iterator& i )
    :itr(i.itr->const_clone()){}
    inline const_iterator::const_iterator( const iterator& i )
    :itr(i.itr->clone()){}
    inline const_iterator::const_iterator( const_iterator&& i )
    :itr(i.itr) { i.itr = 0; }
    inline const_iterator::const_iterator( detail::const_iterator_impl_base* b )
    :itr( b ){}
    inline const_iterator::~const_iterator(){ delete itr; }
    inline std::string const_iterator::key()const { return itr->key(); }
    inline value_cref const_iterator::value()const { return itr->const_value(); }
    inline const_iterator& const_iterator::operator++(int) { itr->next(); return *this; }
    inline const_iterator& const_iterator::operator++() { itr->next(); return *this; }
    inline bool const_iterator::operator == ( const const_iterator& i )const {
      if( itr == i.itr ) return true;
      if( itr == 0 ) return i.itr->equals(itr);
      return itr->equals(i.itr);
    }
    inline bool const_iterator::operator != ( const const_iterator& i )const {
      return !(*this == i);
    }
} }
namespace boost { namespace fusion { namespace detail
{
    template <typename T>
    struct as_fusion_element
    {
        typedef T type;
    };
    template <typename T>
    struct as_fusion_element<reference_wrapper<T> >
    {
        typedef T& type;
    };
    template <typename T, int N>
    struct as_fusion_element<T[N]>
    {
        typedef const T(&type)[N];
    };
    template <typename T, int N>
    struct as_fusion_element<volatile T[N]>
    {
        typedef const volatile T(&type)[N];
    };
    template <typename T, int N>
    struct as_fusion_element<const volatile T[N]>
    {
        typedef const volatile T(&type)[N];
    };
}}}
namespace boost { namespace fusion
{
    struct void_;
    namespace result_of
    {
        template <
            typename T0 = void_ , typename T1 = void_ , typename T2 = void_ , typename T3 = void_ , typename T4 = void_ , typename T5 = void_ , typename T6 = void_ , typename T7 = void_ , typename T8 = void_ , typename T9 = void_
          , typename Extra = void_
        >
        struct make_vector;
        template <>
        struct make_vector<>
        {
            typedef vector0<> type;
        };
    }
    inline vector0<>
    make_vector()
    {
        return vector0<>();
    }
    namespace result_of
    {
        template < typename T0>
        struct make_vector< T0>
        {
            typedef vector1< typename detail::as_fusion_element<T0>::type> type;
        };
    }
    template < typename T0>
    inline vector1< typename detail::as_fusion_element<T0>::type>
    make_vector( T0 const& _0)
    {
        return vector1< typename detail::as_fusion_element<T0>::type>(
            _0);
    }
    namespace result_of
    {
        template < typename T0 , typename T1>
        struct make_vector< T0 , T1>
        {
            typedef vector2< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type> type;
        };
    }
    template < typename T0 , typename T1>
    inline vector2< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type>
    make_vector( T0 const& _0 , T1 const& _1)
    {
        return vector2< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type>(
            _0 , _1);
    }
    namespace result_of
    {
        template < typename T0 , typename T1 , typename T2>
        struct make_vector< T0 , T1 , T2>
        {
            typedef vector3< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type> type;
        };
    }
    template < typename T0 , typename T1 , typename T2>
    inline vector3< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type>
    make_vector( T0 const& _0 , T1 const& _1 , T2 const& _2)
    {
        return vector3< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type>(
            _0 , _1 , _2);
    }
    namespace result_of
    {
        template < typename T0 , typename T1 , typename T2 , typename T3>
        struct make_vector< T0 , T1 , T2 , T3>
        {
            typedef vector4< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type> type;
        };
    }
    template < typename T0 , typename T1 , typename T2 , typename T3>
    inline vector4< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type>
    make_vector( T0 const& _0 , T1 const& _1 , T2 const& _2 , T3 const& _3)
    {
        return vector4< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type>(
            _0 , _1 , _2 , _3);
    }
    namespace result_of
    {
        template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
        struct make_vector< T0 , T1 , T2 , T3 , T4>
        {
            typedef vector5< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type> type;
        };
    }
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4>
    inline vector5< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type>
    make_vector( T0 const& _0 , T1 const& _1 , T2 const& _2 , T3 const& _3 , T4 const& _4)
    {
        return vector5< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type>(
            _0 , _1 , _2 , _3 , _4);
    }
    namespace result_of
    {
        template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
        struct make_vector< T0 , T1 , T2 , T3 , T4 , T5>
        {
            typedef vector6< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type , typename detail::as_fusion_element<T5>::type> type;
        };
    }
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5>
    inline vector6< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type , typename detail::as_fusion_element<T5>::type>
    make_vector( T0 const& _0 , T1 const& _1 , T2 const& _2 , T3 const& _3 , T4 const& _4 , T5 const& _5)
    {
        return vector6< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type , typename detail::as_fusion_element<T5>::type>(
            _0 , _1 , _2 , _3 , _4 , _5);
    }
    namespace result_of
    {
        template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
        struct make_vector< T0 , T1 , T2 , T3 , T4 , T5 , T6>
        {
            typedef vector7< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type , typename detail::as_fusion_element<T5>::type , typename detail::as_fusion_element<T6>::type> type;
        };
    }
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6>
    inline vector7< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type , typename detail::as_fusion_element<T5>::type , typename detail::as_fusion_element<T6>::type>
    make_vector( T0 const& _0 , T1 const& _1 , T2 const& _2 , T3 const& _3 , T4 const& _4 , T5 const& _5 , T6 const& _6)
    {
        return vector7< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type , typename detail::as_fusion_element<T5>::type , typename detail::as_fusion_element<T6>::type>(
            _0 , _1 , _2 , _3 , _4 , _5 , _6);
    }
    namespace result_of
    {
        template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
        struct make_vector< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7>
        {
            typedef vector8< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type , typename detail::as_fusion_element<T5>::type , typename detail::as_fusion_element<T6>::type , typename detail::as_fusion_element<T7>::type> type;
        };
    }
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7>
    inline vector8< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type , typename detail::as_fusion_element<T5>::type , typename detail::as_fusion_element<T6>::type , typename detail::as_fusion_element<T7>::type>
    make_vector( T0 const& _0 , T1 const& _1 , T2 const& _2 , T3 const& _3 , T4 const& _4 , T5 const& _5 , T6 const& _6 , T7 const& _7)
    {
        return vector8< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type , typename detail::as_fusion_element<T5>::type , typename detail::as_fusion_element<T6>::type , typename detail::as_fusion_element<T7>::type>(
            _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7);
    }
    namespace result_of
    {
        template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
        struct make_vector< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8>
        {
            typedef vector9< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type , typename detail::as_fusion_element<T5>::type , typename detail::as_fusion_element<T6>::type , typename detail::as_fusion_element<T7>::type , typename detail::as_fusion_element<T8>::type> type;
        };
    }
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8>
    inline vector9< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type , typename detail::as_fusion_element<T5>::type , typename detail::as_fusion_element<T6>::type , typename detail::as_fusion_element<T7>::type , typename detail::as_fusion_element<T8>::type>
    make_vector( T0 const& _0 , T1 const& _1 , T2 const& _2 , T3 const& _3 , T4 const& _4 , T5 const& _5 , T6 const& _6 , T7 const& _7 , T8 const& _8)
    {
        return vector9< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type , typename detail::as_fusion_element<T5>::type , typename detail::as_fusion_element<T6>::type , typename detail::as_fusion_element<T7>::type , typename detail::as_fusion_element<T8>::type>(
            _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8);
    }
    namespace result_of
    {
        template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
        struct make_vector< T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 , T9>
        {
            typedef vector10< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type , typename detail::as_fusion_element<T5>::type , typename detail::as_fusion_element<T6>::type , typename detail::as_fusion_element<T7>::type , typename detail::as_fusion_element<T8>::type , typename detail::as_fusion_element<T9>::type> type;
        };
    }
    template < typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9>
    inline vector10< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type , typename detail::as_fusion_element<T5>::type , typename detail::as_fusion_element<T6>::type , typename detail::as_fusion_element<T7>::type , typename detail::as_fusion_element<T8>::type , typename detail::as_fusion_element<T9>::type>
    make_vector( T0 const& _0 , T1 const& _1 , T2 const& _2 , T3 const& _3 , T4 const& _4 , T5 const& _5 , T6 const& _6 , T7 const& _7 , T8 const& _8 , T9 const& _9)
    {
        return vector10< typename detail::as_fusion_element<T0>::type , typename detail::as_fusion_element<T1>::type , typename detail::as_fusion_element<T2>::type , typename detail::as_fusion_element<T3>::type , typename detail::as_fusion_element<T4>::type , typename detail::as_fusion_element<T5>::type , typename detail::as_fusion_element<T6>::type , typename detail::as_fusion_element<T7>::type , typename detail::as_fusion_element<T8>::type , typename detail::as_fusion_element<T9>::type>(
            _0 , _1 , _2 , _3 , _4 , _5 , _6 , _7 , _8 , _9);
    }
}}
using namespace boost::reflect;
struct test_struct {
  std::string test_func( int x, double y ) { return boost::lexical_cast<std::string>(x*y); };
};
namespace boost { namespace reflect { 
template<> struct get_typeinfo<test_struct> { enum is_defined_enum{ is_defined = 1 }; static const char* name() { return "test_struct"; } }; } } namespace boost { namespace reflect { template<> 

struct reflector<test_struct> { 
    typedef test_struct type; typedef boost::true_type is_defined; 
    
    template<typename Visitor>
    static inline void visit( const Visitor& v ) 
    { 
      v.template operator()<__typeof__(boost::type_of::ensure_obj(type::test_func)),type,&type::test_func>( "test_func" ); 
    } 
    }; 
    } };


int main( int argc, char** argv ){
  value v(test_struct());
  (__builtin_expect(!(v["test_func"]( 3, 5.5 ).as<std::string>() == boost::lexical_cast<std::string>(3*5.5)), 0) ? __assert_rtn(__FUNCTION__, "value_function.cpp", 18, "v[\"test_func\"]( 3, 5.5 ).as<std::string>() == boost::lexical_cast<std::string>(3*5.5)") : (void)0);
  return 0;
}
