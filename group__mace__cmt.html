<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MACE: CMT (Cooperative Multi-Tasking) Library</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="style.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>


<script type="text/javascript">
  var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-32339400-1']);
      _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
                      })();

</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MACE
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">CMT (Cooperative Multi-Tasking) Library</div>  </div>
<div class="ingroups"><a class="el" href="group__mace.html">MACE - Massively Asynchronous Coding Environment</a></div></div><!--header-->
<div class="contents">
<p>In a cooperative implementation of multitasking, each task must explicitly yield control to the central scheduler to allow the next task to run. This means that a misbehaving task that never yields control, can starve all other tasks.</p>
<p>Multithreading on the other hand, at least on most implementations, implies preemptive multitasking; each task is allowed to run for a certain amount of time, called time-slice. When the time-slice is over the task is forcibly interrupted and the scheduler selects the next task. If the interrupted task was manipulating some shared resource, this can be left in an undefined state. A task cannot control when is preempted, so it must be pessimistic and lock all shared resources that it uses. As any programmer that has had to work with heavily threaded applications knows, dealing with complex locking is not a trivial task. In addition both locking and thread switching imposes some considerable overhead.</p>
<p>Cooperative multitasking does not have these problems as long as a task never yields (waits) while manipulating shared state.</p>
<h2><a class="anchor" id="cmt_single_thread"></a>
Single Threaded Benchmark</h2>
<p>Here is a simple benchmark program that performs an asynchornous operation and waits on the result. This example is effecitvely synchronous because only one async operation is in flight at a time and there is only one real thread.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="thread_8hpp.html">mace/cmt/thread.hpp</a>&gt;</span>

<span class="keywordtype">int</span> hello( <span class="keywordtype">int</span> in ){ <span class="keywordflow">return</span> in; }

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv ) {
    boost::chrono::system_clock::time_point start = boost::chrono::system_clock::now();
    <span class="keywordtype">int</span> sum = 0;
    <span class="keywordflow">for</span>( uint32_t i = 0; i &lt; 1000000; ++i ) 
        sum += mace::cmt::async( std::bind(hello, i) ).wait();
    boost::chrono::system_clock::time_point end = boost::chrono::system_clock::now();
    slog( <span class="stringliteral">&quot;%1% calls/sec&quot;</span>, 
      (1000000.0/((end - start).count()/1000000000.0)) );
}
</pre></div><h2><a class="anchor" id="cmt_multi_threading"></a>
Multi-Threading with MACE.CMT</h2>
<p>In this example all tasks will occur in parallel in three different threads (t1,t2, and main).</p>
<p>While <code>main</code> waits for results from threads <code>t1</code> and <code>t2</code> it will switch contexts and execute other operations that are scheduled in the <code>main</code> thread such as calculating the result of <code>f3</code>.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="thread_8hpp.html">mace/cmt/thread.hpp</a>&gt;</span>

<span class="keywordtype">int</span> hello( <span class="keyword">const</span> std::string&amp; s ) { <span class="keywordflow">return</span> s.size(); }

<span class="keyword">namespace </span>cmt = mace::cmt;

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv ) {
  <span class="keywordflow">try</span>{ 
   cmt::thread::current().set_name(<span class="stringliteral">&quot;main&quot;</span>);
   cmt::thread* t1 = cmt::thread::create( <span class="stringliteral">&quot;t1&quot;</span> );
   cmt::thread* t2 = cmt::thread::create( <span class="stringliteral">&quot;t2&quot;</span> );

   cmt::future&lt;int&gt; f1 = t1-&gt;async( bind(hello,<span class="stringliteral">&quot;world1&quot;</span>) );
   <span class="keyword">auto</span> f2 = t2-&gt;async( bind(hello,<span class="stringliteral">&quot;world2&quot;</span>) );
   <span class="keyword">auto</span> f3 = cmt::async( bind(hello,<span class="stringliteral">&quot;world3&quot;</span>) );

   <span class="comment">// world3 is processed in current thread, while waiting on f1 &amp; f2</span>
   std::cerr&lt;&lt;( f1.wait() + f2.wait() + f3.wait() ) &lt;&lt; std::endl;

   t1-&gt;quit(); <span class="comment">// cancel any tasks and join thread</span>
   t2-&gt;quit(); <span class="comment">// cancel any tasks and join thread</span>

   cmt::thread::current().quit();
 } <span class="keywordflow">catch</span> ( ... ) {
    elog( <span class="stringliteral">&quot;Caught exception&quot;</span> );
    <span class="keywordflow">return</span> 1; 
 }
 <span class="keywordflow">return</span> 0;
}
</pre></div><h2><a class="anchor" id="cmt_exception"></a>
Exception Handling</h2>
<p>Any exception thrown durring an asynchronous operation is caught by the thread that calls cmt::future::wait()</p>
<h2><a class="anchor" id="cmt_usleep"></a>
Yielding and Sleeping</h2>
<p>The current task can either yield and allow other tasks to run before returning or it can sleep for an specific amount of time while allowing other tasks to run.</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacemace_1_1cmt.html#af4a6cb3372677000d4c35d1c377b9bee" title="Same as cmt::current().usleep()">cmt::usleep</a>(100000<span class="comment">/*us*/</span>);
      cmt::yield();

      <span class="comment">// or the more verbose...</span>
      cmt::thread::current().usleep(10000);
      cmt::thread::current().yield();
</pre></div><p>You can only yield or sleep for the current thread. If there are no other tasks ready to run then yield() returns immediately.</p>
<dl class="section note"><dt>Note:</dt><dd>Sleep and yield times are dependent upon other tasks yielding in a timely manner.</dd></dl>
<h2><a class="anchor" id="cmt_async_signal_wait"></a>
Boost.Signals Integration</h2>
<p>This example shows how a task can wait on an event triggered by a boost::signal and return the parameters emited by the signal. The output of the following program is 'hello world!' after waiting for 2 seconds.</p>
<p>Everything in this example runs in the main thread.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="thread_8hpp.html">mace/cmt/thread.hpp</a>&gt;</span>
<span class="preprocessor">#include &lt;mace/cmt/signals.hpp&gt;</span>

<span class="keyword">namespace </span>cmt = mace::cmt;

boost::signal&lt;void(std::string)&gt; test_signal;

<span class="keywordtype">void</span> delay() {
    <a class="code" href="namespacemace_1_1cmt.html#af4a6cb3372677000d4c35d1c377b9bee" title="Same as cmt::current().usleep()">cmt::usleep</a>(2000000);
    test_signal(<span class="stringliteral">&quot;hello world!&quot;</span>);
}

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv ) {
     std::cerr&lt;&lt; <span class="stringliteral">&quot;Delay for 2 seconds...\n&quot;</span>;
     cmt::async( delay );
     std::cerr&lt;&lt; cmt::wait(test_signal) &lt;&lt; std::endl;
     <span class="keywordflow">return</span> 0;
}
</pre></div><h2><a class="anchor" id="cmt_promise"></a>
Using Promises</h2>
<p>Sometimes you need to perform an asynchronous operation of your own, such as a network call or waiting on user input. Here is an example from MACE.CMT's ASIO wrapper. Using <code>cmt::asio::read</code> you can perform a 'synchronous' read in the current thread without blocking the current thread. Instead the current thread will switch to running other tasks while waiting for the read to complete and then switch back once the read is ready. If an error occurs then <code><a class="el" href="namespacemace_1_1cmt_1_1asio.html#a9ba4c2a592e2cd9250b781662d583fc4" title="wraps boost::asio::async_read">read()</a></code> will throw the exception passed to ASIO's completion handler.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> AsyncReadStream, <span class="keyword">typename</span> MutableBufferSequence&gt;
    <span class="keywordtype">size_t</span> <a class="code" href="namespacemace_1_1cmt_1_1asio.html#a9ba4c2a592e2cd9250b781662d583fc4" title="wraps boost::asio::async_read">read</a>( AsyncReadStream&amp; s, <span class="keyword">const</span> MutableBufferSequence&amp; buf, <span class="keyword">const</span> microseconds&amp; timeout_us = microseconds::max() ) {
        promise&lt;size_t&gt;::ptr p(<span class="keyword">new</span> promise&lt;size_t&gt;());
        boost::asio::async_read( s, buf, boost::bind( detail::read_write_handler, p, _1, _2 ) );
        <span class="keywordflow">return</span> p-&gt;wait(timeout_us);
    }
    <span class="keywordtype">void</span> read_write_handler( <span class="keyword">const</span> promise&lt;size_t&gt;::ptr&amp; p, <span class="keyword">const</span> boost::system::error_code&amp; ec, <span class="keywordtype">size_t</span> bytes_transferred ) {
        <span class="keywordflow">if</span>( !ec ) p-&gt;set_value(bytes_transferred);
        <span class="keywordflow">else</span> p-&gt;set_exception( boost::copy_exception( boost::system::system_error(ec) ) );
    }
</pre></div><h2><a class="anchor" id="cmt_asio_integration"></a>
Boost.ASIO Integration</h2>
<h2><a class="anchor" id="cmt_vs_asio"></a>
MACE.CMT vs Boost.ASIO</h2>
<p>Boost.ASIO is currently how many projects perform asynchronous operations and multi-plex tasks on a pool of threads running <code>asio::io_service::run</code>. Synchronization occurs via the use of <code>asio::io_service::strand</code> which ensures that no two handlers within the strand can be run at the same time. Unfortunately, this is not useful for handlers that may want to block.</p>
<p>The Boost.Thread library includes <code>boost::future&lt;T&gt;</code> type that on the surface looks very similar to mace::cmt::future&lt;T&gt;, except that several problems emerge in practice:</p>
<ul>
<li>If you block waiting on a future from a ASIO callback handler you can stall an entire strand and hold up an entire OS thread reducing the effective size of your thread pool.</li>
</ul>
<ul>
<li>By stalling a strand you can end up with deadlock if two strands post events containing promises to one another and then both wait on the future. With cooperative threads, you can gaurantee that no two 'fibers' will run at the same time allowing one to work while the other blocks.</li>
</ul>
<p>Consider the following case study:</p>
<ul>
<li>perform 2 async operation and add the result.</li>
</ul>
<ul>
<li>print an error if either fails.</li>
</ul>
<table class="doxtable">
<tr>
<th>Boost.ASIO</th><th>MACE.CMT</th></tr>
<tr>
<td><div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> async_opp(<span class="keyword">function</span>&lt;<span class="keywordtype">void</span>(<span class="keywordtype">int</span>,<span class="keywordtype">bool</span>)&gt; callback) {
      callback( 42, error_code );  
    }
    <span class="keywordtype">void</span> another_async_opp(<span class="keyword">function</span>&lt;<span class="keywordtype">void</span>(<span class="keywordtype">int</span>,<span class="keywordtype">bool</span>)&gt; callback) {
        callback( 53, error_code );  
    }

    <span class="comment">// Requires shared or global state</span>
    mutex            m;
    <span class="keywordtype">int</span>              shared_state = 0;
    <span class="keywordtype">int</span>              results[2];
    asio::io_service io_service

    <span class="comment">// could be called by any thread running ioservice!</span>
    <span class="keywordtype">void</span> handle_result(<span class="keywordtype">int</span> r, <span class="keywordtype">bool</span> error) {
       unique_lock(m); <span class="comment">// must protect shared_state  </span>
       <span class="keywordflow">if</span>( error &amp;&amp; state != -1 ) { 
          state = -1; 
          std::cerr&lt;&lt;<span class="stringliteral">&quot;An error occured!\n&quot;</span>; 
       } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( state != -1 ) {
          results[state++] = r;
          <span class="keywordflow">if</span>( state == 2 ) 
              std::cout&lt;&lt;results[0]+results[1]&lt;&lt;std::endl;
       }
    }
    <span class="keywordtype">void</span> test( ) {
      io_service.post( bind( async_opp, handle_result ) );
      io_service.post( bind( another_async_opp, handle_result ) );
      other_work();
      <span class="comment">// do other work</span>
   }
</pre></div>  </td><td valign="top"><div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> async_opp() { <span class="keywordflow">return</span> 42; }
  <span class="keywordtype">int</span> another_async_opp() { <span class="keywordflow">return</span> 53; }

  <span class="comment">// given</span>
  cmt::thread* t1;
  cmt::thread* t2;

  <span class="keywordtype">void</span> test() {
    cmt::future&lt;int&gt; f1 = t1-&gt;async&lt;<span class="keywordtype">int</span>&gt;( async_opp );
    cmt::future&lt;int&gt; f2 = t2-&gt;async&lt;<span class="keywordtype">int</span>&gt;( another_async_opp );
    async&lt;void&gt;( other_work ); <span class="comment">// in current thread</span>

    <span class="keywordflow">try</span> {
      <span class="comment">// while waiting other_work can run in this thread.</span>
      std::cerr&lt;&lt; f1.wait() + f2.wait() &lt;&lt; std::endl;
    } <span class="keywordflow">catch</span> ( ... ) {
      std::cerr&lt;&lt;<span class="stringliteral">&quot;An error occured!\n&quot;</span>;
    }
  }
</pre></div><ul>
<li>If this were implemented using <code>boost::future&lt;T&gt;</code> then <code>other_work</code> could not occur in the same thread while waiting for other asynchronous opperations to complete.</li>
<li>In order to avoid blocking an entire <code>boost::asio::strand</code>, you would have to revert to fine-grained locking with mutex.  </li>
</ul>
</td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> test2( ) {
    test(); <span class="comment">// behaves asynchronously, unexpected,  when is it done?</span>
    <span class="comment">// must we propagate another callback? </span>
    test( test2_complete_callback ); 
  }
</pre></div><ul>
<li>now what about exceptions??</li>
<li>should we block this thread, add a global wait condition?</li>
<li>perhaps an event queue to help structure the problem?</li>
<li>Adopt a data-flow architecture?</li>
<li>Avoid async designs all together? </li>
</ul>
</td><td valign="top"><div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> test2() { 
    test(); <span class="comment">// behaves synchronously as expected</span>
    async(test); <span class="comment">// or call async and forget! </span>
  }
</pre></div> </td></tr>
</table>
<h2><a class="anchor" id="mace_cmt_cooperative_threading_vs_qt_eventloop"></a>
Cooperative Threading vs Qt-like Event Loops</h2>
<p>The cooperative multi-tasking implementation is far supperior to the QApplication/QThread event loop when it comes to waiting for asynchronous tasks. If you want to implement a method in Qt that synchronously invokes a remote procedure call, then it must block the thread while it waits for the return value. If you want to keep the user interface responsive then you may optionally "recursively" process events.</p>
<p>There are many problems with recursive event loop invocations that lead to dead locks because the tasks must complete in the order in which they were called or the stack can never unwind.</p>
<p>Typically the solution to this problem is to use callbacks, signals, and other notification techniques. The problem with this approach is that you lose the "localization of code" and variables / algorithms end up spread across multiple methods. Local variables then need to be "maintained" outside of function scope as class member variables, often allocated on the heap. This greatly increases the complexity of the code.</p>
<p>This complexity becomes obvious when you have many asynchronous operations that must be performed synchrously or have some non-trivial dependency. Suppose you need to invoke 3 remote procedure calls on 3 different servers and that you need the return value from 1 of the calls before you can invoke the other two and that you need all three values before you can do your final calculations. This task is creates a mess of speghetti code with callbacks, state machine variables, etc unless you are willing to accept the performance hit of blocking an entire "heavy weight", preemitvely multi-tasked, operating system thread.</p>
<p>This same problem becomes trivial with the use of the MACE.CMT library. Simply asynchronously invoke each method which will return a future object. Then pass the futures into the other methods which will automatically run when the data is available. A complex asynchronous mess turns into what looks like synchronous code. </p>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sat Jun 2 2012 00:52:41 for MACE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
