<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MACE: CMT (Cooperative Multi-Tasking) Library</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="style.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>


<script type="text/javascript">
  var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-32339400-1']);
      _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
                      })();

</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MACE
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">CMT (Cooperative Multi-Tasking) Library</div>  </div>
<div class="ingroups"><a class="el" href="group__mace.html">MACE - Massively Asynchronous Coding Environment</a></div></div><!--header-->
<div class="contents">
<p>The MACE CMT library allows you to effeciently manage large numbers of parallel and asynchronous tasks and inter-thread communication using a <em>lock-free</em> scheduler.</p>
<p>In a cooperative implementation of multitasking, each task must explicitly yield control to the central scheduler to allow the next task to run. Assuming tasks play fairly this can result in much more effecient code when dealing with a high number of parallel tasks that are normally 'idle' waiting for data or a large number of small tasks.</p>
<p>Like traditional multi-threading each task has its own 'thread' of control which I will call a fiber. Unlike traditional multi-threading, you can be 100% sure that there can be no race conditions between two fibers running in the same thread; therefore, you can consider all operations that do not result in a yield to the scheduler 'atomic'.</p>
<p>The ability to treat most of your code as 'atomic' while still performing asynchronous operations that appear 'blocking' and 'synchronous' can greatly improve the readability of your code.</p>
<p>Because you only block a fiber when you are waiting on the result of an asynchronous operation, say posting a task to another thread, you greatly increase the amount of parallelism without increasing the number of 'real threads' and incurring additional synchronization and unnecessary context switching associated with large numbers of pre-emptive threads.</p>
<h2><a class="anchor" id="cmt_lockfree"></a>
Lock-Free Scheduler</h2>
<p>Multi-threading is hard, lock-free multi-threading is even harder and a source of a large number of hard-to-debug race conditions if not done right. With MACE CMT you can develop heavily multi-threaded applications without ever having to block on a <code>boost::mutex</code> (unless a thread is idle waiting for something to do).</p>
<p>Because traditional mutexes such as <code>boost::mutex</code> stall an entire thread and result in a switch between user-space and kernel space they can become a significant bottleneck in cases with high contention. They are also 'deadly' to a cooperative environment where one task grabing a <code>boost::mutex</code> will stop all other tasks from running in that thread.</p>
<p>The preferred method of interthread communication and synchronization is to ensure that only one thread is responsible for manipulating the 'shared' data. If another thread needs to query or set that data it does so by delegating the operation to the appropirate thread.</p>
<div class="fragment"><pre class="fragment">    future&lt;R&gt; r = other_thread-&gt;async( operation ); <span class="comment">// async</span>
    <span class="keywordtype">int</span> r = other_thread-&gt;async( operation );       <span class="comment">// sync</span>
</pre></div><p>The act of posting <code>operation</code> is a single atomic <code>compare_and_exchange</code> and the act of 'waiting' on the result is almost free assuming your thread has other tasks to run while it waits. If it has nothing else to do, then it becomes an effective <code>boost::wait_condition</code>.</p>
<p>Consider the following example; </p>
<div class="fragment"><pre class="fragment">    async(implicit_other_task); <span class="comment">// implicit</span>
    future&lt;R&gt; r = other_thread-&gt;async( operation );
    explicit_other_task();      <span class="comment">// explicit other tasks, no need for context switching</span>
    r.wait();                   <span class="comment">// perform implicit_other_task if r is not ready</span>
</pre></div><p>The other tasks could be 'explicit' such as <code>other_task()</code>, or they could be implicit:</p>
<p>Most of the time a program with many things going on has plenty of asynchronous implicit tasks to keep it busy while waiting and therefore you incure minimal 'locking overhead'. It is even better if you can run call <code>async(operation)</code> and not even care about the return value.</p>
<dl class="section note"><dt>Note:</dt><dd>While no locks are used directly, there is no pratical way to avoid memory allocation as a result of posting an asynchronous operation. The default memory allocator on most systems requires a memory lock. If this becomes a performance issue, you may want to consider using a thread-friendly allocator such as <a href="http://www.canonware.com/jemalloc/index.html">jemalloc</a>.</dd></dl>
<h2><a class="anchor" id="cmt_single_thread"></a>
Single Threaded Benchmark</h2>
<p>Here is a simple benchmark program that performs an asynchornous operation and waits on the result. This example is effecitvely synchronous because only one async operation is in flight at a time and there is only one real thread.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="thread_8hpp.html">mace/cmt/thread.hpp</a>&gt;</span>
<span class="keyword">using</span> boost::chrono::system_clock;
<span class="keyword">namespace </span>cmt = mace::cmt;

<span class="keywordtype">int</span> hello( <span class="keywordtype">int</span> in ){ <span class="keywordflow">return</span> in; }

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv ) {
    system_clock::time_point start = system_clock::now();
    <span class="keywordtype">int</span> sum = 0;
    <span class="keywordflow">for</span>( uint32_t i = 0; i &lt; 100000000; ++i ) {
        sum += cmt::async( std::bind(hello, i) ).wait();
        <span class="keywordflow">if</span>( i % 1000000 == 0 ) {
            system_clock::time_point end = system_clock::now();
            slog( <span class="stringliteral">&quot;%1% calls/sec&quot;</span>, (i/((end - start).count()/1000000000.0)) );
        }
    }
}
</pre></div><h2><a class="anchor" id="cmt_multi_threading"></a>
Multi-Threading with MACE.CMT</h2>
<p>In this example all tasks will occur in parallel in three different threads (t1,t2, and main).</p>
<p>While <code>main</code> waits for results from threads <code>t1</code> and <code>t2</code> it will switch contexts and execute other operations that are scheduled in the <code>main</code> thread such as calculating the result of <code>f3</code>.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="thread_8hpp.html">mace/cmt/thread.hpp</a>&gt;</span>

<span class="keywordtype">int</span> hello( <span class="keyword">const</span> std::string&amp; s ) { <span class="keywordflow">return</span> s.size(); }

<span class="keyword">namespace </span>cmt = mace::cmt;

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv ) {
  <span class="keywordflow">try</span>{ 
   cmt::thread::current().set_name(<span class="stringliteral">&quot;main&quot;</span>);
   cmt::thread* t1 = cmt::thread::create( <span class="stringliteral">&quot;t1&quot;</span> );
   cmt::thread* t2 = cmt::thread::create( <span class="stringliteral">&quot;t2&quot;</span> );

   cmt::future&lt;int&gt; f1 = t1-&gt;async( bind(hello,<span class="stringliteral">&quot;world1&quot;</span>) );
   <span class="keyword">auto</span> f2 = t2-&gt;async( bind(hello,<span class="stringliteral">&quot;world2&quot;</span>) );
   <span class="keyword">auto</span> f3 = cmt::async( bind(hello,<span class="stringliteral">&quot;world3&quot;</span>) );

   <span class="comment">// world3 is processed in current thread, while waiting on f1 &amp; f2</span>
   std::cerr&lt;&lt;( f1.wait() + f2.wait() + f3.wait() ) &lt;&lt; std::endl;

   t1-&gt;quit(); <span class="comment">// cancel any tasks and join thread</span>
   t2-&gt;quit(); <span class="comment">// cancel any tasks and join thread</span>

   cmt::thread::current().quit();
 } <span class="keywordflow">catch</span> ( ... ) {
    elog( <span class="stringliteral">&quot;Caught exception&quot;</span> );
    <span class="keywordflow">return</span> 1; 
 }
 <span class="keywordflow">return</span> 0;
}
</pre></div><h2><a class="anchor" id="cmt_exception"></a>
Exception Handling</h2>
<p>Any exception thrown durring an asynchronous operation is caught by the thread that calls cmt::future::wait()</p>
<h2><a class="anchor" id="cmt_usleep"></a>
Yielding and Sleeping</h2>
<p>The current task can either yield and allow other tasks to run before returning or it can sleep for an specific amount of time while allowing other tasks to run.</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacemace_1_1cmt.html#af4a6cb3372677000d4c35d1c377b9bee" title="Same as cmt::current().usleep()">cmt::usleep</a>(100000<span class="comment">/*us*/</span>);
      <a class="code" href="namespacemace_1_1cmt.html#af8f5129408ef43d58f02d75b101275a8" title="Same as cmt::thread::current().yield()">cmt::yield</a>();

      <span class="comment">// or the more verbose...</span>
      cmt::thread::current().usleep(10000);
      cmt::thread::current().yield();
</pre></div><p>You can only yield or sleep for the current thread. If there are no other tasks ready to run then <a class="el" href="namespacemace_1_1cmt.html#af8f5129408ef43d58f02d75b101275a8" title="Same as cmt::thread::current().yield()">yield()</a> returns immediately.</p>
<dl class="section note"><dt>Note:</dt><dd>Sleep and yield times are dependent upon other tasks yielding in a timely manner.</dd></dl>
<h2><a class="anchor" id="cmt_async_signal_wait"></a>
Boost.Signals Integration</h2>
<p>This example shows how a task can wait on an event triggered by a boost::signal and return the parameters emited by the signal. The output of the following program is 'hello world!' after waiting for 2 seconds.</p>
<p>Everything in this example runs in the main thread.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;<a class="code" href="thread_8hpp.html">mace/cmt/thread.hpp</a>&gt;</span>
<span class="preprocessor">#include &lt;mace/cmt/signals.hpp&gt;</span>

<span class="keyword">namespace </span>cmt = mace::cmt;

boost::signal&lt;void(std::string)&gt; test_signal;

<span class="keywordtype">void</span> delay() {
    <a class="code" href="namespacemace_1_1cmt.html#af4a6cb3372677000d4c35d1c377b9bee" title="Same as cmt::current().usleep()">cmt::usleep</a>(2000000);
    test_signal(<span class="stringliteral">&quot;hello world!&quot;</span>);
}

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv ) {
     std::cerr&lt;&lt; <span class="stringliteral">&quot;Delay for 2 seconds...\n&quot;</span>;
     cmt::async( delay );
     std::cerr&lt;&lt; cmt::wait(test_signal) &lt;&lt; std::endl;
     <span class="keywordflow">return</span> 0;
}
</pre></div><h2><a class="anchor" id="cmt_mutex"></a>
Cooperative Mutexes</h2>
<p>Cooperatively multi-tasked code must still worry about reentrancy. Suppose you have a thread sending a message across a socket, the socket members are thread safe, but the <code>write_message()</code> operation is not rentrant because the context could yield while waiting for a partial write to complete.</p>
<p>If while it has yielded another task in the same thread attempts to write a second message then you will get garbage out as both fibers take turns writing parts of their messages out of the socket.</p>
<p>Example problem: </p>
<div class="fragment"><pre class="fragment">    async(write_message);
    async(write_message);
    <span class="keywordtype">void</span> write_message() {
      sock-&gt;write(part1); <span class="comment">// may yield</span>
      sock-&gt;write(part2); <span class="comment">// may yield</span>
      sock-&gt;write(part3); <span class="comment">// may yield</span>
    }
</pre></div><p>The output could look something like: </p>
<div class="fragment"><pre class="fragment">    part1
    part2
    part1
    part3
    part2
    part3
</pre></div><p>What you want to happen is this: </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> write_message() {
      boost::unique_lock&lt;cmt::mutex&gt; lock(sock-&gt;write_lock);
      sock-&gt;write(part1); <span class="comment">// may yield</span>
      sock-&gt;write(part2); <span class="comment">// may yield</span>
      sock-&gt;write(part3); <span class="comment">// may yield</span>
    }
</pre></div><p>Now if while writing the first message, someone attempts to write a second message second write will 'queue' behind the first by 'blocking' on the mutex.</p>
<p>The difference between <code>boost::mutex</code> and <a class="el" href="classmace_1_1cmt_1_1mutex.html">mace::cmt::mutex</a> is that <a class="el" href="classmace_1_1cmt_1_1mutex.html">mace::cmt::mutex</a> will not 'block' the calling thread while waiting for a lock, it will simply <em>yield</em> to other tasks until the lock has been aquired. There are no system calls and in a single threaded multi-tasked environment like the example above, no spin-lock contention at all. Multi-threaded environments use a spin-lock while updating the lock state.</p>
<h2><a class="anchor" id="cmt_bind"></a>
Move-Aware Bind (passing non-copyable parameters)</h2>
<p>One of the major drawbacks of passing parameters through to asynchronous operations via <code>boost::bind()</code> is that <code>boost::bind</code> must make an internal copy of the parameters. The only way to avoid the internal copy is to use boost::ref(), but now you must make sure that the reference does not go out of scope before the bound functor.</p>
<p>A side effect of this lack of move support is that it becomes impossible to pass non-copyable, but movable, objects between threads without doing heap allocation and using smart pointers.</p>
<p>Often even the simple case of calling an asynchronous method and passing a string as a parameter results in two unnecessary copies.</p>
<ul>
<li>First the string is copied into the <code>boost::bind</code> functor.<ul>
<li>Second the boost::bind functor is copied into the <code>mace::cmt::task</code> object.<ul>
<li>this copies all of the parameters.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>With that background, <code>mace::cmt::bind(...)</code> is designed to serve the needs of the CMT library and returns a functor that takes no arguments, the exact type of functor required for passing to mace::cmt::async(...).</p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> test( std::string&amp;&amp; s );
  
  <span class="keywordtype">int</span> main() {
    <span class="keywordflow">return</span> async( mace::cmt::bind( &amp;test, std::string(<span class="stringliteral">&quot;Hello World&quot;</span>) ) ).wait();
  }
</pre></div><p>This functor takes its arguments by rvalue-reference and therefore, you cannot call it using <code>boost::bind</code> or <code>std::bind</code>.</p>
<p>A side effect of mace::cmt::bind's default assumption of 'move semantics', is that you cannot 'bind' non-rvalues. Therefore, you can use one of the following techniques:</p>
<div class="fragment"><pre class="fragment">   <span class="keywordtype">int</span> cr_test( <span class="keyword">const</span> std::string&amp; s );
   <span class="keywordtype">int</span> main() {
      std::string lvalue;
      <span class="keywordtype">int</span> r  = cmt::async( cmt::bind( &amp;cr_test, boost::ref(lvalue) ) );
      <span class="keywordtype">int</span> r2 = cmt::async( cmt::bind( &amp;cr_test, cmt::copy(lvalue) ) );
   }
</pre></div><p>The benefit of always using mace::cmt::bind is that in addition for potential performance gains, and support for move-only objects, your code is also much more explicit about where copies are being made.</p>
<h2><a class="anchor" id="cmt_promise"></a>
Using Promises</h2>
<p>Sometimes you need to perform an asynchronous operation of your own, such as a network call or waiting on user input. Here is an example from MACE.CMT's ASIO wrapper. Using <code>cmt::asio::read</code> you can perform a 'synchronous' read in the current thread without blocking the current thread. Instead the current thread will switch to running other tasks while waiting for the read to complete and then switch back once the read is ready. If an error occurs then <code><a class="el" href="namespacemace_1_1cmt_1_1asio.html#af5da54b3599ba2c926b071fd2e27d9a7" title="wraps boost::asio::async_read">read()</a></code> will throw the exception passed to ASIO's completion handler.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> AsyncReadStream, <span class="keyword">typename</span> MutableBufferSequence&gt;
    <span class="keywordtype">size_t</span> <a class="code" href="namespacemace_1_1cmt_1_1asio.html#af5da54b3599ba2c926b071fd2e27d9a7" title="wraps boost::asio::async_read">read</a>( AsyncReadStream&amp; s, <span class="keyword">const</span> MutableBufferSequence&amp; buf, <span class="keyword">const</span> microseconds&amp; timeout_us = microseconds::max() ) {
        promise&lt;size_t&gt;::ptr p(<span class="keyword">new</span> promise&lt;size_t&gt;());
        boost::asio::async_read( s, buf, boost::bind( detail::read_write_handler, p, _1, _2 ) );
        <span class="keywordflow">return</span> p-&gt;wait(timeout_us);
    }
    <span class="keywordtype">void</span> read_write_handler( <span class="keyword">const</span> promise&lt;size_t&gt;::ptr&amp; p, <span class="keyword">const</span> boost::system::error_code&amp; ec, <span class="keywordtype">size_t</span> bytes_transferred ) {
        <span class="keywordflow">if</span>( !ec ) p-&gt;set_value(bytes_transferred);
        <span class="keywordflow">else</span> p-&gt;set_exception( boost::copy_exception( boost::system::system_error(ec) ) );
    }
</pre></div><h2><a class="anchor" id="cmt_asio_integration"></a>
Boost.ASIO Integration</h2>
<h2><a class="anchor" id="cmt_vs_asio"></a>
MACE.CMT vs Boost.ASIO</h2>
<p>Boost.ASIO is currently how many projects perform asynchronous operations and multi-plex tasks on a pool of threads running <code>asio::io_service::run</code>. Synchronization occurs via the use of <code>asio::io_service::strand</code> which ensures that no two handlers within the strand can be run at the same time. Unfortunately, this is not useful for handlers that may want to block.</p>
<p>The Boost.Thread library includes <code>boost::future&lt;T&gt;</code> type that on the surface looks very similar to mace::cmt::future&lt;T&gt;, except that several problems emerge in practice:</p>
<ul>
<li>If you block waiting on a future from a ASIO callback handler you can stall an entire strand and hold up an entire OS thread reducing the effective size of your thread pool.</li>
</ul>
<ul>
<li>By stalling a strand you can end up with deadlock if two strands post events containing promises to one another and then both wait on the future. With cooperative threads, you can gaurantee that no two 'fibers' will run at the same time allowing one to work while the other blocks.</li>
</ul>
<p>Consider the following case study:</p>
<ul>
<li>perform 2 async operation and add the result.</li>
</ul>
<ul>
<li>print an error if either fails.</li>
</ul>
<table class="doxtable">
<tr>
<th>Boost.ASIO</th><th>MACE.CMT</th></tr>
<tr>
<td><div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> async_opp(<span class="keyword">function</span>&lt;<span class="keywordtype">void</span>(<span class="keywordtype">int</span>,<span class="keywordtype">bool</span>)&gt; callback) {
      callback( 42, error_code );  
    }
    <span class="keywordtype">void</span> another_async_opp(<span class="keyword">function</span>&lt;<span class="keywordtype">void</span>(<span class="keywordtype">int</span>,<span class="keywordtype">bool</span>)&gt; callback) {
        callback( 53, error_code );  
    }

    <span class="comment">// Requires shared or global state</span>
    mutex            m;
    <span class="keywordtype">int</span>              shared_state = 0;
    <span class="keywordtype">int</span>              results[2];
    asio::io_service io_service

    <span class="comment">// could be called by any thread running ioservice!</span>
    <span class="keywordtype">void</span> handle_result(<span class="keywordtype">int</span> r, <span class="keywordtype">bool</span> error) {
       unique_lock(m); <span class="comment">// must protect shared_state  </span>
       <span class="keywordflow">if</span>( error &amp;&amp; state != -1 ) { 
          state = -1; 
          std::cerr&lt;&lt;<span class="stringliteral">&quot;An error occured!\n&quot;</span>; 
       } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( state != -1 ) {
          results[state++] = r;
          <span class="keywordflow">if</span>( state == 2 ) 
              std::cout&lt;&lt;results[0]+results[1]&lt;&lt;std::endl;
       }
    }
    <span class="keywordtype">void</span> test( ) {
      io_service.post( bind( async_opp, handle_result ) );
      io_service.post( bind( another_async_opp, handle_result ) );
      other_work();
      <span class="comment">// do other work</span>
   }
</pre></div>  </td><td valign="top"><div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> async_opp() { <span class="keywordflow">return</span> 42; }
  <span class="keywordtype">int</span> another_async_opp() { <span class="keywordflow">return</span> 53; }

  <span class="comment">// given</span>
  cmt::thread* t1;
  cmt::thread* t2;

  <span class="keywordtype">void</span> test() {
    cmt::future&lt;int&gt; f1 = t1-&gt;async( async_opp );
    cmt::future&lt;int&gt; f2 = t2-&gt;async( another_async_opp );
    async( other_work ); <span class="comment">// in current thread</span>

    <span class="keywordflow">try</span> {
      <span class="comment">// while waiting other_work can run in this thread.</span>
      std::cerr&lt;&lt; f1.wait() + f2.wait() &lt;&lt; std::endl;
    } <span class="keywordflow">catch</span> ( ... ) {
      std::cerr&lt;&lt;<span class="stringliteral">&quot;An error occured!\n&quot;</span>;
    }
  }
</pre></div><ul>
<li>If this were implemented using <code>boost::future&lt;T&gt;</code> then <code>other_work</code> could not occur in the same thread while waiting for other asynchronous opperations to complete.</li>
<li>In order to avoid blocking an entire <code>boost::asio::strand</code>, you would have to revert to fine-grained locking with mutex.  </li>
</ul>
</td></tr>
<tr>
<td valign="top"><div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> test2( ) {
    test(); <span class="comment">// behaves asynchronously, unexpected,  when is it done?</span>
    <span class="comment">// must we propagate another callback? </span>
    test( test2_complete_callback ); 
  }
</pre></div><ul>
<li>now what about exceptions??</li>
<li>should we block this thread, add a global wait condition?</li>
<li>perhaps an event queue to help structure the problem?</li>
<li>Adopt a data-flow architecture?</li>
<li>Avoid async designs all together? </li>
</ul>
</td><td valign="top"><div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> test2() { 
    test(); <span class="comment">// behaves synchronously as expected</span>
    async(test); <span class="comment">// or call async and forget! </span>
  }
</pre></div> </td></tr>
</table>
<h2><a class="anchor" id="mace_cmt_cooperative_threading_vs_qt_eventloop"></a>
Cooperative Threading vs Qt-like Event Loops</h2>
<p>The cooperative multi-tasking implementation is far supperior to the QApplication/QThread event loop when it comes to waiting for asynchronous tasks. If you want to implement a method in Qt that synchronously invokes a remote procedure call, then it must block the thread while it waits for the return value. If you want to keep the user interface responsive then you may optionally "recursively" process events.</p>
<p>There are many problems with recursive event loop invocations that lead to dead locks because the tasks must complete in the order in which they were called or the stack can never unwind.</p>
<p>Typically the solution to this problem is to use callbacks, signals, and other notification techniques. The problem with this approach is that you lose the "localization of code" and variables / algorithms end up spread across multiple methods. Local variables then need to be "maintained" outside of function scope as class member variables, often allocated on the heap. This greatly increases the complexity of the code.</p>
<p>This complexity becomes obvious when you have many asynchronous operations that must be performed synchrously or have some non-trivial dependency. Suppose you need to invoke 3 remote procedure calls on 3 different servers and that you need the return value from 1 of the calls before you can invoke the other two and that you need all three values before you can do your final calculations. This task is creates a mess of speghetti code with callbacks, state machine variables, etc unless you are willing to accept the performance hit of blocking an entire "heavy weight", preemitvely multi-tasked, operating system thread.</p>
<p>This same problem becomes trivial with the use of the MACE.CMT library. Simply asynchronously invoke each method which will return a future object. Then pass the futures into the other methods which will automatically run when the data is available. A complex asynchronous mess turns into what looks like synchronous code. </p>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sat Jun 9 2012 02:18:54 for MACE by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.0
</small></address>

</body>
</html>
