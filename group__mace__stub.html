<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MACE: Stub Library</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MACE
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Stub Library</div>  </div>
<div class="ingroups"><a class="el" href="group__mace.html">MACE - Massively Asynchronous Coding Environment</a></div></div><!--header-->
<div class="contents">
<p>As defined by wikipedia, a <a href="http://en.wikipedia.org/wiki/Stub_(distributed_computing)"><b>stub</b></a> is a piece of code used for converting parameters passed durring a Remote Procedule Call (RPC). The MACE Stub library provides a means to automatically and dynamically generate Stubs for C++ class interface without resorting to code generation or an interface description language (IDL).</p>
<p>The definition of RPC traditionally implies over the network, however, for the purposes of this library 'remote' could also mean a different thread, process, a scripting engine or any other non-native calling system. Examples are provided for a simple RPC over UDP system and an actor paraidigm via Boost.ASIO.</p>
<p>Using stubs you can achieve a level of abstraction in your code that is not possible by other means. Your objects no long care about where they are run: which thread, which process, or which machine, or which protocol or transport is used.</p>
<h2><a class="anchor" id="mace_stub_example"></a>
Stub Basic Example (Type Erasure)</h2>
<p>The first step is to define your stub interface. This could be an interface lacking implementation, or it could be any other class in you wish to expose on the network.</p>
<p>Given the following interfaces:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>service {
  std::string name()<span class="keyword">const</span>;
  <span class="keywordtype">int</span>         exit();
};
<span class="keyword">struct </span>calculator : service {
  <span class="keywordtype">double</span> add( <span class="keywordtype">double</span> v, <span class="keywordtype">double</span> v2 );
  <span class="keywordtype">double</span> sub( <span class="keywordtype">double</span> v, <span class="keywordtype">double</span> v2 );           
};
</pre></div><p> You would use the following macros to define an appropriate stub:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="vtable_8hpp.html#aed33615d027e291eefa9dfd06f78acff">MACE_STUB</a>( service, (name)(exit) )
<a class="code" href="vtable_8hpp.html#ac6eb8257e3b54944a8d5b8b6dc849cff">MACE_STUB_DERIVED</a>( calculator, (service), (add)(sub) )
</pre></div><p> Once you have defined your stub you can use <a class="el" href="classmace_1_1stub_1_1ptr.html">mace::stub::ptr</a>&lt;calculator&gt; to refer to any object with that interface. For example consider the following class:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>CalculatorServer {
  <span class="keyword">public</span>:
    std::string name()<span class="keyword">const            </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;CalculatorServer&quot;</span>; }
    <span class="keywordtype">int</span>    exit()                      { ::exit(0);                  }
    <span class="keywordtype">double</span> add( <span class="keywordtype">double</span> v, <span class="keywordtype">double</span> v2 )  { <span class="keywordflow">return</span> m_result += v + v2;  }
    <span class="keywordtype">double</span> sub( <span class="keywordtype">double</span> v, <span class="keywordtype">double</span> v2 )  { <span class="keywordflow">return</span> m_result -= v - v2;  }
  <span class="keyword">private</span>:
    <span class="keywordtype">double</span> m_result;
};
</pre></div><p> It provides all of the methods of <code>calculator</code> but does not share the same inheritance nor a common base class. Even though there is no relationship between CalculatorServer and calculator, we can still use it generically in any algorithm that operates on a <code>mace::stub::ptr&lt;calculator&gt;</code>.</p>
<div class="fragment"><pre class="fragment">    stub::ptr&lt;calculator&gt; calc( boost::make_shared&lt;CalculatorServer&gt;() );
</pre></div> <h2><a class="anchor" id="mace_stub_rpc_client_example"></a>
RPC Client Example</h2>
<p>The real power of stubs goes beyond simple type erasure, to providing automatic conversion of parameters passed durring a remote procedure call whether 'remote' means a different Boost.ASIO strand, or a different computer running software written in a different language. Normally this task is performed via code generation that takes an interface description language and generates a stub class; however, the MACE Stub Library utilizes the power of C++ templates to achieve the same transformation natively and as much run-time effeciency as code generation schemes.</p>
<p>This example will demonstrate how to initialize a stub::ptr&lt;calculator&gt; that will perform RPC calls over UDP using Boost.Serialization to serialize the arguments and deserialize the results. For the sake of simplicity, this example uses blocking synchronous network calls.</p>
<p>The primary thing to understand is that the default <a class="el" href="classmace_1_1stub_1_1ptr.html">mace::stub::ptr</a>&lt;T&gt; is essentially a virtual table comprized of boost::function&lt;&gt; objects. To define an RPC client we must merely generate a functor for each method. This can be done using a visitor.</p>
<h3><a class="anchor" id="rpc_client_funtor"></a>
RPC Client Functor</h3>
<p>First, lets define the function object.</p>
<div class="fragment"><pre class="fragment">     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq, <span class="keyword">typename</span> ResultType&gt;
     <span class="keyword">struct </span>rpc_functor {
       rpc_functor( rpc_client&amp; c, <span class="keyword">const</span> <span class="keywordtype">char</span>* name )
       :m_client(c),m_name(name){}

       ResultType operator()( <span class="keyword">const</span> Seq&amp; params )<span class="keyword">const </span>{
          <span class="comment">// serialize the parameters</span>
          std::ostringstream os; 
          boost::archive::binary_oarchive oa(os);
          serialize_fusion_vector(oa, params);
          <span class="comment">// make a call and store the result into the input stream; </span>
          std::istringstream is(m_client.invoke( m_name, os.str() ) );

          <span class="comment">// unpack the result type</span>
          ResultType  ret_val;
          boost::archive::binary_iarchive ia(is);
          ia &gt;&gt; ret_val;
          <span class="keywordflow">return</span> ret_val;
       }
       <span class="keyword">const</span> <span class="keywordtype">char</span>* m_name;
       rpc_client&amp; m_client;
     };
</pre></div><p> In the example, the functor takes two template parameters, a Boost.Fusion Sequence (parameter types) and a ResultType. The constructor takes a pointer to our <code>rpc_client</code> which handles communication and a function name which is used to identify the method when it is received by the RPC server.</p>
<p>The body of the functor takes a <code>Sequence</code> of parameters and returns a <code>Result</code>. It uses boost serialization to serialize the parameters, sends the serialized string out over the network and then dezerializes the result.</p>
<h3><a class="anchor" id="rpc_client_visitor"></a>
RPC Client Visitor</h3>
<p>Next we must assign each method on our stub::ptr&lt;T&gt; with a properly instantiated instance of our <code>rpc_functor&lt;Seq,Result&gt;</code>. This is achieved by creating a visitor:</p>
<div class="fragment"><pre class="fragment">     <span class="keyword">struct </span>set_visitor {
       set_visitor( rpc_client&amp; ci )
       :c(ci){}

       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MemberPtr, MemberPtr m&gt;
       <span class="keywordtype">void</span> operator()( <span class="keyword">const</span> <span class="keywordtype">char</span>* name )<span class="keyword">const </span>{
         <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::result_type&lt;MemberPtr&gt;::type member_ref;
         <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::remove_reference&lt;member_ref&gt;::type member;
         ((*c).*m) = rpc_functor&lt;<span class="keyword">typename</span> member::fused_params, 
                                 <span class="keyword">typename</span> member::result_type&gt;( c, name );
       }
       rpc_client&amp; c;
     };
</pre></div><p> This visitor will be called for each method on the interface. <code>MemberPtr</code> will have a type of something like: <code>MemberType (stub::vtable&lt;Interface,InterfaceDelegate&gt;::*)</code> and <code>m</code> will be a compile-time constant pointing to the actual member. By passing the member pointer as a template parameter instead of an argument the compiler is given the opportunity to inline more effectively as well as reduce unnecessary indirection.</p>
<p><code>MemberType</code> depends entirely upon which <code>InterfaceDelegate</code> was used to define your stub. The <code>InterfaceDelegate</code> enables the stub interface to be transformed. The default delegate simply 'mirrors' the actual interface with the addition of the ability to make fused calls. Lets stop to take a look at how <code><a class="el" href="structmace_1_1stub_1_1mirror__interface.html" title="Interface Delegate that mirrors the reflected interface without any transformation.">mace::stub::mirror_interface</a></code> defines <code>MemberType</code>.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> Class, PARAM_TYPE_NAMES&gt;
<span class="keyword">struct </span>mirror_member&lt;R(Class::*)(PARAM_TYPES)const&gt; {
  <span class="keyword">typedef</span> <span class="keyword">typename</span> adapt_void&lt;R&gt;::result_type                    result_type;
  <span class="keyword">typedef</span> mirror_member                                          self_type;
  <span class="keyword">typedef</span> boost::fusion::vector&lt;PARAM_TYPES&gt;                     fused_params;
  <span class="keyword">typedef</span> boost::fusion::vector&lt;DEDUCED_PARAM_TYPES&gt;             deduced_params;
  <span class="keyword">typedef</span> boost::function_traits&lt;result_type(PARAM_TYPES)&gt;       traits;
  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span>                                              is_const = <span class="keyword">true</span>;

  <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::remove_pointer&lt;result_type(*)(PARAM_TYPES)&gt;::type   signature;

  result_type operator()( PARAM_ARGS )<span class="keyword">const </span>{
    <span class="keywordflow">return</span> m_delegate( boost::fusion::make_vector(PARAM_NAMES) );
  }
  result_type operator() ( <span class="keyword">const</span> fused_params&amp; fp )<span class="keyword">const </span>{
    <span class="keywordflow">return</span> m_delegate( fp );
  }
  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
  mirror_member&amp; operator=( <span class="keyword">const</span> T&amp; d )  {
    m_delegate = adapt_void&lt;R,T&gt;(d);
    <span class="keywordflow">return</span> *<span class="keyword">this</span>;
  }
  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> M&gt;
  <span class="keywordtype">void</span> set_delegate(  C* s, M m );
  <span class="keyword">private</span>:
    boost::function&lt;result_type(const fused_params&amp;)&gt; m_delegate; 
};
</pre></div><p>As you can see the <code>MemberType</code> provided by <a class="el" href="structmace_1_1stub_1_1mirror__interface.html">mace::stub::mirror_interface</a> provides many helpful template-meta-programming typedefs that we can leverage within our visitor. In particular, knowing the fused parameter type and the result type is critical in initializing the proper <code>rpc_functor&lt;Seq,Result&gt;</code>.</p>
<p>Because <code>MemberPtr</code> is the type of a pointer, we must enlist Boost.FunctionTypes to get the type of the member before we can access type <code>result_type</code> and <code>fused_params</code> type.</p>
<p>Once we have the result_type and <code>fused_params</code> we create an <code>rpc_functor&lt;member::fused_params,member::result_type&gt;</code> and give it the name of the function which is passed with our visitor along with a pointer to the <code>rpc_client</code> which ultimately dispatches the remote procedure call after the parameters are serailized by <code>rpc_functor&lt;&gt;</code>.</p>
<h3><a class="anchor" id="rpc_client_visitor_useage"></a>
Visiting your Interface</h3>
<p>After you have defined your functor type and visitor type all that remains is to visit your interface.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>mace { <span class="keyword">namespace </span>stub {

<span class="keyword">template</span>&lt;<span class="keyword">typename</span> InterfaceType,<span class="keyword">typename</span> InterfaceDelegate=mirror_<span class="keywordtype">int</span>erface&gt;
<span class="keyword">class </span>rpc_client : <span class="keyword">public</span> stub::ptr&lt;InterfaceType,InterfaceDelegate&gt; {
  <span class="keyword">public</span>:
    rpc_client()
    :m_ios(),m_sock(m_ios) {
      vtable_reflector&lt;InterfaceType,InterfaceDelegate&gt;::visit( set_visitor( *<span class="keyword">this</span> ) );
    }
</pre></div><p> This is done using the mace::stub::vtable_reflector&lt;InterfaceType,InterfaceDelegate&gt;::visit method which you will pass a copy of your visitor. This method will then call your visitor for each member on the interface.</p>
<h3><a class="anchor" id="rpc_client_invoke"></a>
RPC Client Invoke</h3>
<p>The last detail of our RPC client is the method that actually sends the call and waits for a response. This code is dirt simple:</p>
<div class="fragment"><pre class="fragment">   std::string invoke( <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keyword">const</span> std::string&amp; params ) {
     std::ostringstream os;
     boost::archive::binary_oarchive oa(os);
     std::string n(name);
     oa &lt;&lt; n;
     oa &lt;&lt; params;

     m_sock.send_to( boost::asio::buffer( os.str() ), m_ep );

     boost::asio::ip::udp::endpoint rep;
     std::vector&lt;char&gt; recv_buf(2048);
     <span class="keywordtype">size_t</span> len = m_sock.receive_from( boost::asio::buffer(recv_buf), rep );
     <span class="keywordflow">return</span> std::string(&amp;recv_buf.front(),len);
   }
</pre></div><p> This is the method referenced from the <a class="el" href="group__mace__stub.html#rpc_client_funtor">RPC Client Functor</a>.</p>
<h3><a class="anchor" id="rpc_client_use"></a>
Using our RPC Client</h3>
<p>Now that we have defined how to convert an interface to an RPC over UDP interface, we can use this interface with a natural C++ calling syntax. Algorithms that are designed around <a class="el" href="classmace_1_1stub_1_1ptr.html">mace::stub::ptr</a>&lt;calculator&gt; would not be able to tell the difference between a RPC client or a simple local pointer.</p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">double</span> r  = calc-&gt;add( 5, 5 );
  <span class="keywordtype">double</span> r2 = generic_calc-&gt;add( 5, 5 );
</pre></div><h3><a class="anchor" id="rpc_server"></a>
Defining an RPC Server</h3>
<p>The RPC Server would use a similar pattern, except its visitor would store a functor in a map indexed by method name and the functor would deserialize parameters, call the original method, and serialize the result.</p>
<div class="fragment"><pre class="fragment">      <span class="comment">// rpc_server</span>
       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Seq, <span class="keyword">typename</span> Functor&gt;
       <span class="keyword">struct </span>rpc_functor {
           rpc_functor( Functor f )
           :m_func(f){}

           std::string operator()( <span class="keyword">const</span> std::string&amp; params )<span class="keyword">const </span>{
                Seq paramv;
                std::istringstream is(params);
                boost::archive::binary_iarchive ia(is);
                deserialize_fusion_vector(ia,paramv);                    

                std::ostringstream os;
                boost::archive::binary_oarchive oa(os);
                <span class="keyword">typename</span> boost::remove_reference&lt;Functor&gt;::type::result_type r = m_func(paramv);
                oa &lt;&lt; r;
                <span class="keywordflow">return</span> os.str();
           }
           Functor m_func;
       };


       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
       <span class="keyword">struct </span>get_visitor {
          get_visitor( vtable&lt;T&gt;&amp; vt, rpc_server&amp; si )
          :v(vt),s(si){}

          <span class="keyword">template</span>&lt;<span class="keyword">typename</span> MemberPtr, MemberPtr m&gt;
          <span class="keywordtype">void</span> operator()( <span class="keyword">const</span> <span class="keywordtype">char</span>* name )<span class="keyword">const </span>{
            <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::function_types::result_type&lt;MemberPtr&gt;::type member_ref;
            <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::remove_reference&lt;member_ref&gt;::type member;
            s.methods[name] = rpc_functor&lt;<span class="keyword">typename</span> member::fused_params, 
                                BOOST_TYPEOF( v.*m )&amp;&gt;(v.*m);
          }
          vtable&lt;T&gt;&amp; v;
          rpc_server&amp; s;
       };

       std::map&lt;std::string, boost::function&lt;std::string(const std::string)&gt; &gt; methods;
</pre></div><p> In under 200 lines of code we were able to create a generic, reusable, effecient RPC framework that provides a natural calling syntax via the use of the MACE.Stub library. The full listing of this code can be found at examples/rpc.hpp </p>
</div><!-- contents -->
<script type="text/javascript">

  var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-2423876-2']);
      _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
                      })();

                      </script>
