<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MACE - Massively Asynchronous Coding Environment: cmt_signal.cpp</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MACE - Massively Asynchronous Coding Environment
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">cmt_signal.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<h2><a class="anchor" id="boost_cmt_promise"></a>
Implement your own Promises</h2>
<p>Sometimes you need to perform an asynchronous operation of your own, such as a network call or waiting on user input. Here is an example from Boost.CMT's ASIO wrapper. Using <code>cmt::asio::read</code> you can perform a 'synchronous' read in the current thread without blocking the current thread. Instead the current thread will switch to running other tasks while waiting for the read to complete and then switch back once the read is ready. If an error occurs then <code>read()</code> will throw the exception passed to ASIO's completion handler.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> AsyncReadStream, <span class="keyword">typename</span> MutableBufferSequence&gt;
    <span class="keywordtype">size_t</span> read( AsyncReadStream&amp; s, <span class="keyword">const</span> MutableBufferSequence&amp; buf, <span class="keyword">const</span> microseconds&amp; timeout_us = microseconds::max() ) {
        promise&lt;size_t&gt;::ptr p(<span class="keyword">new</span> promise&lt;size_t&gt;());
        boost::asio::async_read( s, buf, boost::bind( detail::read_write_handler, p, _1, _2 ) );
        <span class="keywordflow">return</span> p-&gt;wait(timeout_us);
    }
    <span class="keywordtype">void</span> read_write_handler( <span class="keyword">const</span> promise&lt;size_t&gt;::ptr&amp; p, <span class="keyword">const</span> boost::system::error_code&amp; ec, <span class="keywordtype">size_t</span> bytes_transferred ) {
        <span class="keywordflow">if</span>( !ec ) p-&gt;set_value(bytes_transferred);
        <span class="keywordflow">else</span> p-&gt;set_exception( boost::copy_exception( boost::system::system_error(ec) ) );
    }
</pre></div><h2><a class="anchor" id="boost_cmt_cooperative_threading_vs_qt_eventloop"></a>
Cooperative Threading vs Qt-like Event Loops</h2>
<p>The cooperative multi-tasking implementation is far supperior to the QApplication/QThread event loop when it comes to waiting for asynchronous tasks. If you want to implement a method in Qt that synchronously invokes a remote procedure call, then it must block the thread while it waits for the return value. If you want to keep the user interface responsive then you may optionally "recursively" process events.</p>
<p>There are many problems with recursive event loop invocations that lead to dead locks because the tasks must complete in the order in which they were called or the stack can never unwind.</p>
<p>Typically the solution to this problem is to use callbacks, signals, and other notification techniques. The problem with this approach is that you lose the "localization of code" and variables / algorithms end up spread across multiple methods. Local variables then need to be "maintained" outside of function scope as class member variables, often allocated on the heap. This greatly increases the complexity of the code.</p>
<p>This complexity becomes obvious when you have many asynchronous operations that must be performed synchrously or have some non-trivial dependency. Suppose you need to invoke 3 remote procedure calls on 3 different servers and that you need the return value from 1 of the calls before you can invoke the other two and that you need all three values before you can do your final calculations. This task is creates a mess of speghetti code with callbacks, state machine variables, etc unless you are willing to accept the performance hit of blocking an entire "heavy weight", preemitvely multi-tasked, operating system thread.</p>
<p>This same problem becomes trivial with the use of the Boost.CMT library. Simply asynchrounsly invoke each method which will return a future object. Then pass the futures into the other methods which will automatically run when the data is available. A complex asynchronous mess turns into what looks like synchronous code.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;boost/cmt/thread.hpp&gt;</span>
<span class="preprocessor">#include &lt;boost/cmt/signals.hpp&gt;</span>

<span class="keyword">namespace </span>cmt = boost::cmt;

boost::signal&lt;void(std::string)&gt; test_signal;

<span class="keywordtype">void</span> delay() {
    cmt::usleep(2000000);
    test_signal(<span class="stringliteral">&quot;hello world!&quot;</span>);
}

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv ) {
     std::cerr&lt;&lt; <span class="stringliteral">&quot;Delay for 2 seconds...\n&quot;</span>;
     cmt::async( delay );
     std::cerr&lt;&lt; cmt::wait(test_signal) &lt;&lt; std::endl;
     <span class="keywordflow">return</span> 0;
}
</pre></div> </div><!-- contents -->
<script type="text/javascript">

  var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-2423876-2']);
      _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
                      })();

                      </script>
