<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>MACE - Massively Asynchronous Coding Environment: Cooperative Multi-Tasking</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">MACE - Massively Asynchronous Coding Environment
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Cooperative Multi-Tasking</div>  </div>
</div><!--header-->
<div class="contents">
<h2><a class="anchor" id="cmt_single_thread"></a>
Single Threaded Benchmark</h2>
<p>Here is a simple benchmark program that performs an asynchornous operation and waits on the result. This example is effecitvely synchronous because only one async operation is in flight at a time and there is only one real thread.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">using namespace </span>boost::cmt;
    <span class="keyword">using namespace </span>boost::chrono;
    <span class="keyword">using namespace </span>boost;

    <span class="keywordtype">int</span> hello(<span class="keyword">const</span> std::string&amp; world ) {
        <span class="keywordflow">return</span> world.size(); 
    }

    <span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv ) {
        system_clock::time_point start = system_clock::now();
        <span class="keywordtype">int</span> sum = 0;
        <span class="keywordflow">for</span>( uint32_t i = 0; i &lt; 1000; ++i ) 
            sum += async&lt;int&gt;( bind(hello, <span class="stringliteral">&quot;world&quot;</span>), <span class="stringliteral">&quot;hello_func&quot;</span> ).wait();
        ptime end = microsec_clock::universal_time();
        slog( <span class="stringliteral">&quot;%1% calls/sec&quot;</span>, (1000.0/((system_clock::now() - start).count()/1000000000.0)) );
    }
</pre></div><h2><a class="anchor" id="cmt_multi_threading"></a>
Multi-Threading with Boost.CMT</h2>
<p>In this example all tasks will occur in parallel in three different threads (t1,t2, and main).</p>
<p>While <code>main</code> waits for results from threads <code>t1</code> and <code>t2</code> it will switch contexts and execute other operations that are scheduled in the <code>main</code> thread such as calculating the result of <code>f3</code>.</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv ) {
       cmt::thread* t1 = cmt::thread::create( <span class="stringliteral">&quot;t1&quot;</span> );
       cmt::thread* t2 = cmt::thread::create( <span class="stringliteral">&quot;t2&quot;</span> );

       cmt::future&lt;int&gt; f1 = t1-&gt;async&lt;<span class="keywordtype">int</span>&gt;( bind(hello,<span class="stringliteral">&quot;world1&quot;</span>) );
       cmt::future&lt;int&gt; f2 = t2-&gt;async&lt;<span class="keywordtype">int</span>&gt;( bind(hello,<span class="stringliteral">&quot;world2&quot;</span>) );
       cmt::future&lt;int&gt; f3 = cmt::async&lt;int&gt;( bind(hello,<span class="stringliteral">&quot;world3&quot;</span>) );

       std::cerr&lt;&lt;( f1.wait() + f2.wait() + f3.wait() );
    }
</pre></div><h2><a class="anchor" id="cmt_exception"></a>
Exception Handling</h2>
<p>Any exception thrown durring an asynchronous operation is caught by the thread that calls cmt::future::wait()</p>
<h2><a class="anchor" id="boost_cmt_usleep"></a>
Yielding and Sleeping</h2>
<p>The current task can either yield and allow other tasks to run before returning or it can sleep for an specific amount of time while allowing other tasks to run.</p>
<div class="fragment"><pre class="fragment">      boost::cmt::usleep(100000<span class="comment">/*us*/</span>);
      boost::cmt::yield();

      <span class="comment">// or the more verbose...</span>
      boost::cmt::thread::current().usleep(10000);
      boost::cmt::thread::current().yield();
</pre></div><p>You can only yield or sleep for the current thread. If there are no other tasks ready to run then yield() returns immediately.</p>
<dl class="section note"><dt>Note:</dt><dd>Sleep and yield times are dependent upon other tasks yielding in a timely manner.</dd></dl>
<h2><a class="anchor" id="boost_cmt_async_signal_wait"></a>
Asynchronously Wait on a Signal</h2>
<p>This example shows how a task can wait on an event triggered by a boost::signal and return the parameters emited by the signal. The output of the following program is 'hello world!' after waiting for 2 seconds.</p>
<p>Everything in this example runs in the main thread.</p>
<div class="fragment"><pre class="fragment">  boost::signal&lt;void(std::string)&gt; test_signal;
  
  <span class="keywordtype">void</span> delay() {
      boost::cmt::usleep(2000000);
      test_signal(<span class="stringliteral">&quot;hello world!&quot;</span>);
  }

  <span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv ) {
       cmt::async( delay );
       std::cerr&lt;&lt; boost::cmt::wait(test_signal);
  }
</pre></div><h2><a class="anchor" id="boost_cmt_promise"></a>
Implement your own Promises</h2>
<p>Sometimes you need to perform an asynchronous operation of your own, such as a network call or waiting on user input. Here is an example from Boost.CMT's ASIO wrapper. Using <code>cmt::asio::read</code> you can perform a 'synchronous' read in the current thread without blocking the current thread. Instead the current thread will switch to running other tasks while waiting for the read to complete and then switch back once the read is ready. If an error occurs then <code>read()</code> will throw the exception passed to ASIO's completion handler.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> AsyncReadStream, <span class="keyword">typename</span> MutableBufferSequence&gt;
    <span class="keywordtype">size_t</span> read( AsyncReadStream&amp; s, <span class="keyword">const</span> MutableBufferSequence&amp; buf, <span class="keyword">const</span> microseconds&amp; timeout_us = microseconds::max() ) {
        promise&lt;size_t&gt;::ptr p(<span class="keyword">new</span> promise&lt;size_t&gt;());
        boost::asio::async_read( s, buf, boost::bind( detail::read_write_handler, p, _1, _2 ) );
        <span class="keywordflow">return</span> p-&gt;wait(timeout_us);
    }
    <span class="keywordtype">void</span> read_write_handler( <span class="keyword">const</span> promise&lt;size_t&gt;::ptr&amp; p, <span class="keyword">const</span> boost::system::error_code&amp; ec, <span class="keywordtype">size_t</span> bytes_transferred ) {
        <span class="keywordflow">if</span>( !ec ) p-&gt;set_value(bytes_transferred);
        <span class="keywordflow">else</span> p-&gt;set_exception( boost::copy_exception( boost::system::system_error(ec) ) );
    }
</pre></div> </div><!-- contents -->
<script type="text/javascript">

  var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-2423876-2']);
      _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
                      })();

                      </script>
